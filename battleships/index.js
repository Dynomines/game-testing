// Copyright (c) 2013-2017 CoolGames

(function() {
/*!
 * pixi.js - v4.5.3
 * Compiled Mon, 12 Jun 2017 14:48:33 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.PIXI=t()}}(function(){var t;return function t(e,r,n){function i(s,a){if(!r[s]){if(!e[s]){var u="function"==typeof require&&require;if(!a&&u)return u(s,!0);if(o)return o(s,!0);var h=new Error("Cannot find module '"+s+"'");throw h.code="MODULE_NOT_FOUND",h}var l=r[s]={exports:{}};e[s][0].call(l.exports,function(t){var r=e[s][1][t];return i(r?r:t)},l,l.exports,t,e,r,n)}return r[s].exports}for(var o="function"==typeof require&&require,s=0;s<n.length;s++)i(n[s]);return i}({1:[function(t,e,r){"use strict";"use restrict";function n(t){var e=32;return t&=-t,t&&e--,65535&t&&(e-=16),16711935&t&&(e-=8),252645135&t&&(e-=4),858993459&t&&(e-=2),1431655765&t&&(e-=1),e}var i=32;r.INT_BITS=i,r.INT_MAX=2147483647,r.INT_MIN=-1<<i-1,r.sign=function(t){return(t>0)-(t<0)},r.abs=function(t){var e=t>>i-1;return(t^e)-e},r.min=function(t,e){return e^(t^e)&-(t<e)},r.max=function(t,e){return t^(t^e)&-(t<e)},r.isPow2=function(t){return!(t&t-1||!t)},r.log2=function(t){var e,r;return e=(t>65535)<<4,t>>>=e,r=(t>255)<<3,t>>>=r,e|=r,r=(t>15)<<2,t>>>=r,e|=r,r=(t>3)<<1,t>>>=r,e|=r,e|t>>1},r.log10=function(t){return t>=1e9?9:t>=1e8?8:t>=1e7?7:t>=1e6?6:t>=1e5?5:t>=1e4?4:t>=1e3?3:t>=100?2:t>=10?1:0},r.popCount=function(t){return t-=t>>>1&1431655765,t=(858993459&t)+(t>>>2&858993459),16843009*(t+(t>>>4)&252645135)>>>24},r.countTrailingZeros=n,r.nextPow2=function(t){return t+=0===t,--t,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t+1},r.prevPow2=function(t){return t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t-(t>>>1)},r.parity=function(t){return t^=t>>>16,t^=t>>>8,t^=t>>>4,t&=15,27030>>>t&1};var o=new Array(256);!function(t){for(var e=0;e<256;++e){var r=e,n=e,i=7;for(r>>>=1;r;r>>>=1)n<<=1,n|=1&r,--i;t[e]=n<<i&255}}(o),r.reverse=function(t){return o[255&t]<<24|o[t>>>8&255]<<16|o[t>>>16&255]<<8|o[t>>>24&255]},r.interleave2=function(t,e){return t&=65535,t=16711935&(t|t<<8),t=252645135&(t|t<<4),t=858993459&(t|t<<2),t=1431655765&(t|t<<1),e&=65535,e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),t|e<<1},r.deinterleave2=function(t,e){return t=t>>>e&1431655765,t=858993459&(t|t>>>1),t=252645135&(t|t>>>2),t=16711935&(t|t>>>4),t=65535&(t|t>>>16),t<<16>>16},r.interleave3=function(t,e,r){return t&=1023,t=4278190335&(t|t<<16),t=251719695&(t|t<<8),t=3272356035&(t|t<<4),t=1227133513&(t|t<<2),e&=1023,e=4278190335&(e|e<<16),e=251719695&(e|e<<8),e=3272356035&(e|e<<4),e=1227133513&(e|e<<2),t|=e<<1,r&=1023,r=4278190335&(r|r<<16),r=251719695&(r|r<<8),r=3272356035&(r|r<<4),r=1227133513&(r|r<<2),t|r<<2},r.deinterleave3=function(t,e){return t=t>>>e&1227133513,t=3272356035&(t|t>>>2),t=251719695&(t|t>>>4),t=4278190335&(t|t>>>8),t=1023&(t|t>>>16),t<<22>>22},r.nextCombination=function(t){var e=t|t-1;return e+1|(~e&-~e)-1>>>n(t)+1}},{}],2:[function(t,e,r){"use strict";function n(t,e,r){r=r||2;var n=e&&e.length,o=n?e[0]*r:t.length,a=i(t,0,o,r,!0),u=[];if(!a)return u;var h,l,d,f,p,v,y;if(n&&(a=c(t,e,a,r)),t.length>80*r){h=d=t[0],l=f=t[1];for(var g=r;g<o;g+=r)p=t[g],v=t[g+1],p<h&&(h=p),v<l&&(l=v),p>d&&(d=p),v>f&&(f=v);y=Math.max(d-h,f-l)}return s(a,u,r,h,l,y),u}function i(t,e,r,n,i){var o,s;if(i===A(t,e,r,n)>0)for(o=e;o<r;o+=n)s=M(o,t[o],t[o+1],s);else for(o=r-n;o>=e;o-=n)s=M(o,t[o],t[o+1],s);return s&&T(s,s.next)&&(C(s),s=s.next),s}function o(t,e){if(!t)return t;e||(e=t);var r,n=t;do if(r=!1,n.steiner||!T(n,n.next)&&0!==x(n.prev,n,n.next))n=n.next;else{if(C(n),n=e=n.prev,n===n.next)return null;r=!0}while(r||n!==e);return e}function s(t,e,r,n,i,c,d){if(t){!d&&c&&v(t,n,i,c);for(var f,p,y=t;t.prev!==t.next;)if(f=t.prev,p=t.next,c?u(t,n,i,c):a(t))e.push(f.i/r),e.push(t.i/r),e.push(p.i/r),C(t),t=p.next,y=p.next;else if(t=p,t===y){d?1===d?(t=h(t,e,r),s(t,e,r,n,i,c,2)):2===d&&l(t,e,r,n,i,c):s(o(t),e,r,n,i,c,1);break}}}function a(t){var e=t.prev,r=t,n=t.next;if(x(e,r,n)>=0)return!1;for(var i=t.next.next;i!==t.prev;){if(_(e.x,e.y,r.x,r.y,n.x,n.y,i.x,i.y)&&x(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function u(t,e,r,n){var i=t.prev,o=t,s=t.next;if(x(i,o,s)>=0)return!1;for(var a=i.x<o.x?i.x<s.x?i.x:s.x:o.x<s.x?o.x:s.x,u=i.y<o.y?i.y<s.y?i.y:s.y:o.y<s.y?o.y:s.y,h=i.x>o.x?i.x>s.x?i.x:s.x:o.x>s.x?o.x:s.x,l=i.y>o.y?i.y>s.y?i.y:s.y:o.y>s.y?o.y:s.y,c=g(a,u,e,r,n),d=g(h,l,e,r,n),f=t.nextZ;f&&f.z<=d;){if(f!==t.prev&&f!==t.next&&_(i.x,i.y,o.x,o.y,s.x,s.y,f.x,f.y)&&x(f.prev,f,f.next)>=0)return!1;f=f.nextZ}for(f=t.prevZ;f&&f.z>=c;){if(f!==t.prev&&f!==t.next&&_(i.x,i.y,o.x,o.y,s.x,s.y,f.x,f.y)&&x(f.prev,f,f.next)>=0)return!1;f=f.prevZ}return!0}function h(t,e,r){var n=t;do{var i=n.prev,o=n.next.next;!T(i,o)&&w(i,n,n.next,o)&&S(i,o)&&S(o,i)&&(e.push(i.i/r),e.push(n.i/r),e.push(o.i/r),C(n),C(n.next),n=t=o),n=n.next}while(n!==t);return n}function l(t,e,r,n,i,a){var u=t;do{for(var h=u.next.next;h!==u.prev;){if(u.i!==h.i&&b(u,h)){var l=P(u,h);return u=o(u,u.next),l=o(l,l.next),s(u,e,r,n,i,a),void s(l,e,r,n,i,a)}h=h.next}u=u.next}while(u!==t)}function c(t,e,r,n){var s,a,u,h,l,c=[];for(s=0,a=e.length;s<a;s++)u=e[s]*n,h=s<a-1?e[s+1]*n:t.length,l=i(t,u,h,n,!1),l===l.next&&(l.steiner=!0),c.push(m(l));for(c.sort(d),s=0;s<c.length;s++)f(c[s],r),r=o(r,r.next);return r}function d(t,e){return t.x-e.x}function f(t,e){if(e=p(t,e)){var r=P(e,t);o(r,r.next)}}function p(t,e){var r,n=e,i=t.x,o=t.y,s=-(1/0);do{if(o<=n.y&&o>=n.next.y){var a=n.x+(o-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(a<=i&&a>s){if(s=a,a===i){if(o===n.y)return n;if(o===n.next.y)return n.next}r=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!r)return null;if(i===s)return r.prev;var u,h=r,l=r.x,c=r.y,d=1/0;for(n=r.next;n!==h;)i>=n.x&&n.x>=l&&_(o<c?i:s,o,l,c,o<c?s:i,o,n.x,n.y)&&(u=Math.abs(o-n.y)/(i-n.x),(u<d||u===d&&n.x>r.x)&&S(n,t)&&(r=n,d=u)),n=n.next;return r}function v(t,e,r,n){var i=t;do null===i.z&&(i.z=g(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,y(i)}function y(t){var e,r,n,i,o,s,a,u,h=1;do{for(r=t,t=null,o=null,s=0;r;){for(s++,n=r,a=0,e=0;e<h&&(a++,n=n.nextZ,n);e++);for(u=h;a>0||u>0&&n;)0===a?(i=n,n=n.nextZ,u--):0!==u&&n?r.z<=n.z?(i=r,r=r.nextZ,a--):(i=n,n=n.nextZ,u--):(i=r,r=r.nextZ,a--),o?o.nextZ=i:t=i,i.prevZ=o,o=i;r=n}o.nextZ=null,h*=2}while(s>1);return t}function g(t,e,r,n,i){return t=32767*(t-r)/i,e=32767*(e-n)/i,t=16711935&(t|t<<8),t=252645135&(t|t<<4),t=858993459&(t|t<<2),t=1431655765&(t|t<<1),e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),t|e<<1}function m(t){var e=t,r=t;do e.x<r.x&&(r=e),e=e.next;while(e!==t);return r}function _(t,e,r,n,i,o,s,a){return(i-s)*(e-a)-(t-s)*(o-a)>=0&&(t-s)*(n-a)-(r-s)*(e-a)>=0&&(r-s)*(o-a)-(i-s)*(n-a)>=0}function b(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!E(t,e)&&S(t,e)&&S(e,t)&&O(t,e)}function x(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function T(t,e){return t.x===e.x&&t.y===e.y}function w(t,e,r,n){return!!(T(t,e)&&T(r,n)||T(t,n)&&T(r,e))||x(t,e,r)>0!=x(t,e,n)>0&&x(r,n,t)>0!=x(r,n,e)>0}function E(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&w(r,r.next,t,e))return!0;r=r.next}while(r!==t);return!1}function S(t,e){return x(t.prev,t,t.next)<0?x(t,e,t.next)>=0&&x(t,t.prev,e)>=0:x(t,e,t.prev)<0||x(t,t.next,e)<0}function O(t,e){var r=t,n=!1,i=(t.x+e.x)/2,o=(t.y+e.y)/2;do r.y>o!=r.next.y>o&&i<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==t);return n}function P(t,e){var r=new R(t.i,t.x,t.y),n=new R(e.i,e.x,e.y),i=t.next,o=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n}function M(t,e,r,n){var i=new R(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function C(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function R(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function A(t,e,r,n){for(var i=0,o=e,s=r-n;o<r;o+=n)i+=(t[s]-t[o])*(t[o+1]+t[s+1]),s=o;return i}e.exports=n,n.deviation=function(t,e,r,n){var i=e&&e.length,o=i?e[0]*r:t.length,s=Math.abs(A(t,0,o,r));if(i)for(var a=0,u=e.length;a<u;a++){var h=e[a]*r,l=a<u-1?e[a+1]*r:t.length;s-=Math.abs(A(t,h,l,r))}var c=0;for(a=0;a<n.length;a+=3){var d=n[a]*r,f=n[a+1]*r,p=n[a+2]*r;c+=Math.abs((t[d]-t[p])*(t[f+1]-t[d+1])-(t[d]-t[f])*(t[p+1]-t[d+1]))}return 0===s&&0===c?0:Math.abs((c-s)/s)},n.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},n=0,i=0;i<t.length;i++){for(var o=0;o<t[i].length;o++)for(var s=0;s<e;s++)r.vertices.push(t[i][o][s]);i>0&&(n+=t[i-1].length,r.holes.push(n))}return r}},{}],3:[function(t,e,r){"use strict";function n(){}function i(t,e,r){this.fn=t,this.context=e,this.once=r||!1}function o(){this._events=new n,this._eventsCount=0}var s=Object.prototype.hasOwnProperty,a="~";Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(a=!1)),o.prototype.eventNames=function(){var t,e,r=[];if(0===this._eventsCount)return r;for(e in t=this._events)s.call(t,e)&&r.push(a?e.slice(1):e);return Object.getOwnPropertySymbols?r.concat(Object.getOwnPropertySymbols(t)):r},o.prototype.listeners=function(t,e){var r=a?a+t:t,n=this._events[r];if(e)return!!n;if(!n)return[];if(n.fn)return[n.fn];for(var i=0,o=n.length,s=new Array(o);i<o;i++)s[i]=n[i].fn;return s},o.prototype.emit=function(t,e,r,n,i,o){var s=a?a+t:t;if(!this._events[s])return!1;var u,h,l=this._events[s],c=arguments.length;if(l.fn){switch(l.once&&this.removeListener(t,l.fn,void 0,!0),c){case 1:return l.fn.call(l.context),!0;case 2:return l.fn.call(l.context,e),!0;case 3:return l.fn.call(l.context,e,r),!0;case 4:return l.fn.call(l.context,e,r,n),!0;case 5:return l.fn.call(l.context,e,r,n,i),!0;case 6:return l.fn.call(l.context,e,r,n,i,o),!0}for(h=1,u=new Array(c-1);h<c;h++)u[h-1]=arguments[h];l.fn.apply(l.context,u)}else{var d,f=l.length;for(h=0;h<f;h++)switch(l[h].once&&this.removeListener(t,l[h].fn,void 0,!0),c){case 1:l[h].fn.call(l[h].context);break;case 2:l[h].fn.call(l[h].context,e);break;case 3:l[h].fn.call(l[h].context,e,r);break;case 4:l[h].fn.call(l[h].context,e,r,n);break;default:if(!u)for(d=1,u=new Array(c-1);d<c;d++)u[d-1]=arguments[d];l[h].fn.apply(l[h].context,u)}}return!0},o.prototype.on=function(t,e,r){var n=new i(e,r||this),o=a?a+t:t;return this._events[o]?this._events[o].fn?this._events[o]=[this._events[o],n]:this._events[o].push(n):(this._events[o]=n,this._eventsCount++),this},o.prototype.once=function(t,e,r){var n=new i(e,r||this,(!0)),o=a?a+t:t;return this._events[o]?this._events[o].fn?this._events[o]=[this._events[o],n]:this._events[o].push(n):(this._events[o]=n,this._eventsCount++),this},o.prototype.removeListener=function(t,e,r,i){var o=a?a+t:t;if(!this._events[o])return this;if(!e)return 0===--this._eventsCount?this._events=new n:delete this._events[o],this;var s=this._events[o];if(s.fn)s.fn!==e||i&&!s.once||r&&s.context!==r||(0===--this._eventsCount?this._events=new n:delete this._events[o]);else{for(var u=0,h=[],l=s.length;u<l;u++)(s[u].fn!==e||i&&!s[u].once||r&&s[u].context!==r)&&h.push(s[u]);h.length?this._events[o]=1===h.length?h[0]:h:0===--this._eventsCount?this._events=new n:delete this._events[o]}return this},o.prototype.removeAllListeners=function(t){var e;return t?(e=a?a+t:t,this._events[e]&&(0===--this._eventsCount?this._events=new n:delete this._events[e])):(this._events=new n,this._eventsCount=0),this},o.prototype.off=o.prototype.removeListener,o.prototype.addListener=o.prototype.on,o.prototype.setMaxListeners=function(){return this},o.prefixed=a,o.EventEmitter=o,"undefined"!=typeof e&&(e.exports=o)},{}],4:[function(e,r,n){!function(e){var n=/iPhone/i,i=/iPod/i,o=/iPad/i,s=/(?=.*\bAndroid\b)(?=.*\bMobile\b)/i,a=/Android/i,u=/(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,h=/(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,l=/IEMobile/i,c=/(?=.*\bWindows\b)(?=.*\bARM\b)/i,d=/BlackBerry/i,f=/BB10/i,p=/Opera Mini/i,v=/(CriOS|Chrome)(?=.*\bMobile\b)/i,y=/(?=.*\bFirefox\b)(?=.*\bMobile\b)/i,g=new RegExp("(?:Nexus 7|BNTV250|Kindle Fire|Silk|GT-P1000)","i"),m=function(t,e){return t.test(e)},_=function(t){var e=t||navigator.userAgent,r=e.split("[FBAN");if("undefined"!=typeof r[1]&&(e=r[0]),r=e.split("Twitter"),"undefined"!=typeof r[1]&&(e=r[0]),this.apple={phone:m(n,e),ipod:m(i,e),tablet:!m(n,e)&&m(o,e),device:m(n,e)||m(i,e)||m(o,e)},this.amazon={phone:m(u,e),tablet:!m(u,e)&&m(h,e),device:m(u,e)||m(h,e)},this.android={phone:m(u,e)||m(s,e),tablet:!m(u,e)&&!m(s,e)&&(m(h,e)||m(a,e)),device:m(u,e)||m(h,e)||m(s,e)||m(a,e)},this.windows={phone:m(l,e),tablet:m(c,e),device:m(l,e)||m(c,e)},this.other={blackberry:m(d,e),blackberry10:m(f,e),opera:m(p,e),firefox:m(y,e),chrome:m(v,e),device:m(d,e)||m(f,e)||m(p,e)||m(y,e)||m(v,e)},this.seven_inch=m(g,e),this.any=this.apple.device||this.android.device||this.windows.device||this.other.device||this.seven_inch,this.phone=this.apple.phone||this.android.phone||this.windows.phone,this.tablet=this.apple.tablet||this.android.tablet||this.windows.tablet,"undefined"==typeof window)return this},b=function(){var t=new _;return t.Class=_,t};"undefined"!=typeof r&&r.exports&&"undefined"==typeof window?r.exports=_:"undefined"!=typeof r&&r.exports&&"undefined"!=typeof window?r.exports=b():"function"==typeof t&&t.amd?t("isMobile",[],e.isMobile=b()):e.isMobile=b()}(this)},{}],5:[function(t,e,r){"use strict";function n(t){if(null===t||void 0===t)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(t)}function i(){try{if(!Object.assign)return!1;var t=new String("abc");if(t[5]="de","5"===Object.getOwnPropertyNames(t)[0])return!1;for(var e={},r=0;r<10;r++)e["_"+String.fromCharCode(r)]=r;var n=Object.getOwnPropertyNames(e).map(function(t){return e[t]});if("0123456789"!==n.join(""))return!1;var i={};return"abcdefghijklmnopqrst".split("").forEach(function(t){i[t]=t}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},i)).join("")}catch(t){return!1}}var o=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;e.exports=i()?Object.assign:function(t,e){for(var r,i,u=n(t),h=1;h<arguments.length;h++){r=Object(arguments[h]);for(var l in r)s.call(r,l)&&(u[l]=r[l]);if(o){i=o(r);for(var c=0;c<i.length;c++)a.call(r,i[c])&&(u[i[c]]=r[i[c]])}}return u}},{}],6:[function(t,e,r){var n=new ArrayBuffer(0),i=function(t,e,r,i){this.gl=t,this.buffer=t.createBuffer(),this.type=e||t.ARRAY_BUFFER,this.drawType=i||t.STATIC_DRAW,this.data=n,r&&this.upload(r)};i.prototype.upload=function(t,e,r){r||this.bind();var n=this.gl;t=t||this.data,e=e||0,this.data.byteLength>=t.byteLength?n.bufferSubData(this.type,e,t):n.bufferData(this.type,t,this.drawType),this.data=t},i.prototype.bind=function(){var t=this.gl;t.bindBuffer(this.type,this.buffer)},i.createVertexBuffer=function(t,e,r){return new i(t,t.ARRAY_BUFFER,e,r)},i.createIndexBuffer=function(t,e,r){return new i(t,t.ELEMENT_ARRAY_BUFFER,e,r)},i.create=function(t,e,r,n){return new i(t,e,r,n)},i.prototype.destroy=function(){this.gl.deleteBuffer(this.buffer)},e.exports=i},{}],7:[function(t,e,r){var n=t("./GLTexture"),i=function(t,e,r){this.gl=t,this.framebuffer=t.createFramebuffer(),this.stencil=null,this.texture=null,this.width=e||100,this.height=r||100};i.prototype.enableTexture=function(t){var e=this.gl;this.texture=t||new n(e),this.texture.bind(),this.bind(),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture.texture,0)},i.prototype.enableStencil=function(){if(!this.stencil){var t=this.gl;this.stencil=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,this.stencil),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,this.stencil),t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_STENCIL,this.width,this.height)}},i.prototype.clear=function(t,e,r,n){this.bind();var i=this.gl;i.clearColor(t,e,r,n),i.clear(i.COLOR_BUFFER_BIT)},i.prototype.bind=function(){var t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer)},i.prototype.unbind=function(){var t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null)},i.prototype.resize=function(t,e){var r=this.gl;this.width=t,this.height=e,this.texture&&this.texture.uploadData(null,t,e),this.stencil&&(r.bindRenderbuffer(r.RENDERBUFFER,this.stencil),r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_STENCIL,t,e))},i.prototype.destroy=function(){var t=this.gl;this.texture&&this.texture.destroy(),t.deleteFramebuffer(this.framebuffer),this.gl=null,this.stencil=null,this.texture=null},i.createRGBA=function(t,e,r,o){var s=n.fromData(t,null,e,r);s.enableNearestScaling(),s.enableWrapClamp();var a=new i(t,e,r);return a.enableTexture(s),a.unbind(),a},i.createFloat32=function(t,e,r,o){var s=new n.fromData(t,o,e,r);s.enableNearestScaling(),s.enableWrapClamp();var a=new i(t,e,r);return a.enableTexture(s),a.unbind(),a},e.exports=i},{"./GLTexture":9}],8:[function(t,e,r){var n=t("./shader/compileProgram"),i=t("./shader/extractAttributes"),o=t("./shader/extractUniforms"),s=t("./shader/generateUniformAccessObject"),a=function(t,e,r){this.gl=t,this.program=n(t,e,r),this.attributes=i(t,this.program);var a=o(t,this.program);this.uniforms=s(t,a)};a.prototype.bind=function(){this.gl.useProgram(this.program)},a.prototype.destroy=function(){},e.exports=a},{"./shader/compileProgram":14,"./shader/extractAttributes":16,"./shader/extractUniforms":17,"./shader/generateUniformAccessObject":18}],9:[function(t,e,r){var n=function(t,e,r,n,i){this.gl=t,this.texture=t.createTexture(),this.mipmap=!1,this.premultiplyAlpha=!1,this.width=e||-1,this.height=r||-1,this.format=n||t.RGBA,this.type=i||t.UNSIGNED_BYTE};n.prototype.upload=function(t){this.bind();var e=this.gl;e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);var r=t.videoWidth||t.width,n=t.videoHeight||t.height;n!==this.height||r!==this.width?e.texImage2D(e.TEXTURE_2D,0,this.format,this.format,this.type,t):e.texSubImage2D(e.TEXTURE_2D,0,0,0,this.format,this.type,t),this.width=r,this.height=n};var i=!1;n.prototype.uploadData=function(t,e,r){this.bind();var n=this.gl;if(t instanceof Float32Array){if(!i){var o=n.getExtension("OES_texture_float");if(!o)throw new Error("floating point textures not available");i=!0}this.type=n.FLOAT}else this.type=n.UNSIGNED_BYTE;n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha),e!==this.width||r!==this.height?n.texImage2D(n.TEXTURE_2D,0,this.format,e,r,0,this.format,this.type,t||null):n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,this.format,this.type,t||null),this.width=e,this.height=r},n.prototype.bind=function(t){var e=this.gl;void 0!==t&&e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,this.texture)},n.prototype.unbind=function(){var t=this.gl;t.bindTexture(t.TEXTURE_2D,null)},n.prototype.minFilter=function(t){var e=this.gl;this.bind(),this.mipmap?e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,t?e.LINEAR_MIPMAP_LINEAR:e.NEAREST_MIPMAP_NEAREST):e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,t?e.LINEAR:e.NEAREST)},n.prototype.magFilter=function(t){var e=this.gl;this.bind(),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,t?e.LINEAR:e.NEAREST)},n.prototype.enableMipmap=function(){var t=this.gl;this.bind(),this.mipmap=!0,t.generateMipmap(t.TEXTURE_2D)},n.prototype.enableLinearScaling=function(){this.minFilter(!0),this.magFilter(!0)},n.prototype.enableNearestScaling=function(){this.minFilter(!1),this.magFilter(!1)},n.prototype.enableWrapClamp=function(){var t=this.gl;this.bind(),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)},n.prototype.enableWrapRepeat=function(){var t=this.gl;this.bind(),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT)},n.prototype.enableWrapMirrorRepeat=function(){var t=this.gl;this.bind(),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.MIRRORED_REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.MIRRORED_REPEAT)},n.prototype.destroy=function(){var t=this.gl;t.deleteTexture(this.texture)},n.fromSource=function(t,e,r){var i=new n(t);return i.premultiplyAlpha=r||!1,i.upload(e),i},n.fromData=function(t,e,r,i){var o=new n(t);return o.uploadData(e,r,i),o},e.exports=n},{}],10:[function(t,e,r){function n(t,e){if(this.nativeVaoExtension=null,n.FORCE_NATIVE||(this.nativeVaoExtension=t.getExtension("OES_vertex_array_object")||t.getExtension("MOZ_OES_vertex_array_object")||t.getExtension("WEBKIT_OES_vertex_array_object")),this.nativeState=e,this.nativeVaoExtension){this.nativeVao=this.nativeVaoExtension.createVertexArrayOES();var r=t.getParameter(t.MAX_VERTEX_ATTRIBS);this.nativeState={tempAttribState:new Array(r),attribState:new Array(r)}}this.gl=t,this.attributes=[],this.indexBuffer=null,this.dirty=!1}var i=t("./setVertexAttribArrays");n.prototype.constructor=n,e.exports=n,n.FORCE_NATIVE=!1,n.prototype.bind=function(){return this.nativeVao?(this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao),this.dirty&&(this.dirty=!1,this.activate())):this.activate(),this},n.prototype.unbind=function(){return this.nativeVao&&this.nativeVaoExtension.bindVertexArrayOES(null),this},n.prototype.activate=function(){for(var t=this.gl,e=null,r=0;r<this.attributes.length;r++){var n=this.attributes[r];e!==n.buffer&&(n.buffer.bind(),e=n.buffer),t.vertexAttribPointer(n.attribute.location,n.attribute.size,n.type||t.FLOAT,n.normalized||!1,n.stride||0,n.start||0)}return i(t,this.attributes,this.nativeState),this.indexBuffer.bind(),this},n.prototype.addAttribute=function(t,e,r,n,i,o){return this.attributes.push({buffer:t,attribute:e,location:e.location,type:r||this.gl.FLOAT,normalized:n||!1,stride:i||0,start:o||0}),this.dirty=!0,this},n.prototype.addIndex=function(t){return this.indexBuffer=t,this.dirty=!0,this},n.prototype.clear=function(){return this.nativeVao&&this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao),this.attributes.length=0,this.indexBuffer=null,this},n.prototype.draw=function(t,e,r){var n=this.gl;return n.drawElements(t,e,n.UNSIGNED_SHORT,r||0),this},n.prototype.destroy=function(){this.gl=null,this.indexBuffer=null,this.attributes=null,this.nativeState=null,this.nativeVao&&this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao),this.nativeVaoExtension=null,this.nativeVao=null}},{"./setVertexAttribArrays":13}],11:[function(t,e,r){var n=function(t,e){var r=t.getContext("webgl",e)||t.getContext("experimental-webgl",e);if(!r)throw new Error("This browser does not support webGL. Try using the canvas renderer");return r};e.exports=n},{}],12:[function(t,e,r){var n={createContext:t("./createContext"),setVertexAttribArrays:t("./setVertexAttribArrays"),GLBuffer:t("./GLBuffer"),GLFramebuffer:t("./GLFramebuffer"),GLShader:t("./GLShader"),GLTexture:t("./GLTexture"),VertexArrayObject:t("./VertexArrayObject"),shader:t("./shader")};"undefined"!=typeof e&&e.exports&&(e.exports=n),"undefined"!=typeof window&&(window.PIXI=window.PIXI||{},window.PIXI.glCore=n)},{"./GLBuffer":6,"./GLFramebuffer":7,"./GLShader":8,"./GLTexture":9,"./VertexArrayObject":10,"./createContext":11,"./setVertexAttribArrays":13,"./shader":19}],13:[function(t,e,r){var n=function(t,e,r){var n;if(r){var i=r.tempAttribState,o=r.attribState;for(n=0;n<i.length;n++)i[n]=!1;for(n=0;n<e.length;n++)i[e[n].attribute.location]=!0;for(n=0;n<o.length;n++)o[n]!==i[n]&&(o[n]=i[n],r.attribState[n]?t.enableVertexAttribArray(n):t.disableVertexAttribArray(n))}else for(n=0;n<e.length;n++){var s=e[n];t.enableVertexAttribArray(s.attribute.location)}};e.exports=n},{}],14:[function(t,e,r){var n=function(t,e,r){var n=i(t,t.VERTEX_SHADER,e),o=i(t,t.FRAGMENT_SHADER,r),s=t.createProgram();return t.attachShader(s,n),t.attachShader(s,o),t.linkProgram(s),t.getProgramParameter(s,t.LINK_STATUS)||(console.error("Pixi.js Error: Could not initialize shader."),console.error("gl.VALIDATE_STATUS",t.getProgramParameter(s,t.VALIDATE_STATUS)),console.error("gl.getError()",t.getError()),""!==t.getProgramInfoLog(s)&&console.warn("Pixi.js Warning: gl.getProgramInfoLog()",t.getProgramInfoLog(s)),t.deleteProgram(s),s=null),t.deleteShader(n),t.deleteShader(o),s},i=function(t,e,r){var n=t.createShader(e);return t.shaderSource(n,r),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS)?n:(console.log(t.getShaderInfoLog(n)),null)};e.exports=n},{}],15:[function(t,e,r){var n=function(t,e){switch(t){case"float":return 0;case"vec2":return new Float32Array(2*e);case"vec3":return new Float32Array(3*e);case"vec4":return new Float32Array(4*e);case"int":case"sampler2D":return 0;case"ivec2":return new Int32Array(2*e);case"ivec3":return new Int32Array(3*e);case"ivec4":return new Int32Array(4*e);case"bool":return!1;case"bvec2":return i(2*e);case"bvec3":return i(3*e);case"bvec4":return i(4*e);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}},i=function(t){for(var e=new Array(t),r=0;r<e.length;r++)e[r]=!1;return e};e.exports=n},{}],16:[function(t,e,r){var n=t("./mapType"),i=t("./mapSize"),o=function(t,e){for(var r={},o=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES),a=0;a<o;a++){var u=t.getActiveAttrib(e,a),h=n(t,u.type);r[u.name]={type:h,size:i(h),location:t.getAttribLocation(e,u.name),pointer:s}}return r},s=function(t,e,r,n){gl.vertexAttribPointer(this.location,this.size,t||gl.FLOAT,e||!1,r||0,n||0)};e.exports=o},{"./mapSize":20,"./mapType":21}],17:[function(t,e,r){var n=t("./mapType"),i=t("./defaultValue"),o=function(t,e){for(var r={},o=t.getProgramParameter(e,t.ACTIVE_UNIFORMS),s=0;s<o;s++){var a=t.getActiveUniform(e,s),u=a.name.replace(/\[.*?\]/,""),h=n(t,a.type);r[u]={type:h,size:a.size,location:t.getUniformLocation(e,u),value:i(h,a.size)}}return r};e.exports=o},{"./defaultValue":15,"./mapType":21}],18:[function(t,e,r){var n=function(t,e){var r={data:{}};r.gl=t;for(var n=Object.keys(e),a=0;a<n.length;a++){var u=n[a],h=u.split("."),l=h[h.length-1],c=s(h,r),d=e[u];c.data[l]=d,c.gl=t,Object.defineProperty(c,l,{get:i(l),set:o(l,d)})}return r},i=function(t){var e=a.replace("%%",t);return new Function(e)},o=function(t,e){var r,n=u.replace(/%%/g,t);return r=1===e.size?h[e.type]:l[e.type],r&&(n+="\nthis.gl."+r+";"),new Function("value",n)},s=function(t,e){for(var r=e,n=0;n<t.length-1;n++){var i=r[t[n]]||{data:{}};r[t[n]]=i,r=i}return r},a=["return this.data.%%.value;"].join("\n"),u=["this.data.%%.value = value;","var location = this.data.%%.location;"].join("\n"),h={float:"uniform1f(location, value)",vec2:"uniform2f(location, value[0], value[1])",vec3:"uniform3f(location, value[0], value[1], value[2])",vec4:"uniform4f(location, value[0], value[1], value[2], value[3])",int:"uniform1i(location, value)",ivec2:"uniform2i(location, value[0], value[1])",ivec3:"uniform3i(location, value[0], value[1], value[2])",ivec4:"uniform4i(location, value[0], value[1], value[2], value[3])",bool:"uniform1i(location, value)",bvec2:"uniform2i(location, value[0], value[1])",bvec3:"uniform3i(location, value[0], value[1], value[2])",bvec4:"uniform4i(location, value[0], value[1], value[2], value[3])",mat2:"uniformMatrix2fv(location, false, value)",mat3:"uniformMatrix3fv(location, false, value)",mat4:"uniformMatrix4fv(location, false, value)",sampler2D:"uniform1i(location, value)"},l={float:"uniform1fv(location, value)",vec2:"uniform2fv(location, value)",vec3:"uniform3fv(location, value)",vec4:"uniform4fv(location, value)",int:"uniform1iv(location, value)",ivec2:"uniform2iv(location, value)",ivec3:"uniform3iv(location, value)",ivec4:"uniform4iv(location, value)",bool:"uniform1iv(location, value)",bvec2:"uniform2iv(location, value)",bvec3:"uniform3iv(location, value)",bvec4:"uniform4iv(location, value)",sampler2D:"uniform1iv(location, value)"};e.exports=n},{}],19:[function(t,e,r){e.exports={compileProgram:t("./compileProgram"),defaultValue:t("./defaultValue"),extractAttributes:t("./extractAttributes"),extractUniforms:t("./extractUniforms"),generateUniformAccessObject:t("./generateUniformAccessObject"),mapSize:t("./mapSize"),mapType:t("./mapType")}},{"./compileProgram":14,"./defaultValue":15,"./extractAttributes":16,"./extractUniforms":17,"./generateUniformAccessObject":18,"./mapSize":20,"./mapType":21}],20:[function(t,e,r){var n=function(t){return i[t]},i={float:1,vec2:2,vec3:3,vec4:4,int:1,ivec2:2,ivec3:3,ivec4:4,bool:1,bvec2:2,bvec3:3,bvec4:4,mat2:4,mat3:9,mat4:16,sampler2D:1};e.exports=n},{}],21:[function(t,e,r){var n=function(t,e){if(!i){var r=Object.keys(o);i={};for(var n=0;n<r.length;++n){var s=r[n];i[t[s]]=o[s]}}return i[e]},i=null,o={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D"};e.exports=n},{}],22:[function(t,e,r){(function(t){function e(t,e){for(var r=0,n=t.length-1;n>=0;n--){var i=t[n];"."===i?t.splice(n,1):".."===i?(t.splice(n,1),r++):r&&(t.splice(n,1),r--)}if(e)for(;r--;r)t.unshift("..");return t}function n(t,e){if(t.filter)return t.filter(e);for(var r=[],n=0;n<t.length;n++)e(t[n],n,t)&&r.push(t[n]);return r}var i=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,o=function(t){return i.exec(t).slice(1)};r.resolve=function(){for(var r="",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s=o>=0?arguments[o]:t.cwd();if("string"!=typeof s)throw new TypeError("Arguments to path.resolve must be strings");s&&(r=s+"/"+r,i="/"===s.charAt(0))}return r=e(n(r.split("/"),function(t){return!!t}),!i).join("/"),(i?"/":"")+r||"."},r.normalize=function(t){var i=r.isAbsolute(t),o="/"===s(t,-1);return t=e(n(t.split("/"),function(t){return!!t}),!i).join("/"),t||i||(t="."),t&&o&&(t+="/"),(i?"/":"")+t},r.isAbsolute=function(t){return"/"===t.charAt(0)},r.join=function(){var t=Array.prototype.slice.call(arguments,0);return r.normalize(n(t,function(t,e){if("string"!=typeof t)throw new TypeError("Arguments to path.join must be strings");return t}).join("/"))},r.relative=function(t,e){function n(t){for(var e=0;e<t.length&&""===t[e];e++);for(var r=t.length-1;r>=0&&""===t[r];r--);return e>r?[]:t.slice(e,r-e+1)}t=r.resolve(t).substr(1),e=r.resolve(e).substr(1);for(var i=n(t.split("/")),o=n(e.split("/")),s=Math.min(i.length,o.length),a=s,u=0;u<s;u++)if(i[u]!==o[u]){a=u;break}for(var h=[],u=a;u<i.length;u++)h.push("..");return h=h.concat(o.slice(a)),h.join("/")},r.sep="/",r.delimiter=":",r.dirname=function(t){var e=o(t),r=e[0],n=e[1];return r||n?(n&&(n=n.substr(0,n.length-1)),r+n):"."},r.basename=function(t,e){var r=o(t)[2];return e&&r.substr(-1*e.length)===e&&(r=r.substr(0,r.length-e.length)),r},r.extname=function(t){return o(t)[3]};var s="b"==="ab".substr(-1)?function(t,e,r){return t.substr(e,r)}:function(t,e,r){return e<0&&(e=t.length+e),t.substr(e,r)}}).call(this,t("_process"))},{_process:23}],23:[function(t,e,r){function n(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function o(t){if(c===setTimeout)return setTimeout(t,0);if((c===n||!c)&&setTimeout)return c=setTimeout,setTimeout(t,0);try{return c(t,0)}catch(e){try{return c.call(null,t,0)}catch(e){return c.call(this,t,0)}}}function s(t){if(d===clearTimeout)return clearTimeout(t);if((d===i||!d)&&clearTimeout)return d=clearTimeout,clearTimeout(t);try{return d(t)}catch(e){try{return d.call(null,t)}catch(e){return d.call(this,t)}}}function a(){y&&p&&(y=!1,p.length?v=p.concat(v):g=-1,v.length&&u())}function u(){if(!y){var t=o(a);y=!0;for(var e=v.length;e;){for(p=v,v=[];++g<e;)p&&p[g].run();g=-1,e=v.length}p=null,y=!1,s(t)}}function h(t,e){this.fun=t,this.array=e}function l(){}var c,d,f=e.exports={};!function(){try{c="function"==typeof setTimeout?setTimeout:n}catch(t){c=n}try{d="function"==typeof clearTimeout?clearTimeout:i}catch(t){
    d=i}}();var p,v=[],y=!1,g=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];v.push(new h(t,e)),1!==v.length||y||o(u)},h.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=l,f.addListener=l,f.once=l,f.off=l,f.removeListener=l,f.removeAllListeners=l,f.emit=l,f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},{}],24:[function(e,r,n){(function(e){!function(i){function o(t){throw new RangeError(L[t])}function s(t,e){for(var r=t.length,n=[];r--;)n[r]=e(t[r]);return n}function a(t,e){var r=t.split("@"),n="";r.length>1&&(n=r[0]+"@",t=r[1]),t=t.replace(D,".");var i=t.split("."),o=s(i,e).join(".");return n+o}function u(t){for(var e,r,n=[],i=0,o=t.length;i<o;)e=t.charCodeAt(i++),e>=55296&&e<=56319&&i<o?(r=t.charCodeAt(i++),56320==(64512&r)?n.push(((1023&e)<<10)+(1023&r)+65536):(n.push(e),i--)):n.push(e);return n}function h(t){return s(t,function(t){var e="";return t>65535&&(t-=65536,e+=B(t>>>10&1023|55296),t=56320|1023&t),e+=B(t)}).join("")}function l(t){return t-48<10?t-22:t-65<26?t-65:t-97<26?t-97:w}function c(t,e){return t+22+75*(t<26)-((0!=e)<<5)}function d(t,e,r){var n=0;for(t=r?F(t/P):t>>1,t+=F(t/e);t>N*S>>1;n+=w)t=F(t/N);return F(n+(N+1)*t/(t+O))}function f(t){var e,r,n,i,s,a,u,c,f,p,v=[],y=t.length,g=0,m=C,_=M;for(r=t.lastIndexOf(R),r<0&&(r=0),n=0;n<r;++n)t.charCodeAt(n)>=128&&o("not-basic"),v.push(t.charCodeAt(n));for(i=r>0?r+1:0;i<y;){for(s=g,a=1,u=w;i>=y&&o("invalid-input"),c=l(t.charCodeAt(i++)),(c>=w||c>F((T-g)/a))&&o("overflow"),g+=c*a,f=u<=_?E:u>=_+S?S:u-_,!(c<f);u+=w)p=w-f,a>F(T/p)&&o("overflow"),a*=p;e=v.length+1,_=d(g-s,e,0==s),F(g/e)>T-m&&o("overflow"),m+=F(g/e),g%=e,v.splice(g++,0,m)}return h(v)}function p(t){var e,r,n,i,s,a,h,l,f,p,v,y,g,m,_,b=[];for(t=u(t),y=t.length,e=C,r=0,s=M,a=0;a<y;++a)v=t[a],v<128&&b.push(B(v));for(n=i=b.length,i&&b.push(R);n<y;){for(h=T,a=0;a<y;++a)v=t[a],v>=e&&v<h&&(h=v);for(g=n+1,h-e>F((T-r)/g)&&o("overflow"),r+=(h-e)*g,e=h,a=0;a<y;++a)if(v=t[a],v<e&&++r>T&&o("overflow"),v==e){for(l=r,f=w;p=f<=s?E:f>=s+S?S:f-s,!(l<p);f+=w)_=l-p,m=w-p,b.push(B(c(p+_%m,0))),l=F(_/m);b.push(B(c(l,0))),s=d(r,g,n==i),r=0,++n}++r,++e}return b.join("")}function v(t){return a(t,function(t){return A.test(t)?f(t.slice(4).toLowerCase()):t})}function y(t){return a(t,function(t){return I.test(t)?"xn--"+p(t):t})}var g="object"==typeof n&&n&&!n.nodeType&&n,m="object"==typeof r&&r&&!r.nodeType&&r,_="object"==typeof e&&e;_.global!==_&&_.window!==_&&_.self!==_||(i=_);var b,x,T=2147483647,w=36,E=1,S=26,O=38,P=700,M=72,C=128,R="-",A=/^xn--/,I=/[^\x20-\x7E]/,D=/[\x2E\u3002\uFF0E\uFF61]/g,L={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},N=w-E,F=Math.floor,B=String.fromCharCode;if(b={version:"1.4.1",ucs2:{decode:u,encode:h},decode:f,encode:p,toASCII:y,toUnicode:v},"function"==typeof t&&"object"==typeof t.amd&&t.amd)t("punycode",function(){return b});else if(g&&m)if(r.exports==g)m.exports=b;else for(x in b)b.hasOwnProperty(x)&&(g[x]=b[x]);else i.punycode=b}(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],25:[function(t,e,r){"use strict";function n(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.exports=function(t,e,r,o){e=e||"&",r=r||"=";var s={};if("string"!=typeof t||0===t.length)return s;var a=/\+/g;t=t.split(e);var u=1e3;o&&"number"==typeof o.maxKeys&&(u=o.maxKeys);var h=t.length;u>0&&h>u&&(h=u);for(var l=0;l<h;++l){var c,d,f,p,v=t[l].replace(a,"%20"),y=v.indexOf(r);y>=0?(c=v.substr(0,y),d=v.substr(y+1)):(c=v,d=""),f=decodeURIComponent(c),p=decodeURIComponent(d),n(s,f)?i(s[f])?s[f].push(p):s[f]=[s[f],p]:s[f]=p}return s};var i=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)}},{}],26:[function(t,e,r){"use strict";function n(t,e){if(t.map)return t.map(e);for(var r=[],n=0;n<t.length;n++)r.push(e(t[n],n));return r}var i=function(t){switch(typeof t){case"string":return t;case"boolean":return t?"true":"false";case"number":return isFinite(t)?t:"";default:return""}};e.exports=function(t,e,r,a){return e=e||"&",r=r||"=",null===t&&(t=void 0),"object"==typeof t?n(s(t),function(s){var a=encodeURIComponent(i(s))+r;return o(t[s])?n(t[s],function(t){return a+encodeURIComponent(i(t))}).join(e):a+encodeURIComponent(i(t[s]))}).join(e):a?encodeURIComponent(i(a))+r+encodeURIComponent(i(t)):""};var o=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},s=Object.keys||function(t){var e=[];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.push(r);return e}},{}],27:[function(t,e,r){"use strict";r.decode=r.parse=t("./decode"),r.encode=r.stringify=t("./encode")},{"./decode":25,"./encode":26}],28:[function(t,e,r){"use strict";function n(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function i(t,e,r){if(t&&h.isObject(t)&&t instanceof n)return t;var i=new n;return i.parse(t,e,r),i}function o(t){return h.isString(t)&&(t=i(t)),t instanceof n?t.format():n.prototype.format.call(t)}function s(t,e){return i(t,!1,!0).resolve(e)}function a(t,e){return t?i(t,!1,!0).resolveObject(e):e}var u=t("punycode"),h=t("./util");r.parse=i,r.resolve=s,r.resolveObject=a,r.format=o,r.Url=n;var l=/^([a-z0-9.+-]+:)/i,c=/:[0-9]*$/,d=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,f=["<",">",'"',"`"," ","\r","\n","\t"],p=["{","}","|","\\","^","`"].concat(f),v=["'"].concat(p),y=["%","/","?",";","#"].concat(v),g=["/","?","#"],m=255,_=/^[+a-z0-9A-Z_-]{0,63}$/,b=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,x={javascript:!0,"javascript:":!0},T={javascript:!0,"javascript:":!0},w={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},E=t("querystring");n.prototype.parse=function(t,e,r){if(!h.isString(t))throw new TypeError("Parameter 'url' must be a string, not "+typeof t);var n=t.indexOf("?"),i=n!==-1&&n<t.indexOf("#")?"?":"#",o=t.split(i),s=/\\/g;o[0]=o[0].replace(s,"/"),t=o.join(i);var a=t;if(a=a.trim(),!r&&1===t.split("#").length){var c=d.exec(a);if(c)return this.path=a,this.href=a,this.pathname=c[1],c[2]?(this.search=c[2],e?this.query=E.parse(this.search.substr(1)):this.query=this.search.substr(1)):e&&(this.search="",this.query={}),this}var f=l.exec(a);if(f){f=f[0];var p=f.toLowerCase();this.protocol=p,a=a.substr(f.length)}if(r||f||a.match(/^\/\/[^@\/]+@[^@\/]+/)){var S="//"===a.substr(0,2);!S||f&&T[f]||(a=a.substr(2),this.slashes=!0)}if(!T[f]&&(S||f&&!w[f])){for(var O=-1,P=0;P<g.length;P++){var M=a.indexOf(g[P]);M!==-1&&(O===-1||M<O)&&(O=M)}var C,R;R=O===-1?a.lastIndexOf("@"):a.lastIndexOf("@",O),R!==-1&&(C=a.slice(0,R),a=a.slice(R+1),this.auth=decodeURIComponent(C)),O=-1;for(var P=0;P<y.length;P++){var M=a.indexOf(y[P]);M!==-1&&(O===-1||M<O)&&(O=M)}O===-1&&(O=a.length),this.host=a.slice(0,O),a=a.slice(O),this.parseHost(),this.hostname=this.hostname||"";var A="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!A)for(var I=this.hostname.split(/\./),P=0,D=I.length;P<D;P++){var L=I[P];if(L&&!L.match(_)){for(var N="",F=0,B=L.length;F<B;F++)N+=L.charCodeAt(F)>127?"x":L[F];if(!N.match(_)){var k=I.slice(0,P),j=I.slice(P+1),U=L.match(b);U&&(k.push(U[1]),j.unshift(U[2])),j.length&&(a="/"+j.join(".")+a),this.hostname=k.join(".");break}}}this.hostname.length>m?this.hostname="":this.hostname=this.hostname.toLowerCase(),A||(this.hostname=u.toASCII(this.hostname));var X=this.port?":"+this.port:"",G=this.hostname||"";this.host=G+X,this.href+=this.host,A&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==a[0]&&(a="/"+a))}if(!x[p])for(var P=0,D=v.length;P<D;P++){var W=v[P];if(a.indexOf(W)!==-1){var H=encodeURIComponent(W);H===W&&(H=escape(W)),a=a.split(W).join(H)}}var Y=a.indexOf("#");Y!==-1&&(this.hash=a.substr(Y),a=a.slice(0,Y));var V=a.indexOf("?");if(V!==-1?(this.search=a.substr(V),this.query=a.substr(V+1),e&&(this.query=E.parse(this.query)),a=a.slice(0,V)):e&&(this.search="",this.query={}),a&&(this.pathname=a),w[p]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var X=this.pathname||"",z=this.search||"";this.path=X+z}return this.href=this.format(),this},n.prototype.format=function(){var t=this.auth||"";t&&(t=encodeURIComponent(t),t=t.replace(/%3A/i,":"),t+="@");var e=this.protocol||"",r=this.pathname||"",n=this.hash||"",i=!1,o="";this.host?i=t+this.host:this.hostname&&(i=t+(this.hostname.indexOf(":")===-1?this.hostname:"["+this.hostname+"]"),this.port&&(i+=":"+this.port)),this.query&&h.isObject(this.query)&&Object.keys(this.query).length&&(o=E.stringify(this.query));var s=this.search||o&&"?"+o||"";return e&&":"!==e.substr(-1)&&(e+=":"),this.slashes||(!e||w[e])&&i!==!1?(i="//"+(i||""),r&&"/"!==r.charAt(0)&&(r="/"+r)):i||(i=""),n&&"#"!==n.charAt(0)&&(n="#"+n),s&&"?"!==s.charAt(0)&&(s="?"+s),r=r.replace(/[?#]/g,function(t){return encodeURIComponent(t)}),s=s.replace("#","%23"),e+i+r+s+n},n.prototype.resolve=function(t){return this.resolveObject(i(t,!1,!0)).format()},n.prototype.resolveObject=function(t){if(h.isString(t)){var e=new n;e.parse(t,!1,!0),t=e}for(var r=new n,i=Object.keys(this),o=0;o<i.length;o++){var s=i[o];r[s]=this[s]}if(r.hash=t.hash,""===t.href)return r.href=r.format(),r;if(t.slashes&&!t.protocol){for(var a=Object.keys(t),u=0;u<a.length;u++){var l=a[u];"protocol"!==l&&(r[l]=t[l])}return w[r.protocol]&&r.hostname&&!r.pathname&&(r.path=r.pathname="/"),r.href=r.format(),r}if(t.protocol&&t.protocol!==r.protocol){if(!w[t.protocol]){for(var c=Object.keys(t),d=0;d<c.length;d++){var f=c[d];r[f]=t[f]}return r.href=r.format(),r}if(r.protocol=t.protocol,t.host||T[t.protocol])r.pathname=t.pathname;else{for(var p=(t.pathname||"").split("/");p.length&&!(t.host=p.shift()););t.host||(t.host=""),t.hostname||(t.hostname=""),""!==p[0]&&p.unshift(""),p.length<2&&p.unshift(""),r.pathname=p.join("/")}if(r.search=t.search,r.query=t.query,r.host=t.host||"",r.auth=t.auth,r.hostname=t.hostname||t.host,r.port=t.port,r.pathname||r.search){var v=r.pathname||"",y=r.search||"";r.path=v+y}return r.slashes=r.slashes||t.slashes,r.href=r.format(),r}var g=r.pathname&&"/"===r.pathname.charAt(0),m=t.host||t.pathname&&"/"===t.pathname.charAt(0),_=m||g||r.host&&t.pathname,b=_,x=r.pathname&&r.pathname.split("/")||[],p=t.pathname&&t.pathname.split("/")||[],E=r.protocol&&!w[r.protocol];if(E&&(r.hostname="",r.port=null,r.host&&(""===x[0]?x[0]=r.host:x.unshift(r.host)),r.host="",t.protocol&&(t.hostname=null,t.port=null,t.host&&(""===p[0]?p[0]=t.host:p.unshift(t.host)),t.host=null),_=_&&(""===p[0]||""===x[0])),m)r.host=t.host||""===t.host?t.host:r.host,r.hostname=t.hostname||""===t.hostname?t.hostname:r.hostname,r.search=t.search,r.query=t.query,x=p;else if(p.length)x||(x=[]),x.pop(),x=x.concat(p),r.search=t.search,r.query=t.query;else if(!h.isNullOrUndefined(t.search)){if(E){r.hostname=r.host=x.shift();var S=!!(r.host&&r.host.indexOf("@")>0)&&r.host.split("@");S&&(r.auth=S.shift(),r.host=r.hostname=S.shift())}return r.search=t.search,r.query=t.query,h.isNull(r.pathname)&&h.isNull(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.href=r.format(),r}if(!x.length)return r.pathname=null,r.search?r.path="/"+r.search:r.path=null,r.href=r.format(),r;for(var O=x.slice(-1)[0],P=(r.host||t.host||x.length>1)&&("."===O||".."===O)||""===O,M=0,C=x.length;C>=0;C--)O=x[C],"."===O?x.splice(C,1):".."===O?(x.splice(C,1),M++):M&&(x.splice(C,1),M--);if(!_&&!b)for(;M--;M)x.unshift("..");!_||""===x[0]||x[0]&&"/"===x[0].charAt(0)||x.unshift(""),P&&"/"!==x.join("/").substr(-1)&&x.push("");var R=""===x[0]||x[0]&&"/"===x[0].charAt(0);if(E){r.hostname=r.host=R?"":x.length?x.shift():"";var S=!!(r.host&&r.host.indexOf("@")>0)&&r.host.split("@");S&&(r.auth=S.shift(),r.host=r.hostname=S.shift())}return _=_||r.host&&x.length,_&&!R&&x.unshift(""),x.length?r.pathname=x.join("/"):(r.pathname=null,r.path=null),h.isNull(r.pathname)&&h.isNull(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.auth=t.auth||r.auth,r.slashes=r.slashes||t.slashes,r.href=r.format(),r},n.prototype.parseHost=function(){var t=this.host,e=c.exec(t);e&&(e=e[0],":"!==e&&(this.port=e.substr(1)),t=t.substr(0,t.length-e.length)),t&&(this.hostname=t)}},{"./util":29,punycode:24,querystring:27}],29:[function(t,e,r){"use strict";e.exports={isString:function(t){return"string"==typeof t},isObject:function(t){return"object"==typeof t&&null!==t},isNull:function(t){return null===t},isNullOrUndefined:function(t){return null==t}}},{}],30:[function(t,e,r){"use strict";e.exports=function(t,e,r){var n,i=t.length;if(!(e>=i||0===r)){r=e+r>i?i-e:r;var o=i-r;for(n=e;n<o;++n)t[n]=t[n+r];t.length=o}}},{}],31:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},a=t("mini-signals"),u=i(a),h=t("parse-uri"),l=i(h),c=t("./async"),d=n(c),f=t("./Resource"),p=i(f),v=100,y=/(#[\w-]+)?$/,g=function(){function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;o(this,t),this.baseUrl=r,this.progress=0,this.loading=!1,this.defaultQueryString="",this._beforeMiddleware=[],this._afterMiddleware=[],this._resourcesParsing=[],this._boundLoadResource=function(t,r){return e._loadResource(t,r)},this._queue=d.queue(this._boundLoadResource,n),this._queue.pause(),this.resources={},this.onProgress=new u.default,this.onError=new u.default,this.onLoad=new u.default,this.onStart=new u.default,this.onComplete=new u.default}return t.prototype.add=function(t,e,r,n){if(Array.isArray(t)){for(var i=0;i<t.length;++i)this.add(t[i]);return this}if("object"===("undefined"==typeof t?"undefined":s(t))&&(n=e||t.callback||t.onComplete,r=t,e=t.url,t=t.name||t.key||t.url),"string"!=typeof e&&(n=r,r=e,e=t),"string"!=typeof e)throw new Error("No url passed to add resource to loader.");if("function"==typeof r&&(n=r,r=null),this.loading&&(!r||!r.parentResource))throw new Error("Cannot add resources while the loader is running.");if(this.resources[t])throw new Error('Resource named "'+t+'" already exists.');if(e=this._prepareUrl(e),this.resources[t]=new p.default(t,e,r),"function"==typeof n&&this.resources[t].onAfterMiddleware.once(n),this.loading){for(var o=r.parentResource,a=[],u=0;u<o.children.length;++u)o.children[u].isComplete||a.push(o.children[u]);var h=o.progressChunk*(a.length+1),l=h/(a.length+2);o.children.push(this.resources[t]),o.progressChunk=l;for(var c=0;c<a.length;++c)a[c].progressChunk=l;this.resources[t].progressChunk=l}return this._queue.push(this.resources[t]),this},t.prototype.pre=function(t){return this._beforeMiddleware.push(t),this},t.prototype.use=function(t){return this._afterMiddleware.push(t),this},t.prototype.reset=function(){this.progress=0,this.loading=!1,this._queue.kill(),this._queue.pause();for(var t in this.resources){var e=this.resources[t];e._onLoadBinding&&e._onLoadBinding.detach(),e.isLoading&&e.abort()}return this.resources={},this},t.prototype.load=function(t){if("function"==typeof t&&this.onComplete.once(t),this.loading)return this;for(var e=100/this._queue._tasks.length,r=0;r<this._queue._tasks.length;++r)this._queue._tasks[r].data.progressChunk=e;return this.loading=!0,this.onStart.dispatch(this),this._queue.resume(),this},t.prototype._prepareUrl=function(t){var e=(0,l.default)(t,{strictMode:!0}),r=void 0;if(r=e.protocol||!e.path||0===t.indexOf("//")?t:this.baseUrl.length&&this.baseUrl.lastIndexOf("/")!==this.baseUrl.length-1&&"/"!==t.charAt(0)?this.baseUrl+"/"+t:this.baseUrl+t,this.defaultQueryString){var n=y.exec(r)[0];r=r.substr(0,r.length-n.length),r+=r.indexOf("?")!==-1?"&"+this.defaultQueryString:"?"+this.defaultQueryString,r+=n}return r},t.prototype._loadResource=function(t,e){var r=this;t._dequeue=e,d.eachSeries(this._beforeMiddleware,function(e,n){e.call(r,t,function(){n(t.isComplete?{}:null)})},function(){t.isComplete?r._onLoad(t):(t._onLoadBinding=t.onComplete.once(r._onLoad,r),t.load())})},t.prototype._onComplete=function(){this.loading=!1,this.onComplete.dispatch(this,this.resources)},t.prototype._onLoad=function(t){var e=this;t._onLoadBinding=null,t._dequeue(),this._resourcesParsing.push(t),d.eachSeries(this._afterMiddleware,function(r,n){r.call(e,t,n)},function(){t.onAfterMiddleware.dispatch(t),e.progress+=t.progressChunk,e.onProgress.dispatch(e,t),t.error?e.onError.dispatch(t.error,e,t):e.onLoad.dispatch(e,t),e._resourcesParsing.splice(e._resourcesParsing.indexOf(t),1),e._queue.idle()&&0===e._resourcesParsing.length&&(e.progress=v,e._onComplete())})},t}();r.default=g},{"./Resource":32,"./async":33,"mini-signals":37,"parse-uri":38}],32:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(){}function s(t,e,r){e&&0===e.indexOf(".")&&(e=e.substring(1)),e&&(t[e]=r)}function a(t){return t.toString().replace("object ","")}r.__esModule=!0;var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=t("parse-uri"),l=n(h),c=t("mini-signals"),d=n(c),f=!(!window.XDomainRequest||"withCredentials"in new XMLHttpRequest),p=null,v=0,y=200,g=204,m=function(){function t(e,r,n){if(i(this,t),"string"!=typeof e||"string"!=typeof r)throw new Error("Both name and url are required for constructing a resource.");n=n||{},this._flags=0,this._setFlag(t.STATUS_FLAGS.DATA_URL,0===r.indexOf("data:")),this.name=e,this.url=r,this.extension=this._getExtension(),this.data=null,this.crossOrigin=n.crossOrigin===!0?"anonymous":n.crossOrigin,this.loadType=n.loadType||this._determineLoadType(),this.xhrType=n.xhrType,this.metadata=n.metadata||{},this.error=null,this.xhr=null,this.children=[],this.type=t.TYPE.UNKNOWN,this.progressChunk=0,this._dequeue=o,this._onLoadBinding=null,this._boundComplete=this.complete.bind(this),this._boundOnError=this._onError.bind(this),this._boundOnProgress=this._onProgress.bind(this),this._boundXhrOnError=this._xhrOnError.bind(this),this._boundXhrOnAbort=this._xhrOnAbort.bind(this),this._boundXhrOnLoad=this._xhrOnLoad.bind(this),this._boundXdrOnTimeout=this._xdrOnTimeout.bind(this),this.onStart=new d.default,this.onProgress=new d.default,this.onComplete=new d.default,this.onAfterMiddleware=new d.default}return t.setExtensionLoadType=function(e,r){s(t._loadTypeMap,e,r)},t.setExtensionXhrType=function(e,r){s(t._xhrTypeMap,e,r)},t.prototype.complete=function(){if(this.data&&this.data.removeEventListener&&(this.data.removeEventListener("error",this._boundOnError,!1),this.data.removeEventListener("load",this._boundComplete,!1),this.data.removeEventListener("progress",this._boundOnProgress,!1),this.data.removeEventListener("canplaythrough",this._boundComplete,!1)),this.xhr&&(this.xhr.removeEventListener?(this.xhr.removeEventListener("error",this._boundXhrOnError,!1),this.xhr.removeEventListener("abort",this._boundXhrOnAbort,!1),this.xhr.removeEventListener("progress",this._boundOnProgress,!1),this.xhr.removeEventListener("load",this._boundXhrOnLoad,!1)):(this.xhr.onerror=null,this.xhr.ontimeout=null,this.xhr.onprogress=null,this.xhr.onload=null)),this.isComplete)throw new Error("Complete called again for an already completed resource.");this._setFlag(t.STATUS_FLAGS.COMPLETE,!0),this._setFlag(t.STATUS_FLAGS.LOADING,!1),this.onComplete.dispatch(this)},t.prototype.abort=function(e){if(!this.error){if(this.error=new Error(e),this.xhr)this.xhr.abort();else if(this.xdr)this.xdr.abort();else if(this.data)if(this.data.src)this.data.src=t.EMPTY_GIF;else for(;this.data.firstChild;)this.data.removeChild(this.data.firstChild);this.complete()}},t.prototype.load=function(e){var r=this;if(!this.isLoading){if(this.isComplete)return void(e&&setTimeout(function(){return e(r)},1));switch(e&&this.onComplete.once(e),this._setFlag(t.STATUS_FLAGS.LOADING,!0),this.onStart.dispatch(this),this.crossOrigin!==!1&&"string"==typeof this.crossOrigin||(this.crossOrigin=this._determineCrossOrigin(this.url)),this.loadType){case t.LOAD_TYPE.IMAGE:this.type=t.TYPE.IMAGE,this._loadElement("image");break;case t.LOAD_TYPE.AUDIO:this.type=t.TYPE.AUDIO,this._loadSourceElement("audio");break;case t.LOAD_TYPE.VIDEO:this.type=t.TYPE.VIDEO,this._loadSourceElement("video");break;case t.LOAD_TYPE.XHR:default:f&&this.crossOrigin?this._loadXdr():this._loadXhr()}}},t.prototype._hasFlag=function(t){return!!(this._flags&t)},t.prototype._setFlag=function(t,e){this._flags=e?this._flags|t:this._flags&~t},t.prototype._loadElement=function(t){this.metadata.loadElement?this.data=this.metadata.loadElement:"image"===t&&"undefined"!=typeof window.Image?this.data=new Image:this.data=document.createElement(t),this.crossOrigin&&(this.data.crossOrigin=this.crossOrigin),this.metadata.skipSource||(this.data.src=this.url),this.data.addEventListener("error",this._boundOnError,!1),this.data.addEventListener("load",this._boundComplete,!1),this.data.addEventListener("progress",this._boundOnProgress,!1)},t.prototype._loadSourceElement=function(t){if(this.metadata.loadElement?this.data=this.metadata.loadElement:"audio"===t&&"undefined"!=typeof window.Audio?this.data=new Audio:this.data=document.createElement(t),null===this.data)return void this.abort("Unsupported element: "+t);if(!this.metadata.skipSource)if(navigator.isCocoonJS)this.data.src=Array.isArray(this.url)?this.url[0]:this.url;else if(Array.isArray(this.url))for(var e=0;e<this.url.length;++e)this.data.appendChild(this._createSource(t,this.url[e]));else this.data.appendChild(this._createSource(t,this.url));this.data.addEventListener("error",this._boundOnError,!1),this.data.addEventListener("load",this._boundComplete,!1),this.data.addEventListener("progress",this._boundOnProgress,!1),this.data.addEventListener("canplaythrough",this._boundComplete,!1),this.data.load()},t.prototype._loadXhr=function(){"string"!=typeof this.xhrType&&(this.xhrType=this._determineXhrType());var e=this.xhr=new XMLHttpRequest;e.open("GET",this.url,!0),this.xhrType===t.XHR_RESPONSE_TYPE.JSON||this.xhrType===t.XHR_RESPONSE_TYPE.DOCUMENT?e.responseType=t.XHR_RESPONSE_TYPE.TEXT:e.responseType=this.xhrType,e.addEventListener("error",this._boundXhrOnError,!1),e.addEventListener("abort",this._boundXhrOnAbort,!1),e.addEventListener("progress",this._boundOnProgress,!1),e.addEventListener("load",this._boundXhrOnLoad,!1),e.send()},t.prototype._loadXdr=function(){"string"!=typeof this.xhrType&&(this.xhrType=this._determineXhrType());var t=this.xhr=new XDomainRequest;t.timeout=5e3,t.onerror=this._boundXhrOnError,t.ontimeout=this._boundXdrOnTimeout,t.onprogress=this._boundOnProgress,t.onload=this._boundXhrOnLoad,t.open("GET",this.url,!0),setTimeout(function(){return t.send()},1)},t.prototype._createSource=function(t,e,r){r||(r=t+"/"+e.substr(e.lastIndexOf(".")+1));var n=document.createElement("source");return n.src=e,n.type=r,n},t.prototype._onError=function(t){this.abort("Failed to load element using: "+t.target.nodeName)},t.prototype._onProgress=function(t){t&&t.lengthComputable&&this.onProgress.dispatch(this,t.loaded/t.total)},t.prototype._xhrOnError=function(){var t=this.xhr;this.abort(a(t)+" Request failed. Status: "+t.status+', text: "'+t.statusText+'"')},t.prototype._xhrOnAbort=function(){this.abort(a(this.xhr)+" Request was aborted by the user.")},t.prototype._xdrOnTimeout=function(){this.abort(a(this.xhr)+" Request timed out.")},t.prototype._xhrOnLoad=function(){var e=this.xhr,r="undefined"==typeof e.status?e.status:y;if(!(r===y||r===g||r===v&&e.responseText.length>0))return void this.abort("["+e.status+"] "+e.statusText+": "+e.responseURL);if(this.xhrType===t.XHR_RESPONSE_TYPE.TEXT)this.data=e.responseText,this.type=t.TYPE.TEXT;else if(this.xhrType===t.XHR_RESPONSE_TYPE.JSON)try{this.data=JSON.parse(e.responseText),this.type=t.TYPE.JSON}catch(t){return void this.abort("Error trying to parse loaded json: "+t)}else if(this.xhrType===t.XHR_RESPONSE_TYPE.DOCUMENT)try{if(window.DOMParser){var n=new DOMParser;this.data=n.parseFromString(e.responseText,"text/xml")}else{var i=document.createElement("div");i.innerHTML=e.responseText,this.data=i}this.type=t.TYPE.XML}catch(t){return void this.abort("Error trying to parse loaded xml: "+t)}else this.data=e.response||e.responseText;this.complete()},t.prototype._determineCrossOrigin=function(t,e){if(0===t.indexOf("data:"))return"";e=e||window.location,p||(p=document.createElement("a")),p.href=t,t=(0,l.default)(p.href,{strictMode:!0});var r=!t.port&&""===e.port||t.port===e.port,n=t.protocol?t.protocol+":":"";return t.host===e.hostname&&r&&n===e.protocol?"":"anonymous"},t.prototype._determineXhrType=function(){return t._xhrTypeMap[this.extension]||t.XHR_RESPONSE_TYPE.TEXT},t.prototype._determineLoadType=function(){return t._loadTypeMap[this.extension]||t.LOAD_TYPE.XHR},t.prototype._getExtension=function(){var t=this.url,e="";if(this.isDataUrl){var r=t.indexOf("/");e=t.substring(r+1,t.indexOf(";",r))}else{var n=t.indexOf("?");n!==-1&&(t=t.substring(0,n)),e=t.substring(t.lastIndexOf(".")+1)}return e.toLowerCase()},t.prototype._getMimeFromXhrType=function(e){switch(e){case t.XHR_RESPONSE_TYPE.BUFFER:return"application/octet-binary";case t.XHR_RESPONSE_TYPE.BLOB:return"application/blob";case t.XHR_RESPONSE_TYPE.DOCUMENT:return"application/xml";case t.XHR_RESPONSE_TYPE.JSON:return"application/json";case t.XHR_RESPONSE_TYPE.DEFAULT:case t.XHR_RESPONSE_TYPE.TEXT:default:return"text/plain"}},u(t,[{key:"isDataUrl",get:function(){return this._hasFlag(t.STATUS_FLAGS.DATA_URL)}},{key:"isComplete",get:function(){return this._hasFlag(t.STATUS_FLAGS.COMPLETE)}},{key:"isLoading",get:function(){return this._hasFlag(t.STATUS_FLAGS.LOADING)}}]),t}();r.default=m,m.STATUS_FLAGS={NONE:0,DATA_URL:1,COMPLETE:2,LOADING:4},m.TYPE={UNKNOWN:0,JSON:1,XML:2,IMAGE:3,AUDIO:4,VIDEO:5,TEXT:6},m.LOAD_TYPE={XHR:1,IMAGE:2,AUDIO:3,VIDEO:4},m.XHR_RESPONSE_TYPE={DEFAULT:"text",BUFFER:"arraybuffer",BLOB:"blob",DOCUMENT:"document",JSON:"json",TEXT:"text"},m._loadTypeMap={gif:m.LOAD_TYPE.IMAGE,png:m.LOAD_TYPE.IMAGE,bmp:m.LOAD_TYPE.IMAGE,jpg:m.LOAD_TYPE.IMAGE,jpeg:m.LOAD_TYPE.IMAGE,tif:m.LOAD_TYPE.IMAGE,tiff:m.LOAD_TYPE.IMAGE,webp:m.LOAD_TYPE.IMAGE,tga:m.LOAD_TYPE.IMAGE,svg:m.LOAD_TYPE.IMAGE,"svg+xml":m.LOAD_TYPE.IMAGE,mp3:m.LOAD_TYPE.AUDIO,ogg:m.LOAD_TYPE.AUDIO,wav:m.LOAD_TYPE.AUDIO,mp4:m.LOAD_TYPE.VIDEO,webm:m.LOAD_TYPE.VIDEO},m._xhrTypeMap={xhtml:m.XHR_RESPONSE_TYPE.DOCUMENT,html:m.XHR_RESPONSE_TYPE.DOCUMENT,htm:m.XHR_RESPONSE_TYPE.DOCUMENT,xml:m.XHR_RESPONSE_TYPE.DOCUMENT,tmx:m.XHR_RESPONSE_TYPE.DOCUMENT,svg:m.XHR_RESPONSE_TYPE.DOCUMENT,tsx:m.XHR_RESPONSE_TYPE.DOCUMENT,gif:m.XHR_RESPONSE_TYPE.BLOB,png:m.XHR_RESPONSE_TYPE.BLOB,bmp:m.XHR_RESPONSE_TYPE.BLOB,jpg:m.XHR_RESPONSE_TYPE.BLOB,jpeg:m.XHR_RESPONSE_TYPE.BLOB,tif:m.XHR_RESPONSE_TYPE.BLOB,tiff:m.XHR_RESPONSE_TYPE.BLOB,webp:m.XHR_RESPONSE_TYPE.BLOB,tga:m.XHR_RESPONSE_TYPE.BLOB,json:m.XHR_RESPONSE_TYPE.JSON,text:m.XHR_RESPONSE_TYPE.TEXT,txt:m.XHR_RESPONSE_TYPE.TEXT,ttf:m.XHR_RESPONSE_TYPE.BUFFER,otf:m.XHR_RESPONSE_TYPE.BUFFER},m.EMPTY_GIF="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="},{"mini-signals":37,"parse-uri":38}],33:[function(t,e,r){"use strict";function n(){}function i(t,e,r){var n=0,i=t.length;!function o(s){return s||n===i?void(r&&r(s)):void e(t[n++],o)}()}function o(t){return function(){if(null===t)throw new Error("Callback was already called.");var e=t;t=null,e.apply(this,arguments)}}function s(t,e){function r(t,e,r){if(null!=r&&"function"!=typeof r)throw new Error("task callback must be a function");if(a.started=!0,null==t&&a.idle())return void setTimeout(function(){return a.drain()},1);var i={data:t,callback:"function"==typeof r?r:n};e?a._tasks.unshift(i):a._tasks.push(i),setTimeout(function(){return a.process()},1)}function i(t){return function(){s-=1,t.callback.apply(t,arguments),null!=arguments[0]&&a.error(arguments[0],t.data),s<=a.concurrency-a.buffer&&a.unsaturated(),a.idle()&&a.drain(),a.process()}}if(null==e)e=1;else if(0===e)throw new Error("Concurrency must not be zero");var s=0,a={_tasks:[],concurrency:e,saturated:n,unsaturated:n,buffer:e/4,empty:n,drain:n,error:n,started:!1,paused:!1,push:function(t,e){r(t,!1,e)},kill:function(){s=0,a.drain=n,a.started=!1,a._tasks=[]},unshift:function(t,e){r(t,!0,e)},process:function(){for(;!a.paused&&s<a.concurrency&&a._tasks.length;){var e=a._tasks.shift();0===a._tasks.length&&a.empty(),s+=1,s===a.concurrency&&a.saturated(),t(e.data,o(i(e)))}},length:function(){return a._tasks.length},running:function(){return s},idle:function(){return a._tasks.length+s===0},pause:function(){a.paused!==!0&&(a.paused=!0)},resume:function(){if(a.paused!==!1){a.paused=!1;for(var t=1;t<=a.concurrency;t++)a.process()}}};return a}r.__esModule=!0,r.eachSeries=i,r.queue=s},{}],34:[function(t,e,r){"use strict";function n(t){for(var e="",r=0;r<t.length;){for(var n=[0,0,0],o=[0,0,0,0],s=0;s<n.length;++s)r<t.length?n[s]=255&t.charCodeAt(r++):n[s]=0;o[0]=n[0]>>2,o[1]=(3&n[0])<<4|n[1]>>4,o[2]=(15&n[1])<<2|n[2]>>6,o[3]=63&n[2];var a=r-(t.length-1);switch(a){case 2:o[3]=64,o[2]=64;break;case 1:o[3]=64}for(var u=0;u<o.length;++u)e+=i.charAt(o[u])}return e}r.__esModule=!0,r.encodeBinary=n;var i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},{}],35:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var o=t("./Loader"),s=i(o),a=t("./Resource"),u=i(a),h=t("./async"),l=n(h),c=t("./b64"),d=n(c);s.default.Resource=u.default,s.default.async=l,s.default.base64=d,e.exports=s.default,r.default=s.default},{"./Loader":31,"./Resource":32,"./async":33,"./b64":34}],36:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(){return function(t,e){if(!t.data)return void e();if(t.xhr&&t.xhrType===a.default.XHR_RESPONSE_TYPE.BLOB)if(window.Blob&&"string"!=typeof t.data){if(0===t.data.type.indexOf("image")){var r=function(){var r=l.createObjectURL(t.data);return t.blob=t.data,t.data=new Image,t.data.src=r,t.type=a.default.TYPE.IMAGE,t.data.onload=function(){l.revokeObjectURL(r),t.data.onload=null,e()},{v:void 0}}();if("object"===("undefined"==typeof r?"undefined":o(r)))return r.v}}else{var n=t.xhr.getResponseHeader("content-type");if(n&&0===n.indexOf("image"))return t.data=new Image,t.data.src="data:"+n+";base64,"+h.default.encodeBinary(t.xhr.responseText),t.type=a.default.TYPE.IMAGE,void(t.data.onload=function(){t.data.onload=null,e()})}e()}}r.__esModule=!0;var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};r.blobMiddlewareFactory=i;var s=t("../../Resource"),a=n(s),u=t("../../b64"),h=n(u),l=window.URL||window.webkitURL},{"../../Resource":32,"../../b64":34}],37:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function");
}function i(t,e){return t._head?(t._tail._next=e,e._prev=t._tail,t._tail=e):(t._head=e,t._tail=e),e._owner=t,e}Object.defineProperty(r,"__esModule",{value:!0});var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=function(){function t(e,r,i){void 0===r&&(r=!1),n(this,t),this._fn=e,this._once=r,this._thisArg=i,this._next=this._prev=this._owner=null}return o(t,[{key:"detach",value:function(){return null!==this._owner&&(this._owner.detach(this),!0)}}]),t}(),a=function(){function t(){n(this,t),this._head=this._tail=void 0}return o(t,[{key:"handlers",value:function(){var t=!(arguments.length<=0||void 0===arguments[0])&&arguments[0],e=this._head;if(t)return!!e;for(var r=[];e;)r.push(e),e=e._next;return r}},{key:"has",value:function(t){if(!(t instanceof s))throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");return t._owner===this}},{key:"dispatch",value:function(){var t=this._head;if(!t)return!1;for(;t;)t._once&&this.detach(t),t._fn.apply(t._thisArg,arguments),t=t._next;return!0}},{key:"add",value:function(t){var e=arguments.length<=1||void 0===arguments[1]?null:arguments[1];if("function"!=typeof t)throw new Error("MiniSignal#add(): First arg must be a Function.");return i(this,new s(t,(!1),e))}},{key:"once",value:function(t){var e=arguments.length<=1||void 0===arguments[1]?null:arguments[1];if("function"!=typeof t)throw new Error("MiniSignal#once(): First arg must be a Function.");return i(this,new s(t,(!0),e))}},{key:"detach",value:function(t){if(!(t instanceof s))throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");return t._owner!==this?this:(t._prev&&(t._prev._next=t._next),t._next&&(t._next._prev=t._prev),t===this._head?(this._head=t._next,null===t._next&&(this._tail=null)):t===this._tail&&(this._tail=t._prev,this._tail._next=null),t._owner=null,this)}},{key:"detachAll",value:function(){var t=this._head;if(!t)return this;for(this._head=this._tail=null;t;)t._owner=null,t=t._next;return this}}]),t}();a.MiniSignalBinding=s,r.default=a,e.exports=r.default},{}],38:[function(t,e,r){"use strict";e.exports=function(t,e){e=e||{};for(var r={key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}},n=r.parser[e.strictMode?"strict":"loose"].exec(t),i={},o=14;o--;)i[r.key[o]]=n[o]||"";return i[r.q.name]={},i[r.key[12]].replace(r.q.parser,function(t,e,n){e&&(i[r.q.name][e]=n)}),i}},{}],39:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var s=t("../core"),a=i(s),u=t("ismobilejs"),h=n(u),l=t("./accessibleTarget"),c=n(l);a.utils.mixins.delayMixin(a.DisplayObject.prototype,c.default);var d=9,f=100,p=0,v=0,y=2,g=1,m=-1e3,_=-1e3,b=2,x=function(){function t(e){o(this,t),!h.default.tablet&&!h.default.phone||navigator.isCocoonJS||this.createTouchHook();var r=document.createElement("div");r.style.width=f+"px",r.style.height=f+"px",r.style.position="absolute",r.style.top=p+"px",r.style.left=v+"px",r.style.zIndex=y,this.div=r,this.pool=[],this.renderId=0,this.debug=!1,this.renderer=e,this.children=[],this._onKeyDown=this._onKeyDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this.isActive=!1,this.isMobileAccessabillity=!1,window.addEventListener("keydown",this._onKeyDown,!1)}return t.prototype.createTouchHook=function(){var t=this,e=document.createElement("button");e.style.width=g+"px",e.style.height=g+"px",e.style.position="absolute",e.style.top=m+"px",e.style.left=_+"px",e.style.zIndex=b,e.style.backgroundColor="#FF0000",e.title="HOOK DIV",e.addEventListener("focus",function(){t.isMobileAccessabillity=!0,t.activate(),document.body.removeChild(e)}),document.body.appendChild(e)},t.prototype.activate=function(){this.isActive||(this.isActive=!0,window.document.addEventListener("mousemove",this._onMouseMove,!0),window.removeEventListener("keydown",this._onKeyDown,!1),this.renderer.on("postrender",this.update,this),this.renderer.view.parentNode&&this.renderer.view.parentNode.appendChild(this.div))},t.prototype.deactivate=function(){this.isActive&&!this.isMobileAccessabillity&&(this.isActive=!1,window.document.removeEventListener("mousemove",this._onMouseMove),window.addEventListener("keydown",this._onKeyDown,!1),this.renderer.off("postrender",this.update),this.div.parentNode&&this.div.parentNode.removeChild(this.div))},t.prototype.updateAccessibleObjects=function(t){if(t.visible){t.accessible&&t.interactive&&(t._accessibleActive||this.addChild(t),t.renderId=this.renderId);for(var e=t.children,r=e.length-1;r>=0;r--)this.updateAccessibleObjects(e[r])}},t.prototype.update=function(){if(this.renderer.renderingToScreen){this.updateAccessibleObjects(this.renderer._lastObjectRendered);var t=this.renderer.view.getBoundingClientRect(),e=t.width/this.renderer.width,r=t.height/this.renderer.height,n=this.div;n.style.left=t.left+"px",n.style.top=t.top+"px",n.style.width=this.renderer.width+"px",n.style.height=this.renderer.height+"px";for(var i=0;i<this.children.length;i++){var o=this.children[i];if(o.renderId!==this.renderId)o._accessibleActive=!1,a.utils.removeItems(this.children,i,1),this.div.removeChild(o._accessibleDiv),this.pool.push(o._accessibleDiv),o._accessibleDiv=null,i--,0===this.children.length&&this.deactivate();else{n=o._accessibleDiv;var s=o.hitArea,u=o.worldTransform;o.hitArea?(n.style.left=(u.tx+s.x*u.a)*e+"px",n.style.top=(u.ty+s.y*u.d)*r+"px",n.style.width=s.width*u.a*e+"px",n.style.height=s.height*u.d*r+"px"):(s=o.getBounds(),this.capHitArea(s),n.style.left=s.x*e+"px",n.style.top=s.y*r+"px",n.style.width=s.width*e+"px",n.style.height=s.height*r+"px")}}this.renderId++}},t.prototype.capHitArea=function(t){t.x<0&&(t.width+=t.x,t.x=0),t.y<0&&(t.height+=t.y,t.y=0),t.x+t.width>this.renderer.width&&(t.width=this.renderer.width-t.x),t.y+t.height>this.renderer.height&&(t.height=this.renderer.height-t.y)},t.prototype.addChild=function(t){var e=this.pool.pop();e||(e=document.createElement("button"),e.style.width=f+"px",e.style.height=f+"px",e.style.backgroundColor=this.debug?"rgba(255,0,0,0.5)":"transparent",e.style.position="absolute",e.style.zIndex=y,e.style.borderStyle="none",e.addEventListener("click",this._onClick.bind(this)),e.addEventListener("focus",this._onFocus.bind(this)),e.addEventListener("focusout",this._onFocusOut.bind(this))),t.accessibleTitle?e.title=t.accessibleTitle:t.accessibleTitle||t.accessibleHint||(e.title="displayObject "+this.tabIndex),t.accessibleHint&&e.setAttribute("aria-label",t.accessibleHint),t._accessibleActive=!0,t._accessibleDiv=e,e.displayObject=t,this.children.push(t),this.div.appendChild(t._accessibleDiv),t._accessibleDiv.tabIndex=t.tabIndex},t.prototype._onClick=function(t){var e=this.renderer.plugins.interaction;e.dispatchEvent(t.target.displayObject,"click",e.eventData)},t.prototype._onFocus=function(t){var e=this.renderer.plugins.interaction;e.dispatchEvent(t.target.displayObject,"mouseover",e.eventData)},t.prototype._onFocusOut=function(t){var e=this.renderer.plugins.interaction;e.dispatchEvent(t.target.displayObject,"mouseout",e.eventData)},t.prototype._onKeyDown=function(t){t.keyCode===d&&this.activate()},t.prototype._onMouseMove=function(){this.deactivate()},t.prototype.destroy=function(){this.div=null;for(var t=0;t<this.children.length;t++)this.children[t].div=null;window.document.removeEventListener("mousemove",this._onMouseMove),window.removeEventListener("keydown",this._onKeyDown),this.pool=null,this.children=null,this.renderer=null},t}();r.default=x,a.WebGLRenderer.registerPlugin("accessibility",x),a.CanvasRenderer.registerPlugin("accessibility",x)},{"../core":64,"./accessibleTarget":40,ismobilejs:4}],40:[function(t,e,r){"use strict";r.__esModule=!0,r.default={accessible:!1,accessibleTitle:null,accessibleHint:null,tabIndex:0,_accessibleActive:!1,_accessibleDiv:!1}},{}],41:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./accessibleTarget");Object.defineProperty(r,"accessibleTarget",{enumerable:!0,get:function(){return n(i).default}});var o=t("./AccessibilityManager");Object.defineProperty(r,"AccessibilityManager",{enumerable:!0,get:function(){return n(o).default}})},{"./AccessibilityManager":39,"./accessibleTarget":40}],42:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=t("./autoDetectRenderer"),a=t("./display/Container"),u=n(a),h=t("./ticker"),l=t("./settings"),c=n(l),d=t("./const"),f=function(){function t(e,r,n,o,a){i(this,t),"number"==typeof e&&(e=Object.assign({width:e,height:r||c.default.RENDER_OPTIONS.height,forceCanvas:!!o,sharedTicker:!!a},n)),this._options=e=Object.assign({sharedTicker:!1,forceCanvas:!1,sharedLoader:!1},e),this.renderer=(0,s.autoDetectRenderer)(e),this.stage=new u.default,this._ticker=null,this.ticker=e.sharedTicker?h.shared:new h.Ticker,this.start()}return t.prototype.render=function(){this.renderer.render(this.stage)},t.prototype.stop=function(){this._ticker.stop()},t.prototype.start=function(){this._ticker.start()},t.prototype.destroy=function(t){var e=this._ticker;this.ticker=null,e.destroy(),this.stage.destroy(),this.stage=null,this.renderer.destroy(t),this.renderer=null,this._options=null},o(t,[{key:"ticker",set:function(t){this._ticker&&this._ticker.remove(this.render,this),this._ticker=t,t&&t.add(this.render,this,d.UPDATE_PRIORITY.LOW)},get:function(){return this._ticker}},{key:"view",get:function(){return this.renderer.view}},{key:"screen",get:function(){return this.renderer.screen}}]),t}();r.default=f},{"./autoDetectRenderer":44,"./const":45,"./display/Container":47,"./settings":100,"./ticker":119}],43:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t,e){if(t instanceof Array){if("precision"!==t[0].substring(0,9)){var r=t.slice(0);return r.unshift("precision "+e+" float;"),r}}else if("precision"!==t.substring(0,9))return"precision "+e+" float;\n"+t;return t}r.__esModule=!0;var u=t("pixi-gl-core"),h=t("./settings"),l=n(h),c=function(t){function e(r,n,s){return i(this,e),o(this,t.call(this,r,a(n,l.default.PRECISION_VERTEX),a(s,l.default.PRECISION_FRAGMENT)))}return s(e,t),e}(u.GLShader);r.default=c},{"./settings":100,"pixi-gl-core":12}],44:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e,r,n){var i=t&&t.forceCanvas;return void 0!==n&&(i=n),!i&&a.isWebGLSupported()?new c.default(t,e,r):new h.default(t,e,r)}r.__esModule=!0,r.autoDetectRenderer=o;var s=t("./utils"),a=i(s),u=t("./renderers/canvas/CanvasRenderer"),h=n(u),l=t("./renderers/webgl/WebGLRenderer"),c=n(l)},{"./renderers/canvas/CanvasRenderer":76,"./renderers/webgl/WebGLRenderer":83,"./utils":123}],45:[function(t,e,r){"use strict";r.__esModule=!0;r.VERSION="4.5.3",r.PI_2=2*Math.PI,r.RAD_TO_DEG=180/Math.PI,r.DEG_TO_RAD=Math.PI/180,r.RENDERER_TYPE={UNKNOWN:0,WEBGL:1,CANVAS:2},r.BLEND_MODES={NORMAL:0,ADD:1,MULTIPLY:2,SCREEN:3,OVERLAY:4,DARKEN:5,LIGHTEN:6,COLOR_DODGE:7,COLOR_BURN:8,HARD_LIGHT:9,SOFT_LIGHT:10,DIFFERENCE:11,EXCLUSION:12,HUE:13,SATURATION:14,COLOR:15,LUMINOSITY:16,NORMAL_NPM:17,ADD_NPM:18,SCREEN_NPM:19},r.DRAW_MODES={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},r.SCALE_MODES={LINEAR:0,NEAREST:1},r.WRAP_MODES={CLAMP:0,REPEAT:1,MIRRORED_REPEAT:2},r.GC_MODES={AUTO:0,MANUAL:1},r.URL_FILE_EXTENSION=/\.(\w{3,4})(?:$|\?|#)/i,r.DATA_URI=/^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;(charset=[\w-]+|base64))?,(.*)/i,r.SVG_SIZE=/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i,r.SHAPES={POLY:0,RECT:1,CIRC:2,ELIP:3,RREC:4},r.PRECISION={LOW:"lowp",MEDIUM:"mediump",HIGH:"highp"},r.TRANSFORM_MODE={STATIC:0,DYNAMIC:1},r.TEXT_GRADIENT={LINEAR_VERTICAL:0,LINEAR_HORIZONTAL:1},r.UPDATE_PRIORITY={INTERACTION:50,HIGH:25,NORMAL:0,LOW:-25,UTILITY:-50}},{}],46:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=t("../math"),o=function(){function t(){n(this,t),this.minX=1/0,this.minY=1/0,this.maxX=-(1/0),this.maxY=-(1/0),this.rect=null}return t.prototype.isEmpty=function(){return this.minX>this.maxX||this.minY>this.maxY},t.prototype.clear=function(){this.updateID++,this.minX=1/0,this.minY=1/0,this.maxX=-(1/0),this.maxY=-(1/0)},t.prototype.getRectangle=function(t){return this.minX>this.maxX||this.minY>this.maxY?i.Rectangle.EMPTY:(t=t||new i.Rectangle(0,0,1,1),t.x=this.minX,t.y=this.minY,t.width=this.maxX-this.minX,t.height=this.maxY-this.minY,t)},t.prototype.addPoint=function(t){this.minX=Math.min(this.minX,t.x),this.maxX=Math.max(this.maxX,t.x),this.minY=Math.min(this.minY,t.y),this.maxY=Math.max(this.maxY,t.y)},t.prototype.addQuad=function(t){var e=this.minX,r=this.minY,n=this.maxX,i=this.maxY,o=t[0],s=t[1];e=o<e?o:e,r=s<r?s:r,n=o>n?o:n,i=s>i?s:i,o=t[2],s=t[3],e=o<e?o:e,r=s<r?s:r,n=o>n?o:n,i=s>i?s:i,o=t[4],s=t[5],e=o<e?o:e,r=s<r?s:r,n=o>n?o:n,i=s>i?s:i,o=t[6],s=t[7],e=o<e?o:e,r=s<r?s:r,n=o>n?o:n,i=s>i?s:i,this.minX=e,this.minY=r,this.maxX=n,this.maxY=i},t.prototype.addFrame=function(t,e,r,n,i){var o=t.worldTransform,s=o.a,a=o.b,u=o.c,h=o.d,l=o.tx,c=o.ty,d=this.minX,f=this.minY,p=this.maxX,v=this.maxY,y=s*e+u*r+l,g=a*e+h*r+c;d=y<d?y:d,f=g<f?g:f,p=y>p?y:p,v=g>v?g:v,y=s*n+u*r+l,g=a*n+h*r+c,d=y<d?y:d,f=g<f?g:f,p=y>p?y:p,v=g>v?g:v,y=s*e+u*i+l,g=a*e+h*i+c,d=y<d?y:d,f=g<f?g:f,p=y>p?y:p,v=g>v?g:v,y=s*n+u*i+l,g=a*n+h*i+c,d=y<d?y:d,f=g<f?g:f,p=y>p?y:p,v=g>v?g:v,this.minX=d,this.minY=f,this.maxX=p,this.maxY=v},t.prototype.addVertices=function(t,e,r,n){for(var i=t.worldTransform,o=i.a,s=i.b,a=i.c,u=i.d,h=i.tx,l=i.ty,c=this.minX,d=this.minY,f=this.maxX,p=this.maxY,v=r;v<n;v+=2){var y=e[v],g=e[v+1],m=o*y+a*g+h,_=u*g+s*y+l;c=m<c?m:c,d=_<d?_:d,f=m>f?m:f,p=_>p?_:p}this.minX=c,this.minY=d,this.maxX=f,this.maxY=p},t.prototype.addBounds=function(t){var e=this.minX,r=this.minY,n=this.maxX,i=this.maxY;this.minX=t.minX<e?t.minX:e,this.minY=t.minY<r?t.minY:r,this.maxX=t.maxX>n?t.maxX:n,this.maxY=t.maxY>i?t.maxY:i},t.prototype.addBoundsMask=function(t,e){var r=t.minX>e.minX?t.minX:e.minX,n=t.minY>e.minY?t.minY:e.minY,i=t.maxX<e.maxX?t.maxX:e.maxX,o=t.maxY<e.maxY?t.maxY:e.maxY;if(r<=i&&n<=o){var s=this.minX,a=this.minY,u=this.maxX,h=this.maxY;this.minX=r<s?r:s,this.minY=n<a?n:a,this.maxX=i>u?i:u,this.maxY=o>h?o:h}},t.prototype.addBoundsArea=function(t,e){var r=t.minX>e.x?t.minX:e.x,n=t.minY>e.y?t.minY:e.y,i=t.maxX<e.x+e.width?t.maxX:e.x+e.width,o=t.maxY<e.y+e.height?t.maxY:e.y+e.height;if(r<=i&&n<=o){var s=this.minX,a=this.minY,u=this.maxX,h=this.maxY;this.minX=r<s?r:s,this.minY=n<a?n:a,this.maxX=i>u?i:u,this.maxY=o>h?o:h}},t}();r.default=o},{"../math":69}],47:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../utils"),h=t("./DisplayObject"),l=n(h),c=function(t){function e(){i(this,e);var r=o(this,t.call(this));return r.children=[],r}return s(e,t),e.prototype.onChildrenChange=function(){},e.prototype.addChild=function(t){var e=arguments.length;if(e>1)for(var r=0;r<e;r++)this.addChild(arguments[r]);else t.parent&&t.parent.removeChild(t),t.parent=this,t.transform._parentID=-1,this.children.push(t),this._boundsID++,this.onChildrenChange(this.children.length-1),t.emit("added",this);return t},e.prototype.addChildAt=function(t,e){if(e<0||e>this.children.length)throw new Error(t+"addChildAt: The index "+e+" supplied is out of bounds "+this.children.length);return t.parent&&t.parent.removeChild(t),t.parent=this,t.transform._parentID=-1,this.children.splice(e,0,t),this._boundsID++,this.onChildrenChange(e),t.emit("added",this),t},e.prototype.swapChildren=function(t,e){if(t!==e){var r=this.getChildIndex(t),n=this.getChildIndex(e);this.children[r]=e,this.children[n]=t,this.onChildrenChange(r<n?r:n)}},e.prototype.getChildIndex=function(t){var e=this.children.indexOf(t);if(e===-1)throw new Error("The supplied DisplayObject must be a child of the caller");return e},e.prototype.setChildIndex=function(t,e){if(e<0||e>=this.children.length)throw new Error("The supplied index is out of bounds");var r=this.getChildIndex(t);(0,u.removeItems)(this.children,r,1),this.children.splice(e,0,t),this.onChildrenChange(e)},e.prototype.getChildAt=function(t){if(t<0||t>=this.children.length)throw new Error("getChildAt: Index ("+t+") does not exist.");return this.children[t]},e.prototype.removeChild=function(t){var e=arguments.length;if(e>1)for(var r=0;r<e;r++)this.removeChild(arguments[r]);else{var n=this.children.indexOf(t);if(n===-1)return null;t.parent=null,t.transform._parentID=-1,(0,u.removeItems)(this.children,n,1),this._boundsID++,this.onChildrenChange(n),t.emit("removed",this)}return t},e.prototype.removeChildAt=function(t){var e=this.getChildAt(t);return e.parent=null,e.transform._parentID=-1,(0,u.removeItems)(this.children,t,1),this._boundsID++,this.onChildrenChange(t),e.emit("removed",this),e},e.prototype.removeChildren=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments[1],r=t,n="number"==typeof e?e:this.children.length,i=n-r,o=void 0;if(i>0&&i<=n){o=this.children.splice(r,i);for(var s=0;s<o.length;++s)o[s].parent=null,o[s].transform&&(o[s].transform._parentID=-1);this._boundsID++,this.onChildrenChange(t);for(var a=0;a<o.length;++a)o[a].emit("removed",this);return o}if(0===i&&0===this.children.length)return[];throw new RangeError("removeChildren: numeric values are outside the acceptable range.")},e.prototype.updateTransform=function(){this._boundsID++,this.transform.updateTransform(this.parent.transform),this.worldAlpha=this.alpha*this.parent.worldAlpha;for(var t=0,e=this.children.length;t<e;++t){var r=this.children[t];r.visible&&r.updateTransform()}},e.prototype.calculateBounds=function(){this._bounds.clear(),this._calculateBounds();for(var t=0;t<this.children.length;t++){var e=this.children[t];e.visible&&e.renderable&&(e.calculateBounds(),e._mask?(e._mask.calculateBounds(),this._bounds.addBoundsMask(e._bounds,e._mask._bounds)):e.filterArea?this._bounds.addBoundsArea(e._bounds,e.filterArea):this._bounds.addBounds(e._bounds))}this._lastBoundsID=this._boundsID},e.prototype._calculateBounds=function(){},e.prototype.renderWebGL=function(t){if(this.visible&&!(this.worldAlpha<=0)&&this.renderable)if(this._mask||this._filters)this.renderAdvancedWebGL(t);else{this._renderWebGL(t);for(var e=0,r=this.children.length;e<r;++e)this.children[e].renderWebGL(t)}},e.prototype.renderAdvancedWebGL=function(t){t.flush();var e=this._filters,r=this._mask;if(e){this._enabledFilters||(this._enabledFilters=[]),this._enabledFilters.length=0;for(var n=0;n<e.length;n++)e[n].enabled&&this._enabledFilters.push(e[n]);this._enabledFilters.length&&t.filterManager.pushFilter(this,this._enabledFilters)}r&&t.maskManager.pushMask(this,this._mask),this._renderWebGL(t);for(var i=0,o=this.children.length;i<o;i++)this.children[i].renderWebGL(t);t.flush(),r&&t.maskManager.popMask(this,this._mask),e&&this._enabledFilters&&this._enabledFilters.length&&t.filterManager.popFilter()},e.prototype._renderWebGL=function(t){},e.prototype._renderCanvas=function(t){},e.prototype.renderCanvas=function(t){if(this.visible&&!(this.worldAlpha<=0)&&this.renderable){this._mask&&t.maskManager.pushMask(this._mask),this._renderCanvas(t);for(var e=0,r=this.children.length;e<r;++e)this.children[e].renderCanvas(t);this._mask&&t.maskManager.popMask(t)}},e.prototype.destroy=function(e){t.prototype.destroy.call(this);var r="boolean"==typeof e?e:e&&e.children,n=this.removeChildren(0,this.children.length);if(r)for(var i=0;i<n.length;++i)n[i].destroy(e)},a(e,[{key:"width",get:function(){return this.scale.x*this.getLocalBounds().width},set:function(t){var e=this.getLocalBounds().width;0!==e?this.scale.x=t/e:this.scale.x=1,this._width=t}},{key:"height",get:function(){return this.scale.y*this.getLocalBounds().height},set:function(t){var e=this.getLocalBounds().height;0!==e?this.scale.y=t/e:this.scale.y=1,this._height=t}}]),e}(l.default);r.default=c,c.prototype.containerUpdateTransform=c.prototype.updateTransform},{"../utils":123,"./DisplayObject":48}],48:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("eventemitter3"),h=n(u),l=t("../const"),c=t("../settings"),d=n(c),f=t("./TransformStatic"),p=n(f),v=t("./Transform"),y=n(v),g=t("./Bounds"),m=n(g),_=t("../math"),b=function(t){function e(){i(this,e);var r=o(this,t.call(this)),n=d.default.TRANSFORM_MODE===l.TRANSFORM_MODE.STATIC?p.default:y.default;return r.tempDisplayObjectParent=null,r.transform=new n,r.alpha=1,r.visible=!0,r.renderable=!0,r.parent=null,r.worldAlpha=1,r.filterArea=null,r._filters=null,r._enabledFilters=null,r._bounds=new m.default,r._boundsID=0,r._lastBoundsID=-1,r._boundsRect=null,r._localBoundsRect=null,r._mask=null,r._destroyed=!1,r}return s(e,t),e.prototype.updateTransform=function(){this.transform.updateTransform(this.parent.transform),this.worldAlpha=this.alpha*this.parent.worldAlpha,this._bounds.updateID++},e.prototype._recursivePostUpdateTransform=function(){this.parent?(this.parent._recursivePostUpdateTransform(),this.transform.updateTransform(this.parent.transform)):this.transform.updateTransform(this._tempDisplayObjectParent.transform)},e.prototype.getBounds=function(t,e){return t||(this.parent?(this._recursivePostUpdateTransform(),this.updateTransform()):(this.parent=this._tempDisplayObjectParent,this.updateTransform(),this.parent=null)),this._boundsID!==this._lastBoundsID&&this.calculateBounds(),e||(this._boundsRect||(this._boundsRect=new _.Rectangle),e=this._boundsRect),this._bounds.getRectangle(e)},e.prototype.getLocalBounds=function(t){var e=this.transform,r=this.parent;this.parent=null,this.transform=this._tempDisplayObjectParent.transform,t||(this._localBoundsRect||(this._localBoundsRect=new _.Rectangle),t=this._localBoundsRect);var n=this.getBounds(!1,t);return this.parent=r,this.transform=e,n},e.prototype.toGlobal=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return r||(this._recursivePostUpdateTransform(),this.parent?this.displayObjectUpdateTransform():(this.parent=this._tempDisplayObjectParent,this.displayObjectUpdateTransform(),this.parent=null)),this.worldTransform.apply(t,e)},e.prototype.toLocal=function(t,e,r,n){return e&&(t=e.toGlobal(t,r,n)),n||(this._recursivePostUpdateTransform(),this.parent?this.displayObjectUpdateTransform():(this.parent=this._tempDisplayObjectParent,this.displayObjectUpdateTransform(),this.parent=null)),this.worldTransform.applyInverse(t,r)},e.prototype.renderWebGL=function(t){},e.prototype.renderCanvas=function(t){},e.prototype.setParent=function(t){if(!t||!t.addChild)throw new Error("setParent: Argument must be a Container");return t.addChild(this),t},e.prototype.setTransform=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;return this.position.x=t,this.position.y=e,this.scale.x=r?r:1,this.scale.y=n?n:1,this.rotation=i,this.skew.x=o,this.skew.y=s,this.pivot.x=a,this.pivot.y=u,this},e.prototype.destroy=function(){this.removeAllListeners(),this.parent&&this.parent.removeChild(this),this.transform=null,this.parent=null,this._bounds=null,this._currentBounds=null,this._mask=null,this.filterArea=null,this.interactive=!1,this.interactiveChildren=!1,this._destroyed=!0},a(e,[{key:"_tempDisplayObjectParent",get:function(){return null===this.tempDisplayObjectParent&&(this.tempDisplayObjectParent=new e),this.tempDisplayObjectParent}},{key:"x",get:function(){return this.position.x},set:function(t){this.transform.position.x=t}},{key:"y",get:function(){return this.position.y},set:function(t){this.transform.position.y=t}},{key:"worldTransform",get:function(){return this.transform.worldTransform}},{key:"localTransform",get:function(){return this.transform.localTransform}},{key:"position",get:function(){return this.transform.position},set:function(t){this.transform.position.copy(t)}},{key:"scale",get:function(){return this.transform.scale},set:function(t){this.transform.scale.copy(t)}},{key:"pivot",get:function(){return this.transform.pivot},set:function(t){this.transform.pivot.copy(t)}},{key:"skew",get:function(){return this.transform.skew},set:function(t){this.transform.skew.copy(t)}},{key:"rotation",get:function(){return this.transform.rotation},set:function(t){this.transform.rotation=t}},{key:"worldVisible",get:function(){var t=this;do{if(!t.visible)return!1;t=t.parent}while(t);return!0}},{key:"mask",get:function(){return this._mask},set:function(t){this._mask&&(this._mask.renderable=!0),this._mask=t,this._mask&&(this._mask.renderable=!1)}},{key:"filters",get:function(){return this._filters&&this._filters.slice()},set:function(t){this._filters=t&&t.slice()}}]),e}(h.default);r.default=b,b.prototype.displayObjectUpdateTransform=b.prototype.updateTransform},{"../const":45,"../math":69,"../settings":100,"./Bounds":46,"./Transform":49,"./TransformStatic":51,eventemitter3:3}],49:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../math"),h=t("./TransformBase"),l=n(h),c=function(t){function e(){i(this,e);var r=o(this,t.call(this));return r.position=new u.Point(0,0),r.scale=new u.Point(1,1),r.skew=new u.ObservablePoint(r.updateSkew,r,0,0),r.pivot=new u.Point(0,0),r._rotation=0,r._cx=1,r._sx=0,r._cy=0,r._sy=1,r}return s(e,t),e.prototype.updateSkew=function(){this._cx=Math.cos(this._rotation+this.skew._y),this._sx=Math.sin(this._rotation+this.skew._y),this._cy=-Math.sin(this._rotation-this.skew._x),this._sy=Math.cos(this._rotation-this.skew._x)},e.prototype.updateLocalTransform=function(){var t=this.localTransform;t.a=this._cx*this.scale.x,t.b=this._sx*this.scale.x,t.c=this._cy*this.scale.y,t.d=this._sy*this.scale.y,t.tx=this.position.x-(this.pivot.x*t.a+this.pivot.y*t.c),t.ty=this.position.y-(this.pivot.x*t.b+this.pivot.y*t.d)},e.prototype.updateTransform=function(t){var e=this.localTransform;e.a=this._cx*this.scale.x,e.b=this._sx*this.scale.x,e.c=this._cy*this.scale.y,e.d=this._sy*this.scale.y,e.tx=this.position.x-(this.pivot.x*e.a+this.pivot.y*e.c),e.ty=this.position.y-(this.pivot.x*e.b+this.pivot.y*e.d);var r=t.worldTransform,n=this.worldTransform;n.a=e.a*r.a+e.b*r.c,n.b=e.a*r.b+e.b*r.d,n.c=e.c*r.a+e.d*r.c,n.d=e.c*r.b+e.d*r.d,n.tx=e.tx*r.a+e.ty*r.c+r.tx,n.ty=e.tx*r.b+e.ty*r.d+r.ty,this._worldID++},e.prototype.setFromMatrix=function(t){t.decompose(this)},a(e,[{key:"rotation",get:function(){return this._rotation},set:function(t){this._rotation=t,this.updateSkew()}}]),e}(l.default);r.default=c},{"../math":69,"./TransformBase":50}],50:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=t("../math"),o=function(){function t(){n(this,t),this.worldTransform=new i.Matrix,this.localTransform=new i.Matrix,this._worldID=0,this._parentID=0}return t.prototype.updateLocalTransform=function(){},t.prototype.updateTransform=function(t){var e=t.worldTransform,r=this.worldTransform,n=this.localTransform;r.a=n.a*e.a+n.b*e.c,r.b=n.a*e.b+n.b*e.d,r.c=n.c*e.a+n.d*e.c,r.d=n.c*e.b+n.d*e.d,r.tx=n.tx*e.a+n.ty*e.c+e.tx,r.ty=n.tx*e.b+n.ty*e.d+e.ty,
    this._worldID++},t}();r.default=o,o.prototype.updateWorldTransform=o.prototype.updateTransform,o.IDENTITY=new o},{"../math":69}],51:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../math"),h=t("./TransformBase"),l=n(h),c=function(t){function e(){i(this,e);var r=o(this,t.call(this));return r.position=new u.ObservablePoint(r.onChange,r,0,0),r.scale=new u.ObservablePoint(r.onChange,r,1,1),r.pivot=new u.ObservablePoint(r.onChange,r,0,0),r.skew=new u.ObservablePoint(r.updateSkew,r,0,0),r._rotation=0,r._cx=1,r._sx=0,r._cy=0,r._sy=1,r._localID=0,r._currentLocalID=0,r}return s(e,t),e.prototype.onChange=function(){this._localID++},e.prototype.updateSkew=function(){this._cx=Math.cos(this._rotation+this.skew._y),this._sx=Math.sin(this._rotation+this.skew._y),this._cy=-Math.sin(this._rotation-this.skew._x),this._sy=Math.cos(this._rotation-this.skew._x),this._localID++},e.prototype.updateLocalTransform=function(){var t=this.localTransform;this._localID!==this._currentLocalID&&(t.a=this._cx*this.scale._x,t.b=this._sx*this.scale._x,t.c=this._cy*this.scale._y,t.d=this._sy*this.scale._y,t.tx=this.position._x-(this.pivot._x*t.a+this.pivot._y*t.c),t.ty=this.position._y-(this.pivot._x*t.b+this.pivot._y*t.d),this._currentLocalID=this._localID,this._parentID=-1)},e.prototype.updateTransform=function(t){var e=this.localTransform;if(this._localID!==this._currentLocalID&&(e.a=this._cx*this.scale._x,e.b=this._sx*this.scale._x,e.c=this._cy*this.scale._y,e.d=this._sy*this.scale._y,e.tx=this.position._x-(this.pivot._x*e.a+this.pivot._y*e.c),e.ty=this.position._y-(this.pivot._x*e.b+this.pivot._y*e.d),this._currentLocalID=this._localID,this._parentID=-1),this._parentID!==t._worldID){var r=t.worldTransform,n=this.worldTransform;n.a=e.a*r.a+e.b*r.c,n.b=e.a*r.b+e.b*r.d,n.c=e.c*r.a+e.d*r.c,n.d=e.c*r.b+e.d*r.d,n.tx=e.tx*r.a+e.ty*r.c+r.tx,n.ty=e.tx*r.b+e.ty*r.d+r.ty,this._parentID=t._worldID,this._worldID++}},e.prototype.setFromMatrix=function(t){t.decompose(this),this._localID++},a(e,[{key:"rotation",get:function(){return this._rotation},set:function(t){this._rotation=t,this.updateSkew()}}]),e}(l.default);r.default=c},{"../math":69,"./TransformBase":50}],52:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../display/Container"),u=n(a),h=t("../textures/RenderTexture"),l=n(h),c=t("../textures/Texture"),d=n(c),f=t("./GraphicsData"),p=n(f),v=t("../sprites/Sprite"),y=n(v),g=t("../math"),m=t("../utils"),_=t("../const"),b=t("../display/Bounds"),x=n(b),T=t("./utils/bezierCurveTo"),w=n(T),E=t("../renderers/canvas/CanvasRenderer"),S=n(E),O=void 0,P=new g.Matrix,M=new g.Point,C=new Float32Array(4),R=new Float32Array(4),A=function(t){function e(){var r=arguments.length>0&&void 0!==arguments[0]&&arguments[0];i(this,e);var n=o(this,t.call(this));return n.fillAlpha=1,n.lineWidth=0,n.nativeLines=r,n.lineColor=0,n.graphicsData=[],n.tint=16777215,n._prevTint=16777215,n.blendMode=_.BLEND_MODES.NORMAL,n.currentPath=null,n._webGL={},n.isMask=!1,n.boundsPadding=0,n._localBounds=new x.default,n.dirty=0,n.fastRectDirty=-1,n.clearDirty=0,n.boundsDirty=-1,n.cachedSpriteDirty=!1,n._spriteRect=null,n._fastRect=!1,n}return s(e,t),e.prototype.clone=function t(){var t=new e;t.renderable=this.renderable,t.fillAlpha=this.fillAlpha,t.lineWidth=this.lineWidth,t.lineColor=this.lineColor,t.tint=this.tint,t.blendMode=this.blendMode,t.isMask=this.isMask,t.boundsPadding=this.boundsPadding,t.dirty=0,t.cachedSpriteDirty=this.cachedSpriteDirty;for(var r=0;r<this.graphicsData.length;++r)t.graphicsData.push(this.graphicsData[r].clone());return t.currentPath=t.graphicsData[t.graphicsData.length-1],t.updateLocalBounds(),t},e.prototype.lineStyle=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(this.lineWidth=t,this.lineColor=e,this.lineAlpha=r,this.currentPath)if(this.currentPath.shape.points.length){var n=new g.Polygon(this.currentPath.shape.points.slice(-2));n.closed=!1,this.drawShape(n)}else this.currentPath.lineWidth=this.lineWidth,this.currentPath.lineColor=this.lineColor,this.currentPath.lineAlpha=this.lineAlpha;return this},e.prototype.moveTo=function(t,e){var r=new g.Polygon([t,e]);return r.closed=!1,this.drawShape(r),this},e.prototype.lineTo=function(t,e){return this.currentPath.shape.points.push(t,e),this.dirty++,this},e.prototype.quadraticCurveTo=function(t,e,r,n){this.currentPath?0===this.currentPath.shape.points.length&&(this.currentPath.shape.points=[0,0]):this.moveTo(0,0);var i=20,o=this.currentPath.shape.points,s=0,a=0;0===o.length&&this.moveTo(0,0);for(var u=o[o.length-2],h=o[o.length-1],l=1;l<=i;++l){var c=l/i;s=u+(t-u)*c,a=h+(e-h)*c,o.push(s+(t+(r-t)*c-s)*c,a+(e+(n-e)*c-a)*c)}return this.dirty++,this},e.prototype.bezierCurveTo=function(t,e,r,n,i,o){this.currentPath?0===this.currentPath.shape.points.length&&(this.currentPath.shape.points=[0,0]):this.moveTo(0,0);var s=this.currentPath.shape.points,a=s[s.length-2],u=s[s.length-1];return s.length-=2,(0,w.default)(a,u,t,e,r,n,i,o,s),this.dirty++,this},e.prototype.arcTo=function(t,e,r,n,i){this.currentPath?0===this.currentPath.shape.points.length&&this.currentPath.shape.points.push(t,e):this.moveTo(t,e);var o=this.currentPath.shape.points,s=o[o.length-2],a=o[o.length-1],u=a-e,h=s-t,l=n-e,c=r-t,d=Math.abs(u*c-h*l);if(d<1e-8||0===i)o[o.length-2]===t&&o[o.length-1]===e||o.push(t,e);else{var f=u*u+h*h,p=l*l+c*c,v=u*l+h*c,y=i*Math.sqrt(f)/d,g=i*Math.sqrt(p)/d,m=y*v/f,_=g*v/p,b=y*c+g*h,x=y*l+g*u,T=h*(g+m),w=u*(g+m),E=c*(y+_),S=l*(y+_),O=Math.atan2(w-x,T-b),P=Math.atan2(S-x,E-b);this.arc(b+t,x+e,i,O,P,h*l>c*u)}return this.dirty++,this},e.prototype.arc=function(t,e,r,n,i){var o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(n===i)return this;!o&&i<=n?i+=2*Math.PI:o&&n<=i&&(n+=2*Math.PI);var s=i-n,a=40*Math.ceil(Math.abs(s)/(2*Math.PI));if(0===s)return this;var u=t+Math.cos(n)*r,h=e+Math.sin(n)*r,l=this.currentPath?this.currentPath.shape.points:null;l?l[l.length-2]===u&&l[l.length-1]===h||l.push(u,h):(this.moveTo(u,h),l=this.currentPath.shape.points);for(var c=s/(2*a),d=2*c,f=Math.cos(c),p=Math.sin(c),v=a-1,y=v%1/v,g=0;g<=v;++g){var m=g+y*g,_=c+n+d*m,b=Math.cos(_),x=-Math.sin(_);l.push((f*b+p*x)*r+t,(f*-x+p*b)*r+e)}return this.dirty++,this},e.prototype.beginFill=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.filling=!0,this.fillColor=t,this.fillAlpha=e,this.currentPath&&this.currentPath.shape.points.length<=2&&(this.currentPath.fill=this.filling,this.currentPath.fillColor=this.fillColor,this.currentPath.fillAlpha=this.fillAlpha),this},e.prototype.endFill=function(){return this.filling=!1,this.fillColor=null,this.fillAlpha=1,this},e.prototype.drawRect=function(t,e,r,n){return this.drawShape(new g.Rectangle(t,e,r,n)),this},e.prototype.drawRoundedRect=function(t,e,r,n,i){return this.drawShape(new g.RoundedRectangle(t,e,r,n,i)),this},e.prototype.drawCircle=function(t,e,r){return this.drawShape(new g.Circle(t,e,r)),this},e.prototype.drawEllipse=function(t,e,r,n){return this.drawShape(new g.Ellipse(t,e,r,n)),this},e.prototype.drawPolygon=function(t){var e=t,r=!0;if(e instanceof g.Polygon&&(r=e.closed,e=e.points),!Array.isArray(e)){e=new Array(arguments.length);for(var n=0;n<e.length;++n)e[n]=arguments[n]}var i=new g.Polygon(e);return i.closed=r,this.drawShape(i),this},e.prototype.clear=function(){return(this.lineWidth||this.filling||this.graphicsData.length>0)&&(this.lineWidth=0,this.filling=!1,this.boundsDirty=-1,this.dirty++,this.clearDirty++,this.graphicsData.length=0),this.currentPath=null,this._spriteRect=null,this},e.prototype.isFastRect=function(){return 1===this.graphicsData.length&&this.graphicsData[0].shape.type===_.SHAPES.RECT&&!this.graphicsData[0].lineWidth},e.prototype._renderWebGL=function(t){this.dirty!==this.fastRectDirty&&(this.fastRectDirty=this.dirty,this._fastRect=this.isFastRect()),this._fastRect?this._renderSpriteRect(t):(t.setObjectRenderer(t.plugins.graphics),t.plugins.graphics.render(this))},e.prototype._renderSpriteRect=function(t){var e=this.graphicsData[0].shape;this._spriteRect||(this._spriteRect=new y.default(new d.default(d.default.WHITE)));var r=this._spriteRect;if(16777215===this.tint)r.tint=this.graphicsData[0].fillColor;else{var n=C,i=R;(0,m.hex2rgb)(this.graphicsData[0].fillColor,n),(0,m.hex2rgb)(this.tint,i),n[0]*=i[0],n[1]*=i[1],n[2]*=i[2],r.tint=(0,m.rgb2hex)(n)}r.alpha=this.graphicsData[0].fillAlpha,r.worldAlpha=this.worldAlpha*r.alpha,r.blendMode=this.blendMode,r._texture._frame.width=e.width,r._texture._frame.height=e.height,r.transform.worldTransform=this.transform.worldTransform,r.anchor.set(-e.x/e.width,-e.y/e.height),r._onAnchorUpdate(),r._renderWebGL(t)},e.prototype._renderCanvas=function(t){this.isMask!==!0&&t.plugins.graphics.render(this)},e.prototype._calculateBounds=function(){this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.updateLocalBounds(),this.cachedSpriteDirty=!0);var t=this._localBounds;this._bounds.addFrame(this.transform,t.minX,t.minY,t.maxX,t.maxY)},e.prototype.containsPoint=function(t){this.worldTransform.applyInverse(t,M);for(var e=this.graphicsData,r=0;r<e.length;++r){var n=e[r];if(n.fill&&n.shape&&n.shape.contains(M.x,M.y)){if(n.holes)for(var i=0;i<n.holes.length;i++){var o=n.holes[i];if(o.contains(M.x,M.y))return!1}return!0}}return!1},e.prototype.updateLocalBounds=function(){var t=1/0,e=-(1/0),r=1/0,n=-(1/0);if(this.graphicsData.length)for(var i=0,o=0,s=0,a=0,u=0,h=0;h<this.graphicsData.length;h++){var l=this.graphicsData[h],c=l.type,d=l.lineWidth;if(i=l.shape,c===_.SHAPES.RECT||c===_.SHAPES.RREC)o=i.x-d/2,s=i.y-d/2,a=i.width+d,u=i.height+d,t=o<t?o:t,e=o+a>e?o+a:e,r=s<r?s:r,n=s+u>n?s+u:n;else if(c===_.SHAPES.CIRC)o=i.x,s=i.y,a=i.radius+d/2,u=i.radius+d/2,t=o-a<t?o-a:t,e=o+a>e?o+a:e,r=s-u<r?s-u:r,n=s+u>n?s+u:n;else if(c===_.SHAPES.ELIP)o=i.x,s=i.y,a=i.width+d/2,u=i.height+d/2,t=o-a<t?o-a:t,e=o+a>e?o+a:e,r=s-u<r?s-u:r,n=s+u>n?s+u:n;else for(var f=i.points,p=0,v=0,y=0,g=0,m=0,b=0,x=0,T=0,w=0;w+2<f.length;w+=2)o=f[w],s=f[w+1],p=f[w+2],v=f[w+3],y=Math.abs(p-o),g=Math.abs(v-s),u=d,a=Math.sqrt(y*y+g*g),a<1e-9||(m=(u/a*g+y)/2,b=(u/a*y+g)/2,x=(p+o)/2,T=(v+s)/2,t=x-m<t?x-m:t,e=x+m>e?x+m:e,r=T-b<r?T-b:r,n=T+b>n?T+b:n)}else t=0,e=0,r=0,n=0;var E=this.boundsPadding;this._localBounds.minX=t-E,this._localBounds.maxX=e+E,this._localBounds.minY=r-E,this._localBounds.maxY=n+E},e.prototype.drawShape=function(t){this.currentPath&&this.currentPath.shape.points.length<=2&&this.graphicsData.pop(),this.currentPath=null;var e=new p.default(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.filling,this.nativeLines,t);return this.graphicsData.push(e),e.type===_.SHAPES.POLY&&(e.shape.closed=e.shape.closed||this.filling,this.currentPath=e),this.dirty++,e},e.prototype.generateCanvasTexture=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,r=this.getLocalBounds(),n=l.default.create(r.width,r.height,t,e);O||(O=new S.default),this.transform.updateLocalTransform(),this.transform.localTransform.copy(P),P.invert(),P.tx-=r.x,P.ty-=r.y,O.render(this,n,!0,P);var i=d.default.fromCanvas(n.baseTexture._canvasRenderTarget.canvas,t,"graphics");return i.baseTexture.resolution=e,i.baseTexture.update(),i},e.prototype.closePath=function(){var t=this.currentPath;return t&&t.shape&&t.shape.close(),this},e.prototype.addHole=function(){var t=this.graphicsData.pop();return this.currentPath=this.graphicsData[this.graphicsData.length-1],this.currentPath.addHole(t.shape),this.currentPath=null,this},e.prototype.destroy=function(e){t.prototype.destroy.call(this,e);for(var r=0;r<this.graphicsData.length;++r)this.graphicsData[r].destroy();for(var n in this._webgl)for(var i=0;i<this._webgl[n].data.length;++i)this._webgl[n].data[i].destroy();this._spriteRect&&this._spriteRect.destroy(),this.graphicsData=null,this.currentPath=null,this._webgl=null,this._localBounds=null},e}(u.default);r.default=A,A._SPRITE_TEXTURE=null},{"../const":45,"../display/Bounds":46,"../display/Container":47,"../math":69,"../renderers/canvas/CanvasRenderer":76,"../sprites/Sprite":101,"../textures/RenderTexture":112,"../textures/Texture":114,"../utils":123,"./GraphicsData":53,"./utils/bezierCurveTo":55}],53:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(e,r,i,o,s,a,u,h){n(this,t),this.lineWidth=e,this.nativeLines=u,this.lineColor=r,this.lineAlpha=i,this._lineTint=r,this.fillColor=o,this.fillAlpha=s,this._fillTint=o,this.fill=a,this.holes=[],this.shape=h,this.type=h.type}return t.prototype.clone=function(){return new t(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.fill,this.nativeLines,this.shape)},t.prototype.addHole=function(t){this.holes.push(t)},t.prototype.destroy=function(){this.shape=null,this.holes=null},t}();r.default=i},{}],54:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("../../renderers/canvas/CanvasRenderer"),s=n(o),a=t("../../const"),u=function(){function t(e){i(this,t),this.renderer=e}return t.prototype.render=function(t){var e=this.renderer,r=e.context,n=t.worldAlpha,i=t.transform.worldTransform,o=e.resolution;this._prevTint!==this.tint&&(this.dirty=!0),r.setTransform(i.a*o,i.b*o,i.c*o,i.d*o,i.tx*o,i.ty*o),t.dirty&&(this.updateGraphicsTint(t),t.dirty=!1),e.setBlendMode(t.blendMode);for(var s=0;s<t.graphicsData.length;s++){var u=t.graphicsData[s],h=u.shape,l=u._fillTint,c=u._lineTint;if(r.lineWidth=u.lineWidth,u.type===a.SHAPES.POLY){r.beginPath(),this.renderPolygon(h.points,h.closed,r);for(var d=0;d<u.holes.length;d++)this.renderPolygon(u.holes[d].points,!0,r);u.fill&&(r.globalAlpha=u.fillAlpha*n,r.fillStyle="#"+("00000"+(0|l).toString(16)).substr(-6),r.fill()),u.lineWidth&&(r.globalAlpha=u.lineAlpha*n,r.strokeStyle="#"+("00000"+(0|c).toString(16)).substr(-6),r.stroke())}else if(u.type===a.SHAPES.RECT)(u.fillColor||0===u.fillColor)&&(r.globalAlpha=u.fillAlpha*n,r.fillStyle="#"+("00000"+(0|l).toString(16)).substr(-6),r.fillRect(h.x,h.y,h.width,h.height)),u.lineWidth&&(r.globalAlpha=u.lineAlpha*n,r.strokeStyle="#"+("00000"+(0|c).toString(16)).substr(-6),r.strokeRect(h.x,h.y,h.width,h.height));else if(u.type===a.SHAPES.CIRC)r.beginPath(),r.arc(h.x,h.y,h.radius,0,2*Math.PI),r.closePath(),u.fill&&(r.globalAlpha=u.fillAlpha*n,r.fillStyle="#"+("00000"+(0|l).toString(16)).substr(-6),r.fill()),u.lineWidth&&(r.globalAlpha=u.lineAlpha*n,r.strokeStyle="#"+("00000"+(0|c).toString(16)).substr(-6),r.stroke());else if(u.type===a.SHAPES.ELIP){var f=2*h.width,p=2*h.height,v=h.x-f/2,y=h.y-p/2;r.beginPath();var g=.5522848,m=f/2*g,_=p/2*g,b=v+f,x=y+p,T=v+f/2,w=y+p/2;r.moveTo(v,w),r.bezierCurveTo(v,w-_,T-m,y,T,y),r.bezierCurveTo(T+m,y,b,w-_,b,w),r.bezierCurveTo(b,w+_,T+m,x,T,x),r.bezierCurveTo(T-m,x,v,w+_,v,w),r.closePath(),u.fill&&(r.globalAlpha=u.fillAlpha*n,r.fillStyle="#"+("00000"+(0|l).toString(16)).substr(-6),r.fill()),u.lineWidth&&(r.globalAlpha=u.lineAlpha*n,r.strokeStyle="#"+("00000"+(0|c).toString(16)).substr(-6),r.stroke())}else if(u.type===a.SHAPES.RREC){var E=h.x,S=h.y,O=h.width,P=h.height,M=h.radius,C=Math.min(O,P)/2|0;M=M>C?C:M,r.beginPath(),r.moveTo(E,S+M),r.lineTo(E,S+P-M),r.quadraticCurveTo(E,S+P,E+M,S+P),r.lineTo(E+O-M,S+P),r.quadraticCurveTo(E+O,S+P,E+O,S+P-M),r.lineTo(E+O,S+M),r.quadraticCurveTo(E+O,S,E+O-M,S),r.lineTo(E+M,S),r.quadraticCurveTo(E,S,E,S+M),r.closePath(),(u.fillColor||0===u.fillColor)&&(r.globalAlpha=u.fillAlpha*n,r.fillStyle="#"+("00000"+(0|l).toString(16)).substr(-6),r.fill()),u.lineWidth&&(r.globalAlpha=u.lineAlpha*n,r.strokeStyle="#"+("00000"+(0|c).toString(16)).substr(-6),r.stroke())}}},t.prototype.updateGraphicsTint=function(t){t._prevTint=t.tint;for(var e=(t.tint>>16&255)/255,r=(t.tint>>8&255)/255,n=(255&t.tint)/255,i=0;i<t.graphicsData.length;++i){var o=t.graphicsData[i],s=0|o.fillColor,a=0|o.lineColor;o._fillTint=((s>>16&255)/255*e*255<<16)+((s>>8&255)/255*r*255<<8)+(255&s)/255*n*255,o._lineTint=((a>>16&255)/255*e*255<<16)+((a>>8&255)/255*r*255<<8)+(255&a)/255*n*255}},t.prototype.renderPolygon=function(t,e,r){r.moveTo(t[0],t[1]);for(var n=1;n<t.length/2;++n)r.lineTo(t[2*n],t[2*n+1]);e&&r.closePath()},t.prototype.destroy=function(){this.renderer=null},t}();r.default=u,s.default.registerPlugin("graphics",u)},{"../../const":45,"../../renderers/canvas/CanvasRenderer":76}],55:[function(t,e,r){"use strict";function n(t,e,r,n,i,o,s,a){var u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:[],h=20,l=0,c=0,d=0,f=0,p=0;u.push(t,e);for(var v=1,y=0;v<=h;++v)y=v/h,l=1-y,c=l*l,d=c*l,f=y*y,p=f*y,u.push(d*t+3*c*y*r+3*l*f*i+p*s,d*e+3*c*y*n+3*l*f*o+p*a);return u}r.__esModule=!0,r.default=n},{}],56:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../../utils"),u=t("../../const"),h=t("../../renderers/webgl/utils/ObjectRenderer"),l=n(h),c=t("../../renderers/webgl/WebGLRenderer"),d=n(c),f=t("./WebGLGraphicsData"),p=n(f),v=t("./shaders/PrimitiveShader"),y=n(v),g=t("./utils/buildPoly"),m=n(g),_=t("./utils/buildRectangle"),b=n(_),x=t("./utils/buildRoundedRectangle"),T=n(x),w=t("./utils/buildCircle"),E=n(w),S=function(t){function e(r){i(this,e);var n=o(this,t.call(this,r));return n.graphicsDataPool=[],n.primitiveShader=null,n.gl=r.gl,n.CONTEXT_UID=0,n}return s(e,t),e.prototype.onContextChange=function(){this.gl=this.renderer.gl,this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.primitiveShader=new y.default(this.gl)},e.prototype.destroy=function(){l.default.prototype.destroy.call(this);for(var t=0;t<this.graphicsDataPool.length;++t)this.graphicsDataPool[t].destroy();this.graphicsDataPool=null},e.prototype.render=function(t){var e=this.renderer,r=e.gl,n=void 0,i=t._webGL[this.CONTEXT_UID];i&&t.dirty===i.dirty||(this.updateGraphics(t),i=t._webGL[this.CONTEXT_UID]);var o=this.primitiveShader;e.bindShader(o),e.state.setBlendMode(t.blendMode);for(var s=0,u=i.data.length;s<u;s++){n=i.data[s];var h=n.shader;e.bindShader(h),h.uniforms.translationMatrix=t.transform.worldTransform.toArray(!0),h.uniforms.tint=(0,a.hex2rgb)(t.tint),h.uniforms.alpha=t.worldAlpha,e.bindVao(n.vao),n.nativeLines?r.drawArrays(r.LINES,0,n.points.length/6):n.vao.draw(r.TRIANGLE_STRIP,n.indices.length)}},e.prototype.updateGraphics=function(t){var e=this.renderer.gl,r=t._webGL[this.CONTEXT_UID];if(r||(r=t._webGL[this.CONTEXT_UID]={lastIndex:0,data:[],gl:e,clearDirty:-1,dirty:-1}),r.dirty=t.dirty,t.clearDirty!==r.clearDirty){r.clearDirty=t.clearDirty;for(var n=0;n<r.data.length;n++)this.graphicsDataPool.push(r.data[n]);r.data.length=0,r.lastIndex=0}for(var i=void 0,o=void 0,s=r.lastIndex;s<t.graphicsData.length;s++){var a=t.graphicsData[s];i=this.getWebGLData(r,0),a.nativeLines&&a.lineWidth&&(o=this.getWebGLData(r,0,!0),r.lastIndex++),a.type===u.SHAPES.POLY&&(0,m.default)(a,i,o),a.type===u.SHAPES.RECT?(0,b.default)(a,i,o):a.type===u.SHAPES.CIRC||a.type===u.SHAPES.ELIP?(0,E.default)(a,i,o):a.type===u.SHAPES.RREC&&(0,T.default)(a,i,o),r.lastIndex++}this.renderer.bindVao(null);for(var h=0;h<r.data.length;h++)i=r.data[h],i.dirty&&i.upload()},e.prototype.getWebGLData=function(t,e,r){var n=t.data[t.data.length-1];return(!n||n.nativeLines!==r||n.points.length>32e4)&&(n=this.graphicsDataPool.pop()||new p.default(this.renderer.gl,this.primitiveShader,this.renderer.state.attribsState),n.nativeLines=r,n.reset(e),t.data.push(n)),n.dirty=!0,n},e}(l.default);r.default=S,d.default.registerPlugin("graphics",S)},{"../../const":45,"../../renderers/webgl/WebGLRenderer":83,"../../renderers/webgl/utils/ObjectRenderer":93,"../../utils":123,"./WebGLGraphicsData":57,"./shaders/PrimitiveShader":58,"./utils/buildCircle":59,"./utils/buildPoly":61,"./utils/buildRectangle":62,"./utils/buildRoundedRectangle":63}],57:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("pixi-gl-core"),s=n(o),a=function(){function t(e,r,n){i(this,t),this.gl=e,this.color=[0,0,0],this.points=[],this.indices=[],this.buffer=s.default.GLBuffer.createVertexBuffer(e),this.indexBuffer=s.default.GLBuffer.createIndexBuffer(e),this.dirty=!0,this.nativeLines=!1,this.glPoints=null,this.glIndices=null,this.shader=r,this.vao=new s.default.VertexArrayObject(e,n).addIndex(this.indexBuffer).addAttribute(this.buffer,r.attributes.aVertexPosition,e.FLOAT,!1,24,0).addAttribute(this.buffer,r.attributes.aColor,e.FLOAT,!1,24,8)}return t.prototype.reset=function(){this.points.length=0,this.indices.length=0},t.prototype.upload=function(){this.glPoints=new Float32Array(this.points),this.buffer.upload(this.glPoints),this.glIndices=new Uint16Array(this.indices),this.indexBuffer.upload(this.glIndices),this.dirty=!1},t.prototype.destroy=function(){this.color=null,this.points=null,this.indices=null,this.vao.destroy(),this.buffer.destroy(),this.indexBuffer.destroy(),this.gl=null,this.buffer=null,this.indexBuffer=null,this.glPoints=null,this.glIndices=null},t}();r.default=a},{"pixi-gl-core":12}],58:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../../../Shader"),u=n(a),h=function(t){function e(r){return i(this,e),o(this,t.call(this,r,["attribute vec2 aVertexPosition;","attribute vec4 aColor;","uniform mat3 translationMatrix;","uniform mat3 projectionMatrix;","uniform float alpha;","uniform vec3 tint;","varying vec4 vColor;","void main(void){","   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);","   vColor = aColor * vec4(tint * alpha, alpha);","}"].join("\n"),["varying vec4 vColor;","void main(void){","   gl_FragColor = vColor;","}"].join("\n")))}return s(e,t),e}(u.default);r.default=h},{"../../../Shader":43}],59:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e,r){var n=t.shape,i=n.x,o=n.y,h=void 0,l=void 0;if(t.type===a.SHAPES.CIRC?(h=n.radius,l=n.radius):(h=n.width,l=n.height),0!==h&&0!==l){var c=Math.floor(30*Math.sqrt(n.radius))||Math.floor(15*Math.sqrt(n.width+n.height)),d=2*Math.PI/c;if(t.fill){var f=(0,u.hex2rgb)(t.fillColor),p=t.fillAlpha,v=f[0]*p,y=f[1]*p,g=f[2]*p,m=e.points,_=e.indices,b=m.length/6;_.push(b);for(var x=0;x<c+1;x++)m.push(i,o,v,y,g,p),m.push(i+Math.sin(d*x)*h,o+Math.cos(d*x)*l,v,y,g,p),_.push(b++,b++);_.push(b-1)}if(t.lineWidth){var T=t.points;t.points=[];for(var w=0;w<c+1;w++)t.points.push(i+Math.sin(d*w)*h,o+Math.cos(d*w)*l);(0,s.default)(t,e,r),t.points=T}}}r.__esModule=!0,r.default=i;var o=t("./buildLine"),s=n(o),a=t("../../../const"),u=t("../../../utils")},{"../../../const":45,"../../../utils":123,"./buildLine":60}],60:[function(t,e,r){"use strict";function n(t,e){var r=t.points;if(0!==r.length){var n=new o.Point(r[0],r[1]),i=new o.Point(r[r.length-2],r[r.length-1]);if(n.x===i.x&&n.y===i.y){r=r.slice(),r.pop(),r.pop(),i=new o.Point(r[r.length-2],r[r.length-1]);var a=i.x+.5*(n.x-i.x),u=i.y+.5*(n.y-i.y);r.unshift(a,u),r.push(a,u)}var h=e.points,l=e.indices,c=r.length/2,d=r.length,f=h.length/6,p=t.lineWidth/2,v=(0,s.hex2rgb)(t.lineColor),y=t.lineAlpha,g=v[0]*y,m=v[1]*y,_=v[2]*y,b=r[0],x=r[1],T=r[2],w=r[3],E=0,S=0,O=-(x-w),P=b-T,M=0,C=0,R=0,A=0,I=Math.sqrt(O*O+P*P);O/=I,P/=I,O*=p,P*=p,h.push(b-O,x-P,g,m,_,y),h.push(b+O,x+P,g,m,_,y);for(var D=1;D<c-1;++D){b=r[2*(D-1)],x=r[2*(D-1)+1],T=r[2*D],w=r[2*D+1],E=r[2*(D+1)],S=r[2*(D+1)+1],O=-(x-w),P=b-T,I=Math.sqrt(O*O+P*P),O/=I,P/=I,O*=p,P*=p,M=-(w-S),C=T-E,I=Math.sqrt(M*M+C*C),M/=I,C/=I,M*=p,C*=p;var L=-P+x-(-P+w),N=-O+T-(-O+b),F=(-O+b)*(-P+w)-(-O+T)*(-P+x),B=-C+S-(-C+w),k=-M+T-(-M+E),j=(-M+E)*(-C+w)-(-M+T)*(-C+S),U=L*k-B*N;if(Math.abs(U)<.1)U+=10.1,h.push(T-O,w-P,g,m,_,y),h.push(T+O,w+P,g,m,_,y);else{var X=(N*j-k*F)/U,G=(B*F-L*j)/U,W=(X-T)*(X-T)+(G-w)*(G-w);W>196*p*p?(R=O-M,A=P-C,I=Math.sqrt(R*R+A*A),R/=I,A/=I,R*=p,A*=p,h.push(T-R,w-A),h.push(g,m,_,y),h.push(T+R,w+A),h.push(g,m,_,y),h.push(T-R,w-A),h.push(g,m,_,y),d++):(h.push(X,G),h.push(g,m,_,y),h.push(T-(X-T),w-(G-w)),h.push(g,m,_,y))}}b=r[2*(c-2)],x=r[2*(c-2)+1],T=r[2*(c-1)],w=r[2*(c-1)+1],O=-(x-w),P=b-T,I=Math.sqrt(O*O+P*P),O/=I,P/=I,O*=p,P*=p,h.push(T-O,w-P),h.push(g,m,_,y),h.push(T+O,w+P),h.push(g,m,_,y),l.push(f);for(var H=0;H<d;++H)l.push(f++);l.push(f-1)}}function i(t,e){var r=0,n=t.points;if(0!==n.length){var i=e.points,o=n.length/2,a=(0,s.hex2rgb)(t.lineColor),u=t.lineAlpha,h=a[0]*u,l=a[1]*u,c=a[2]*u;for(r=1;r<o;r++){var d=n[2*(r-1)],f=n[2*(r-1)+1],p=n[2*r],v=n[2*r+1];i.push(d,f),i.push(h,l,c,u),i.push(p,v),i.push(h,l,c,u)}}}r.__esModule=!0,r.default=function(t,e,r){t.nativeLines?i(t,r):n(t,e)};var o=t("../../../math"),s=t("../../../utils")},{"../../../math":69,"../../../utils":123}],61:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e,r){t.points=t.shape.points.slice();var n=t.points;if(t.fill&&n.length>=6){for(var i=[],o=t.holes,u=0;u<o.length;u++){var l=o[u];i.push(n.length/2),n=n.concat(l.points)}var c=e.points,d=e.indices,f=n.length/2,p=(0,a.hex2rgb)(t.fillColor),v=t.fillAlpha,y=p[0]*v,g=p[1]*v,m=p[2]*v,_=(0,h.default)(n,i,2);if(!_)return;for(var b=c.length/6,x=0;x<_.length;x+=3)d.push(_[x]+b),d.push(_[x]+b),d.push(_[x+1]+b),d.push(_[x+2]+b),d.push(_[x+2]+b);for(var T=0;T<f;T++)c.push(n[2*T],n[2*T+1],y,g,m,v)}t.lineWidth>0&&(0,s.default)(t,e,r)}r.__esModule=!0,r.default=i;var o=t("./buildLine"),s=n(o),a=t("../../../utils"),u=t("earcut"),h=n(u)},{"../../../utils":123,"./buildLine":60,earcut:2}],62:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e,r){var n=t.shape,i=n.x,o=n.y,u=n.width,h=n.height;if(t.fill){var l=(0,a.hex2rgb)(t.fillColor),c=t.fillAlpha,d=l[0]*c,f=l[1]*c,p=l[2]*c,v=e.points,y=e.indices,g=v.length/6;v.push(i,o),v.push(d,f,p,c),v.push(i+u,o),v.push(d,f,p,c),v.push(i,o+h),v.push(d,f,p,c),v.push(i+u,o+h),v.push(d,f,p,c),y.push(g,g,g+1,g+2,g+3,g+3)}if(t.lineWidth){var m=t.points;t.points=[i,o,i+u,o,i+u,o+h,i,o+h,i,o],(0,s.default)(t,e,r),t.points=m}}r.__esModule=!0,r.default=i;var o=t("./buildLine"),s=n(o),a=t("../../../utils")},{"../../../utils":123,"./buildLine":60}],63:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e,r){var n=t.shape,i=n.x,o=n.y,a=n.width,h=n.height,d=n.radius,f=[];if(f.push(i,o+d),s(i,o+h-d,i,o+h,i+d,o+h,f),s(i+a-d,o+h,i+a,o+h,i+a,o+h-d,f),s(i+a,o+d,i+a,o,i+a-d,o,f),s(i+d,o,i,o,i,o+d+1e-10,f),t.fill){for(var p=(0,c.hex2rgb)(t.fillColor),v=t.fillAlpha,y=p[0]*v,g=p[1]*v,m=p[2]*v,_=e.points,b=e.indices,x=_.length/6,T=(0,u.default)(f,null,2),w=0,E=T.length;w<E;w+=3)b.push(T[w]+x),b.push(T[w]+x),b.push(T[w+1]+x),b.push(T[w+2]+x),b.push(T[w+2]+x);for(var S=0,O=f.length;S<O;S++)_.push(f[S],f[++S],y,g,m,v)}if(t.lineWidth){var P=t.points;t.points=f,(0,l.default)(t,e,r),t.points=P}}function o(t,e,r){var n=e-t;return t+n*r}function s(t,e,r,n,i,s){for(var a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:[],u=20,h=a,l=0,c=0,d=0,f=0,p=0,v=0,y=0,g=0;y<=u;++y)g=y/u,l=o(t,r,g),c=o(e,n,g),d=o(r,i,g),f=o(n,s,g),p=o(l,d,g),v=o(c,f,g),h.push(p,v);return h}r.__esModule=!0,r.default=i;var a=t("earcut"),u=n(a),h=t("./buildLine"),l=n(h),c=t("../../../utils")},{"../../../utils":123,"./buildLine":60,earcut:2}],64:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0,r.autoDetectRenderer=r.Application=r.Filter=r.SpriteMaskFilter=r.Quad=r.RenderTarget=r.ObjectRenderer=r.WebGLManager=r.Shader=r.CanvasRenderTarget=r.TextureUvs=r.VideoBaseTexture=r.BaseRenderTexture=r.RenderTexture=r.BaseTexture=r.Texture=r.Spritesheet=r.CanvasGraphicsRenderer=r.GraphicsRenderer=r.GraphicsData=r.Graphics=r.TextMetrics=r.TextStyle=r.Text=r.SpriteRenderer=r.CanvasTinter=r.CanvasSpriteRenderer=r.Sprite=r.TransformBase=r.TransformStatic=r.Transform=r.Container=r.DisplayObject=r.Bounds=r.glCore=r.WebGLRenderer=r.CanvasRenderer=r.ticker=r.utils=r.settings=void 0;var o=t("./const");Object.keys(o).forEach(function(t){"default"!==t&&"__esModule"!==t&&Object.defineProperty(r,t,{enumerable:!0,get:function(){return o[t]}})});var s=t("./math");Object.keys(s).forEach(function(t){"default"!==t&&"__esModule"!==t&&Object.defineProperty(r,t,{enumerable:!0,get:function(){return s[t]}})});var a=t("pixi-gl-core");Object.defineProperty(r,"glCore",{enumerable:!0,get:function(){return i(a).default}});var u=t("./display/Bounds");Object.defineProperty(r,"Bounds",{enumerable:!0,get:function(){return i(u).default}});var h=t("./display/DisplayObject");Object.defineProperty(r,"DisplayObject",{enumerable:!0,get:function(){return i(h).default}});var l=t("./display/Container");Object.defineProperty(r,"Container",{enumerable:!0,get:function(){return i(l).default}});var c=t("./display/Transform");Object.defineProperty(r,"Transform",{enumerable:!0,get:function(){return i(c).default}});var d=t("./display/TransformStatic");Object.defineProperty(r,"TransformStatic",{enumerable:!0,get:function(){return i(d).default}});var f=t("./display/TransformBase");
    Object.defineProperty(r,"TransformBase",{enumerable:!0,get:function(){return i(f).default}});var p=t("./sprites/Sprite");Object.defineProperty(r,"Sprite",{enumerable:!0,get:function(){return i(p).default}});var v=t("./sprites/canvas/CanvasSpriteRenderer");Object.defineProperty(r,"CanvasSpriteRenderer",{enumerable:!0,get:function(){return i(v).default}});var y=t("./sprites/canvas/CanvasTinter");Object.defineProperty(r,"CanvasTinter",{enumerable:!0,get:function(){return i(y).default}});var g=t("./sprites/webgl/SpriteRenderer");Object.defineProperty(r,"SpriteRenderer",{enumerable:!0,get:function(){return i(g).default}});var m=t("./text/Text");Object.defineProperty(r,"Text",{enumerable:!0,get:function(){return i(m).default}});var _=t("./text/TextStyle");Object.defineProperty(r,"TextStyle",{enumerable:!0,get:function(){return i(_).default}});var b=t("./text/TextMetrics");Object.defineProperty(r,"TextMetrics",{enumerable:!0,get:function(){return i(b).default}});var x=t("./graphics/Graphics");Object.defineProperty(r,"Graphics",{enumerable:!0,get:function(){return i(x).default}});var T=t("./graphics/GraphicsData");Object.defineProperty(r,"GraphicsData",{enumerable:!0,get:function(){return i(T).default}});var w=t("./graphics/webgl/GraphicsRenderer");Object.defineProperty(r,"GraphicsRenderer",{enumerable:!0,get:function(){return i(w).default}});var E=t("./graphics/canvas/CanvasGraphicsRenderer");Object.defineProperty(r,"CanvasGraphicsRenderer",{enumerable:!0,get:function(){return i(E).default}});var S=t("./textures/Spritesheet");Object.defineProperty(r,"Spritesheet",{enumerable:!0,get:function(){return i(S).default}});var O=t("./textures/Texture");Object.defineProperty(r,"Texture",{enumerable:!0,get:function(){return i(O).default}});var P=t("./textures/BaseTexture");Object.defineProperty(r,"BaseTexture",{enumerable:!0,get:function(){return i(P).default}});var M=t("./textures/RenderTexture");Object.defineProperty(r,"RenderTexture",{enumerable:!0,get:function(){return i(M).default}});var C=t("./textures/BaseRenderTexture");Object.defineProperty(r,"BaseRenderTexture",{enumerable:!0,get:function(){return i(C).default}});var R=t("./textures/VideoBaseTexture");Object.defineProperty(r,"VideoBaseTexture",{enumerable:!0,get:function(){return i(R).default}});var A=t("./textures/TextureUvs");Object.defineProperty(r,"TextureUvs",{enumerable:!0,get:function(){return i(A).default}});var I=t("./renderers/canvas/utils/CanvasRenderTarget");Object.defineProperty(r,"CanvasRenderTarget",{enumerable:!0,get:function(){return i(I).default}});var D=t("./Shader");Object.defineProperty(r,"Shader",{enumerable:!0,get:function(){return i(D).default}});var L=t("./renderers/webgl/managers/WebGLManager");Object.defineProperty(r,"WebGLManager",{enumerable:!0,get:function(){return i(L).default}});var N=t("./renderers/webgl/utils/ObjectRenderer");Object.defineProperty(r,"ObjectRenderer",{enumerable:!0,get:function(){return i(N).default}});var F=t("./renderers/webgl/utils/RenderTarget");Object.defineProperty(r,"RenderTarget",{enumerable:!0,get:function(){return i(F).default}});var B=t("./renderers/webgl/utils/Quad");Object.defineProperty(r,"Quad",{enumerable:!0,get:function(){return i(B).default}});var k=t("./renderers/webgl/filters/spriteMask/SpriteMaskFilter");Object.defineProperty(r,"SpriteMaskFilter",{enumerable:!0,get:function(){return i(k).default}});var j=t("./renderers/webgl/filters/Filter");Object.defineProperty(r,"Filter",{enumerable:!0,get:function(){return i(j).default}});var U=t("./Application");Object.defineProperty(r,"Application",{enumerable:!0,get:function(){return i(U).default}});var X=t("./autoDetectRenderer");Object.defineProperty(r,"autoDetectRenderer",{enumerable:!0,get:function(){return X.autoDetectRenderer}});var G=t("./utils"),W=n(G),H=t("./ticker"),Y=n(H),V=t("./settings"),z=i(V),q=t("./renderers/canvas/CanvasRenderer"),K=i(q),Z=t("./renderers/webgl/WebGLRenderer"),J=i(Z);r.settings=z.default,r.utils=W,r.ticker=Y,r.CanvasRenderer=K.default,r.WebGLRenderer=J.default},{"./Application":42,"./Shader":43,"./autoDetectRenderer":44,"./const":45,"./display/Bounds":46,"./display/Container":47,"./display/DisplayObject":48,"./display/Transform":49,"./display/TransformBase":50,"./display/TransformStatic":51,"./graphics/Graphics":52,"./graphics/GraphicsData":53,"./graphics/canvas/CanvasGraphicsRenderer":54,"./graphics/webgl/GraphicsRenderer":56,"./math":69,"./renderers/canvas/CanvasRenderer":76,"./renderers/canvas/utils/CanvasRenderTarget":78,"./renderers/webgl/WebGLRenderer":83,"./renderers/webgl/filters/Filter":85,"./renderers/webgl/filters/spriteMask/SpriteMaskFilter":88,"./renderers/webgl/managers/WebGLManager":92,"./renderers/webgl/utils/ObjectRenderer":93,"./renderers/webgl/utils/Quad":94,"./renderers/webgl/utils/RenderTarget":95,"./settings":100,"./sprites/Sprite":101,"./sprites/canvas/CanvasSpriteRenderer":102,"./sprites/canvas/CanvasTinter":103,"./sprites/webgl/SpriteRenderer":105,"./text/Text":107,"./text/TextMetrics":108,"./text/TextStyle":109,"./textures/BaseRenderTexture":110,"./textures/BaseTexture":111,"./textures/RenderTexture":112,"./textures/Spritesheet":113,"./textures/Texture":114,"./textures/TextureUvs":115,"./textures/VideoBaseTexture":116,"./ticker":119,"./utils":123,"pixi-gl-core":12}],65:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){return t<0?-1:t>0?1:0}function o(){for(var t=0;t<16;t++){var e=[];f.push(e);for(var r=0;r<16;r++)for(var n=i(u[t]*u[r]+l[t]*h[r]),o=i(h[t]*u[r]+c[t]*h[r]),s=i(u[t]*l[r]+l[t]*c[r]),p=i(h[t]*l[r]+c[t]*c[r]),v=0;v<16;v++)if(u[v]===n&&h[v]===o&&l[v]===s&&c[v]===p){e.push(v);break}}for(var y=0;y<16;y++){var g=new a.default;g.set(u[y],h[y],l[y],c[y],0,0),d.push(g)}}r.__esModule=!0;var s=t("./Matrix"),a=n(s),u=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],h=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],l=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],c=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],d=[],f=[];o();var p={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MIRROR_HORIZONTAL:12,uX:function(t){return u[t]},uY:function(t){return h[t]},vX:function(t){return l[t]},vY:function(t){return c[t]},inv:function(t){return 8&t?15&t:7&-t},add:function(t,e){return f[t][e]},sub:function(t,e){return f[t][p.inv(e)]},rotate180:function(t){return 4^t},isSwapWidthHeight:function(t){return 2===(3&t)},byDirection:function(t,e){return 2*Math.abs(t)<=Math.abs(e)?e>=0?p.S:p.N:2*Math.abs(e)<=Math.abs(t)?t>0?p.E:p.W:e>0?t>0?p.SE:p.SW:t>0?p.NE:p.NW},matrixAppendRotationInv:function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=d[p.inv(e)];i.tx=r,i.ty=n,t.append(i)}};r.default=p},{"./Matrix":66}],66:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=t("./Point"),a=n(s),u=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;i(this,t),this.a=e,this.b=r,this.c=n,this.d=o,this.tx=s,this.ty=a,this.array=null}return t.prototype.fromArray=function(t){this.a=t[0],this.b=t[1],this.c=t[3],this.d=t[4],this.tx=t[2],this.ty=t[5]},t.prototype.set=function(t,e,r,n,i,o){return this.a=t,this.b=e,this.c=r,this.d=n,this.tx=i,this.ty=o,this},t.prototype.toArray=function(t,e){this.array||(this.array=new Float32Array(9));var r=e||this.array;return t?(r[0]=this.a,r[1]=this.b,r[2]=0,r[3]=this.c,r[4]=this.d,r[5]=0,r[6]=this.tx,r[7]=this.ty,r[8]=1):(r[0]=this.a,r[1]=this.c,r[2]=this.tx,r[3]=this.b,r[4]=this.d,r[5]=this.ty,r[6]=0,r[7]=0,r[8]=1),r},t.prototype.apply=function(t,e){e=e||new a.default;var r=t.x,n=t.y;return e.x=this.a*r+this.c*n+this.tx,e.y=this.b*r+this.d*n+this.ty,e},t.prototype.applyInverse=function(t,e){e=e||new a.default;var r=1/(this.a*this.d+this.c*-this.b),n=t.x,i=t.y;return e.x=this.d*r*n+-this.c*r*i+(this.ty*this.c-this.tx*this.d)*r,e.y=this.a*r*i+-this.b*r*n+(-this.ty*this.a+this.tx*this.b)*r,e},t.prototype.translate=function(t,e){return this.tx+=t,this.ty+=e,this},t.prototype.scale=function(t,e){return this.a*=t,this.d*=e,this.c*=t,this.b*=e,this.tx*=t,this.ty*=e,this},t.prototype.rotate=function(t){var e=Math.cos(t),r=Math.sin(t),n=this.a,i=this.c,o=this.tx;return this.a=n*e-this.b*r,this.b=n*r+this.b*e,this.c=i*e-this.d*r,this.d=i*r+this.d*e,this.tx=o*e-this.ty*r,this.ty=o*r+this.ty*e,this},t.prototype.append=function(t){var e=this.a,r=this.b,n=this.c,i=this.d;return this.a=t.a*e+t.b*n,this.b=t.a*r+t.b*i,this.c=t.c*e+t.d*n,this.d=t.c*r+t.d*i,this.tx=t.tx*e+t.ty*n+this.tx,this.ty=t.tx*r+t.ty*i+this.ty,this},t.prototype.setTransform=function(t,e,r,n,i,o,s,a,u){var h=Math.sin(s),l=Math.cos(s),c=Math.cos(u),d=Math.sin(u),f=-Math.sin(a),p=Math.cos(a),v=l*i,y=h*i,g=-h*o,m=l*o;return this.a=c*v+d*g,this.b=c*y+d*m,this.c=f*v+p*g,this.d=f*y+p*m,this.tx=t+(r*v+n*g),this.ty=e+(r*y+n*m),this},t.prototype.prepend=function(t){var e=this.tx;if(1!==t.a||0!==t.b||0!==t.c||1!==t.d){var r=this.a,n=this.c;this.a=r*t.a+this.b*t.c,this.b=r*t.b+this.b*t.d,this.c=n*t.a+this.d*t.c,this.d=n*t.b+this.d*t.d}return this.tx=e*t.a+this.ty*t.c+t.tx,this.ty=e*t.b+this.ty*t.d+t.ty,this},t.prototype.decompose=function(t){var e=this.a,r=this.b,n=this.c,i=this.d,o=-Math.atan2(-n,i),s=Math.atan2(r,e),a=Math.abs(o+s);return a<1e-5?(t.rotation=s,e<0&&i>=0&&(t.rotation+=t.rotation<=0?Math.PI:-Math.PI),t.skew.x=t.skew.y=0):(t.skew.x=o,t.skew.y=s),t.scale.x=Math.sqrt(e*e+r*r),t.scale.y=Math.sqrt(n*n+i*i),t.position.x=this.tx,t.position.y=this.ty,t},t.prototype.invert=function(){var t=this.a,e=this.b,r=this.c,n=this.d,i=this.tx,o=t*n-e*r;return this.a=n/o,this.b=-e/o,this.c=-r/o,this.d=t/o,this.tx=(r*this.ty-n*i)/o,this.ty=-(t*this.ty-e*i)/o,this},t.prototype.identity=function(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this},t.prototype.clone=function(){var e=new t;return e.a=this.a,e.b=this.b,e.c=this.c,e.d=this.d,e.tx=this.tx,e.ty=this.ty,e},t.prototype.copy=function(t){return t.a=this.a,t.b=this.b,t.c=this.c,t.d=this.d,t.tx=this.tx,t.ty=this.ty,t},o(t,null,[{key:"IDENTITY",get:function(){return new t}},{key:"TEMP_MATRIX",get:function(){return new t}}]),t}();r.default=u},{"./Point":68}],67:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),o=function(){function t(e,r){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;n(this,t),this._x=i,this._y=o,this.cb=e,this.scope=r}return t.prototype.set=function(t,e){var r=t||0,n=e||(0!==e?r:0);this._x===r&&this._y===n||(this._x=r,this._y=n,this.cb.call(this.scope))},t.prototype.copy=function(t){this._x===t.x&&this._y===t.y||(this._x=t.x,this._y=t.y,this.cb.call(this.scope))},i(t,[{key:"x",get:function(){return this._x},set:function(t){this._x!==t&&(this._x=t,this.cb.call(this.scope))}},{key:"y",get:function(){return this._y},set:function(t){this._y!==t&&(this._y=t,this.cb.call(this.scope))}}]),t}();r.default=o},{}],68:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;n(this,t),this.x=e,this.y=r}return t.prototype.clone=function(){return new t(this.x,this.y)},t.prototype.copy=function(t){this.set(t.x,t.y)},t.prototype.equals=function(t){return t.x===this.x&&t.y===this.y},t.prototype.set=function(t,e){this.x=t||0,this.y=e||(0!==e?this.x:0)},t}();r.default=i},{}],69:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./Point");Object.defineProperty(r,"Point",{enumerable:!0,get:function(){return n(i).default}});var o=t("./ObservablePoint");Object.defineProperty(r,"ObservablePoint",{enumerable:!0,get:function(){return n(o).default}});var s=t("./Matrix");Object.defineProperty(r,"Matrix",{enumerable:!0,get:function(){return n(s).default}});var a=t("./GroupD8");Object.defineProperty(r,"GroupD8",{enumerable:!0,get:function(){return n(a).default}});var u=t("./shapes/Circle");Object.defineProperty(r,"Circle",{enumerable:!0,get:function(){return n(u).default}});var h=t("./shapes/Ellipse");Object.defineProperty(r,"Ellipse",{enumerable:!0,get:function(){return n(h).default}});var l=t("./shapes/Polygon");Object.defineProperty(r,"Polygon",{enumerable:!0,get:function(){return n(l).default}});var c=t("./shapes/Rectangle");Object.defineProperty(r,"Rectangle",{enumerable:!0,get:function(){return n(c).default}});var d=t("./shapes/RoundedRectangle");Object.defineProperty(r,"RoundedRectangle",{enumerable:!0,get:function(){return n(d).default}})},{"./GroupD8":65,"./Matrix":66,"./ObservablePoint":67,"./Point":68,"./shapes/Circle":70,"./shapes/Ellipse":71,"./shapes/Polygon":72,"./shapes/Rectangle":73,"./shapes/RoundedRectangle":74}],70:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("./Rectangle"),s=n(o),a=t("../../const"),u=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;i(this,t),this.x=e,this.y=r,this.radius=n,this.type=a.SHAPES.CIRC}return t.prototype.clone=function(){return new t(this.x,this.y,this.radius)},t.prototype.contains=function(t,e){if(this.radius<=0)return!1;var r=this.radius*this.radius,n=this.x-t,i=this.y-e;return n*=n,i*=i,n+i<=r},t.prototype.getBounds=function(){return new s.default(this.x-this.radius,this.y-this.radius,2*this.radius,2*this.radius)},t}();r.default=u},{"../../const":45,"./Rectangle":73}],71:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("./Rectangle"),s=n(o),a=t("../../const"),u=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;i(this,t),this.x=e,this.y=r,this.width=n,this.height=o,this.type=a.SHAPES.ELIP}return t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height)},t.prototype.contains=function(t,e){if(this.width<=0||this.height<=0)return!1;var r=(t-this.x)/this.width,n=(e-this.y)/this.height;return r*=r,n*=n,r+n<=1},t.prototype.getBounds=function(){return new s.default(this.x-this.width,this.y-this.height,this.width,this.height)},t}();r.default=u},{"../../const":45,"./Rectangle":73}],72:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("../Point"),s=n(o),a=t("../../const"),u=function(){function t(){for(var e=arguments.length,r=Array(e),n=0;n<e;n++)r[n]=arguments[n];if(i(this,t),Array.isArray(r[0])&&(r=r[0]),r[0]instanceof s.default){for(var o=[],u=0,h=r.length;u<h;u++)o.push(r[u].x,r[u].y);r=o}this.closed=!0,this.points=r,this.type=a.SHAPES.POLY}return t.prototype.clone=function(){return new t(this.points.slice())},t.prototype.close=function(){var t=this.points;t[0]===t[t.length-2]&&t[1]===t[t.length-1]||t.push(t[0],t[1])},t.prototype.contains=function(t,e){for(var r=!1,n=this.points.length/2,i=0,o=n-1;i<n;o=i++){var s=this.points[2*i],a=this.points[2*i+1],u=this.points[2*o],h=this.points[2*o+1],l=a>e!=h>e&&t<(u-s)*((e-a)/(h-a))+s;l&&(r=!r)}return r},t}();r.default=u},{"../../const":45,"../Point":68}],73:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),o=t("../../const"),s=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;n(this,t),this.x=e,this.y=r,this.width=i,this.height=s,this.type=o.SHAPES.RECT}return t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height)},t.prototype.copy=function(t){return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this},t.prototype.contains=function(t,e){return!(this.width<=0||this.height<=0)&&(t>=this.x&&t<this.x+this.width&&e>=this.y&&e<this.y+this.height)},t.prototype.pad=function(t,e){t=t||0,e=e||(0!==e?t:0),this.x-=t,this.y-=e,this.width+=2*t,this.height+=2*e},t.prototype.fit=function(t){this.x<t.x&&(this.width+=this.x,this.width<0&&(this.width=0),this.x=t.x),this.y<t.y&&(this.height+=this.y,this.height<0&&(this.height=0),this.y=t.y),this.x+this.width>t.x+t.width&&(this.width=t.width-this.x,this.width<0&&(this.width=0)),this.y+this.height>t.y+t.height&&(this.height=t.height-this.y,this.height<0&&(this.height=0))},t.prototype.enlarge=function(t){var e=Math.min(this.x,t.x),r=Math.max(this.x+this.width,t.x+t.width),n=Math.min(this.y,t.y),i=Math.max(this.y+this.height,t.y+t.height);this.x=e,this.width=r-e,this.y=n,this.height=i-n},i(t,[{key:"left",get:function(){return this.x}},{key:"right",get:function(){return this.x+this.width}},{key:"top",get:function(){return this.y}},{key:"bottom",get:function(){return this.y+this.height}}],[{key:"EMPTY",get:function(){return new t(0,0,0,0)}}]),t}();r.default=s},{"../../const":45}],74:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=t("../../const"),o=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:20;n(this,t),this.x=e,this.y=r,this.width=o,this.height=s,this.radius=a,this.type=i.SHAPES.RREC}return t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height,this.radius)},t.prototype.contains=function(t,e){if(this.width<=0||this.height<=0)return!1;if(t>=this.x&&t<=this.x+this.width&&e>=this.y&&e<=this.y+this.height){if(e>=this.y+this.radius&&e<=this.y+this.height-this.radius||t>=this.x+this.radius&&t<=this.x+this.width-this.radius)return!0;var r=t-(this.x+this.radius),n=e-(this.y+this.radius),i=this.radius*this.radius;if(r*r+n*n<=i)return!0;if(r=t-(this.x+this.width-this.radius),r*r+n*n<=i)return!0;if(n=e-(this.y+this.height-this.radius),r*r+n*n<=i)return!0;if(r=t-(this.x+this.radius),r*r+n*n<=i)return!0}return!1},t}();r.default=o},{"../../const":45}],75:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../utils"),h=t("../math"),l=t("../const"),c=t("../settings"),d=n(c),f=t("../display/Container"),p=n(f),v=t("../textures/RenderTexture"),y=n(v),g=t("eventemitter3"),m=n(g),_=new h.Matrix,b=function(t){function e(r,n,s,a){i(this,e);var c=o(this,t.call(this));return(0,u.sayHello)(r),"number"==typeof n&&(n=Object.assign({width:n,height:s||d.default.RENDER_OPTIONS.height},a)),n=Object.assign({},d.default.RENDER_OPTIONS,n),c.options=n,c.type=l.RENDERER_TYPE.UNKNOWN,c.screen=new h.Rectangle(0,0,n.width,n.height),c.view=n.view||document.createElement("canvas"),c.resolution=n.resolution||d.default.RESOLUTION,c.transparent=n.transparent,c.autoResize=n.autoResize||!1,c.blendModes=null,c.preserveDrawingBuffer=n.preserveDrawingBuffer,c.clearBeforeRender=n.clearBeforeRender,c.roundPixels=n.roundPixels,c._backgroundColor=0,c._backgroundColorRgba=[0,0,0,0],c._backgroundColorString="#000000",c.backgroundColor=n.backgroundColor||c._backgroundColor,c._tempDisplayObjectParent=new p.default,c._lastObjectRendered=c._tempDisplayObjectParent,c}return s(e,t),e.prototype.resize=function(t,e){this.screen.width=t,this.screen.height=e,this.view.width=t*this.resolution,this.view.height=e*this.resolution,this.autoResize&&(this.view.style.width=t+"px",this.view.style.height=e+"px")},e.prototype.generateTexture=function(t,e,r){var n=t.getLocalBounds(),i=y.default.create(0|n.width,0|n.height,e,r);return _.tx=-n.x,_.ty=-n.y,this.render(t,i,!1,_,!0),i},e.prototype.destroy=function(t){t&&this.view.parentNode&&this.view.parentNode.removeChild(this.view),this.type=l.RENDERER_TYPE.UNKNOWN,this.view=null,this.screen=null,this.resolution=0,this.transparent=!1,this.autoResize=!1,this.blendModes=null,this.options=null,this.preserveDrawingBuffer=!1,this.clearBeforeRender=!1,this.roundPixels=!1,this._backgroundColor=0,this._backgroundColorRgba=null,this._backgroundColorString=null,this._tempDisplayObjectParent=null,this._lastObjectRendered=null},a(e,[{key:"width",get:function(){return this.view.width}},{key:"height",get:function(){return this.view.height}},{key:"backgroundColor",get:function(){return this._backgroundColor},set:function(t){this._backgroundColor=t,this._backgroundColorString=(0,u.hex2string)(t),(0,u.hex2rgb)(t,this._backgroundColorRgba)}}]),e}(m.default);r.default=b},{"../const":45,"../display/Container":47,"../math":69,"../settings":100,"../textures/RenderTexture":112,"../utils":123,eventemitter3:3}],76:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../SystemRenderer"),u=n(a),h=t("./utils/CanvasMaskManager"),l=n(h),c=t("./utils/CanvasRenderTarget"),d=n(c),f=t("./utils/mapCanvasBlendModesToPixi"),p=n(f),v=t("../../utils"),y=t("../../const"),g=t("../../settings"),m=n(g),_=function(t){function e(r,n,s){i(this,e);var a=o(this,t.call(this,"Canvas",r,n,s));return a.type=y.RENDERER_TYPE.CANVAS,a.rootContext=a.view.getContext("2d",{alpha:a.transparent}),a.context=a.rootContext,a.refresh=!0,a.maskManager=new l.default(a),a.smoothProperty="imageSmoothingEnabled",a.rootContext.imageSmoothingEnabled||(a.rootContext.webkitImageSmoothingEnabled?a.smoothProperty="webkitImageSmoothingEnabled":a.rootContext.mozImageSmoothingEnabled?a.smoothProperty="mozImageSmoothingEnabled":a.rootContext.oImageSmoothingEnabled?a.smoothProperty="oImageSmoothingEnabled":a.rootContext.msImageSmoothingEnabled&&(a.smoothProperty="msImageSmoothingEnabled")),a.initPlugins(),a.blendModes=(0,p.default)(),a._activeBlendMode=null,a.renderingToScreen=!1,a.resize(a.options.width,a.options.height),a}return s(e,t),e.prototype.render=function(t,e,r,n,i){if(this.view){this.renderingToScreen=!e,this.emit("prerender");var o=this.resolution;e?(e=e.baseTexture||e,e._canvasRenderTarget||(e._canvasRenderTarget=new d.default(e.width,e.height,e.resolution),e.source=e._canvasRenderTarget.canvas,e.valid=!0),this.context=e._canvasRenderTarget.context,this.resolution=e._canvasRenderTarget.resolution):this.context=this.rootContext;var s=this.context;if(e||(this._lastObjectRendered=t),!i){var a=t.parent,u=this._tempDisplayObjectParent.transform.worldTransform;n?(n.copy(u),this._tempDisplayObjectParent.transform._worldID=-1):u.identity(),t.parent=this._tempDisplayObjectParent,t.updateTransform(),t.parent=a}s.setTransform(1,0,0,1,0,0),s.globalAlpha=1,s.globalCompositeOperation=this.blendModes[y.BLEND_MODES.NORMAL],navigator.isCocoonJS&&this.view.screencanvas&&(s.fillStyle="black",s.clear()),(void 0!==r?r:this.clearBeforeRender)&&this.renderingToScreen&&(this.transparent?s.clearRect(0,0,this.width,this.height):(s.fillStyle=this._backgroundColorString,s.fillRect(0,0,this.width,this.height)));var h=this.context;this.context=s,t.renderCanvas(this),this.context=h,this.resolution=o,this.emit("postrender")}},e.prototype.clear=function(t){var e=this.context;t=t||this._backgroundColorString,!this.transparent&&t?(e.fillStyle=t,e.fillRect(0,0,this.width,this.height)):e.clearRect(0,0,this.width,this.height)},e.prototype.setBlendMode=function(t){this._activeBlendMode!==t&&(this._activeBlendMode=t,this.context.globalCompositeOperation=this.blendModes[t])},e.prototype.destroy=function(e){this.destroyPlugins(),t.prototype.destroy.call(this,e),this.context=null,this.refresh=!0,this.maskManager.destroy(),this.maskManager=null,this.smoothProperty=null},e.prototype.resize=function(e,r){t.prototype.resize.call(this,e,r),this.smoothProperty&&(this.rootContext[this.smoothProperty]=m.default.SCALE_MODE===y.SCALE_MODES.LINEAR)},e}(u.default);r.default=_,v.pluginTarget.mixin(_)},{"../../const":45,"../../settings":100,"../../utils":123,"../SystemRenderer":75,"./utils/CanvasMaskManager":77,"./utils/CanvasRenderTarget":78,"./utils/mapCanvasBlendModesToPixi":80}],77:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=t("../../../const"),o=function(){function t(e){n(this,t),this.renderer=e}return t.prototype.pushMask=function(t){var e=this.renderer;e.context.save();var r=t.alpha,n=t.transform.worldTransform,i=e.resolution;e.context.setTransform(n.a*i,n.b*i,n.c*i,n.d*i,n.tx*i,n.ty*i),t._texture||(this.renderGraphicsShape(t),e.context.clip()),t.worldAlpha=r},t.prototype.renderGraphicsShape=function(t){var e=this.renderer.context,r=t.graphicsData.length;if(0!==r){e.beginPath();for(var n=0;n<r;n++){var o=t.graphicsData[n],s=o.shape;if(o.type===i.SHAPES.POLY){var a=s.points;e.moveTo(a[0],a[1]);for(var u=1;u<a.length/2;u++)e.lineTo(a[2*u],a[2*u+1]);a[0]===a[a.length-2]&&a[1]===a[a.length-1]&&e.closePath()}else if(o.type===i.SHAPES.RECT)e.rect(s.x,s.y,s.width,s.height),e.closePath();else if(o.type===i.SHAPES.CIRC)e.arc(s.x,s.y,s.radius,0,2*Math.PI),e.closePath();else if(o.type===i.SHAPES.ELIP){var h=2*s.width,l=2*s.height,c=s.x-h/2,d=s.y-l/2,f=.5522848,p=h/2*f,v=l/2*f,y=c+h,g=d+l,m=c+h/2,_=d+l/2;e.moveTo(c,_),e.bezierCurveTo(c,_-v,m-p,d,m,d),e.bezierCurveTo(m+p,d,y,_-v,y,_),e.bezierCurveTo(y,_+v,m+p,g,m,g),e.bezierCurveTo(m-p,g,c,_+v,c,_),e.closePath()}else if(o.type===i.SHAPES.RREC){var b=s.x,x=s.y,T=s.width,w=s.height,E=s.radius,S=Math.min(T,w)/2|0;E=E>S?S:E,e.moveTo(b,x+E),e.lineTo(b,x+w-E),e.quadraticCurveTo(b,x+w,b+E,x+w),e.lineTo(b+T-E,x+w),e.quadraticCurveTo(b+T,x+w,b+T,x+w-E),e.lineTo(b+T,x+E),e.quadraticCurveTo(b+T,x,b+T-E,x),e.lineTo(b+E,x),e.quadraticCurveTo(b,x,b,x+E),e.closePath()}}}},t.prototype.popMask=function(t){t.context.restore()},t.prototype.destroy=function(){},t}();r.default=o},{"../../../const":45}],78:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=t("../../../settings"),a=n(s),u=function(){function t(e,r,n){i(this,t),this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.resolution=n||a.default.RESOLUTION,this.resize(e,r)}return t.prototype.clear=function(){this.context.setTransform(1,0,0,1,0,0),this.context.clearRect(0,0,this.canvas.width,this.canvas.height)},t.prototype.resize=function(t,e){this.canvas.width=t*this.resolution,this.canvas.height=e*this.resolution},t.prototype.destroy=function(){this.context=null,this.canvas=null},o(t,[{key:"width",get:function(){return this.canvas.width},set:function(t){this.canvas.width=t}},{key:"height",get:function(){return this.canvas.height},set:function(t){this.canvas.height=t}}]),t}();r.default=u},{"../../../settings":100}],79:[function(t,e,r){"use strict";function n(t){var e=document.createElement("canvas");e.width=6,e.height=1;var r=e.getContext("2d");return r.fillStyle=t,r.fillRect(0,0,6,1),e}function i(){if("undefined"==typeof document)return!1;var t=n("#ff00ff"),e=n("#ffff00"),r=document.createElement("canvas");r.width=6,r.height=1;var i=r.getContext("2d");i.globalCompositeOperation="multiply",i.drawImage(t,0,0),i.drawImage(e,2,0);var o=i.getImageData(2,0,1,1);if(!o)return!1;var s=o.data;return 255===s[0]&&0===s[1]&&0===s[2]}r.__esModule=!0,r.default=i},{}],80:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(0,a.default)()?(t[o.BLEND_MODES.NORMAL]="source-over",t[o.BLEND_MODES.ADD]="lighter",t[o.BLEND_MODES.MULTIPLY]="multiply",t[o.BLEND_MODES.SCREEN]="screen",t[o.BLEND_MODES.OVERLAY]="overlay",t[o.BLEND_MODES.DARKEN]="darken",t[o.BLEND_MODES.LIGHTEN]="lighten",t[o.BLEND_MODES.COLOR_DODGE]="color-dodge",t[o.BLEND_MODES.COLOR_BURN]="color-burn",t[o.BLEND_MODES.HARD_LIGHT]="hard-light",t[o.BLEND_MODES.SOFT_LIGHT]="soft-light",t[o.BLEND_MODES.DIFFERENCE]="difference",t[o.BLEND_MODES.EXCLUSION]="exclusion",t[o.BLEND_MODES.HUE]="hue",t[o.BLEND_MODES.SATURATION]="saturate",t[o.BLEND_MODES.COLOR]="color",t[o.BLEND_MODES.LUMINOSITY]="luminosity"):(t[o.BLEND_MODES.NORMAL]="source-over",t[o.BLEND_MODES.ADD]="lighter",t[o.BLEND_MODES.MULTIPLY]="source-over",t[o.BLEND_MODES.SCREEN]="source-over",t[o.BLEND_MODES.OVERLAY]="source-over",t[o.BLEND_MODES.DARKEN]="source-over",t[o.BLEND_MODES.LIGHTEN]="source-over",t[o.BLEND_MODES.COLOR_DODGE]="source-over",t[o.BLEND_MODES.COLOR_BURN]="source-over",t[o.BLEND_MODES.HARD_LIGHT]="source-over",t[o.BLEND_MODES.SOFT_LIGHT]="source-over",
    t[o.BLEND_MODES.DIFFERENCE]="source-over",t[o.BLEND_MODES.EXCLUSION]="source-over",t[o.BLEND_MODES.HUE]="source-over",t[o.BLEND_MODES.SATURATION]="source-over",t[o.BLEND_MODES.COLOR]="source-over",t[o.BLEND_MODES.LUMINOSITY]="source-over"),t[o.BLEND_MODES.NORMAL_NPM]=t[o.BLEND_MODES.NORMAL],t[o.BLEND_MODES.ADD_NPM]=t[o.BLEND_MODES.ADD],t[o.BLEND_MODES.SCREEN_NPM]=t[o.BLEND_MODES.SCREEN],t}r.__esModule=!0,r.default=i;var o=t("../../../const"),s=t("./canUseNewCanvasBlendModes"),a=n(s)},{"../../../const":45,"./canUseNewCanvasBlendModes":79}],81:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("../../const"),s=t("../../settings"),a=n(s),u=function(){function t(e){i(this,t),this.renderer=e,this.count=0,this.checkCount=0,this.maxIdle=a.default.GC_MAX_IDLE,this.checkCountMax=a.default.GC_MAX_CHECK_COUNT,this.mode=a.default.GC_MODE}return t.prototype.update=function(){this.count++,this.mode!==o.GC_MODES.MANUAL&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run()))},t.prototype.run=function(){for(var t=this.renderer.textureManager,e=t._managedTextures,r=!1,n=0;n<e.length;n++){var i=e[n];!i._glRenderTargets&&this.count-i.touched>this.maxIdle&&(t.destroyTexture(i,!0),e[n]=null,r=!0)}if(r){for(var o=0,s=0;s<e.length;s++)null!==e[s]&&(e[o++]=e[s]);e.length=o}},t.prototype.unload=function(t){var e=this.renderer.textureManager;t._texture&&t._texture._glRenderTargets&&e.destroyTexture(t._texture,!0);for(var r=t.children.length-1;r>=0;r--)this.unload(t.children[r])},t}();r.default=u},{"../../const":45,"../../settings":100}],82:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("pixi-gl-core"),s=t("../../const"),a=t("./utils/RenderTarget"),u=n(a),h=t("../../utils"),l=function(){function t(e){i(this,t),this.renderer=e,this.gl=e.gl,this._managedTextures=[]}return t.prototype.bindTexture=function(){},t.prototype.getTexture=function(){},t.prototype.updateTexture=function(t,e){var r=this.gl,n=!!t._glRenderTargets;if(!t.hasLoaded)return null;var i=this.renderer.boundTextures;if(void 0===e){e=0;for(var a=0;a<i.length;++a)if(i[a]===t){e=a;break}}i[e]=t,r.activeTexture(r.TEXTURE0+e);var h=t._glTextures[this.renderer.CONTEXT_UID];if(h)n?t._glRenderTargets[this.renderer.CONTEXT_UID].resize(t.width,t.height):h.upload(t.source);else{if(n){var l=new u.default(this.gl,t.width,t.height,t.scaleMode,t.resolution);l.resize(t.width,t.height),t._glRenderTargets[this.renderer.CONTEXT_UID]=l,h=l.texture}else h=new o.GLTexture(this.gl,null,null,null,null),h.bind(e),h.premultiplyAlpha=!0,h.upload(t.source);t._glTextures[this.renderer.CONTEXT_UID]=h,t.on("update",this.updateTexture,this),t.on("dispose",this.destroyTexture,this),this._managedTextures.push(t),t.isPowerOfTwo?(t.mipmap&&h.enableMipmap(),t.wrapMode===s.WRAP_MODES.CLAMP?h.enableWrapClamp():t.wrapMode===s.WRAP_MODES.REPEAT?h.enableWrapRepeat():h.enableWrapMirrorRepeat()):h.enableWrapClamp(),t.scaleMode===s.SCALE_MODES.NEAREST?h.enableNearestScaling():h.enableLinearScaling()}return h},t.prototype.destroyTexture=function(t,e){if(t=t.baseTexture||t,t.hasLoaded&&t._glTextures[this.renderer.CONTEXT_UID]&&(this.renderer.unbindTexture(t),t._glTextures[this.renderer.CONTEXT_UID].destroy(),t.off("update",this.updateTexture,this),t.off("dispose",this.destroyTexture,this),delete t._glTextures[this.renderer.CONTEXT_UID],!e)){var r=this._managedTextures.indexOf(t);r!==-1&&(0,h.removeItems)(this._managedTextures,r,1)}},t.prototype.removeAll=function(){for(var t=0;t<this._managedTextures.length;++t){var e=this._managedTextures[t];e._glTextures[this.renderer.CONTEXT_UID]&&delete e._glTextures[this.renderer.CONTEXT_UID]}},t.prototype.destroy=function(){for(var t=0;t<this._managedTextures.length;++t){var e=this._managedTextures[t];this.destroyTexture(e,!0),e.off("update",this.updateTexture,this),e.off("dispose",this.destroyTexture,this)}this._managedTextures=null},t}();r.default=l},{"../../const":45,"../../utils":123,"./utils/RenderTarget":95,"pixi-gl-core":12}],83:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../SystemRenderer"),u=n(a),h=t("./managers/MaskManager"),l=n(h),c=t("./managers/StencilManager"),d=n(c),f=t("./managers/FilterManager"),p=n(f),v=t("./utils/RenderTarget"),y=n(v),g=t("./utils/ObjectRenderer"),m=n(g),_=t("./TextureManager"),b=n(_),x=t("../../textures/BaseTexture"),T=n(x),w=t("./TextureGarbageCollector"),E=n(w),S=t("./WebGLState"),O=n(S),P=t("./utils/mapWebGLDrawModesToPixi"),M=n(P),C=t("./utils/validateContext"),R=n(C),A=t("../../utils"),I=t("pixi-gl-core"),D=n(I),L=t("../../const"),N=0,F=function(t){function e(r,n,s){i(this,e);var a=o(this,t.call(this,"WebGL",r,n,s));return a.legacy=a.options.legacy,a.legacy&&(D.default.VertexArrayObject.FORCE_NATIVE=!0),a.type=L.RENDERER_TYPE.WEBGL,a.handleContextLost=a.handleContextLost.bind(a),a.handleContextRestored=a.handleContextRestored.bind(a),a.view.addEventListener("webglcontextlost",a.handleContextLost,!1),a.view.addEventListener("webglcontextrestored",a.handleContextRestored,!1),a._contextOptions={alpha:a.transparent,antialias:a.options.antialias,premultipliedAlpha:a.transparent&&"notMultiplied"!==a.transparent,stencil:!0,preserveDrawingBuffer:a.options.preserveDrawingBuffer},a._backgroundColorRgba[3]=a.transparent?0:1,a.maskManager=new l.default(a),a.stencilManager=new d.default(a),a.emptyRenderer=new m.default(a),a.currentRenderer=a.emptyRenderer,a.initPlugins(),a.options.context&&(0,R.default)(a.options.context),a.gl=a.options.context||D.default.createContext(a.view,a._contextOptions),a.CONTEXT_UID=N++,a.state=new O.default(a.gl),a.renderingToScreen=!0,a.boundTextures=null,a._activeShader=null,a._activeVao=null,a._activeRenderTarget=null,a._initContext(),a.filterManager=new p.default(a),a.drawModes=(0,M.default)(a.gl),a._nextTextureLocation=0,a.setBlendMode(0),a}return s(e,t),e.prototype._initContext=function(){var t=this.gl;t.isContextLost()&&t.getExtension("WEBGL_lose_context")&&t.getExtension("WEBGL_lose_context").restoreContext();var e=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);this._activeShader=null,this._activeVao=null,this.boundTextures=new Array(e),this.emptyTextures=new Array(e),this.textureManager=new b.default(this),this.textureGC=new E.default(this),this.state.resetToDefault(),this.rootRenderTarget=new y.default(t,this.width,this.height,null,this.resolution,(!0)),this.rootRenderTarget.clearColor=this._backgroundColorRgba,this.bindRenderTarget(this.rootRenderTarget);var r=new D.default.GLTexture.fromData(t,null,1,1),n={_glTextures:{}};n._glTextures[this.CONTEXT_UID]={};for(var i=0;i<e;i++){var o=new T.default;o._glTextures[this.CONTEXT_UID]=r,this.boundTextures[i]=n,this.emptyTextures[i]=o,this.bindTexture(null,i)}this.emit("context",t),this.resize(this.screen.width,this.screen.height)},e.prototype.render=function(t,e,r,n,i){if(this.renderingToScreen=!e,this.emit("prerender"),this.gl&&!this.gl.isContextLost()){if(this._nextTextureLocation=0,e||(this._lastObjectRendered=t),!i){var o=t.parent;t.parent=this._tempDisplayObjectParent,t.updateTransform(),t.parent=o}this.bindRenderTexture(e,n),this.currentRenderer.start(),(void 0!==r?r:this.clearBeforeRender)&&this._activeRenderTarget.clear(),t.renderWebGL(this),this.currentRenderer.flush(),this.textureGC.update(),this.emit("postrender")}},e.prototype.setObjectRenderer=function(t){this.currentRenderer!==t&&(this.currentRenderer.stop(),this.currentRenderer=t,this.currentRenderer.start())},e.prototype.flush=function(){this.setObjectRenderer(this.emptyRenderer)},e.prototype.resize=function(t,e){u.default.prototype.resize.call(this,t,e),this.rootRenderTarget.resize(t,e),this._activeRenderTarget===this.rootRenderTarget&&(this.rootRenderTarget.activate(),this._activeShader&&(this._activeShader.uniforms.projectionMatrix=this.rootRenderTarget.projectionMatrix.toArray(!0)))},e.prototype.setBlendMode=function(t){this.state.setBlendMode(t)},e.prototype.clear=function(t){this._activeRenderTarget.clear(t)},e.prototype.setTransform=function(t){this._activeRenderTarget.transform=t},e.prototype.clearRenderTexture=function(t,e){var r=t.baseTexture,n=r._glRenderTargets[this.CONTEXT_UID];return n&&n.clear(e),this},e.prototype.bindRenderTexture=function(t,e){var r=void 0;if(t){var n=t.baseTexture;n._glRenderTargets[this.CONTEXT_UID]||this.textureManager.updateTexture(n,0),this.unbindTexture(n),r=n._glRenderTargets[this.CONTEXT_UID],r.setFrame(t.frame)}else r=this.rootRenderTarget;return r.transform=e,this.bindRenderTarget(r),this},e.prototype.bindRenderTarget=function(t){return t!==this._activeRenderTarget&&(this._activeRenderTarget=t,t.activate(),this._activeShader&&(this._activeShader.uniforms.projectionMatrix=t.projectionMatrix.toArray(!0)),this.stencilManager.setMaskStack(t.stencilMaskStack)),this},e.prototype.bindShader=function(t,e){return this._activeShader!==t&&(this._activeShader=t,t.bind(),e!==!1&&(t.uniforms.projectionMatrix=this._activeRenderTarget.projectionMatrix.toArray(!0))),this},e.prototype.bindTexture=function(t,e,r){if(t=t||this.emptyTextures[e],t=t.baseTexture||t,t.touched=this.textureGC.count,r)e=e||0;else{for(var n=0;n<this.boundTextures.length;n++)if(this.boundTextures[n]===t)return n;void 0===e&&(this._nextTextureLocation++,this._nextTextureLocation%=this.boundTextures.length,e=this.boundTextures.length-this._nextTextureLocation-1)}var i=this.gl,o=t._glTextures[this.CONTEXT_UID];return o?(this.boundTextures[e]=t,i.activeTexture(i.TEXTURE0+e),i.bindTexture(i.TEXTURE_2D,o.texture)):this.textureManager.updateTexture(t,e),e},e.prototype.unbindTexture=function(t){var e=this.gl;t=t.baseTexture||t;for(var r=0;r<this.boundTextures.length;r++)this.boundTextures[r]===t&&(this.boundTextures[r]=this.emptyTextures[r],e.activeTexture(e.TEXTURE0+r),e.bindTexture(e.TEXTURE_2D,this.emptyTextures[r]._glTextures[this.CONTEXT_UID].texture));return this},e.prototype.createVao=function(){return new D.default.VertexArrayObject(this.gl,this.state.attribState)},e.prototype.bindVao=function(t){return this._activeVao===t?this:(t?t.bind():this._activeVao&&this._activeVao.unbind(),this._activeVao=t,this)},e.prototype.reset=function(){return this.setObjectRenderer(this.emptyRenderer),this._activeShader=null,this._activeRenderTarget=this.rootRenderTarget,this.rootRenderTarget.activate(),this.state.resetToDefault(),this},e.prototype.handleContextLost=function(t){t.preventDefault()},e.prototype.handleContextRestored=function(){this.textureManager.removeAll(),this._initContext()},e.prototype.destroy=function(e){this.destroyPlugins(),this.view.removeEventListener("webglcontextlost",this.handleContextLost),this.view.removeEventListener("webglcontextrestored",this.handleContextRestored),this.textureManager.destroy(),t.prototype.destroy.call(this,e),this.uid=0,this.maskManager.destroy(),this.stencilManager.destroy(),this.filterManager.destroy(),this.maskManager=null,this.filterManager=null,this.textureManager=null,this.currentRenderer=null,this.handleContextLost=null,this.handleContextRestored=null,this._contextOptions=null,this.gl.useProgram(null),this.gl.getExtension("WEBGL_lose_context")&&this.gl.getExtension("WEBGL_lose_context").loseContext(),this.gl=null},e}(u.default);r.default=F,A.pluginTarget.mixin(F)},{"../../const":45,"../../textures/BaseTexture":111,"../../utils":123,"../SystemRenderer":75,"./TextureGarbageCollector":81,"./TextureManager":82,"./WebGLState":84,"./managers/FilterManager":89,"./managers/MaskManager":90,"./managers/StencilManager":91,"./utils/ObjectRenderer":93,"./utils/RenderTarget":95,"./utils/mapWebGLDrawModesToPixi":98,"./utils/validateContext":99,"pixi-gl-core":12}],84:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("./utils/mapWebGLBlendModesToPixi"),s=n(o),a=0,u=1,h=2,l=3,c=4,d=function(){function t(e){i(this,t),this.activeState=new Uint8Array(16),this.defaultState=new Uint8Array(16),this.defaultState[0]=1,this.stackIndex=0,this.stack=[],this.gl=e,this.maxAttribs=e.getParameter(e.MAX_VERTEX_ATTRIBS),this.attribState={tempAttribState:new Array(this.maxAttribs),attribState:new Array(this.maxAttribs)},this.blendModes=(0,s.default)(e),this.nativeVaoExtension=e.getExtension("OES_vertex_array_object")||e.getExtension("MOZ_OES_vertex_array_object")||e.getExtension("WEBKIT_OES_vertex_array_object")}return t.prototype.push=function(){var t=this.stack[this.stackIndex];t||(t=this.stack[this.stackIndex]=new Uint8Array(16)),++this.stackIndex;for(var e=0;e<this.activeState.length;e++)t[e]=this.activeState[e]},t.prototype.pop=function(){var t=this.stack[--this.stackIndex];this.setState(t)},t.prototype.setState=function(t){this.setBlend(t[a]),this.setDepthTest(t[u]),this.setFrontFace(t[h]),this.setCullFace(t[l]),this.setBlendMode(t[c])},t.prototype.setBlend=function(t){t=t?1:0,this.activeState[a]!==t&&(this.activeState[a]=t,this.gl[t?"enable":"disable"](this.gl.BLEND))},t.prototype.setBlendMode=function(t){if(t!==this.activeState[c]){this.activeState[c]=t;var e=this.blendModes[t];2===e.length?this.gl.blendFunc(e[0],e[1]):this.gl.blendFuncSeparate(e[0],e[1],e[2],e[3])}},t.prototype.setDepthTest=function(t){t=t?1:0,this.activeState[u]!==t&&(this.activeState[u]=t,this.gl[t?"enable":"disable"](this.gl.DEPTH_TEST))},t.prototype.setCullFace=function(t){t=t?1:0,this.activeState[l]!==t&&(this.activeState[l]=t,this.gl[t?"enable":"disable"](this.gl.CULL_FACE))},t.prototype.setFrontFace=function(t){t=t?1:0,this.activeState[h]!==t&&(this.activeState[h]=t,this.gl.frontFace(this.gl[t?"CW":"CCW"]))},t.prototype.resetAttributes=function(){for(var t=0;t<this.attribState.tempAttribState.length;t++)this.attribState.tempAttribState[t]=0;for(var e=0;e<this.attribState.attribState.length;e++)this.attribState.attribState[e]=0;for(var r=1;r<this.maxAttribs;r++)this.gl.disableVertexAttribArray(r)},t.prototype.resetToDefault=function(){this.nativeVaoExtension&&this.nativeVaoExtension.bindVertexArrayOES(null),this.resetAttributes();for(var t=0;t<this.activeState.length;++t)this.activeState[t]=32;this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.setState(this.defaultState)},t}();r.default=d},{"./utils/mapWebGLBlendModesToPixi":97}],85:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=t("./extractUniformsFromSrc"),a=n(s),u=t("../../../utils"),h=t("../../../const"),l=t("../../../settings"),c=n(l),d={},f=function(){function t(e,r,n){i(this,t),this.vertexSrc=e||t.defaultVertexSrc,this.fragmentSrc=r||t.defaultFragmentSrc,this.blendMode=h.BLEND_MODES.NORMAL,this.uniformData=n||(0,a.default)(this.vertexSrc,this.fragmentSrc,"projectionMatrix|uSampler"),this.uniforms={};for(var o in this.uniformData)this.uniforms[o]=this.uniformData[o].value;this.glShaders={},d[this.vertexSrc+this.fragmentSrc]||(d[this.vertexSrc+this.fragmentSrc]=(0,u.uid)()),this.glShaderKey=d[this.vertexSrc+this.fragmentSrc],this.padding=4,this.resolution=c.default.RESOLUTION,this.enabled=!0,this.autoFit=!0}return t.prototype.apply=function(t,e,r,n,i){t.applyFilter(this,e,r,n)},o(t,null,[{key:"defaultVertexSrc",get:function(){return["attribute vec2 aVertexPosition;","attribute vec2 aTextureCoord;","uniform mat3 projectionMatrix;","uniform mat3 filterMatrix;","varying vec2 vTextureCoord;","varying vec2 vFilterCoord;","void main(void){","   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);","   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;","   vTextureCoord = aTextureCoord ;","}"].join("\n")}},{key:"defaultFragmentSrc",get:function(){return["varying vec2 vTextureCoord;","varying vec2 vFilterCoord;","uniform sampler2D uSampler;","uniform sampler2D filterSampler;","void main(void){","   vec4 masky = texture2D(filterSampler, vFilterCoord);","   vec4 sample = texture2D(uSampler, vTextureCoord);","   vec4 color;","   if(mod(vFilterCoord.x, 1.0) > 0.5)","   {","     color = vec4(1.0, 0.0, 0.0, 1.0);","   }","   else","   {","     color = vec4(0.0, 1.0, 0.0, 1.0);","   }","   gl_FragColor = mix(sample, masky, 0.5);","   gl_FragColor *= sample.a;","}"].join("\n")}}]),t}();r.default=f},{"../../../const":45,"../../../settings":100,"../../../utils":123,"./extractUniformsFromSrc":86}],86:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e,r){var n=o(t,r),i=o(e,r);return Object.assign(n,i)}function o(t){for(var e=new RegExp("^(projectionMatrix|uSampler|filterArea|filterClamp)$"),r={},n=void 0,i=t.replace(/\s+/g," ").split(/\s*;\s*/),o=0;o<i.length;o++){var s=i[o].trim();if(s.indexOf("uniform")>-1){var a=s.split(" "),h=a[1],l=a[2],c=1;l.indexOf("[")>-1&&(n=l.split(/\[|]/),l=n[0],c*=Number(n[1])),l.match(e)||(r[l]={value:u(h,c),name:l,type:h})}}return r}r.__esModule=!0,r.default=i;var s=t("pixi-gl-core"),a=n(s),u=a.default.shader.defaultValue},{"pixi-gl-core":12}],87:[function(t,e,r){"use strict";function n(t,e,r){var n=t.identity();return n.translate(e.x/r.width,e.y/r.height),n.scale(r.width,r.height),n}function i(t,e,r){var n=t.identity();n.translate(e.x/r.width,e.y/r.height);var i=r.width/e.width,o=r.height/e.height;return n.scale(i,o),n}function o(t,e,r,n){var i=n.worldTransform.copy(s.Matrix.TEMP_MATRIX),o=n._texture.baseTexture,a=t.identity(),u=r.height/r.width;a.translate(e.x/r.width,e.y/r.height),a.scale(1,u);var h=r.width/o.width,l=r.height/o.height;return i.tx/=o.width*h,i.ty/=o.width*h,i.invert(),a.prepend(i),a.scale(1,1/u),a.scale(h,l),a.translate(n.anchor.x,n.anchor.y),a}r.__esModule=!0,r.calculateScreenSpaceMatrix=n,r.calculateNormalizedScreenSpaceMatrix=i,r.calculateSpriteMatrix=o;var s=t("../../../math")},{"../../../math":69}],88:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../Filter"),u=n(a),h=t("../../../../math"),l=(t("path"),function(t){function e(r){i(this,e);var n=new h.Matrix,s=o(this,t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n","varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n\n    original *= (masky.r * masky.a * alpha * clip);\n\n    gl_FragColor = original;\n}\n"));return r.renderable=!1,s.maskSprite=r,s.maskMatrix=n,s}return s(e,t),e.prototype.apply=function(t,e,r){var n=this.maskSprite;this.uniforms.mask=n._texture,this.uniforms.otherMatrix=t.calculateSpriteMatrix(this.maskMatrix,n),this.uniforms.alpha=n.worldAlpha,t.applyFilter(this,e,r)},e}(u.default));r.default=l},{"../../../../math":69,"../Filter":85,path:22}],89:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var u=t("./WebGLManager"),h=i(u),l=t("../utils/RenderTarget"),c=i(l),d=t("../utils/Quad"),f=i(d),p=t("../../../math"),v=t("../../../Shader"),y=i(v),g=t("../filters/filterTransforms"),m=n(g),_=t("bit-twiddle"),b=i(_),x=function t(){a(this,t),this.renderTarget=null,this.sourceFrame=new p.Rectangle,this.destinationFrame=new p.Rectangle,this.filters=[],this.target=null,this.resolution=1},T=function(t){function e(r){a(this,e);var n=o(this,t.call(this,r));return n.gl=n.renderer.gl,n.quad=new f.default(n.gl,r.state.attribState),n.shaderCache={},n.pool={},n.filterData=null,n}return s(e,t),e.prototype.pushFilter=function(t,e){var r=this.renderer,n=this.filterData;if(!n){n=this.renderer._activeRenderTarget.filterStack;var i=new x;i.sourceFrame=i.destinationFrame=this.renderer._activeRenderTarget.size,i.renderTarget=r._activeRenderTarget,this.renderer._activeRenderTarget.filterData=n={index:0,stack:[i]},this.filterData=n}var o=n.stack[++n.index];o||(o=n.stack[n.index]=new x);var s=e[0].resolution,a=0|e[0].padding,u=t.filterArea||t.getBounds(!0),h=o.sourceFrame,l=o.destinationFrame;h.x=(u.x*s|0)/s,h.y=(u.y*s|0)/s,h.width=(u.width*s|0)/s,h.height=(u.height*s|0)/s,n.stack[0].renderTarget.transform||e[0].autoFit&&h.fit(n.stack[0].destinationFrame),h.pad(a),l.width=h.width,l.height=h.height;var c=this.getPotRenderTarget(r.gl,h.width,h.height,s);o.target=t,o.filters=e,o.resolution=s,o.renderTarget=c,c.setFrame(l,h),r.bindRenderTarget(c),c.clear()},e.prototype.popFilter=function(){var t=this.filterData,e=t.stack[t.index-1],r=t.stack[t.index];this.quad.map(r.renderTarget.size,r.sourceFrame).upload();var n=r.filters;if(1===n.length)n[0].apply(this,r.renderTarget,e.renderTarget,!1,r),this.freePotRenderTarget(r.renderTarget);else{var i=r.renderTarget,o=this.getPotRenderTarget(this.renderer.gl,r.sourceFrame.width,r.sourceFrame.height,r.resolution);o.setFrame(r.destinationFrame,r.sourceFrame),o.clear();var s=0;for(s=0;s<n.length-1;++s){n[s].apply(this,i,o,!0,r);var a=i;i=o,o=a}n[s].apply(this,i,e.renderTarget,!1,r),this.freePotRenderTarget(i),this.freePotRenderTarget(o)}t.index--,0===t.index&&(this.filterData=null)},e.prototype.applyFilter=function(t,e,r,n){var i=this.renderer,o=i.gl,s=t.glShaders[i.CONTEXT_UID];s||(t.glShaderKey?(s=this.shaderCache[t.glShaderKey],s||(s=new y.default(this.gl,t.vertexSrc,t.fragmentSrc),t.glShaders[i.CONTEXT_UID]=this.shaderCache[t.glShaderKey]=s)):s=t.glShaders[i.CONTEXT_UID]=new y.default(this.gl,t.vertexSrc,t.fragmentSrc),i.bindVao(null),this.quad.initVao(s)),i.bindVao(this.quad.vao),i.bindRenderTarget(r),n&&(o.disable(o.SCISSOR_TEST),i.clear(),o.enable(o.SCISSOR_TEST)),r===i.maskManager.scissorRenderTarget&&i.maskManager.pushScissorMask(null,i.maskManager.scissorData),i.bindShader(s);var a=this.renderer.emptyTextures[0];this.renderer.boundTextures[0]=a,this.syncUniforms(s,t),i.state.setBlendMode(t.blendMode),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,e.texture.texture),this.quad.vao.draw(this.renderer.gl.TRIANGLES,6,0),o.bindTexture(o.TEXTURE_2D,a._glTextures[this.renderer.CONTEXT_UID].texture)},e.prototype.syncUniforms=function(t,e){var r=e.uniformData,n=e.uniforms,i=1,o=void 0;if(t.uniforms.filterArea){o=this.filterData.stack[this.filterData.index];var s=t.uniforms.filterArea;s[0]=o.renderTarget.size.width,s[1]=o.renderTarget.size.height,s[2]=o.sourceFrame.x,s[3]=o.sourceFrame.y,t.uniforms.filterArea=s}if(t.uniforms.filterClamp){o=o||this.filterData.stack[this.filterData.index];var a=t.uniforms.filterClamp;a[0]=0,a[1]=0,a[2]=(o.sourceFrame.width-1)/o.renderTarget.size.width,a[3]=(o.sourceFrame.height-1)/o.renderTarget.size.height,t.uniforms.filterClamp=a}for(var u in r)if("sampler2D"===r[u].type&&0!==n[u]){if(n[u].baseTexture)t.uniforms[u]=this.renderer.bindTexture(n[u].baseTexture,i);else{t.uniforms[u]=i;var h=this.renderer.gl;this.renderer.boundTextures[i]=this.renderer.emptyTextures[i],h.activeTexture(h.TEXTURE0+i),n[u].texture.bind()}i++}else if("mat3"===r[u].type)void 0!==n[u].a?t.uniforms[u]=n[u].toArray(!0):t.uniforms[u]=n[u];else if("vec2"===r[u].type)if(void 0!==n[u].x){var l=t.uniforms[u]||new Float32Array(2);l[0]=n[u].x,l[1]=n[u].y,t.uniforms[u]=l}else t.uniforms[u]=n[u];else"float"===r[u].type?t.uniforms.data[u].value!==r[u]&&(t.uniforms[u]=n[u]):t.uniforms[u]=n[u]},e.prototype.getRenderTarget=function(t,e){var r=this.filterData.stack[this.filterData.index],n=this.getPotRenderTarget(this.renderer.gl,r.sourceFrame.width,r.sourceFrame.height,e||r.resolution);return n.setFrame(r.destinationFrame,r.sourceFrame),n},e.prototype.returnRenderTarget=function(t){this.freePotRenderTarget(t)},e.prototype.calculateScreenSpaceMatrix=function(t){var e=this.filterData.stack[this.filterData.index];return m.calculateScreenSpaceMatrix(t,e.sourceFrame,e.renderTarget.size)},e.prototype.calculateNormalizedScreenSpaceMatrix=function(t){var e=this.filterData.stack[this.filterData.index];return m.calculateNormalizedScreenSpaceMatrix(t,e.sourceFrame,e.renderTarget.size,e.destinationFrame)},e.prototype.calculateSpriteMatrix=function(t,e){var r=this.filterData.stack[this.filterData.index];return m.calculateSpriteMatrix(t,r.sourceFrame,r.renderTarget.size,e)},e.prototype.destroy=function(){this.shaderCache={},this.emptyPool()},e.prototype.getPotRenderTarget=function(t,e,r,n){e=b.default.nextPow2(e*n),r=b.default.nextPow2(r*n);var i=(65535&e)<<16|65535&r;this.pool[i]||(this.pool[i]=[]);var o=this.pool[i].pop();if(!o){var s=this.renderer.boundTextures[0];t.activeTexture(t.TEXTURE0),o=new c.default(t,e,r,null,1),t.bindTexture(t.TEXTURE_2D,s._glTextures[this.renderer.CONTEXT_UID].texture)}return o.resolution=n,o.defaultFrame.width=o.size.width=e/n,o.defaultFrame.height=o.size.height=r/n,o},e.prototype.emptyPool=function(){for(var t in this.pool){var e=this.pool[t];if(e)for(var r=0;r<e.length;r++)e[r].destroy(!0)}this.pool={}},e.prototype.freePotRenderTarget=function(t){var e=t.size.width*t.resolution,r=t.size.height*t.resolution,n=(65535&e)<<16|65535&r;this.pool[n].push(t)},e}(h.default);r.default=T},{"../../../Shader":43,"../../../math":69,"../filters/filterTransforms":87,"../utils/Quad":94,"../utils/RenderTarget":95,"./WebGLManager":92,"bit-twiddle":1}],90:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("./WebGLManager"),u=n(a),h=t("../filters/spriteMask/SpriteMaskFilter"),l=n(h),c=function(t){function e(r){i(this,e);var n=o(this,t.call(this,r));return n.scissor=!1,n.scissorData=null,n.scissorRenderTarget=null,n.enableScissor=!0,n.alphaMaskPool=[],n.alphaMaskIndex=0,n}return s(e,t),e.prototype.pushMask=function(t,e){if(e.texture)this.pushSpriteMask(t,e);else if(this.enableScissor&&!this.scissor&&this.renderer._activeRenderTarget.root&&!this.renderer.stencilManager.stencilMaskStack.length&&e.isFastRect()){var r=e.worldTransform,n=Math.atan2(r.b,r.a);n=Math.round(n*(180/Math.PI)),n%90?this.pushStencilMask(e):this.pushScissorMask(t,e)}else this.pushStencilMask(e)},e.prototype.popMask=function(t,e){e.texture?this.popSpriteMask(t,e):this.enableScissor&&!this.renderer.stencilManager.stencilMaskStack.length?this.popScissorMask(t,e):this.popStencilMask(t,e)},e.prototype.pushSpriteMask=function(t,e){var r=this.alphaMaskPool[this.alphaMaskIndex];r||(r=this.alphaMaskPool[this.alphaMaskIndex]=[new l.default(e)]),r[0].resolution=this.renderer.resolution,r[0].maskSprite=e,t.filterArea=e.getBounds(!0),this.renderer.filterManager.pushFilter(t,r),this.alphaMaskIndex++},e.prototype.popSpriteMask=function(){this.renderer.filterManager.popFilter(),this.alphaMaskIndex--},e.prototype.pushStencilMask=function(t){this.renderer.currentRenderer.stop(),this.renderer.stencilManager.pushStencil(t)},e.prototype.popStencilMask=function(){this.renderer.currentRenderer.stop(),this.renderer.stencilManager.popStencil()},e.prototype.pushScissorMask=function(t,e){e.renderable=!0;var r=this.renderer._activeRenderTarget,n=e.getBounds();n.fit(r.size),e.renderable=!1,this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);var i=this.renderer.resolution;this.renderer.gl.scissor(n.x*i,(r.root?r.size.height-n.y-n.height:n.y)*i,n.width*i,n.height*i),this.scissorRenderTarget=r,this.scissorData=e,this.scissor=!0},e.prototype.popScissorMask=function(){this.scissorRenderTarget=null,this.scissorData=null,this.scissor=!1;var t=this.renderer.gl;t.disable(t.SCISSOR_TEST)},e}(u.default);r.default=c},{"../filters/spriteMask/SpriteMaskFilter":88,"./WebGLManager":92}],91:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("./WebGLManager"),u=n(a),h=function(t){function e(r){i(this,e);var n=o(this,t.call(this,r));return n.stencilMaskStack=null,n}return s(e,t),e.prototype.setMaskStack=function(t){this.stencilMaskStack=t;var e=this.renderer.gl;0===t.length?e.disable(e.STENCIL_TEST):e.enable(e.STENCIL_TEST)},e.prototype.pushStencil=function(t){this.renderer.setObjectRenderer(this.renderer.plugins.graphics),this.renderer._activeRenderTarget.attachStencilBuffer();var e=this.renderer.gl,r=this.stencilMaskStack;
    0===r.length&&(e.enable(e.STENCIL_TEST),e.clear(e.STENCIL_BUFFER_BIT),e.stencilFunc(e.ALWAYS,1,1)),r.push(t),e.colorMask(!1,!1,!1,!1),e.stencilOp(e.KEEP,e.KEEP,e.INCR),this.renderer.plugins.graphics.render(t),e.colorMask(!0,!0,!0,!0),e.stencilFunc(e.NOTEQUAL,0,r.length),e.stencilOp(e.KEEP,e.KEEP,e.KEEP)},e.prototype.popStencil=function(){this.renderer.setObjectRenderer(this.renderer.plugins.graphics);var t=this.renderer.gl,e=this.stencilMaskStack,r=e.pop();0===e.length?t.disable(t.STENCIL_TEST):(t.colorMask(!1,!1,!1,!1),t.stencilOp(t.KEEP,t.KEEP,t.DECR),this.renderer.plugins.graphics.render(r),t.colorMask(!0,!0,!0,!0),t.stencilFunc(t.NOTEQUAL,0,e.length),t.stencilOp(t.KEEP,t.KEEP,t.KEEP))},e.prototype.destroy=function(){u.default.prototype.destroy.call(this),this.stencilMaskStack.stencilStack=null},e}(u.default);r.default=h},{"./WebGLManager":92}],92:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(e){n(this,t),this.renderer=e,this.renderer.on("context",this.onContextChange,this)}return t.prototype.onContextChange=function(){},t.prototype.destroy=function(){this.renderer.off("context",this.onContextChange,this),this.renderer=null},t}();r.default=i},{}],93:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../managers/WebGLManager"),u=n(a),h=function(t){function e(){return i(this,e),o(this,t.apply(this,arguments))}return s(e,t),e.prototype.start=function(){},e.prototype.stop=function(){this.flush()},e.prototype.flush=function(){},e.prototype.render=function(t){},e}(u.default);r.default=h},{"../managers/WebGLManager":92}],94:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("pixi-gl-core"),s=n(o),a=t("../../../utils/createIndicesForQuads"),u=n(a),h=function(){function t(e,r){i(this,t),this.gl=e,this.vertices=new Float32Array([-1,-1,1,-1,1,1,-1,1]),this.uvs=new Float32Array([0,0,1,0,1,1,0,1]),this.interleaved=new Float32Array(16);for(var n=0;n<4;n++)this.interleaved[4*n]=this.vertices[2*n],this.interleaved[4*n+1]=this.vertices[2*n+1],this.interleaved[4*n+2]=this.uvs[2*n],this.interleaved[4*n+3]=this.uvs[2*n+1];this.indices=(0,u.default)(1),this.vertexBuffer=s.default.GLBuffer.createVertexBuffer(e,this.interleaved,e.STATIC_DRAW),this.indexBuffer=s.default.GLBuffer.createIndexBuffer(e,this.indices,e.STATIC_DRAW),this.vao=new s.default.VertexArrayObject(e,r)}return t.prototype.initVao=function(t){this.vao.clear().addIndex(this.indexBuffer).addAttribute(this.vertexBuffer,t.attributes.aVertexPosition,this.gl.FLOAT,!1,16,0).addAttribute(this.vertexBuffer,t.attributes.aTextureCoord,this.gl.FLOAT,!1,16,8)},t.prototype.map=function(t,e){var r=0,n=0;return this.uvs[0]=r,this.uvs[1]=n,this.uvs[2]=r+e.width/t.width,this.uvs[3]=n,this.uvs[4]=r+e.width/t.width,this.uvs[5]=n+e.height/t.height,this.uvs[6]=r,this.uvs[7]=n+e.height/t.height,r=e.x,n=e.y,this.vertices[0]=r,this.vertices[1]=n,this.vertices[2]=r+e.width,this.vertices[3]=n,this.vertices[4]=r+e.width,this.vertices[5]=n+e.height,this.vertices[6]=r,this.vertices[7]=n+e.height,this},t.prototype.upload=function(){for(var t=0;t<4;t++)this.interleaved[4*t]=this.vertices[2*t],this.interleaved[4*t+1]=this.vertices[2*t+1],this.interleaved[4*t+2]=this.uvs[2*t],this.interleaved[4*t+3]=this.uvs[2*t+1];return this.vertexBuffer.upload(this.interleaved),this},t.prototype.destroy=function(){var t=this.gl;t.deleteBuffer(this.vertexBuffer),t.deleteBuffer(this.indexBuffer)},t}();r.default=h},{"../../../utils/createIndicesForQuads":121,"pixi-gl-core":12}],95:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("../../../math"),s=t("../../../const"),a=t("../../../settings"),u=n(a),h=t("pixi-gl-core"),l=function(){function t(e,r,n,a,l,c){i(this,t),this.gl=e,this.frameBuffer=null,this.texture=null,this.clearColor=[0,0,0,0],this.size=new o.Rectangle(0,0,1,1),this.resolution=l||u.default.RESOLUTION,this.projectionMatrix=new o.Matrix,this.transform=null,this.frame=null,this.defaultFrame=new o.Rectangle,this.destinationFrame=null,this.sourceFrame=null,this.stencilBuffer=null,this.stencilMaskStack=[],this.filterData=null,this.scaleMode=void 0!==a?a:u.default.SCALE_MODE,this.root=c,this.root?(this.frameBuffer=new h.GLFramebuffer(e,100,100),this.frameBuffer.framebuffer=null):(this.frameBuffer=h.GLFramebuffer.createRGBA(e,100,100),this.scaleMode===s.SCALE_MODES.NEAREST?this.frameBuffer.texture.enableNearestScaling():this.frameBuffer.texture.enableLinearScaling(),this.texture=this.frameBuffer.texture),this.setFrame(),this.resize(r,n)}return t.prototype.clear=function(t){var e=t||this.clearColor;this.frameBuffer.clear(e[0],e[1],e[2],e[3])},t.prototype.attachStencilBuffer=function(){this.root||this.frameBuffer.enableStencil()},t.prototype.setFrame=function(t,e){this.destinationFrame=t||this.destinationFrame||this.defaultFrame,this.sourceFrame=e||this.sourceFrame||this.destinationFrame},t.prototype.activate=function(){var t=this.gl;this.frameBuffer.bind(),this.calculateProjection(this.destinationFrame,this.sourceFrame),this.transform&&this.projectionMatrix.append(this.transform),this.destinationFrame!==this.sourceFrame?(t.enable(t.SCISSOR_TEST),t.scissor(0|this.destinationFrame.x,0|this.destinationFrame.y,this.destinationFrame.width*this.resolution|0,this.destinationFrame.height*this.resolution|0)):t.disable(t.SCISSOR_TEST),t.viewport(0|this.destinationFrame.x,0|this.destinationFrame.y,this.destinationFrame.width*this.resolution|0,this.destinationFrame.height*this.resolution|0)},t.prototype.calculateProjection=function(t,e){var r=this.projectionMatrix;e=e||t,r.identity(),this.root?(r.a=1/t.width*2,r.d=-1/t.height*2,r.tx=-1-e.x*r.a,r.ty=1-e.y*r.d):(r.a=1/t.width*2,r.d=1/t.height*2,r.tx=-1-e.x*r.a,r.ty=-1-e.y*r.d)},t.prototype.resize=function(t,e){if(t=0|t,e=0|e,this.size.width!==t||this.size.height!==e){this.size.width=t,this.size.height=e,this.defaultFrame.width=t,this.defaultFrame.height=e,this.frameBuffer.resize(t*this.resolution,e*this.resolution);var r=this.frame||this.size;this.calculateProjection(r)}},t.prototype.destroy=function(){this.frameBuffer.destroy(),this.frameBuffer=null,this.texture=null},t}();r.default=l},{"../../../const":45,"../../../math":69,"../../../settings":100,"pixi-gl-core":12}],96:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){var r=!e;if(r){var n=document.createElement("canvas");n.width=1,n.height=1,e=a.default.createContext(n)}for(var i=e.createShader(e.FRAGMENT_SHADER);;){var s=u.replace(/%forloop%/gi,o(t));if(e.shaderSource(i,s),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS))break;t=t/2|0}return r&&e.getExtension("WEBGL_lose_context")&&e.getExtension("WEBGL_lose_context").loseContext(),t}function o(t){for(var e="",r=0;r<t;++r)r>0&&(e+="\nelse "),r<t-1&&(e+="if(test == "+r+".0){}");return e}r.__esModule=!0,r.default=i;var s=t("pixi-gl-core"),a=n(s),u=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join("\n")},{"pixi-gl-core":12}],97:[function(t,e,r){"use strict";function n(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e[i.BLEND_MODES.NORMAL]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.ADD]=[t.ONE,t.DST_ALPHA],e[i.BLEND_MODES.MULTIPLY]=[t.DST_COLOR,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.SCREEN]=[t.ONE,t.ONE_MINUS_SRC_COLOR],e[i.BLEND_MODES.OVERLAY]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.DARKEN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.LIGHTEN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.COLOR_DODGE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.COLOR_BURN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.HARD_LIGHT]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.SOFT_LIGHT]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.DIFFERENCE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.EXCLUSION]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.HUE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.SATURATION]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.COLOR]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.LUMINOSITY]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.NORMAL_NPM]=[t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA],e[i.BLEND_MODES.ADD_NPM]=[t.SRC_ALPHA,t.DST_ALPHA,t.ONE,t.DST_ALPHA],e[i.BLEND_MODES.SCREEN_NPM]=[t.SRC_ALPHA,t.ONE_MINUS_SRC_COLOR,t.ONE,t.ONE_MINUS_SRC_COLOR],e}r.__esModule=!0,r.default=n;var i=t("../../../const")},{"../../../const":45}],98:[function(t,e,r){"use strict";function n(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return e[i.DRAW_MODES.POINTS]=t.POINTS,e[i.DRAW_MODES.LINES]=t.LINES,e[i.DRAW_MODES.LINE_LOOP]=t.LINE_LOOP,e[i.DRAW_MODES.LINE_STRIP]=t.LINE_STRIP,e[i.DRAW_MODES.TRIANGLES]=t.TRIANGLES,e[i.DRAW_MODES.TRIANGLE_STRIP]=t.TRIANGLE_STRIP,e[i.DRAW_MODES.TRIANGLE_FAN]=t.TRIANGLE_FAN,e}r.__esModule=!0,r.default=n;var i=t("../../../const")},{"../../../const":45}],99:[function(t,e,r){"use strict";function n(t){var e=t.getContextAttributes();e.stencil||console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly")}r.__esModule=!0,r.default=n},{}],100:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./utils/maxRecommendedTextures"),o=n(i),s=t("./utils/canUploadSameBuffer"),a=n(s);r.default={TARGET_FPMS:.06,MIPMAP_TEXTURES:!0,RESOLUTION:1,FILTER_RESOLUTION:1,SPRITE_MAX_TEXTURES:(0,o.default)(32),SPRITE_BATCH_SIZE:4096,RETINA_PREFIX:/@([0-9\.]+)x/,RENDER_OPTIONS:{view:null,antialias:!1,forceFXAA:!1,autoResize:!1,transparent:!1,backgroundColor:0,clearBeforeRender:!0,preserveDrawingBuffer:!1,roundPixels:!1,width:800,height:600,legacy:!1},TRANSFORM_MODE:0,GC_MODE:0,GC_MAX_IDLE:3600,GC_MAX_CHECK_COUNT:600,WRAP_MODE:0,SCALE_MODE:0,PRECISION_VERTEX:"highp",PRECISION_FRAGMENT:"mediump",CAN_UPLOAD_SAME_BUFFER:(0,a.default)()}},{"./utils/canUploadSameBuffer":120,"./utils/maxRecommendedTextures":125}],101:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../math"),h=t("../utils"),l=t("../const"),c=t("../textures/Texture"),d=n(c),f=t("../display/Container"),p=n(f),v=new u.Point,y=function(t){function e(r){i(this,e);var n=o(this,t.call(this));return n._anchor=new u.ObservablePoint(n._onAnchorUpdate,n),n._texture=null,n._width=0,n._height=0,n._tint=null,n._tintRGB=null,n.tint=16777215,n.blendMode=l.BLEND_MODES.NORMAL,n.shader=null,n.cachedTint=16777215,n.texture=r||d.default.EMPTY,n.vertexData=new Float32Array(8),n.vertexTrimmedData=null,n._transformID=-1,n._textureID=-1,n._transformTrimmedID=-1,n._textureTrimmedID=-1,n.pluginName="sprite",n}return s(e,t),e.prototype._onTextureUpdate=function(){this._textureID=-1,this._textureTrimmedID=-1,this._width&&(this.scale.x=(0,h.sign)(this.scale.x)*this._width/this._texture.orig.width),this._height&&(this.scale.y=(0,h.sign)(this.scale.y)*this._height/this._texture.orig.height)},e.prototype._onAnchorUpdate=function(){this._transformID=-1,this._transformTrimmedID=-1},e.prototype.calculateVertices=function(){if(this._transformID!==this.transform._worldID||this._textureID!==this._texture._updateID){this._transformID=this.transform._worldID,this._textureID=this._texture._updateID;var t=this._texture,e=this.transform.worldTransform,r=e.a,n=e.b,i=e.c,o=e.d,s=e.tx,a=e.ty,u=this.vertexData,h=t.trim,l=t.orig,c=this._anchor,d=0,f=0,p=0,v=0;h?(f=h.x-c._x*l.width,d=f+h.width,v=h.y-c._y*l.height,p=v+h.height):(f=-c._x*l.width,d=f+l.width,v=-c._y*l.height,p=v+l.height),u[0]=r*f+i*v+s,u[1]=o*v+n*f+a,u[2]=r*d+i*v+s,u[3]=o*v+n*d+a,u[4]=r*d+i*p+s,u[5]=o*p+n*d+a,u[6]=r*f+i*p+s,u[7]=o*p+n*f+a}},e.prototype.calculateTrimmedVertices=function(){if(this.vertexTrimmedData){if(this._transformTrimmedID===this.transform._worldID&&this._textureTrimmedID===this._texture._updateID)return}else this.vertexTrimmedData=new Float32Array(8);this._transformTrimmedID=this.transform._worldID,this._textureTrimmedID=this._texture._updateID;var t=this._texture,e=this.vertexTrimmedData,r=t.orig,n=this._anchor,i=this.transform.worldTransform,o=i.a,s=i.b,a=i.c,u=i.d,h=i.tx,l=i.ty,c=-n._x*r.width,d=c+r.width,f=-n._y*r.height,p=f+r.height;e[0]=o*c+a*f+h,e[1]=u*f+s*c+l,e[2]=o*d+a*f+h,e[3]=u*f+s*d+l,e[4]=o*d+a*p+h,e[5]=u*p+s*d+l,e[6]=o*c+a*p+h,e[7]=u*p+s*c+l},e.prototype._renderWebGL=function(t){this.calculateVertices(),t.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this)},e.prototype._renderCanvas=function(t){t.plugins[this.pluginName].render(this)},e.prototype._calculateBounds=function(){var t=this._texture.trim,e=this._texture.orig;!t||t.width===e.width&&t.height===e.height?(this.calculateVertices(),this._bounds.addQuad(this.vertexData)):(this.calculateTrimmedVertices(),this._bounds.addQuad(this.vertexTrimmedData))},e.prototype.getLocalBounds=function(e){return 0===this.children.length?(this._bounds.minX=this._texture.orig.width*-this._anchor._x,this._bounds.minY=this._texture.orig.height*-this._anchor._y,this._bounds.maxX=this._texture.orig.width*(1-this._anchor._x),this._bounds.maxY=this._texture.orig.height*(1-this._anchor._x),e||(this._localBoundsRect||(this._localBoundsRect=new u.Rectangle),e=this._localBoundsRect),this._bounds.getRectangle(e)):t.prototype.getLocalBounds.call(this,e)},e.prototype.containsPoint=function(t){this.worldTransform.applyInverse(t,v);var e=this._texture.orig.width,r=this._texture.orig.height,n=-e*this.anchor.x,i=0;return v.x>=n&&v.x<n+e&&(i=-r*this.anchor.y,v.y>=i&&v.y<i+r)},e.prototype.destroy=function(e){t.prototype.destroy.call(this,e),this._anchor=null;var r="boolean"==typeof e?e:e&&e.texture;if(r){var n="boolean"==typeof e?e:e&&e.baseTexture;this._texture.destroy(!!n)}this._texture=null,this.shader=null},e.from=function(t){return new e(d.default.from(t))},e.fromFrame=function(t){var r=h.TextureCache[t];if(!r)throw new Error('The frameId "'+t+'" does not exist in the texture cache');return new e(r)},e.fromImage=function(t,r,n){return new e(d.default.fromImage(t,r,n))},a(e,[{key:"width",get:function(){return Math.abs(this.scale.x)*this._texture.orig.width},set:function(t){var e=(0,h.sign)(this.scale.x)||1;this.scale.x=e*t/this._texture.orig.width,this._width=t}},{key:"height",get:function(){return Math.abs(this.scale.y)*this._texture.orig.height},set:function(t){var e=(0,h.sign)(this.scale.y)||1;this.scale.y=e*t/this._texture.orig.height,this._height=t}},{key:"anchor",get:function(){return this._anchor},set:function(t){this._anchor.copy(t)}},{key:"tint",get:function(){return this._tint},set:function(t){this._tint=t,this._tintRGB=(t>>16)+(65280&t)+((255&t)<<16)}},{key:"texture",get:function(){return this._texture},set:function(t){this._texture!==t&&(this._texture=t,this.cachedTint=16777215,this._textureID=-1,this._textureTrimmedID=-1,t&&(t.baseTexture.hasLoaded?this._onTextureUpdate():t.once("update",this._onTextureUpdate,this)))}}]),e}(p.default);r.default=y},{"../const":45,"../display/Container":47,"../math":69,"../textures/Texture":114,"../utils":123}],102:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("../../renderers/canvas/CanvasRenderer"),s=n(o),a=t("../../const"),u=t("../../math"),h=t("./CanvasTinter"),l=n(h),c=new u.Matrix,d=function(){function t(e){i(this,t),this.renderer=e}return t.prototype.render=function(t){var e=t._texture,r=this.renderer,n=e._frame.width,i=e._frame.height,o=t.transform.worldTransform,s=0,h=0;if(!(e.orig.width<=0||e.orig.height<=0)&&e.baseTexture.source&&(r.setBlendMode(t.blendMode),e.valid)){r.context.globalAlpha=t.worldAlpha;var d=e.baseTexture.scaleMode===a.SCALE_MODES.LINEAR;r.smoothProperty&&r.context[r.smoothProperty]!==d&&(r.context[r.smoothProperty]=d),e.trim?(s=e.trim.width/2+e.trim.x-t.anchor.x*e.orig.width,h=e.trim.height/2+e.trim.y-t.anchor.y*e.orig.height):(s=(.5-t.anchor.x)*e.orig.width,h=(.5-t.anchor.y)*e.orig.height),e.rotate&&(o.copy(c),o=c,u.GroupD8.matrixAppendRotationInv(o,e.rotate,s,h),s=0,h=0),s-=n/2,h-=i/2,r.roundPixels?(r.context.setTransform(o.a,o.b,o.c,o.d,o.tx*r.resolution|0,o.ty*r.resolution|0),s=0|s,h=0|h):r.context.setTransform(o.a,o.b,o.c,o.d,o.tx*r.resolution,o.ty*r.resolution);var f=e.baseTexture.resolution;16777215!==t.tint?(t.cachedTint===t.tint&&t.tintedTexture.tintId===t._texture._updateID||(t.cachedTint=t.tint,t.tintedTexture=l.default.getTintedTexture(t,t.tint)),r.context.drawImage(t.tintedTexture,0,0,n*f,i*f,s*r.resolution,h*r.resolution,n*r.resolution,i*r.resolution)):r.context.drawImage(e.baseTexture.source,e._frame.x*f,e._frame.y*f,n*f,i*f,s*r.resolution,h*r.resolution,n*r.resolution,i*r.resolution)}},t.prototype.destroy=function(){this.renderer=null},t}();r.default=d,s.default.registerPlugin("sprite",d)},{"../../const":45,"../../math":69,"../../renderers/canvas/CanvasRenderer":76,"./CanvasTinter":103}],103:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("../../utils"),o=t("../../renderers/canvas/utils/canUseNewCanvasBlendModes"),s=n(o),a={getTintedTexture:function(t,e){var r=t._texture;e=a.roundColor(e);var n="#"+("00000"+(0|e).toString(16)).substr(-6);r.tintCache=r.tintCache||{};var i=r.tintCache[n],o=void 0;if(i){if(i.tintId===r._updateID)return r.tintCache[n];o=r.tintCache[n]}else o=a.canvas||document.createElement("canvas");if(a.tintMethod(r,e,o),o.tintId=r._updateID,a.convertTintToImage){var s=new Image;s.src=o.toDataURL(),r.tintCache[n]=s}else r.tintCache[n]=o,a.canvas=null;return o},tintWithMultiply:function(t,e,r){var n=r.getContext("2d"),i=t._frame.clone(),o=t.baseTexture.resolution;i.x*=o,i.y*=o,i.width*=o,i.height*=o,r.width=Math.ceil(i.width),r.height=Math.ceil(i.height),n.fillStyle="#"+("00000"+(0|e).toString(16)).substr(-6),n.fillRect(0,0,i.width,i.height),n.globalCompositeOperation="multiply",n.drawImage(t.baseTexture.source,i.x,i.y,i.width,i.height,0,0,i.width,i.height),n.globalCompositeOperation="destination-atop",n.drawImage(t.baseTexture.source,i.x,i.y,i.width,i.height,0,0,i.width,i.height)},tintWithOverlay:function(t,e,r){var n=r.getContext("2d"),i=t._frame.clone(),o=t.baseTexture.resolution;i.x*=o,i.y*=o,i.width*=o,i.height*=o,r.width=Math.ceil(i.width),r.height=Math.ceil(i.height),n.globalCompositeOperation="copy",n.fillStyle="#"+("00000"+(0|e).toString(16)).substr(-6),n.fillRect(0,0,i.width,i.height),n.globalCompositeOperation="destination-atop",n.drawImage(t.baseTexture.source,i.x,i.y,i.width,i.height,0,0,i.width,i.height)},tintWithPerPixel:function(t,e,r){var n=r.getContext("2d"),o=t._frame.clone(),s=t.baseTexture.resolution;o.x*=s,o.y*=s,o.width*=s,o.height*=s,r.width=Math.ceil(o.width),r.height=Math.ceil(o.height),n.globalCompositeOperation="copy",n.drawImage(t.baseTexture.source,o.x,o.y,o.width,o.height,0,0,o.width,o.height);for(var a=(0,i.hex2rgb)(e),u=a[0],h=a[1],l=a[2],c=n.getImageData(0,0,o.width,o.height),d=c.data,f=0;f<d.length;f+=4)d[f+0]*=u,d[f+1]*=h,d[f+2]*=l;n.putImageData(c,0,0)},roundColor:function(t){var e=a.cacheStepsPerColorChannel,r=(0,i.hex2rgb)(t);return r[0]=Math.min(255,r[0]/e*e),r[1]=Math.min(255,r[1]/e*e),r[2]=Math.min(255,r[2]/e*e),(0,i.rgb2hex)(r)},cacheStepsPerColorChannel:8,convertTintToImage:!1,canUseMultiply:(0,s.default)(),tintMethod:0};a.tintMethod=a.canUseMultiply?a.tintWithMultiply:a.tintWithPerPixel,r.default=a},{"../../renderers/canvas/utils/canUseNewCanvasBlendModes":79,"../../utils":123}],104:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(e){n(this,t),this.vertices=new ArrayBuffer(e),this.float32View=new Float32Array(this.vertices),this.uint32View=new Uint32Array(this.vertices)}return t.prototype.destroy=function(){this.vertices=null,this.positions=null,this.uvs=null,this.colors=null},t}();r.default=i},{}],105:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../../renderers/webgl/utils/ObjectRenderer"),u=n(a),h=t("../../renderers/webgl/WebGLRenderer"),l=n(h),c=t("../../utils/createIndicesForQuads"),d=n(c),f=t("./generateMultiTextureShader"),p=n(f),v=t("../../renderers/webgl/utils/checkMaxIfStatmentsInShader"),y=n(v),g=t("./BatchBuffer"),m=n(g),_=t("../../settings"),b=n(_),x=t("../../utils"),T=t("pixi-gl-core"),w=n(T),E=t("bit-twiddle"),S=n(E),O=0,P=0,M=function(t){function e(r){i(this,e);var n=o(this,t.call(this,r));n.vertSize=5,n.vertByteSize=4*n.vertSize,n.size=b.default.SPRITE_BATCH_SIZE,n.buffers=[];for(var s=1;s<=S.default.nextPow2(n.size);s*=2)n.buffers.push(new m.default(4*s*n.vertByteSize));n.indices=(0,d.default)(n.size),n.shader=null,n.currentIndex=0,n.groups=[];for(var a=0;a<n.size;a++)n.groups[a]={textures:[],textureCount:0,ids:[],size:0,start:0,blend:0};return n.sprites=[],n.vertexBuffers=[],n.vaos=[],n.vaoMax=2,n.vertexCount=0,n.renderer.on("prerender",n.onPrerender,n),n}return s(e,t),e.prototype.onContextChange=function(){var t=this.renderer.gl;this.renderer.legacy?this.MAX_TEXTURES=1:(this.MAX_TEXTURES=Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),b.default.SPRITE_MAX_TEXTURES),this.MAX_TEXTURES=(0,y.default)(this.MAX_TEXTURES,t)),this.shader=(0,p.default)(t,this.MAX_TEXTURES),this.indexBuffer=w.default.GLBuffer.createIndexBuffer(t,this.indices,t.STATIC_DRAW),this.renderer.bindVao(null);for(var e=this.shader.attributes,r=0;r<this.vaoMax;r++){var n=this.vertexBuffers[r]=w.default.GLBuffer.createVertexBuffer(t,null,t.STREAM_DRAW),i=this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(n,e.aVertexPosition,t.FLOAT,!1,this.vertByteSize,0).addAttribute(n,e.aTextureCoord,t.UNSIGNED_SHORT,!0,this.vertByteSize,8).addAttribute(n,e.aColor,t.UNSIGNED_BYTE,!0,this.vertByteSize,12);e.aTextureId&&i.addAttribute(n,e.aTextureId,t.FLOAT,!1,this.vertByteSize,16),this.vaos[r]=i}this.vao=this.vaos[0],this.currentBlendMode=99999,this.boundTextures=new Array(this.MAX_TEXTURES)},e.prototype.onPrerender=function(){this.vertexCount=0},e.prototype.render=function(t){this.currentIndex>=this.size&&this.flush(),t._texture._uvs&&(this.sprites[this.currentIndex++]=t)},e.prototype.flush=function(){if(0!==this.currentIndex){var t=this.renderer.gl,e=this.MAX_TEXTURES,r=S.default.nextPow2(this.currentIndex),n=S.default.log2(r),i=this.buffers[n],o=this.sprites,s=this.groups,a=i.float32View,u=i.uint32View,h=this.boundTextures,l=this.renderer.boundTextures,c=this.renderer.textureGC.count,d=0,f=void 0,p=void 0,v=1,y=0,g=s[0],m=void 0,_=void 0,T=x.premultiplyBlendMode[o[0]._texture.baseTexture.premultipliedAlpha?1:0][o[0].blendMode];g.textureCount=0,g.start=0,g.blend=T,O++;var E=void 0;for(E=0;E<e;++E)h[E]=l[E],h[E]._virtalBoundId=E;for(E=0;E<this.currentIndex;++E){var M=o[E];f=M._texture.baseTexture;var C=x.premultiplyBlendMode[Number(f.premultipliedAlpha)][M.blendMode];if(T!==C&&(T=C,p=null,y=e,O++),p!==f&&(p=f,f._enabled!==O)){if(y===e&&(O++,g.size=E-g.start,y=0,g=s[v++],g.blend=T,g.textureCount=0,g.start=E),f.touched=c,f._virtalBoundId===-1)for(var R=0;R<e;++R){var A=(R+P)%e,I=h[A];if(I._enabled!==O){P++,I._virtalBoundId=-1,f._virtalBoundId=A,h[A]=f;break}}f._enabled=O,g.textureCount++,g.ids[y]=f._virtalBoundId,g.textures[y++]=f}if(m=M.vertexData,_=M._texture._uvs.uvsUint32,this.renderer.roundPixels){var D=this.renderer.resolution;a[d]=(m[0]*D|0)/D,a[d+1]=(m[1]*D|0)/D,a[d+5]=(m[2]*D|0)/D,a[d+6]=(m[3]*D|0)/D,a[d+10]=(m[4]*D|0)/D,a[d+11]=(m[5]*D|0)/D,a[d+15]=(m[6]*D|0)/D,a[d+16]=(m[7]*D|0)/D}else a[d]=m[0],a[d+1]=m[1],a[d+5]=m[2],a[d+6]=m[3],a[d+10]=m[4],a[d+11]=m[5],a[d+15]=m[6],a[d+16]=m[7];u[d+2]=_[0],u[d+7]=_[1],u[d+12]=_[2],u[d+17]=_[3];var L=Math.min(M.worldAlpha,1),N=L<1&&f.premultipliedAlpha?(0,x.premultiplyTint)(M._tintRGB,L):M._tintRGB+(255*L<<24);u[d+3]=u[d+8]=u[d+13]=u[d+18]=N,a[d+4]=a[d+9]=a[d+14]=a[d+19]=f._virtalBoundId,d+=20}if(g.size=E-g.start,b.default.CAN_UPLOAD_SAME_BUFFER)this.vertexBuffers[this.vertexCount].upload(i.vertices,0,!0);else{if(this.vaoMax<=this.vertexCount){this.vaoMax++;var F=this.shader.attributes,B=this.vertexBuffers[this.vertexCount]=w.default.GLBuffer.createVertexBuffer(t,null,t.STREAM_DRAW),k=this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(B,F.aVertexPosition,t.FLOAT,!1,this.vertByteSize,0).addAttribute(B,F.aTextureCoord,t.UNSIGNED_SHORT,!0,this.vertByteSize,8).addAttribute(B,F.aColor,t.UNSIGNED_BYTE,!0,this.vertByteSize,12);F.aTextureId&&k.addAttribute(B,F.aTextureId,t.FLOAT,!1,this.vertByteSize,16),this.vaos[this.vertexCount]=k}this.renderer.bindVao(this.vaos[this.vertexCount]),this.vertexBuffers[this.vertexCount].upload(i.vertices,0,!1),this.vertexCount++}for(E=0;E<e;++E)l[E]._virtalBoundId=-1;for(E=0;E<v;++E){for(var j=s[E],U=j.textureCount,X=0;X<U;X++)p=j.textures[X],l[j.ids[X]]!==p&&this.renderer.bindTexture(p,j.ids[X],!0),p._virtalBoundId=-1;this.renderer.state.setBlendMode(j.blend),t.drawElements(t.TRIANGLES,6*j.size,t.UNSIGNED_SHORT,6*j.start*2)}this.currentIndex=0}},e.prototype.start=function(){this.renderer.bindShader(this.shader),b.default.CAN_UPLOAD_SAME_BUFFER&&(this.renderer.bindVao(this.vaos[this.vertexCount]),this.vertexBuffers[this.vertexCount].bind())},e.prototype.stop=function(){this.flush()},e.prototype.destroy=function(){for(var e=0;e<this.vaoMax;e++)this.vertexBuffers[e]&&this.vertexBuffers[e].destroy(),this.vaos[e]&&this.vaos[e].destroy();this.indexBuffer&&this.indexBuffer.destroy(),this.renderer.off("prerender",this.onPrerender,this),t.prototype.destroy.call(this),this.shader&&(this.shader.destroy(),this.shader=null),this.vertexBuffers=null,this.vaos=null,this.indexBuffer=null,this.indices=null,this.sprites=null;for(var r=0;r<this.buffers.length;++r)this.buffers[r].destroy()},e}(u.default);r.default=M,l.default.registerPlugin("sprite",M)},{"../../renderers/webgl/WebGLRenderer":83,"../../renderers/webgl/utils/ObjectRenderer":93,"../../renderers/webgl/utils/checkMaxIfStatmentsInShader":96,"../../settings":100,"../../utils":123,"../../utils/createIndicesForQuads":121,"./BatchBuffer":104,"./generateMultiTextureShader":106,"bit-twiddle":1,"pixi-gl-core":12}],106:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){var r="precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor;\n}\n",n=u;n=n.replace(/%count%/gi,e),n=n.replace(/%forloop%/gi,o(e));for(var i=new a.default(t,r,n),s=[],h=0;h<e;h++)s[h]=h;return i.bind(),i.uniforms.uSamplers=s,i}function o(t){var e="";e+="\n",e+="\n";for(var r=0;r<t;r++)r>0&&(e+="\nelse "),r<t-1&&(e+="if(textureId == "+r+".0)"),e+="\n{",e+="\n\tcolor = texture2D(uSamplers["+r+"], vTextureCoord);",e+="\n}";return e+="\n",e+="\n"}r.__esModule=!0,r.default=i;var s=t("../../Shader"),a=n(s),u=(t("path"),["varying vec2 vTextureCoord;","varying vec4 vColor;","varying float vTextureId;","uniform sampler2D uSamplers[%count%];","void main(void){","vec4 color;","float textureId = floor(vTextureId+0.5);","%forloop%","gl_FragColor = color * vColor;","}"].join("\n"))},{"../../Shader":43,path:22}],107:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../sprites/Sprite"),h=n(u),l=t("../textures/Texture"),c=n(l),d=t("../math"),f=t("../utils"),p=t("../const"),v=t("../settings"),y=n(v),g=t("./TextStyle"),m=n(g),_=t("./TextMetrics"),b=n(_),x=t("../utils/trimCanvas"),T=n(x),w={texture:!0,children:!1,baseTexture:!0},E=function(t){function e(r,n,s){i(this,e),s=s||document.createElement("canvas"),s.width=3,s.height=3;var a=c.default.fromCanvas(s,y.default.SCALE_MODE,"text");a.orig=new d.Rectangle,a.trim=new d.Rectangle;var u=o(this,t.call(this,a));return c.default.addToCache(u._texture,u._texture.baseTexture.textureCacheIds[0]),u.canvas=s,u.context=u.canvas.getContext("2d"),u.resolution=y.default.RESOLUTION,u._text=null,u._style=null,u._styleListener=null,u._font="",u.text=r,u.style=n,u.localStyleID=-1,u}return s(e,t),e.prototype.updateText=function(t){var e=this._style;if(this.localStyleID!==e.styleID&&(this.dirty=!0,this.localStyleID=e.styleID),this.dirty||!t){this._font=this._style.toFontString();var r=this.context,n=b.default.measureText(this._text,this._style,this._style.wordWrap,this.canvas),i=n.width,o=n.height,s=n.lines,a=n.lineHeight,u=n.lineWidths,h=n.maxLineWidth,l=n.fontProperties;this.canvas.width=Math.ceil((i+2*e.padding)*this.resolution),this.canvas.height=Math.ceil((o+2*e.padding)*this.resolution),r.scale(this.resolution,this.resolution),r.clearRect(0,0,this.canvas.width,this.canvas.height),
    r.font=this._font,r.strokeStyle=e.stroke,r.lineWidth=e.strokeThickness,r.textBaseline=e.textBaseline,r.lineJoin=e.lineJoin,r.miterLimit=e.miterLimit;var c=void 0,d=void 0;if(e.dropShadow){r.fillStyle=e.dropShadowColor,r.globalAlpha=e.dropShadowAlpha,r.shadowBlur=e.dropShadowBlur,e.dropShadowBlur>0&&(r.shadowColor=e.dropShadowColor);for(var f=Math.cos(e.dropShadowAngle)*e.dropShadowDistance,p=Math.sin(e.dropShadowAngle)*e.dropShadowDistance,v=0;v<s.length;v++)c=e.strokeThickness/2,d=e.strokeThickness/2+v*a+l.ascent,"right"===e.align?c+=h-u[v]:"center"===e.align&&(c+=(h-u[v])/2),e.fill&&(this.drawLetterSpacing(s[v],c+f+e.padding,d+p+e.padding),e.stroke&&e.strokeThickness&&(r.strokeStyle=e.dropShadowColor,this.drawLetterSpacing(s[v],c+f+e.padding,d+p+e.padding,!0),r.strokeStyle=e.stroke))}r.shadowBlur=0,r.globalAlpha=1,r.fillStyle=this._generateFillStyle(e,s);for(var y=0;y<s.length;y++)c=e.strokeThickness/2,d=e.strokeThickness/2+y*a+l.ascent,"right"===e.align?c+=h-u[y]:"center"===e.align&&(c+=(h-u[y])/2),e.stroke&&e.strokeThickness&&this.drawLetterSpacing(s[y],c+e.padding,d+e.padding,!0),e.fill&&this.drawLetterSpacing(s[y],c+e.padding,d+e.padding);this.updateTexture()}},e.prototype.drawLetterSpacing=function(t,e,r){var n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=this._style,o=i.letterSpacing;if(0===o)return void(n?this.context.strokeText(t,e,r):this.context.fillText(t,e,r));for(var s=String.prototype.split.call(t,""),a=e,u=0,h="";u<t.length;)h=s[u++],n?this.context.strokeText(h,a,r):this.context.fillText(h,a,r),a+=this.context.measureText(h).width+o},e.prototype.updateTexture=function(){var t=this.canvas;if(this._style.trim){var e=(0,T.default)(t);t.width=e.width,t.height=e.height,this.context.putImageData(e.data,0,0)}var r=this._texture,n=this._style,i=n.trim?0:n.padding,o=r.baseTexture;o.hasLoaded=!0,o.resolution=this.resolution,o.realWidth=t.width,o.realHeight=t.height,o.width=t.width/this.resolution,o.height=t.height/this.resolution,r.trim.width=r._frame.width=t.width/this.resolution,r.trim.height=r._frame.height=t.height/this.resolution,r.trim.x=-i,r.trim.y=-i,r.orig.width=r._frame.width-2*i,r.orig.height=r._frame.height-2*i,this._onTextureUpdate(),o.emit("update",o),this.dirty=!1},e.prototype.renderWebGL=function(e){this.resolution!==e.resolution&&(this.resolution=e.resolution,this.dirty=!0),this.updateText(!0),t.prototype.renderWebGL.call(this,e)},e.prototype._renderCanvas=function(e){this.resolution!==e.resolution&&(this.resolution=e.resolution,this.dirty=!0),this.updateText(!0),t.prototype._renderCanvas.call(this,e)},e.prototype.getLocalBounds=function(e){return this.updateText(!0),t.prototype.getLocalBounds.call(this,e)},e.prototype._calculateBounds=function(){this.updateText(!0),this.calculateVertices(),this._bounds.addQuad(this.vertexData)},e.prototype._onStyleChange=function(){this.dirty=!0},e.prototype._generateFillStyle=function(t,e){if(!Array.isArray(t.fill))return t.fill;if(navigator.isCocoonJS)return t.fill[0];var r=void 0,n=void 0,i=void 0,o=void 0,s=this.canvas.width/this.resolution,a=this.canvas.height/this.resolution,u=t.fill.slice(),h=t.fillGradientStops.slice();if(!h.length)for(var l=u.length+1,c=1;c<l;++c)h.push(c/l);if(u.unshift(t.fill[0]),h.unshift(0),u.push(t.fill[t.fill.length-1]),h.push(1),t.fillGradientType===p.TEXT_GRADIENT.LINEAR_VERTICAL){r=this.context.createLinearGradient(s/2,0,s/2,a),n=(u.length+1)*e.length,i=0;for(var d=0;d<e.length;d++){i+=1;for(var f=0;f<u.length;f++)o="number"==typeof h[f]?h[f]/e.length+d/e.length:i/n,r.addColorStop(o,u[f]),i++}}else{r=this.context.createLinearGradient(0,a/2,s,a/2),n=u.length+1,i=1;for(var v=0;v<u.length;v++)o="number"==typeof h[v]?h[v]:i/n,r.addColorStop(o,u[v]),i++}return r},e.prototype.destroy=function(e){"boolean"==typeof e&&(e={children:e}),e=Object.assign({},w,e),t.prototype.destroy.call(this,e),this.context=null,this.canvas=null,this._style=null},a(e,[{key:"width",get:function(){return this.updateText(!0),Math.abs(this.scale.x)*this._texture.orig.width},set:function(t){this.updateText(!0);var e=(0,f.sign)(this.scale.x)||1;this.scale.x=e*t/this._texture.orig.width,this._width=t}},{key:"height",get:function(){return this.updateText(!0),Math.abs(this.scale.y)*this._texture.orig.height},set:function(t){this.updateText(!0);var e=(0,f.sign)(this.scale.y)||1;this.scale.y=e*t/this._texture.orig.height,this._height=t}},{key:"style",get:function(){return this._style},set:function(t){t=t||{},t instanceof m.default?this._style=t:this._style=new m.default(t),this.localStyleID=-1,this.dirty=!0}},{key:"text",get:function(){return this._text},set:function(t){t=String(""===t||null===t||void 0===t?" ":t),this._text!==t&&(this._text=t,this.dirty=!0)}}]),e}(h.default);r.default=E},{"../const":45,"../math":69,"../settings":100,"../sprites/Sprite":101,"../textures/Texture":114,"../utils":123,"../utils/trimCanvas":128,"./TextMetrics":108,"./TextStyle":109}],108:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(e,r,i,o,s,a,u,h,l){n(this,t),this.text=e,this.style=r,this.width=i,this.height=o,this.lines=s,this.lineWidths=a,this.lineHeight=u,this.maxLineWidth=h,this.fontProperties=l}return t.measureText=function(e,r,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._canvas;n=n||r.wordWrap;var o=r.toFontString(),s=t.measureFont(o),a=i.getContext("2d");a.font=o;for(var u=n?t.wordWrap(e,r,i):e,h=u.split(/(?:\r\n|\r|\n)/),l=new Array(h.length),c=0,d=0;d<h.length;d++){var f=a.measureText(h[d]).width+(h[d].length-1)*r.letterSpacing;l[d]=f,c=Math.max(c,f)}var p=c+r.strokeThickness;r.dropShadow&&(p+=r.dropShadowDistance);var v=r.lineHeight||s.fontSize+r.strokeThickness,y=Math.max(v,s.fontSize+r.strokeThickness)+(h.length-1)*v;return r.dropShadow&&(y+=r.dropShadowDistance),new t(e,r,p,y,h,l,v,c,s)},t.wordWrap=function(e,r){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t._canvas,i=n.getContext("2d"),o="",s=e.split("\n"),a=r.wordWrapWidth,u={},h=0;h<s.length;h++){for(var l=a,c=s[h].split(" "),d=0;d<c.length;d++){var f=i.measureText(c[d]).width;if(r.breakWords&&f>a)for(var p=c[d].split(""),v=0;v<p.length;v++){var y=p[v],g=u[y];void 0===g&&(g=i.measureText(y).width,u[y]=g),g>l?(o+="\n"+y,l=a-g):(0===v&&(o+=" "),o+=y,l-=g)}else{var m=f+i.measureText(" ").width;0===d||m>l?(d>0&&(o+="\n"),o+=c[d],l=a-f):(l-=m,o+=" "+c[d])}}h<s.length-1&&(o+="\n")}return o},t.measureFont=function(e){if(t._fonts[e])return t._fonts[e];var r={},n=t._canvas,i=t._context;i.font=e;var o=Math.ceil(i.measureText("|Mq").width),s=Math.ceil(i.measureText("M").width),a=2*s;s=1.4*s|0,n.width=o,n.height=a,i.fillStyle="#f00",i.fillRect(0,0,o,a),i.font=e,i.textBaseline="alphabetic",i.fillStyle="#000",i.fillText("|Mq",0,s);var u=i.getImageData(0,0,o,a).data,h=u.length,l=4*o,c=0,d=0,f=!1;for(c=0;c<s;++c){for(var p=0;p<l;p+=4)if(255!==u[d+p]){f=!0;break}if(f)break;d+=l}for(r.ascent=s-c,d=h-l,f=!1,c=a;c>s;--c){for(var v=0;v<l;v+=4)if(255!==u[d+v]){f=!0;break}if(f)break;d-=l}return r.descent=c-s,r.fontSize=r.ascent+r.descent,t._fonts[e]=r,r},t}();r.default=i;var o=document.createElement("canvas");o.width=o.height=10,i._canvas=o,i._context=o.getContext("2d"),i._fonts={}},{}],109:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t){return"number"==typeof t?(0,h.hex2string)(t):("string"==typeof t&&0===t.indexOf("0x")&&(t=t.replace("0x","#")),t)}function o(t){if(Array.isArray(t)){for(var e=0;e<t.length;++e)t[e]=i(t[e]);return t}return i(t)}function s(t,e){if(!Array.isArray(t)||!Array.isArray(e))return!1;if(t.length!==e.length)return!1;for(var r=0;r<t.length;++r)if(t[r]!==e[r])return!1;return!0}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../const"),h=t("../utils"),l={align:"left",breakWords:!1,dropShadow:!1,dropShadowAlpha:1,dropShadowAngle:Math.PI/6,dropShadowBlur:0,dropShadowColor:"black",dropShadowDistance:5,fill:"black",fillGradientType:u.TEXT_GRADIENT.LINEAR_VERTICAL,fillGradientStops:[],fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",letterSpacing:0,lineHeight:0,lineJoin:"miter",miterLimit:10,padding:0,stroke:"black",strokeThickness:0,textBaseline:"alphabetic",trim:!1,wordWrap:!1,wordWrapWidth:100},c=function(){function t(e){n(this,t),this.styleID=0,Object.assign(this,l,e)}return t.prototype.clone=function(){var e={};for(var r in l)e[r]=this[r];return new t(e)},t.prototype.reset=function(){Object.assign(this,l)},t.prototype.toFontString=function(){var t="number"==typeof this.fontSize?this.fontSize+"px":this.fontSize,e=this.fontFamily;Array.isArray(this.fontFamily)||(e=this.fontFamily.split(","));for(var r=e.length-1;r>=0;r--){var n=e[r].trim();/([\"\'])[^\'\"]+\1/.test(n)||(n='"'+n+'"'),e[r]=n}return this.fontStyle+" "+this.fontVariant+" "+this.fontWeight+" "+t+" "+e.join(",")},a(t,[{key:"align",get:function(){return this._align},set:function(t){this._align!==t&&(this._align=t,this.styleID++)}},{key:"breakWords",get:function(){return this._breakWords},set:function(t){this._breakWords!==t&&(this._breakWords=t,this.styleID++)}},{key:"dropShadow",get:function(){return this._dropShadow},set:function(t){this._dropShadow!==t&&(this._dropShadow=t,this.styleID++)}},{key:"dropShadowAlpha",get:function(){return this._dropShadowAlpha},set:function(t){this._dropShadowAlpha!==t&&(this._dropShadowAlpha=t,this.styleID++)}},{key:"dropShadowAngle",get:function(){return this._dropShadowAngle},set:function(t){this._dropShadowAngle!==t&&(this._dropShadowAngle=t,this.styleID++)}},{key:"dropShadowBlur",get:function(){return this._dropShadowBlur},set:function(t){this._dropShadowBlur!==t&&(this._dropShadowBlur=t,this.styleID++)}},{key:"dropShadowColor",get:function(){return this._dropShadowColor},set:function(t){var e=o(t);this._dropShadowColor!==e&&(this._dropShadowColor=e,this.styleID++)}},{key:"dropShadowDistance",get:function(){return this._dropShadowDistance},set:function(t){this._dropShadowDistance!==t&&(this._dropShadowDistance=t,this.styleID++)}},{key:"fill",get:function(){return this._fill},set:function(t){var e=o(t);this._fill!==e&&(this._fill=e,this.styleID++)}},{key:"fillGradientType",get:function(){return this._fillGradientType},set:function(t){this._fillGradientType!==t&&(this._fillGradientType=t,this.styleID++)}},{key:"fillGradientStops",get:function(){return this._fillGradientStops},set:function(t){s(this._fillGradientStops,t)||(this._fillGradientStops=t,this.styleID++)}},{key:"fontFamily",get:function(){return this._fontFamily},set:function(t){this.fontFamily!==t&&(this._fontFamily=t,this.styleID++)}},{key:"fontSize",get:function(){return this._fontSize},set:function(t){this._fontSize!==t&&(this._fontSize=t,this.styleID++)}},{key:"fontStyle",get:function(){return this._fontStyle},set:function(t){this._fontStyle!==t&&(this._fontStyle=t,this.styleID++)}},{key:"fontVariant",get:function(){return this._fontVariant},set:function(t){this._fontVariant!==t&&(this._fontVariant=t,this.styleID++)}},{key:"fontWeight",get:function(){return this._fontWeight},set:function(t){this._fontWeight!==t&&(this._fontWeight=t,this.styleID++)}},{key:"letterSpacing",get:function(){return this._letterSpacing},set:function(t){this._letterSpacing!==t&&(this._letterSpacing=t,this.styleID++)}},{key:"lineHeight",get:function(){return this._lineHeight},set:function(t){this._lineHeight!==t&&(this._lineHeight=t,this.styleID++)}},{key:"lineJoin",get:function(){return this._lineJoin},set:function(t){this._lineJoin!==t&&(this._lineJoin=t,this.styleID++)}},{key:"miterLimit",get:function(){return this._miterLimit},set:function(t){this._miterLimit!==t&&(this._miterLimit=t,this.styleID++)}},{key:"padding",get:function(){return this._padding},set:function(t){this._padding!==t&&(this._padding=t,this.styleID++)}},{key:"stroke",get:function(){return this._stroke},set:function(t){var e=o(t);this._stroke!==e&&(this._stroke=e,this.styleID++)}},{key:"strokeThickness",get:function(){return this._strokeThickness},set:function(t){this._strokeThickness!==t&&(this._strokeThickness=t,this.styleID++)}},{key:"textBaseline",get:function(){return this._textBaseline},set:function(t){this._textBaseline!==t&&(this._textBaseline=t,this.styleID++)}},{key:"trim",get:function(){return this._trim},set:function(t){this._trim!==t&&(this._trim=t,this.styleID++)}},{key:"wordWrap",get:function(){return this._wordWrap},set:function(t){this._wordWrap!==t&&(this._wordWrap=t,this.styleID++)}},{key:"wordWrapWidth",get:function(){return this._wordWrapWidth},set:function(t){this._wordWrapWidth!==t&&(this._wordWrapWidth=t,this.styleID++)}}]),t}();r.default=c},{"../const":45,"../utils":123}],110:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("./BaseTexture"),u=n(a),h=t("../settings"),l=n(h),c=function(t){function e(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:100,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:100,s=arguments[2],a=arguments[3];i(this,e);var u=o(this,t.call(this,null,s));return u.resolution=a||l.default.RESOLUTION,u.width=r,u.height=n,u.realWidth=u.width*u.resolution,u.realHeight=u.height*u.resolution,u.scaleMode=void 0!==s?s:l.default.SCALE_MODE,u.hasLoaded=!0,u._glRenderTargets={},u._canvasRenderTarget=null,u.valid=!1,u}return s(e,t),e.prototype.resize=function(t,e){t===this.width&&e===this.height||(this.valid=t>0&&e>0,this.width=t,this.height=e,this.realWidth=this.width*this.resolution,this.realHeight=this.height*this.resolution,this.valid&&this.emit("update",this))},e.prototype.destroy=function(){t.prototype.destroy.call(this,!0),this.renderer=null},e}(u.default);r.default=c},{"../settings":100,"./BaseTexture":111}],111:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},u=t("../utils"),h=t("../settings"),l=n(h),c=t("eventemitter3"),d=n(c),f=t("../utils/determineCrossOrigin"),p=n(f),v=t("bit-twiddle"),y=n(v),g=function(t){function e(r,n,s){i(this,e);var a=o(this,t.call(this));return a.uid=(0,u.uid)(),a.touched=0,a.resolution=s||l.default.RESOLUTION,a.width=100,a.height=100,a.realWidth=100,a.realHeight=100,a.scaleMode=void 0!==n?n:l.default.SCALE_MODE,a.hasLoaded=!1,a.isLoading=!1,a.source=null,a.origSource=null,a.imageType=null,a.sourceScale=1,a.premultipliedAlpha=!0,a.imageUrl=null,a.isPowerOfTwo=!1,a.mipmap=l.default.MIPMAP_TEXTURES,a.wrapMode=l.default.WRAP_MODE,a._glTextures={},a._enabled=0,a._virtalBoundId=-1,a._destroyed=!1,a.textureCacheIds=[],r&&a.loadSource(r),a}return s(e,t),e.prototype.update=function(){"svg"!==this.imageType&&(this.realWidth=this.source.naturalWidth||this.source.videoWidth||this.source.width,this.realHeight=this.source.naturalHeight||this.source.videoHeight||this.source.height,this._updateDimensions()),this.emit("update",this)},e.prototype._updateDimensions=function(){this.width=this.realWidth/this.resolution,this.height=this.realHeight/this.resolution,this.isPowerOfTwo=y.default.isPow2(this.realWidth)&&y.default.isPow2(this.realHeight)},e.prototype.loadSource=function(t){var e=this,r=this.isLoading;this.hasLoaded=!1,this.isLoading=!1,r&&this.source&&(this.source.onload=null,this.source.onerror=null);var n=!this.source;if(this.source=t,(t.src&&t.complete||t.getContext)&&t.width&&t.height)this._updateImageType(),"svg"===this.imageType?this._loadSvgSource():this._sourceLoaded(),n&&this.emit("loaded",this);else if(!t.getContext){var i=function(){e.isLoading=!0;var n=e;if(t.onload=function(){if(n._updateImageType(),t.onload=null,t.onerror=null,n.isLoading)return n.isLoading=!1,n._sourceLoaded(),"svg"===n.imageType?void n._loadSvgSource():void n.emit("loaded",n)},t.onerror=function(){t.onload=null,t.onerror=null,n.isLoading&&(n.isLoading=!1,n.emit("error",n))},t.complete&&t.src){if(t.onload=null,t.onerror=null,"svg"===n.imageType)return n._loadSvgSource(),{v:void 0};e.isLoading=!1,t.width&&t.height?(e._sourceLoaded(),r&&e.emit("loaded",e)):r&&e.emit("error",e)}}();if("object"===("undefined"==typeof i?"undefined":a(i)))return i.v}},e.prototype._updateImageType=function(){if(this.imageUrl){var t=(0,u.decomposeDataUri)(this.imageUrl),e=void 0;if(t&&"image"===t.mediaType){var r=t.subType.split("+")[0];if(e=(0,u.getUrlFileExtension)("."+r),!e)throw new Error("Invalid image type in data URI.")}else e=(0,u.getUrlFileExtension)(this.imageUrl),e||(e="png");this.imageType=e}},e.prototype._loadSvgSource=function(){if("svg"===this.imageType){var t=(0,u.decomposeDataUri)(this.imageUrl);t?this._loadSvgSourceUsingDataUri(t):this._loadSvgSourceUsingXhr()}},e.prototype._loadSvgSourceUsingDataUri=function(t){var e=void 0;if("base64"===t.encoding){if(!atob)throw new Error("Your browser doesn't support base64 conversions.");e=atob(t.data)}else e=t.data;this._loadSvgSourceUsingString(e)},e.prototype._loadSvgSourceUsingXhr=function(){var t=this,e=new XMLHttpRequest;e.onload=function(){if(e.readyState!==e.DONE||200!==e.status)throw new Error("Failed to load SVG using XHR.");t._loadSvgSourceUsingString(e.response)},e.onerror=function(){return t.emit("error",t)},e.open("GET",this.imageUrl,!0),e.send()},e.prototype._loadSvgSourceUsingString=function(t){var r=(0,u.getSvgSize)(t),n=r.width,i=r.height;if(!n||!i)throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");this.realWidth=Math.round(n*this.sourceScale),this.realHeight=Math.round(i*this.sourceScale),this._updateDimensions();var o=document.createElement("canvas");o.width=this.realWidth,o.height=this.realHeight,o._pixiId="canvas_"+(0,u.uid)(),o.getContext("2d").drawImage(this.source,0,0,n,i,0,0,this.realWidth,this.realHeight),this.origSource=this.source,this.source=o,e.addToCache(this,o._pixiId),this.isLoading=!1,this._sourceLoaded(),this.emit("loaded",this)},e.prototype._sourceLoaded=function(){this.hasLoaded=!0,this.update()},e.prototype.destroy=function(){this.imageUrl&&(delete u.TextureCache[this.imageUrl],this.imageUrl=null,navigator.isCocoonJS||(this.source.src="")),this.source=null,this.dispose(),e.removeFromCache(this),this.textureCacheIds=null,this._destroyed=!0},e.prototype.dispose=function(){this.emit("dispose",this)},e.prototype.updateSourceImage=function(t){this.source.src=t,this.loadSource(this.source)},e.fromImage=function(t,r,n,i){var o=u.BaseTextureCache[t];if(!o){var s=new Image;void 0===r&&0!==t.indexOf("data:")?s.crossOrigin=(0,p.default)(t):r&&(s.crossOrigin="string"==typeof r?r:"anonymous"),o=new e(s,n),o.imageUrl=t,i&&(o.sourceScale=i),o.resolution=(0,u.getResolutionOfUrl)(t),s.src=t,e.addToCache(o,t)}return o},e.fromCanvas=function(t,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"canvas";t._pixiId||(t._pixiId=n+"_"+(0,u.uid)());var i=u.BaseTextureCache[t._pixiId];return i||(i=new e(t,r),e.addToCache(i,t._pixiId)),i},e.from=function(t,r,n){if("string"==typeof t)return e.fromImage(t,void 0,r,n);if(t instanceof HTMLImageElement){var i=t.src,o=u.BaseTextureCache[i];return o||(o=new e(t,r),o.imageUrl=i,n&&(o.sourceScale=n),o.resolution=(0,u.getResolutionOfUrl)(i),e.addToCache(o,i)),o}return t instanceof HTMLCanvasElement?e.fromCanvas(t,r):t},e.addToCache=function(t,e){e&&(t.textureCacheIds.indexOf(e)===-1&&t.textureCacheIds.push(e),u.BaseTextureCache[e]=t)},e.removeFromCache=function(t){if("string"==typeof t){var e=u.BaseTextureCache[t];if(e){var r=e.textureCacheIds.indexOf(t);return r>-1&&e.textureCacheIds.splice(r,1),delete u.BaseTextureCache[t],e}}else if(t&&t.textureCacheIds){for(var n=0;n<t.textureCacheIds.length;++n)delete u.BaseTextureCache[t.textureCacheIds[n]];return t.textureCacheIds.length=0,t}return null},e}(d.default);r.default=g},{"../settings":100,"../utils":123,"../utils/determineCrossOrigin":122,"bit-twiddle":1,eventemitter3:3}],112:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("./BaseRenderTexture"),u=n(a),h=t("./Texture"),l=n(h),c=function(t){function e(r,n){i(this,e);var s=null;if(!(r instanceof u.default)){var a=arguments[1],h=arguments[2],l=arguments[3],c=arguments[4];console.warn("Please use RenderTexture.create("+a+", "+h+") instead of the ctor directly."),s=arguments[0],n=null,r=new u.default(a,h,l,c)}var d=o(this,t.call(this,r,n));return d.legacyRenderer=s,d.valid=!0,d._updateUvs(),d}return s(e,t),e.prototype.resize=function(t,e,r){this.valid=t>0&&e>0,this._frame.width=this.orig.width=t,this._frame.height=this.orig.height=e,r||this.baseTexture.resize(t,e),this._updateUvs()},e.create=function(t,r,n,i){return new e(new u.default(t,r,n,i))},e}(l.default);r.default=c},{"./BaseRenderTexture":110,"./Texture":114}],113:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),o=t("../"),s=t("../utils"),a=function(){function t(e,r){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;n(this,t),this.baseTexture=e,this.textures={},this.data=r,this.resolution=this._updateResolution(i||this.baseTexture.imageUrl),this._frames=this.data.frames,this._frameKeys=Object.keys(this._frames),this._batchIndex=0,this._callback=null}return i(t,null,[{key:"BATCH_SIZE",get:function(){return 1e3}}]),t.prototype._updateResolution=function(t){var e=this.data.meta.scale,r=(0,s.getResolutionOfUrl)(t,null);return null===r&&(r=void 0!==e?parseFloat(e):1),1!==r&&(this.baseTexture.resolution=r,this.baseTexture.update()),r},t.prototype.parse=function(e){this._batchIndex=0,this._callback=e,this._frameKeys.length<=t.BATCH_SIZE?(this._processFrames(0),this._parseComplete()):this._nextBatch()},t.prototype._processFrames=function(e){for(var r=e,n=t.BATCH_SIZE;r-e<n&&r<this._frameKeys.length;){var i=this._frameKeys[r],s=this._frames[i].frame;if(s){var a=null,u=null,h=new o.Rectangle(0,0,this._frames[i].sourceSize.w/this.resolution,this._frames[i].sourceSize.h/this.resolution);a=this._frames[i].rotated?new o.Rectangle(s.x/this.resolution,s.y/this.resolution,s.h/this.resolution,s.w/this.resolution):new o.Rectangle(s.x/this.resolution,s.y/this.resolution,s.w/this.resolution,s.h/this.resolution),this._frames[i].trimmed&&(u=new o.Rectangle(this._frames[i].spriteSourceSize.x/this.resolution,this._frames[i].spriteSourceSize.y/this.resolution,s.w/this.resolution,s.h/this.resolution)),this.textures[i]=new o.Texture(this.baseTexture,a,h,u,this._frames[i].rotated?2:0),o.Texture.addToCache(this.textures[i],i)}r++}},t.prototype._parseComplete=function(){var t=this._callback;this._callback=null,this._batchIndex=0,t.call(this,this.textures)},t.prototype._nextBatch=function(){var e=this;this._processFrames(this._batchIndex*t.BATCH_SIZE),this._batchIndex++,setTimeout(function(){e._batchIndex*t.BATCH_SIZE<e._frameKeys.length?e._nextBatch():e._parseComplete()},0)},t.prototype.destroy=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];for(var e in this.textures)this.textures[e].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,t&&this.baseTexture.destroy(),this.baseTexture=null},t}();r.default=a},{"../":64,"../utils":123}],114:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(){var t=document.createElement("canvas");t.width=10,t.height=10;var e=t.getContext("2d");return e.fillStyle="white",e.fillRect(0,0,10,10),new T(new c.default(t))}function u(t){t.destroy=function(){},t.on=function(){},t.once=function(){},t.emit=function(){}}r.__esModule=!0;var h=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),l=t("./BaseTexture"),c=n(l),d=t("./VideoBaseTexture"),f=n(d),p=t("./TextureUvs"),v=n(p),y=t("eventemitter3"),g=n(y),m=t("../math"),_=t("../utils"),b=t("../settings"),x=n(b),T=function(t){function e(r,n,s,a,u){i(this,e);var h=o(this,t.call(this));if(h.noFrame=!1,n||(h.noFrame=!0,n=new m.Rectangle(0,0,1,1)),r instanceof e&&(r=r.baseTexture),h.baseTexture=r,h._frame=n,h.trim=a,h.valid=!1,h.requiresUpdate=!1,h._uvs=null,h.orig=s||n,h._rotate=Number(u||0),u===!0)h._rotate=2;else if(h._rotate%2!==0)throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");return r.hasLoaded?(h.noFrame&&(n=new m.Rectangle(0,0,r.width,r.height),r.on("update",h.onBaseTextureUpdated,h)),h.frame=n):r.once("loaded",h.onBaseTextureLoaded,h),h._updateID=0,h.transform=null,h.textureCacheIds=[],h}return s(e,t),e.prototype.update=function(){this.baseTexture.update()},e.prototype.onBaseTextureLoaded=function(t){this._updateID++,this.noFrame?this.frame=new m.Rectangle(0,0,t.width,t.height):this.frame=this._frame,this.baseTexture.on("update",this.onBaseTextureUpdated,this),this.emit("update",this)},e.prototype.onBaseTextureUpdated=function(t){this._updateID++,this._frame.width=t.width,this._frame.height=t.height,this.emit("update",this)},e.prototype.destroy=function(t){this.baseTexture&&(t&&(_.TextureCache[this.baseTexture.imageUrl]&&e.removeFromCache(this.baseTexture.imageUrl),this.baseTexture.destroy()),this.baseTexture.off("update",this.onBaseTextureUpdated,this),this.baseTexture.off("loaded",this.onBaseTextureLoaded,this),this.baseTexture=null),this._frame=null,this._uvs=null,this.trim=null,this.orig=null,this.valid=!1,e.removeFromCache(this),this.textureCacheIds=null},e.prototype.clone=function(){return new e(this.baseTexture,this.frame,this.orig,this.trim,this.rotate)},e.prototype._updateUvs=function(){this._uvs||(this._uvs=new v.default),this._uvs.set(this._frame,this.baseTexture,this.rotate),this._updateID++},e.fromImage=function(t,r,n,i){var o=_.TextureCache[t];return o||(o=new e(c.default.fromImage(t,r,n,i)),e.addToCache(o,t)),o},e.fromFrame=function(t){var e=_.TextureCache[t];if(!e)throw new Error('The frameId "'+t+'" does not exist in the texture cache');return e},e.fromCanvas=function(t,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"canvas";return new e(c.default.fromCanvas(t,r,n))},e.fromVideo=function(t,r){return"string"==typeof t?e.fromVideoUrl(t,r):new e(f.default.fromVideo(t,r))},e.fromVideoUrl=function(t,r){return new e(f.default.fromUrl(t,r))},e.from=function(t){if("string"==typeof t){var r=_.TextureCache[t];if(!r){var n=null!==t.match(/\.(mp4|webm|ogg|h264|avi|mov)$/);return n?e.fromVideoUrl(t):e.fromImage(t)}return r}return t instanceof HTMLImageElement?new e(c.default.from(t)):t instanceof HTMLCanvasElement?e.fromCanvas(t,x.default.SCALE_MODE,"HTMLCanvasElement"):t instanceof HTMLVideoElement?e.fromVideo(t):t instanceof c.default?new e(t):t},e.fromLoader=function(t,r,n){var i=new c.default(t,(void 0),(0,_.getResolutionOfUrl)(r)),o=new e(i);return i.imageUrl=r,n||(n=r),c.default.addToCache(o.baseTexture,n),e.addToCache(o,n),n!==r&&(c.default.addToCache(o.baseTexture,r),e.addToCache(o,r)),o},e.addToCache=function(t,e){e&&(t.textureCacheIds.indexOf(e)===-1&&t.textureCacheIds.push(e),_.TextureCache[e]=t)},e.removeFromCache=function(t){if("string"==typeof t){var e=_.TextureCache[t];if(e){var r=e.textureCacheIds.indexOf(t);return r>-1&&e.textureCacheIds.splice(r,1),delete _.TextureCache[t],e}}else if(t&&t.textureCacheIds){for(var n=0;n<t.textureCacheIds.length;++n)delete _.TextureCache[t.textureCacheIds[n]];return t.textureCacheIds.length=0,t}return null},h(e,[{key:"frame",get:function(){return this._frame},set:function(t){if(this._frame=t,this.noFrame=!1,t.x+t.width>this.baseTexture.width||t.y+t.height>this.baseTexture.height)throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: "+("X: "+t.x+" + "+t.width+" > "+this.baseTexture.width+" ")+("Y: "+t.y+" + "+t.height+" > "+this.baseTexture.height));this.valid=t&&t.width&&t.height&&this.baseTexture.hasLoaded,this.trim||this.rotate||(this.orig=t),this.valid&&this._updateUvs()}},{key:"rotate",get:function(){return this._rotate},set:function(t){this._rotate=t,this.valid&&this._updateUvs()}},{key:"width",get:function(){return this.orig.width}},{key:"height",get:function(){return this.orig.height}}]),e}(g.default);r.default=T,T.EMPTY=new T(new c.default),u(T.EMPTY),u(T.EMPTY.baseTexture),T.WHITE=a(),u(T.WHITE),u(T.WHITE.baseTexture)},{"../math":69,"../settings":100,"../utils":123,"./BaseTexture":111,"./TextureUvs":115,"./VideoBaseTexture":116,eventemitter3:3}],115:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("../math/GroupD8"),s=n(o),a=function(){function t(){i(this,t),this.x0=0,this.y0=0,this.x1=1,this.y1=0,this.x2=1,this.y2=1,this.x3=0,this.y3=1,this.uvsUint32=new Uint32Array(4)}return t.prototype.set=function(t,e,r){var n=e.width,i=e.height;if(r){var o=t.width/2/n,a=t.height/2/i,u=t.x/n+o,h=t.y/i+a;r=s.default.add(r,s.default.NW),this.x0=u+o*s.default.uX(r),this.y0=h+a*s.default.uY(r),r=s.default.add(r,2),this.x1=u+o*s.default.uX(r),
    this.y1=h+a*s.default.uY(r),r=s.default.add(r,2),this.x2=u+o*s.default.uX(r),this.y2=h+a*s.default.uY(r),r=s.default.add(r,2),this.x3=u+o*s.default.uX(r),this.y3=h+a*s.default.uY(r)}else this.x0=t.x/n,this.y0=t.y/i,this.x1=(t.x+t.width)/n,this.y1=t.y/i,this.x2=(t.x+t.width)/n,this.y2=(t.y+t.height)/i,this.x3=t.x/n,this.y3=(t.y+t.height)/i;this.uvsUint32[0]=(65535*this.y0&65535)<<16|65535*this.x0&65535,this.uvsUint32[1]=(65535*this.y1&65535)<<16|65535*this.x1&65535,this.uvsUint32[2]=(65535*this.y2&65535)<<16|65535*this.x2&65535,this.uvsUint32[3]=(65535*this.y3&65535)<<16|65535*this.x3&65535},t}();r.default=a},{"../math/GroupD8":65}],116:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t,e){e||(e="video/"+t.substr(t.lastIndexOf(".")+1));var r=document.createElement("source");return r.src=t,r.type=e,r}r.__esModule=!0;var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=t("./BaseTexture"),l=n(h),c=t("../utils"),d=t("../ticker"),f=t("../const"),p=function(t){function e(r,n){if(i(this,e),!r)throw new Error("No video source element specified.");(r.readyState===r.HAVE_ENOUGH_DATA||r.readyState===r.HAVE_FUTURE_DATA)&&r.width&&r.height&&(r.complete=!0);var s=o(this,t.call(this,r,n));return s.width=r.videoWidth,s.height=r.videoHeight,s._autoUpdate=!0,s._isAutoUpdating=!1,s.autoPlay=!0,s.update=s.update.bind(s),s._onCanPlay=s._onCanPlay.bind(s),r.addEventListener("play",s._onPlayStart.bind(s)),r.addEventListener("pause",s._onPlayStop.bind(s)),s.hasLoaded=!1,s.__loaded=!1,s._isSourceReady()?s._onCanPlay():(r.addEventListener("canplay",s._onCanPlay),r.addEventListener("canplaythrough",s._onCanPlay)),s}return s(e,t),e.prototype._isSourcePlaying=function(){var t=this.source;return t.currentTime>0&&t.paused===!1&&t.ended===!1&&t.readyState>2},e.prototype._isSourceReady=function(){return 3===this.source.readyState||4===this.source.readyState},e.prototype._onPlayStart=function(){this.hasLoaded||this._onCanPlay(),!this._isAutoUpdating&&this.autoUpdate&&(d.shared.add(this.update,this,f.UPDATE_PRIORITY.HIGH),this._isAutoUpdating=!0)},e.prototype._onPlayStop=function(){this._isAutoUpdating&&(d.shared.remove(this.update,this),this._isAutoUpdating=!1)},e.prototype._onCanPlay=function(){this.hasLoaded=!0,this.source&&(this.source.removeEventListener("canplay",this._onCanPlay),this.source.removeEventListener("canplaythrough",this._onCanPlay),this.width=this.source.videoWidth,this.height=this.source.videoHeight,this.__loaded||(this.__loaded=!0,this.emit("loaded",this)),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&this.source.play())},e.prototype.destroy=function(){this._isAutoUpdating&&d.shared.remove(this.update,this),this.source&&this.source._pixiId&&(l.default.removeFromCache(this.source._pixiId),delete this.source._pixiId),t.prototype.destroy.call(this)},e.fromVideo=function(t,r){t._pixiId||(t._pixiId="video_"+(0,c.uid)());var n=c.BaseTextureCache[t._pixiId];return n||(n=new e(t,r),l.default.addToCache(n,t._pixiId)),n},e.fromUrl=function(t,r){var n=document.createElement("video");if(n.setAttribute("webkit-playsinline",""),n.setAttribute("playsinline",""),Array.isArray(t))for(var i=0;i<t.length;++i)n.appendChild(a(t[i].src||t[i],t[i].mime));else n.appendChild(a(t.src||t,t.mime));return n.load(),e.fromVideo(n,r)},u(e,[{key:"autoUpdate",get:function(){return this._autoUpdate},set:function(t){t!==this._autoUpdate&&(this._autoUpdate=t,!this._autoUpdate&&this._isAutoUpdating?(d.shared.remove(this.update,this),this._isAutoUpdating=!1):this._autoUpdate&&!this._isAutoUpdating&&(d.shared.add(this.update,this,f.UPDATE_PRIORITY.HIGH),this._isAutoUpdating=!0))}}]),e}(l.default);r.default=p,p.fromUrls=p.fromUrl},{"../const":45,"../ticker":119,"../utils":123,"./BaseTexture":111}],117:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=t("../settings"),a=n(s),u=t("../const"),h=t("./TickerListener"),l=n(h),c=function(){function t(){var e=this;i(this,t),this._head=new l.default(null,null,1/0),this._requestId=null,this._maxElapsedMS=100,this.autoStart=!1,this.deltaTime=1,this.elapsedMS=1/a.default.TARGET_FPMS,this.lastTime=0,this.speed=1,this.started=!1,this._tick=function(t){e._requestId=null,e.started&&(e.update(t),e.started&&null===e._requestId&&e._head.next&&(e._requestId=requestAnimationFrame(e._tick)))}}return t.prototype._requestIfNeeded=function(){null===this._requestId&&this._head.next&&(this.lastTime=performance.now(),this._requestId=requestAnimationFrame(this._tick))},t.prototype._cancelIfNeeded=function(){null!==this._requestId&&(cancelAnimationFrame(this._requestId),this._requestId=null)},t.prototype._startIfPossible=function(){this.started?this._requestIfNeeded():this.autoStart&&this.start()},t.prototype.add=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:u.UPDATE_PRIORITY.NORMAL;return this._addListener(new l.default(t,e,r))},t.prototype.addOnce=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:u.UPDATE_PRIORITY.NORMAL;return this._addListener(new l.default(t,e,r,(!0)))},t.prototype._addListener=function(t){var e=this._head.next,r=this._head;if(e){for(;e;){if(t.priority>e.priority){t.connect(r);break}r=e,e=e.next}t.previous||t.connect(r)}else t.connect(r);return this._startIfPossible(),this},t.prototype.remove=function(t,e){for(var r=this._head.next;r;)r=r.match(t,e)?r.destroy():r.next;return this._head.next||this._cancelIfNeeded(),this},t.prototype.start=function(){this.started||(this.started=!0,this._requestIfNeeded())},t.prototype.stop=function(){this.started&&(this.started=!1,this._cancelIfNeeded())},t.prototype.destroy=function(){this.stop();for(var t=this._head.next;t;)t=t.destroy(!0);this._head.destroy(),this._head=null},t.prototype.update=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:performance.now(),e=void 0;if(t>this.lastTime){e=this.elapsedMS=t-this.lastTime,e>this._maxElapsedMS&&(e=this._maxElapsedMS),this.deltaTime=e*a.default.TARGET_FPMS*this.speed;for(var r=this._head,n=r.next;n;)n=n.emit(this.deltaTime);r.next||this._cancelIfNeeded()}else this.deltaTime=this.elapsedMS=0;this.lastTime=t},o(t,[{key:"FPS",get:function(){return 1e3/this.elapsedMS}},{key:"minFPS",get:function(){return 1e3/this._maxElapsedMS},set:function(t){var e=Math.min(Math.max(0,t)/1e3,a.default.TARGET_FPMS);this._maxElapsedMS=1/e}}]),t}();r.default=c},{"../const":45,"../settings":100,"./TickerListener":118}],118:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];n(this,t),this.fn=e,this.context=r,this.priority=i,this.once=o,this.next=null,this.previous=null,this._destroyed=!1}return t.prototype.match=function(t,e){return e=e||null,this.fn===t&&this.context===e},t.prototype.emit=function(t){this.fn&&(this.context?this.fn.call(this.context,t):this.fn(t));var e=this.next;return this.once&&this.destroy(!0),this._destroyed&&(this.next=null),e},t.prototype.connect=function(t){this.previous=t,t.next&&(t.next.previous=this),this.next=t.next,t.next=this},t.prototype.destroy=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._destroyed=!0,this.fn=null,this.context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);var e=this.previous;return this.next=t?null:e,this.previous=null,e},t}();r.default=i},{}],119:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0,r.Ticker=r.shared=void 0;var i=t("./Ticker"),o=n(i),s=new o.default;s.autoStart=!0,s.destroy=function(){},r.shared=s,r.Ticker=o.default},{"./Ticker":117}],120:[function(t,e,r){"use strict";function n(){var t=!!navigator.platform&&/iPad|iPhone|iPod/.test(navigator.platform);return!t}r.__esModule=!0,r.default=n},{}],121:[function(t,e,r){"use strict";function n(t){for(var e=6*t,r=new Uint16Array(e),n=0,i=0;n<e;n+=6,i+=4)r[n+0]=i+0,r[n+1]=i+1,r[n+2]=i+2,r[n+3]=i+0,r[n+4]=i+2,r[n+5]=i+3;return r}r.__esModule=!0,r.default=n},{}],122:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location;if(0===t.indexOf("data:"))return"";e=e||window.location,a||(a=document.createElement("a")),a.href=t,t=s.default.parse(a.href);var r=!t.port&&""===e.port||t.port===e.port;return t.hostname===e.hostname&&r&&t.protocol===e.protocol?"":"anonymous"}r.__esModule=!0,r.default=i;var o=t("url"),s=n(o),a=void 0},{url:28}],123:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t){return t&&t.__esModule?t:{default:t}}function o(){return++k}function s(t,e){return e=e||[],e[0]=(t>>16&255)/255,e[1]=(t>>8&255)/255,e[2]=(255&t)/255,e}function a(t){return t=t.toString(16),t="000000".substr(0,6-t.length)+t,"#"+t}function u(t){return(255*t[0]<<16)+(255*t[1]<<8)+(255*t[2]|0)}function h(t,e){var r=S.default.RETINA_PREFIX.exec(t);return r?parseFloat(r[1]):void 0!==e?e:1}function l(t){var e=w.DATA_URI.exec(t);if(e)return{mediaType:e[1]?e[1].toLowerCase():void 0,subType:e[2]?e[2].toLowerCase():void 0,encoding:e[3]?e[3].toLowerCase():void 0,data:e[4]}}function c(t){var e=w.URL_FILE_EXTENSION.exec(t);if(e)return e[1].toLowerCase()}function d(t){var e=w.SVG_SIZE.exec(t),r={};return e&&(r[e[1]]=Math.round(parseFloat(e[3])),r[e[5]]=Math.round(parseFloat(e[7]))),r}function f(){j=!0}function p(t){if(!j){if(navigator.userAgent.toLowerCase().indexOf("chrome")>-1){var e=["\n %c %c %c Pixi.js "+w.VERSION+" -  "+t+"   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n","background: #ff66a5; padding:5px 0;","background: #ff66a5; padding:5px 0;","color: #ff66a5; background: #030307; padding:5px 0;","background: #ff66a5; padding:5px 0;","background: #ffc3dc; padding:5px 0;","background: #ff66a5; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;"];window.console.log.apply(console,e)}else window.console&&window.console.log("Pixi.js "+w.VERSION+" - "+t+" - http://www.pixijs.com/");j=!0}}function v(){var t={stencil:!0,failIfMajorPerformanceCaveat:!0};try{if(!window.WebGLRenderingContext)return!1;var e=document.createElement("canvas"),r=e.getContext("webgl",t)||e.getContext("experimental-webgl",t),n=!(!r||!r.getContextAttributes().stencil);if(r){var i=r.getExtension("WEBGL_lose_context");i&&i.loseContext()}return r=null,n}catch(t){return!1}}function y(t){return 0===t?0:t<0?-1:1}function g(){var t=void 0;for(t in U)U[t].destroy();for(t in X)X[t].destroy()}function m(){var t=void 0;for(t in U)delete U[t];for(t in X)delete X[t]}function _(t,e){return G[e?1:0][t]}function b(t,e){if(1===e)return(255*e<<24)+t;if(0===e)return 0;var r=t>>16&255,n=t>>8&255,i=255&t;return r=r*e+.5|0,n=n*e+.5|0,i=i*e+.5|0,(255*e<<24)+(r<<16)+(n<<8)+i}function x(t,e,r,n){return r=r||new Float32Array(4),n||void 0===n?(r[0]=t[0]*e,r[1]=t[1]*e,r[2]=t[2]*e):(r[0]=t[0],r[1]=t[1],r[2]=t[2]),r[3]=e,r}function T(t,e,r,n){return r=r||new Float32Array(4),r[0]=(t>>16&255)/255,r[1]=(t>>8&255)/255,r[2]=(255&t)/255,(n||void 0===n)&&(r[0]*=e,r[1]*=e,r[2]*=e),r[3]=e,r}r.__esModule=!0,r.premultiplyBlendMode=r.BaseTextureCache=r.TextureCache=r.mixins=r.pluginTarget=r.EventEmitter=r.removeItems=r.isMobile=void 0,r.uid=o,r.hex2rgb=s,r.hex2string=a,r.rgb2hex=u,r.getResolutionOfUrl=h,r.decomposeDataUri=l,r.getUrlFileExtension=c,r.getSvgSize=d,r.skipHello=f,r.sayHello=p,r.isWebGLSupported=v,r.sign=y,r.destroyTextureCache=g,r.clearTextureCache=m,r.correctBlendMode=_,r.premultiplyTint=b,r.premultiplyRgba=x,r.premultiplyTintToRgba=T;var w=t("../const"),E=t("../settings"),S=i(E),O=t("eventemitter3"),P=i(O),M=t("./pluginTarget"),C=i(M),R=t("./mixin"),A=n(R),I=t("ismobilejs"),D=n(I),L=t("remove-array-items"),N=i(L),F=t("./mapPremultipliedBlendModes"),B=i(F),k=0,j=!1;r.isMobile=D,r.removeItems=N.default,r.EventEmitter=P.default,r.pluginTarget=C.default,r.mixins=A;var U=r.TextureCache=Object.create(null),X=r.BaseTextureCache=Object.create(null),G=r.premultiplyBlendMode=(0,B.default)()},{"../const":45,"../settings":100,"./mapPremultipliedBlendModes":124,"./mixin":126,"./pluginTarget":127,eventemitter3:3,ismobilejs:4,"remove-array-items":30}],124:[function(t,e,r){"use strict";function n(){for(var t=[],e=[],r=0;r<32;r++)t[r]=r,e[r]=r;t[i.BLEND_MODES.NORMAL_NPM]=i.BLEND_MODES.NORMAL,t[i.BLEND_MODES.ADD_NPM]=i.BLEND_MODES.ADD,t[i.BLEND_MODES.SCREEN_NPM]=i.BLEND_MODES.SCREEN,e[i.BLEND_MODES.NORMAL]=i.BLEND_MODES.NORMAL_NPM,e[i.BLEND_MODES.ADD]=i.BLEND_MODES.ADD_NPM,e[i.BLEND_MODES.SCREEN]=i.BLEND_MODES.SCREEN_NPM;var n=[];return n.push(e),n.push(t),n}r.__esModule=!0,r.default=n;var i=t("../const")},{"../const":45}],125:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){return s.default.tablet||s.default.phone?4:t}r.__esModule=!0,r.default=i;var o=t("ismobilejs"),s=n(o)},{ismobilejs:4}],126:[function(t,e,r){"use strict";function n(t,e){if(t&&e)for(var r=Object.keys(e),n=0;n<r.length;++n){var i=r[n];Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(e,i))}}function i(t,e){s.push(t,e)}function o(){for(var t=0;t<s.length;t+=2)n(s[t],s[t+1]);s.length=0}r.__esModule=!0,r.mixin=n,r.delayMixin=i,r.performMixins=o;var s=[]},{}],127:[function(t,e,r){"use strict";function n(t){t.__plugins={},t.registerPlugin=function(e,r){t.__plugins[e]=r},t.prototype.initPlugins=function(){this.plugins=this.plugins||{};for(var e in t.__plugins)this.plugins[e]=new t.__plugins[e](this)},t.prototype.destroyPlugins=function(){for(var t in this.plugins)this.plugins[t].destroy(),this.plugins[t]=null;this.plugins=null}}r.__esModule=!0,r.default={mixin:function(t){n(t)}}},{}],128:[function(t,e,r){"use strict";function n(t){var e=t.width,r=t.height,n=t.getContext("2d"),i=n.getImageData(0,0,e,r),o=i.data,s=o.length,a={top:null,left:null,right:null,bottom:null},u=void 0,h=void 0,l=void 0;for(u=0;u<s;u+=4)0!==o[u+3]&&(h=u/4%e,l=~~(u/4/e),null===a.top&&(a.top=l),null===a.left?a.left=h:h<a.left&&(a.left=h),null===a.right?a.right=h+1:a.right<h&&(a.right=h+1),null===a.bottom?a.bottom=l:a.bottom<l&&(a.bottom=l));e=a.right-a.left,r=a.bottom-a.top+1;var c=n.getImageData(a.left,a.top,e,r);return{height:r,width:e,data:c}}r.__esModule=!0,r.default=n},{}],129:[function(t,e,r){"use strict";function n(t){}function i(t){var e=t.mesh,r=t.particles,i=t.extras,o=t.filters,s=t.prepare,a=t.loaders,u=t.interaction;Object.defineProperties(t,{SpriteBatch:{get:function(){throw new ReferenceError("SpriteBatch does not exist any more, please use the new ParticleContainer instead.")}},AssetLoader:{get:function(){throw new ReferenceError("The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.")}},Stage:{get:function(){return n("You do not need to use a PIXI Stage any more, you can simply render any container."),t.Container}},DisplayObjectContainer:{get:function(){return n("DisplayObjectContainer has been shortened to Container, please use Container from now on."),t.Container}},Strip:{get:function(){return n("The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on."),e.Mesh}},Rope:{get:function(){return n("The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on."),e.Rope}},ParticleContainer:{get:function(){return n("The ParticleContainer class has been moved to particles.ParticleContainer, please use particles.ParticleContainer from now on."),r.ParticleContainer}},MovieClip:{get:function(){return n("The MovieClip class has been moved to extras.AnimatedSprite, please use extras.AnimatedSprite."),i.AnimatedSprite}},TilingSprite:{get:function(){return n("The TilingSprite class has been moved to extras.TilingSprite, please use extras.TilingSprite from now on."),i.TilingSprite}},BitmapText:{get:function(){return n("The BitmapText class has been moved to extras.BitmapText, please use extras.BitmapText from now on."),i.BitmapText}},blendModes:{get:function(){return n("The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on."),t.BLEND_MODES}},scaleModes:{get:function(){return n("The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on."),t.SCALE_MODES}},BaseTextureCache:{get:function(){return n("The BaseTextureCache class has been moved to utils.BaseTextureCache, please use utils.BaseTextureCache from now on."),t.utils.BaseTextureCache}},TextureCache:{get:function(){return n("The TextureCache class has been moved to utils.TextureCache, please use utils.TextureCache from now on."),t.utils.TextureCache}},math:{get:function(){return n("The math namespace is deprecated, please access members already accessible on PIXI."),t}},AbstractFilter:{get:function(){return n("AstractFilter has been renamed to Filter, please use PIXI.Filter"),t.Filter}},TransformManual:{get:function(){return n("TransformManual has been renamed to TransformBase, please update your pixi-spine"),t.TransformBase}},TARGET_FPMS:{get:function(){return n("PIXI.TARGET_FPMS has been deprecated, please use PIXI.settings.TARGET_FPMS"),t.settings.TARGET_FPMS},set:function(e){n("PIXI.TARGET_FPMS has been deprecated, please use PIXI.settings.TARGET_FPMS"),t.settings.TARGET_FPMS=e}},FILTER_RESOLUTION:{get:function(){return n("PIXI.FILTER_RESOLUTION has been deprecated, please use PIXI.settings.FILTER_RESOLUTION"),t.settings.FILTER_RESOLUTION},set:function(e){n("PIXI.FILTER_RESOLUTION has been deprecated, please use PIXI.settings.FILTER_RESOLUTION"),t.settings.FILTER_RESOLUTION=e}},RESOLUTION:{get:function(){return n("PIXI.RESOLUTION has been deprecated, please use PIXI.settings.RESOLUTION"),t.settings.RESOLUTION},set:function(e){n("PIXI.RESOLUTION has been deprecated, please use PIXI.settings.RESOLUTION"),t.settings.RESOLUTION=e}},MIPMAP_TEXTURES:{get:function(){return n("PIXI.MIPMAP_TEXTURES has been deprecated, please use PIXI.settings.MIPMAP_TEXTURES"),t.settings.MIPMAP_TEXTURES},set:function(e){n("PIXI.MIPMAP_TEXTURES has been deprecated, please use PIXI.settings.MIPMAP_TEXTURES"),t.settings.MIPMAP_TEXTURES=e}},SPRITE_BATCH_SIZE:{get:function(){return n("PIXI.SPRITE_BATCH_SIZE has been deprecated, please use PIXI.settings.SPRITE_BATCH_SIZE"),t.settings.SPRITE_BATCH_SIZE},set:function(e){n("PIXI.SPRITE_BATCH_SIZE has been deprecated, please use PIXI.settings.SPRITE_BATCH_SIZE"),t.settings.SPRITE_BATCH_SIZE=e}},SPRITE_MAX_TEXTURES:{get:function(){return n("PIXI.SPRITE_MAX_TEXTURES has been deprecated, please use PIXI.settings.SPRITE_MAX_TEXTURES"),t.settings.SPRITE_MAX_TEXTURES},set:function(e){n("PIXI.SPRITE_MAX_TEXTURES has been deprecated, please use PIXI.settings.SPRITE_MAX_TEXTURES"),t.settings.SPRITE_MAX_TEXTURES=e}},RETINA_PREFIX:{get:function(){return n("PIXI.RETINA_PREFIX has been deprecated, please use PIXI.settings.RETINA_PREFIX"),t.settings.RETINA_PREFIX},set:function(e){n("PIXI.RETINA_PREFIX has been deprecated, please use PIXI.settings.RETINA_PREFIX"),t.settings.RETINA_PREFIX=e}},DEFAULT_RENDER_OPTIONS:{get:function(){return n("PIXI.DEFAULT_RENDER_OPTIONS has been deprecated, please use PIXI.settings.DEFAULT_RENDER_OPTIONS"),t.settings.RENDER_OPTIONS}}});for(var h=[{parent:"TRANSFORM_MODE",target:"TRANSFORM_MODE"},{parent:"GC_MODES",target:"GC_MODE"},{parent:"WRAP_MODES",target:"WRAP_MODE"},{parent:"SCALE_MODES",target:"SCALE_MODE"},{parent:"PRECISION",target:"PRECISION_FRAGMENT"}],l=function(e){var r=h[e];Object.defineProperty(t[r.parent],"DEFAULT",{get:function(){return n("PIXI."+r.parent+".DEFAULT has been deprecated, please use PIXI.settings."+r.target),t.settings[r.target]},set:function(e){n("PIXI."+r.parent+".DEFAULT has been deprecated, please use PIXI.settings."+r.target),t.settings[r.target]=e}})},c=0;c<h.length;c++)l(c);Object.defineProperties(t.settings,{PRECISION:{get:function(){return n("PIXI.settings.PRECISION has been deprecated, please use PIXI.settings.PRECISION_FRAGMENT"),t.settings.PRECISION_FRAGMENT},set:function(e){n("PIXI.settings.PRECISION has been deprecated, please use PIXI.settings.PRECISION_FRAGMENT"),t.settings.PRECISION_FRAGMENT=e}}}),i.AnimatedSprite&&Object.defineProperties(i,{MovieClip:{get:function(){return n("The MovieClip class has been renamed to AnimatedSprite, please use AnimatedSprite from now on."),i.AnimatedSprite}}}),t.DisplayObject.prototype.generateTexture=function(t,e,r){return n("generateTexture has moved to the renderer, please use renderer.generateTexture(displayObject)"),t.generateTexture(this,e,r)},t.Graphics.prototype.generateTexture=function(t,e){return n("graphics generate texture has moved to the renderer. Or to render a graphics to a texture using canvas please use generateCanvasTexture"),this.generateCanvasTexture(t,e)},t.RenderTexture.prototype.render=function(t,e,r,i){this.legacyRenderer.render(t,this,r,e,!i),n("RenderTexture.render is now deprecated, please use renderer.render(displayObject, renderTexture)")},t.RenderTexture.prototype.getImage=function(t){return n("RenderTexture.getImage is now deprecated, please use renderer.extract.image(target)"),this.legacyRenderer.extract.image(t)},t.RenderTexture.prototype.getBase64=function(t){return n("RenderTexture.getBase64 is now deprecated, please use renderer.extract.base64(target)"),this.legacyRenderer.extract.base64(t)},t.RenderTexture.prototype.getCanvas=function(t){return n("RenderTexture.getCanvas is now deprecated, please use renderer.extract.canvas(target)"),this.legacyRenderer.extract.canvas(t)},t.RenderTexture.prototype.getPixels=function(t){return n("RenderTexture.getPixels is now deprecated, please use renderer.extract.pixels(target)"),this.legacyRenderer.pixels(t)},t.Sprite.prototype.setTexture=function(t){this.texture=t,n("setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;")},i.BitmapText&&(i.BitmapText.prototype.setText=function(t){this.text=t,n("setText is now deprecated, please use the text property, e.g : myBitmapText.text = 'my text';")}),t.Text.prototype.setText=function(t){this.text=t,n("setText is now deprecated, please use the text property, e.g : myText.text = 'my text';")},t.Text.calculateFontProperties=function(e){return n("Text.calculateFontProperties is now deprecated, please use the TextMetrics.measureFont"),t.TextMetrics.measureFont(e)},Object.defineProperties(t.Text,{fontPropertiesCache:{get:function(){return n("Text.fontPropertiesCache is deprecated"),t.TextMetrics._fonts}},fontPropertiesCanvas:{get:function(){return n("Text.fontPropertiesCanvas is deprecated"),t.TextMetrics._canvas}},fontPropertiesContext:{get:function(){return n("Text.fontPropertiesContext is deprecated"),t.TextMetrics._context}}}),t.Text.prototype.setStyle=function(t){this.style=t,n("setStyle is now deprecated, please use the style property, e.g : myText.style = style;")},t.Text.prototype.determineFontProperties=function(e){return n("determineFontProperties is now deprecated, please use TextMetrics.measureFont method"),t.TextMetrics.measureFont(e)},t.Text.getFontStyle=function(e){return n("getFontStyle is now deprecated, please use TextStyle.toFontString() instead"),e=e||{},e instanceof t.TextStyle||(e=new t.TextStyle(e)),e.toFontString()},Object.defineProperties(t.TextStyle.prototype,{font:{get:function(){n("text style property 'font' is now deprecated, please use the 'fontFamily', 'fontSize', 'fontStyle', 'fontVariant' and 'fontWeight' properties from now on");var t="number"==typeof this._fontSize?this._fontSize+"px":this._fontSize;return this._fontStyle+" "+this._fontVariant+" "+this._fontWeight+" "+t+" "+this._fontFamily},set:function(t){n("text style property 'font' is now deprecated, please use the 'fontFamily','fontSize',fontStyle','fontVariant' and 'fontWeight' properties from now on"),t.indexOf("italic")>1?this._fontStyle="italic":t.indexOf("oblique")>-1?this._fontStyle="oblique":this._fontStyle="normal",t.indexOf("small-caps")>-1?this._fontVariant="small-caps":this._fontVariant="normal";var e=t.split(" "),r=-1;this._fontSize=26;for(var i=0;i<e.length;++i)if(e[i].match(/(px|pt|em|%)/)){r=i,this._fontSize=e[i];break}this._fontWeight="normal";for(var o=0;o<r;++o)if(e[o].match(/(bold|bolder|lighter|100|200|300|400|500|600|700|800|900)/)){this._fontWeight=e[o];break}if(r>-1&&r<e.length-1){this._fontFamily="";for(var s=r+1;s<e.length;++s)this._fontFamily+=e[s]+" ";this._fontFamily=this._fontFamily.slice(0,-1)}else this._fontFamily="Arial";this.styleID++}}}),t.Texture.prototype.setFrame=function(t){this.frame=t,n("setFrame is now deprecated, please use the frame property, e.g: myTexture.frame = frame;")},t.Texture.addTextureToCache=function(e,r){t.Texture.addToCache(e,r),n("Texture.addTextureToCache is deprecated, please use Texture.addToCache from now on.")},t.Texture.removeTextureFromCache=function(e){return n("Texture.removeTextureFromCache is deprecated, please use Texture.removeFromCache from now on. Be aware that Texture.removeFromCache does not automatically its BaseTexture from the BaseTextureCache. For that, use BaseTexture.removeFromCache"),t.BaseTexture.removeFromCache(e),t.Texture.removeFromCache(e)},Object.defineProperties(o,{AbstractFilter:{get:function(){return n("AstractFilter has been renamed to Filter, please use PIXI.Filter"),t.AbstractFilter}},SpriteMaskFilter:{get:function(){return n("filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on."),t.SpriteMaskFilter}}}),t.utils.uuid=function(){return n("utils.uuid() is deprecated, please use utils.uid() from now on."),t.utils.uid()},t.utils.canUseNewCanvasBlendModes=function(){return n("utils.canUseNewCanvasBlendModes() is deprecated, please use CanvasTinter.canUseMultiply from now on"),t.CanvasTinter.canUseMultiply};var d=!0;Object.defineProperty(t.utils,"_saidHello",{set:function(t){t&&(n("PIXI.utils._saidHello is deprecated, please use PIXI.utils.skipHello()"),this.skipHello()),d=t},get:function(){return d}}),s.BasePrepare&&(s.BasePrepare.prototype.register=function(t,e){return n("renderer.plugins.prepare.register is now deprecated, please use renderer.plugins.prepare.registerFindHook & renderer.plugins.prepare.registerUploadHook"),t&&this.registerFindHook(t),e&&this.registerUploadHook(e),this}),s.canvas&&Object.defineProperty(s.canvas,"UPLOADS_PER_FRAME",{set:function(){n("PIXI.CanvasPrepare.UPLOADS_PER_FRAME has been removed. Please set renderer.plugins.prepare.limiter.maxItemsPerFrame on your renderer")},get:function(){return n("PIXI.CanvasPrepare.UPLOADS_PER_FRAME has been removed. Please use renderer.plugins.prepare.limiter"),NaN}}),s.webgl&&Object.defineProperty(s.webgl,"UPLOADS_PER_FRAME",{set:function(){n("PIXI.WebGLPrepare.UPLOADS_PER_FRAME has been removed. Please set renderer.plugins.prepare.limiter.maxItemsPerFrame on your renderer")},get:function(){return n("PIXI.WebGLPrepare.UPLOADS_PER_FRAME has been removed. Please use renderer.plugins.prepare.limiter"),NaN}}),a.Loader&&!function(){var t=a.Resource,e=a.Loader;Object.defineProperties(t.prototype,{isJson:{get:function(){return n("The isJson property is deprecated, please use `resource.type === Resource.TYPE.JSON`."),this.type===t.TYPE.JSON}},isXml:{get:function(){return n("The isXml property is deprecated, please use `resource.type === Resource.TYPE.XML`."),this.type===t.TYPE.XML}},isImage:{get:function(){return n("The isImage property is deprecated, please use `resource.type === Resource.TYPE.IMAGE`."),this.type===t.TYPE.IMAGE}},isAudio:{get:function(){return n("The isAudio property is deprecated, please use `resource.type === Resource.TYPE.AUDIO`."),this.type===t.TYPE.AUDIO}},isVideo:{get:function(){return n("The isVideo property is deprecated, please use `resource.type === Resource.TYPE.VIDEO`."),this.type===t.TYPE.VIDEO}}}),Object.defineProperties(e.prototype,{before:{get:function(){return n("The before() method is deprecated, please use pre()."),this.pre}},after:{get:function(){return n("The after() method is deprecated, please use use()."),this.use}}})}(),u.interactiveTarget&&Object.defineProperty(u.interactiveTarget,"defaultCursor",{set:function(t){n("Property defaultCursor has been replaced with 'cursor'. "),this.cursor=t},get:function(){return n("Property defaultCursor has been replaced with 'cursor'. "),this.cursor}}),u.InteractionManager&&(Object.defineProperty(u.InteractionManager,"defaultCursorStyle",{set:function(t){n("Property defaultCursorStyle has been replaced with 'cursorStyles.default'. "),this.cursorStyles.default=t},get:function(){return n("Property defaultCursorStyle has been replaced with 'cursorStyles.default'. "),this.cursorStyles.default}}),Object.defineProperty(u.InteractionManager,"currentCursorStyle",{set:function(t){n("Property currentCursorStyle has been removed.See the currentCursorMode property, which works differently."),this.currentCursorMode=t},get:function(){return n("Property currentCursorStyle has been removed.See the currentCursorMode property, which works differently."),this.currentCursorMode}}))}r.__esModule=!0,r.default=i},{}],130:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("../../core"),s=n(o),a=new s.Rectangle,u=function(){function t(e){i(this,t),this.renderer=e,e.extract=this}return t.prototype.image=function t(e){var t=new Image;return t.src=this.base64(e),t},t.prototype.base64=function(t){return this.canvas(t).toDataURL()},t.prototype.canvas=function(t){var e=this.renderer,r=void 0,n=void 0,i=void 0,o=void 0;t&&(o=t instanceof s.RenderTexture?t:e.generateTexture(t)),o?(r=o.baseTexture._canvasRenderTarget.context,n=o.baseTexture._canvasRenderTarget.resolution,i=o.frame):(r=e.rootContext,i=a,i.width=this.renderer.width,i.height=this.renderer.height);var u=i.width*n,h=i.height*n,l=new s.CanvasRenderTarget(u,h),c=r.getImageData(i.x*n,i.y*n,u,h);return l.context.putImageData(c,0,0),l.canvas},t.prototype.pixels=function(t){var e=this.renderer,r=void 0,n=void 0,i=void 0,o=void 0;return t&&(o=t instanceof s.RenderTexture?t:e.generateTexture(t)),o?(r=o.baseTexture._canvasRenderTarget.context,n=o.baseTexture._canvasRenderTarget.resolution,i=o.frame):(r=e.rootContext,i=a,i.width=e.width,i.height=e.height),r.getImageData(0,0,i.width*n,i.height*n).data},t.prototype.destroy=function(){this.renderer.extract=null,this.renderer=null},t}();r.default=u,s.CanvasRenderer.registerPlugin("extract",u);
},{"../../core":64}],131:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./webgl/WebGLExtract");Object.defineProperty(r,"webgl",{enumerable:!0,get:function(){return n(i).default}});var o=t("./canvas/CanvasExtract");Object.defineProperty(r,"canvas",{enumerable:!0,get:function(){return n(o).default}})},{"./canvas/CanvasExtract":130,"./webgl/WebGLExtract":132}],132:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("../../core"),s=n(o),a=new s.Rectangle,u=4,h=function(){function t(e){i(this,t),this.renderer=e,e.extract=this}return t.prototype.image=function t(e){var t=new Image;return t.src=this.base64(e),t},t.prototype.base64=function(t){return this.canvas(t).toDataURL()},t.prototype.canvas=function(t){var e=this.renderer,r=void 0,n=void 0,i=void 0,o=!1,h=void 0;t&&(h=t instanceof s.RenderTexture?t:this.renderer.generateTexture(t)),h?(r=h.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID],n=r.resolution,i=h.frame,o=!1):(r=this.renderer.rootRenderTarget,n=r.resolution,o=!0,i=a,i.width=r.size.width,i.height=r.size.height);var l=i.width*n,c=i.height*n,d=new s.CanvasRenderTarget(l,c);if(r){e.bindRenderTarget(r);var f=new Uint8Array(u*l*c),p=e.gl;p.readPixels(i.x*n,i.y*n,l,c,p.RGBA,p.UNSIGNED_BYTE,f);var v=d.context.getImageData(0,0,l,c);v.data.set(f),d.context.putImageData(v,0,0),o&&(d.context.scale(1,-1),d.context.drawImage(d.canvas,0,-c))}return d.canvas},t.prototype.pixels=function(t){var e=this.renderer,r=void 0,n=void 0,i=void 0,o=void 0;t&&(o=t instanceof s.RenderTexture?t:this.renderer.generateTexture(t)),o?(r=o.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID],n=r.resolution,i=o.frame):(r=this.renderer.rootRenderTarget,n=r.resolution,i=a,i.width=r.size.width,i.height=r.size.height);var h=i.width*n,l=i.height*n,c=new Uint8Array(u*h*l);if(r){e.bindRenderTarget(r);var d=e.gl;d.readPixels(i.x*n,i.y*n,h,l,d.RGBA,d.UNSIGNED_BYTE,c)}return c},t.prototype.destroy=function(){this.renderer.extract=null,this.renderer=null},t}();r.default=h,s.WebGLRenderer.registerPlugin("extract",h)},{"../../core":64}],133:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../core"),h=n(u),l=function(t){function e(r,n){i(this,e);var s=o(this,t.call(this,r[0]instanceof h.Texture?r[0]:r[0].texture));return s._textures=null,s._durations=null,s.textures=r,s._autoUpdate=n!==!1,s.animationSpeed=1,s.loop=!0,s.onComplete=null,s.onFrameChange=null,s.onLoop=null,s._currentTime=0,s.playing=!1,s}return s(e,t),e.prototype.stop=function(){this.playing&&(this.playing=!1,this._autoUpdate&&h.ticker.shared.remove(this.update,this))},e.prototype.play=function(){this.playing||(this.playing=!0,this._autoUpdate&&h.ticker.shared.add(this.update,this,h.UPDATE_PRIORITY.HIGH))},e.prototype.gotoAndStop=function(t){this.stop();var e=this.currentFrame;this._currentTime=t,e!==this.currentFrame&&this.updateTexture()},e.prototype.gotoAndPlay=function(t){var e=this.currentFrame;this._currentTime=t,e!==this.currentFrame&&this.updateTexture(),this.play()},e.prototype.update=function(t){var e=this.animationSpeed*t,r=this.currentFrame;if(null!==this._durations){var n=this._currentTime%1*this._durations[this.currentFrame];for(n+=e/60*1e3;n<0;)this._currentTime--,n+=this._durations[this.currentFrame];var i=Math.sign(this.animationSpeed*t);for(this._currentTime=Math.floor(this._currentTime);n>=this._durations[this.currentFrame];)n-=this._durations[this.currentFrame]*i,this._currentTime+=i;this._currentTime+=n/this._durations[this.currentFrame]}else this._currentTime+=e;this._currentTime<0&&!this.loop?(this.gotoAndStop(0),this.onComplete&&this.onComplete()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-1),this.onComplete&&this.onComplete()):r!==this.currentFrame&&(this.loop&&this.onLoop&&(this.animationSpeed>0&&this.currentFrame<r?this.onLoop():this.animationSpeed<0&&this.currentFrame>r&&this.onLoop()),this.updateTexture())},e.prototype.updateTexture=function(){this._texture=this._textures[this.currentFrame],this._textureID=-1,this.onFrameChange&&this.onFrameChange(this.currentFrame)},e.prototype.destroy=function(e){this.stop(),t.prototype.destroy.call(this,e)},e.fromFrames=function(t){for(var r=[],n=0;n<t.length;++n)r.push(h.Texture.fromFrame(t[n]));return new e(r)},e.fromImages=function(t){for(var r=[],n=0;n<t.length;++n)r.push(h.Texture.fromImage(t[n]));return new e(r)},a(e,[{key:"totalFrames",get:function(){return this._textures.length}},{key:"textures",get:function(){return this._textures},set:function(t){if(t[0]instanceof h.Texture)this._textures=t,this._durations=null;else{this._textures=[],this._durations=[];for(var e=0;e<t.length;e++)this._textures.push(t[e].texture),this._durations.push(t[e].time)}this.gotoAndStop(0),this.updateTexture()}},{key:"currentFrame",get:function(){var t=Math.floor(this._currentTime)%this._textures.length;return t<0&&(t+=this._textures.length),t}}]),e}(h.Sprite);r.default=l},{"../core":64}],134:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=t("../core"),l=i(h),c=t("../core/math/ObservablePoint"),d=n(c),f=t("../core/settings"),p=n(f),v=function(t){function e(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};o(this,e);var i=s(this,t.call(this));return i._textWidth=0,i._textHeight=0,i._glyphs=[],i._font={tint:void 0!==n.tint?n.tint:16777215,align:n.align||"left",name:null,size:0},i.font=n.font,i._text=r,i._maxWidth=0,i._maxLineHeight=0,i._anchor=new d.default(function(){i.dirty=!0},i,0,0),i.dirty=!1,i.updateText(),i}return a(e,t),e.prototype.updateText=function(){for(var t=e.fonts[this._font.name],r=this._font.size/t.size,n=new l.Point,i=[],o=[],s=null,a=0,u=0,h=0,c=-1,d=0,f=0,p=0,v=0;v<this.text.length;v++){var y=this.text.charCodeAt(v);if(/(\s)/.test(this.text.charAt(v))&&(c=v,d=a),/(?:\r\n|\r|\n)/.test(this.text.charAt(v)))o.push(a),u=Math.max(u,a),h++,n.x=0,n.y+=t.lineHeight,s=null;else if(c!==-1&&this._maxWidth>0&&n.x*r>this._maxWidth)l.utils.removeItems(i,c-f,v-c),v=c,c=-1,++f,o.push(d),u=Math.max(u,d),h++,n.x=0,n.y+=t.lineHeight,s=null;else{var g=t.chars[y];g&&(s&&g.kerning[s]&&(n.x+=g.kerning[s]),i.push({texture:g.texture,line:h,charCode:y,position:new l.Point(n.x+g.xOffset,n.y+g.yOffset)}),a=n.x+(g.texture.width+g.xOffset),n.x+=g.xAdvance,p=Math.max(p,g.yOffset+g.texture.height),s=y)}}o.push(a),u=Math.max(u,a);for(var m=[],_=0;_<=h;_++){var b=0;"right"===this._font.align?b=u-o[_]:"center"===this._font.align&&(b=(u-o[_])/2),m.push(b)}for(var x=i.length,T=this.tint,w=0;w<x;w++){var E=this._glyphs[w];E?E.texture=i[w].texture:(E=new l.Sprite(i[w].texture),this._glyphs.push(E)),E.position.x=(i[w].position.x+m[i[w].line])*r,E.position.y=i[w].position.y*r,E.scale.x=E.scale.y=r,E.tint=T,E.parent||this.addChild(E)}for(var S=x;S<this._glyphs.length;++S)this.removeChild(this._glyphs[S]);if(this._textWidth=u*r,this._textHeight=(n.y+t.lineHeight)*r,0!==this.anchor.x||0!==this.anchor.y)for(var O=0;O<x;O++)this._glyphs[O].x-=this._textWidth*this.anchor.x,this._glyphs[O].y-=this._textHeight*this.anchor.y;this._maxLineHeight=p*r},e.prototype.updateTransform=function(){this.validate(),this.containerUpdateTransform()},e.prototype.getLocalBounds=function(){return this.validate(),t.prototype.getLocalBounds.call(this)},e.prototype.validate=function(){this.dirty&&(this.updateText(),this.dirty=!1)},e.registerFont=function(t,r){var n={},i=t.getElementsByTagName("info")[0],o=t.getElementsByTagName("common")[0],s=r.baseTexture.resolution||p.default.RESOLUTION;n.font=i.getAttribute("face"),n.size=parseInt(i.getAttribute("size"),10),n.lineHeight=parseInt(o.getAttribute("lineHeight"),10)/s,n.chars={};for(var a=t.getElementsByTagName("char"),u=0;u<a.length;u++){var h=a[u],c=parseInt(h.getAttribute("id"),10),d=new l.Rectangle(parseInt(h.getAttribute("x"),10)/s+r.frame.x/s,parseInt(h.getAttribute("y"),10)/s+r.frame.y/s,parseInt(h.getAttribute("width"),10)/s,parseInt(h.getAttribute("height"),10)/s);n.chars[c]={xOffset:parseInt(h.getAttribute("xoffset"),10)/s,yOffset:parseInt(h.getAttribute("yoffset"),10)/s,xAdvance:parseInt(h.getAttribute("xadvance"),10)/s,kerning:{},texture:new l.Texture(r.baseTexture,d)}}for(var f=t.getElementsByTagName("kerning"),v=0;v<f.length;v++){var y=f[v],g=parseInt(y.getAttribute("first"),10)/s,m=parseInt(y.getAttribute("second"),10)/s,_=parseInt(y.getAttribute("amount"),10)/s;n.chars[m]&&(n.chars[m].kerning[g]=_)}return e.fonts[n.font]=n,n},u(e,[{key:"tint",get:function(){return this._font.tint},set:function(t){this._font.tint="number"==typeof t&&t>=0?t:16777215,this.dirty=!0}},{key:"align",get:function(){return this._font.align},set:function(t){this._font.align=t||"left",this.dirty=!0}},{key:"anchor",get:function(){return this._anchor},set:function(t){"number"==typeof t?this._anchor.set(t):this._anchor.copy(t)}},{key:"font",get:function(){return this._font},set:function(t){t&&("string"==typeof t?(t=t.split(" "),this._font.name=1===t.length?t[0]:t.slice(1).join(" "),this._font.size=t.length>=2?parseInt(t[0],10):e.fonts[this._font.name].size):(this._font.name=t.name,this._font.size="number"==typeof t.size?t.size:parseInt(t.size,10)),this.dirty=!0)}},{key:"text",get:function(){return this._text},set:function(t){t=t.toString()||" ",this._text!==t&&(this._text=t,this.dirty=!0)}},{key:"maxWidth",get:function(){return this._maxWidth},set:function(t){this._maxWidth!==t&&(this._maxWidth=t,this.dirty=!0)}},{key:"maxLineHeight",get:function(){return this.validate(),this._maxLineHeight}},{key:"textWidth",get:function(){return this.validate(),this._textWidth}},{key:"textHeight",get:function(){return this.validate(),this._textHeight}}]),e}(l.Container);r.default=v,v.fonts={}},{"../core":64,"../core/math/ObservablePoint":67,"../core/settings":100}],135:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=t("../core/math/Matrix"),a=n(s),u=new a.default,h=function(){function t(e,r){i(this,t),this._texture=e,this.mapCoord=new a.default,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._lastTextureID=-1,this.clampOffset=0,this.clampMargin="undefined"==typeof r?.5:r}return t.prototype.multiplyUvs=function(t,e){void 0===e&&(e=t);for(var r=this.mapCoord,n=0;n<t.length;n+=2){var i=t[n],o=t[n+1];e[n]=i*r.a+o*r.c+r.tx,e[n+1]=i*r.b+o*r.d+r.ty}return e},t.prototype.update=function(t){var e=this._texture;if(!e||!e.valid)return!1;if(!t&&this._lastTextureID===e._updateID)return!1;this._lastTextureID=e._updateID;var r=e._uvs;this.mapCoord.set(r.x1-r.x0,r.y1-r.y0,r.x3-r.x0,r.y3-r.y0,r.x0,r.y0);var n=e.orig,i=e.trim;i&&(u.set(n.width/i.width,0,0,n.height/i.height,-i.x/i.width,-i.y/i.height),this.mapCoord.append(u));var o=e.baseTexture,s=this.uClampFrame,a=this.clampMargin/o.resolution,h=this.clampOffset;return s[0]=(e._frame.x+a+h)/o.width,s[1]=(e._frame.y+a+h)/o.height,s[2]=(e._frame.x+e._frame.width-a+h)/o.width,s[3]=(e._frame.y+e._frame.height-a+h)/o.height,this.uClampOffset[0]=h/o.realWidth,this.uClampOffset[1]=h/o.realHeight,!0},o(t,[{key:"texture",get:function(){return this._texture},set:function(t){this._texture=t,this._lastTextureID=-1}}]),t}();r.default=h},{"../core/math/Matrix":66}],136:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=t("../core"),l=i(h),c=t("../core/sprites/canvas/CanvasTinter"),d=n(c),f=t("./TextureTransform"),p=n(f),v=new l.Point,y=function(t){function e(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:100,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:100;o(this,e);var a=s(this,t.call(this,r));return a.tileTransform=new l.TransformStatic,a._width=n,a._height=i,a._canvasPattern=null,a.uvTransform=r.transform||new p.default(r),a.pluginName="tilingSprite",a.uvRespectAnchor=!1,a}return a(e,t),e.prototype._onTextureUpdate=function(){this.uvTransform&&(this.uvTransform.texture=this._texture)},e.prototype._renderWebGL=function(t){var e=this._texture;e&&e.valid&&(this.tileTransform.updateLocalTransform(),this.uvTransform.update(),t.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this))},e.prototype._renderCanvas=function(t){var e=this._texture;if(e.baseTexture.hasLoaded){var r=t.context,n=this.worldTransform,i=t.resolution,o=e.baseTexture,s=o.resolution,a=this.tilePosition.x/this.tileScale.x%e._frame.width*s,u=this.tilePosition.y/this.tileScale.y%e._frame.height*s;if(!this._canvasPattern){var h=new l.CanvasRenderTarget(e._frame.width,e._frame.height,s);16777215!==this.tint?(this.cachedTint!==this.tint&&(this.cachedTint=this.tint,this.tintedTexture=d.default.getTintedTexture(this,this.tint)),h.context.drawImage(this.tintedTexture,0,0)):h.context.drawImage(o.source,-e._frame.x*s,-e._frame.y*s),this._canvasPattern=h.context.createPattern(h.canvas,"repeat")}r.globalAlpha=this.worldAlpha,r.setTransform(n.a*i,n.b*i,n.c*i,n.d*i,n.tx*i,n.ty*i),t.setBlendMode(this.blendMode),r.fillStyle=this._canvasPattern,r.scale(this.tileScale.x/s,this.tileScale.y/s);var c=this.anchor.x*-this._width,f=this.anchor.y*-this._height;this.uvRespectAnchor?(r.translate(a,u),r.fillRect(-a+c,-u+f,this._width/this.tileScale.x*s,this._height/this.tileScale.y*s)):(r.translate(a+c,u+f),r.fillRect(-a,-u,this._width/this.tileScale.x*s,this._height/this.tileScale.y*s))}},e.prototype._calculateBounds=function(){var t=this._width*-this._anchor._x,e=this._height*-this._anchor._y,r=this._width*(1-this._anchor._x),n=this._height*(1-this._anchor._y);this._bounds.addFrame(this.transform,t,e,r,n)},e.prototype.getLocalBounds=function(e){return 0===this.children.length?(this._bounds.minX=this._width*-this._anchor._x,this._bounds.minY=this._height*-this._anchor._y,this._bounds.maxX=this._width*(1-this._anchor._x),this._bounds.maxY=this._height*(1-this._anchor._x),e||(this._localBoundsRect||(this._localBoundsRect=new l.Rectangle),e=this._localBoundsRect),this._bounds.getRectangle(e)):t.prototype.getLocalBounds.call(this,e)},e.prototype.containsPoint=function(t){this.worldTransform.applyInverse(t,v);var e=this._width,r=this._height,n=-e*this.anchor._x;if(v.x>=n&&v.x<n+e){var i=-r*this.anchor._y;if(v.y>=i&&v.y<i+r)return!0}return!1},e.prototype.destroy=function(e){t.prototype.destroy.call(this,e),this.tileTransform=null,this.uvTransform=null},e.from=function(t,r,n){return new e(l.Texture.from(t),r,n)},e.fromFrame=function(t,r,n){var i=l.utils.TextureCache[t];if(!i)throw new Error('The frameId "'+t+'" does not exist in the texture cache '+this);return new e(i,r,n)},e.fromImage=function(t,r,n,i,o){return new e(l.Texture.fromImage(t,i,o),r,n)},u(e,[{key:"clampMargin",get:function(){return this.uvTransform.clampMargin},set:function(t){this.uvTransform.clampMargin=t,this.uvTransform.update(!0)}},{key:"tileScale",get:function(){return this.tileTransform.scale},set:function(t){this.tileTransform.scale.copy(t)}},{key:"tilePosition",get:function(){return this.tileTransform.position},set:function(t){this.tileTransform.position.copy(t)}},{key:"width",get:function(){return this._width},set:function(t){this._width=t}},{key:"height",get:function(){return this._height},set:function(t){this._height=t}}]),e}(l.Sprite);r.default=y},{"../core":64,"../core/sprites/canvas/CanvasTinter":103,"./TextureTransform":135}],137:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var s=t("../core"),a=i(s),u=t("../core/textures/Texture"),h=n(u),l=t("../core/textures/BaseTexture"),c=n(l),d=t("../core/utils"),f=a.DisplayObject,p=new a.Matrix;f.prototype._cacheAsBitmap=!1,f.prototype._cacheData=!1;var v=function t(){o(this,t),this.textureCacheId=null,this.originalRenderWebGL=null,this.originalRenderCanvas=null,this.originalCalculateBounds=null,this.originalGetLocalBounds=null,this.originalUpdateTransform=null,this.originalHitTest=null,this.originalDestroy=null,this.originalMask=null,this.originalFilterArea=null,this.sprite=null};Object.defineProperties(f.prototype,{cacheAsBitmap:{get:function(){return this._cacheAsBitmap},set:function(t){if(this._cacheAsBitmap!==t){this._cacheAsBitmap=t;var e=void 0;t?(this._cacheData||(this._cacheData=new v),e=this._cacheData,e.originalRenderWebGL=this.renderWebGL,e.originalRenderCanvas=this.renderCanvas,e.originalUpdateTransform=this.updateTransform,e.originalCalculateBounds=this._calculateBounds,e.originalGetLocalBounds=this.getLocalBounds,e.originalDestroy=this.destroy,e.originalContainsPoint=this.containsPoint,e.originalMask=this._mask,e.originalFilterArea=this.filterArea,this.renderWebGL=this._renderCachedWebGL,this.renderCanvas=this._renderCachedCanvas,this.destroy=this._cacheAsBitmapDestroy):(e=this._cacheData,e.sprite&&this._destroyCachedDisplayObject(),this.renderWebGL=e.originalRenderWebGL,this.renderCanvas=e.originalRenderCanvas,this._calculateBounds=e.originalCalculateBounds,this.getLocalBounds=e.originalGetLocalBounds,this.destroy=e.originalDestroy,this.updateTransform=e.originalUpdateTransform,this.containsPoint=e.originalContainsPoint,this._mask=e.originalMask,this.filterArea=e.originalFilterArea)}}}}),f.prototype._renderCachedWebGL=function(t){!this.visible||this.worldAlpha<=0||!this.renderable||(this._initCachedDisplayObject(t),this._cacheData.sprite._transformID=-1,this._cacheData.sprite.worldAlpha=this.worldAlpha,this._cacheData.sprite._renderWebGL(t))},f.prototype._initCachedDisplayObject=function(t){if(!this._cacheData||!this._cacheData.sprite){var e=this.alpha;this.alpha=1,t.currentRenderer.flush();var r=this.getLocalBounds().clone();if(this._filters){var n=this._filters[0].padding;r.pad(n)}var i=t._activeRenderTarget,o=t.filterManager.filterStack,s=a.RenderTexture.create(0|r.width,0|r.height),u="cacheAsBitmap_"+(0,d.uid)();this._cacheData.textureCacheId=u,c.default.addToCache(s.baseTexture,u),h.default.addToCache(s,u);var l=p;l.tx=-r.x,l.ty=-r.y,this.transform.worldTransform.identity(),this.renderWebGL=this._cacheData.originalRenderWebGL,t.render(this,s,!0,l,!0),t.bindRenderTarget(i),t.filterManager.filterStack=o,this.renderWebGL=this._renderCachedWebGL,this.updateTransform=this.displayObjectUpdateTransform,this._mask=null,this.filterArea=null;var f=new a.Sprite(s);f.transform.worldTransform=this.transform.worldTransform,f.anchor.x=-(r.x/r.width),f.anchor.y=-(r.y/r.height),f.alpha=e,f._bounds=this._bounds,this._calculateBounds=this._calculateCachedBounds,this.getLocalBounds=this._getCachedLocalBounds,this._cacheData.sprite=f,this.transform._parentID=-1,this.parent?this.updateTransform():(this.parent=t._tempDisplayObjectParent,this.updateTransform(),this.parent=null),this.containsPoint=f.containsPoint.bind(f)}},f.prototype._renderCachedCanvas=function(t){!this.visible||this.worldAlpha<=0||!this.renderable||(this._initCachedDisplayObjectCanvas(t),this._cacheData.sprite.worldAlpha=this.worldAlpha,this._cacheData.sprite.renderCanvas(t))},f.prototype._initCachedDisplayObjectCanvas=function(t){if(!this._cacheData||!this._cacheData.sprite){var e=this.getLocalBounds(),r=this.alpha;this.alpha=1;var n=t.context,i=a.RenderTexture.create(0|e.width,0|e.height),o="cacheAsBitmap_"+(0,d.uid)();this._cacheData.textureCacheId=o,c.default.addToCache(i.baseTexture,o),h.default.addToCache(i,o);var s=p;this.transform.localTransform.copy(s),s.invert(),s.tx-=e.x,s.ty-=e.y,this.renderCanvas=this._cacheData.originalRenderCanvas,t.render(this,i,!0,s,!1),t.context=n,this.renderCanvas=this._renderCachedCanvas,this._calculateBounds=this._calculateCachedBounds,this._mask=null,this.filterArea=null;var u=new a.Sprite(i);u.transform.worldTransform=this.transform.worldTransform,u.anchor.x=-(e.x/e.width),u.anchor.y=-(e.y/e.height),u._bounds=this._bounds,u.alpha=r,this.parent?this.updateTransform():(this.parent=t._tempDisplayObjectParent,this.updateTransform(),this.parent=null),this.updateTransform=this.displayObjectUpdateTransform,this._cacheData.sprite=u,this.containsPoint=u.containsPoint.bind(u)}},f.prototype._calculateCachedBounds=function(){this._cacheData.sprite._calculateBounds()},f.prototype._getCachedLocalBounds=function(){return this._cacheData.sprite.getLocalBounds()},f.prototype._destroyCachedDisplayObject=function(){this._cacheData.sprite._texture.destroy(!0),this._cacheData.sprite=null,c.default.removeFromCache(this._cacheData.textureCacheId),h.default.removeFromCache(this._cacheData.textureCacheId),this._cacheData.textureCacheId=null},f.prototype._cacheAsBitmapDestroy=function(t){this.cacheAsBitmap=!1,this.destroy(t)}},{"../core":64,"../core/textures/BaseTexture":111,"../core/textures/Texture":114,"../core/utils":123}],138:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}var i=t("../core"),o=n(i);o.DisplayObject.prototype.name=null,o.Container.prototype.getChildByName=function(t){for(var e=0;e<this.children.length;e++)if(this.children[e].name===t)return this.children[e];return null}},{"../core":64}],139:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}var i=t("../core"),o=n(i);o.DisplayObject.prototype.getGlobalPosition=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new o.Point,e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this.parent?this.parent.toGlobal(this.position,t,e):(t.x=this.position.x,t.y=this.position.y),t}},{"../core":64}],140:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0,r.BitmapText=r.TilingSpriteRenderer=r.TilingSprite=r.TextureTransform=r.AnimatedSprite=void 0;var i=t("./AnimatedSprite");Object.defineProperty(r,"AnimatedSprite",{enumerable:!0,get:function(){return n(i).default}});var o=t("./TextureTransform");Object.defineProperty(r,"TextureTransform",{enumerable:!0,get:function(){return n(o).default}});var s=t("./TilingSprite");Object.defineProperty(r,"TilingSprite",{enumerable:!0,get:function(){return n(s).default}});var a=t("./webgl/TilingSpriteRenderer");Object.defineProperty(r,"TilingSpriteRenderer",{enumerable:!0,get:function(){return n(a).default}});var u=t("./BitmapText");Object.defineProperty(r,"BitmapText",{enumerable:!0,get:function(){return n(u).default}}),t("./cacheAsBitmap"),t("./getChildByName"),t("./getGlobalPosition")},{"./AnimatedSprite":133,"./BitmapText":134,"./TextureTransform":135,"./TilingSprite":136,"./cacheAsBitmap":137,"./getChildByName":138,"./getGlobalPosition":139,"./webgl/TilingSpriteRenderer":141}],141:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../../core"),u=n(a),h=t("../../core/const"),l=(t("path"),new u.Matrix),c=function(t){function e(r){i(this,e);var n=o(this,t.call(this,r));return n.shader=null,n.simpleShader=null,n.quad=null,n}return s(e,t),e.prototype.onContextChange=function(){var t=this.renderer.gl;this.shader=new u.Shader(t,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 sample = texture2D(uSampler, coord);\n    vec4 color = vec4(uColor.rgb * uColor.a, uColor.a);\n\n    gl_FragColor = sample * color ;\n}\n"),this.simpleShader=new u.Shader(t,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    vec4 color = vec4(uColor.rgb * uColor.a, uColor.a);\n    gl_FragColor = sample * color;\n}\n"),this.renderer.bindVao(null),this.quad=new u.Quad(t,this.renderer.state.attribState),this.quad.initVao(this.shader)},e.prototype.render=function(t){var e=this.renderer,r=this.quad;e.bindVao(r.vao);var n=r.vertices;n[0]=n[6]=t._width*-t.anchor.x,n[1]=n[3]=t._height*-t.anchor.y,n[2]=n[4]=t._width*(1-t.anchor.x),n[5]=n[7]=t._height*(1-t.anchor.y),t.uvRespectAnchor&&(n=r.uvs,n[0]=n[6]=-t.anchor.x,n[1]=n[3]=-t.anchor.y,n[2]=n[4]=1-t.anchor.x,n[5]=n[7]=1-t.anchor.y),r.upload();var i=t._texture,o=i.baseTexture,s=t.tileTransform.localTransform,a=t.uvTransform,c=o.isPowerOfTwo&&i.frame.width===o.width&&i.frame.height===o.height;c&&(o._glTextures[e.CONTEXT_UID]?c=o.wrapMode!==h.WRAP_MODES.CLAMP:o.wrapMode===h.WRAP_MODES.CLAMP&&(o.wrapMode=h.WRAP_MODES.REPEAT));var d=c?this.simpleShader:this.shader;e.bindShader(d);var f=i.width,p=i.height,v=t._width,y=t._height;l.set(s.a*f/v,s.b*f/y,s.c*p/v,s.d*p/y,s.tx/v,s.ty/y),l.invert(),c?l.prepend(a.mapCoord):(d.uniforms.uMapCoord=a.mapCoord.toArray(!0),d.uniforms.uClampFrame=a.uClampFrame,d.uniforms.uClampOffset=a.uClampOffset),d.uniforms.uTransform=l.toArray(!0),d.uniforms.uColor=u.utils.premultiplyTintToRgba(t.tint,t.worldAlpha,d.uniforms.uColor,o.premultipliedAlpha),d.uniforms.translationMatrix=t.transform.worldTransform.toArray(!0),d.uniforms.uSampler=e.bindTexture(i),e.setBlendMode(u.utils.correctBlendMode(t.blendMode,o.premultipliedAlpha)),r.vao.draw(this.renderer.gl.TRIANGLES,6,0)},e}(u.ObjectRenderer);r.default=c,u.WebGLRenderer.registerPlugin("tilingSprite",c)},{"../../core":64,"../../core/const":45,path:22}],142:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=t("../../core"),l=i(h),c=t("./BlurXFilter"),d=n(c),f=t("./BlurYFilter"),p=n(f),v=function(t){function e(r,n,i,a){o(this,e);var u=s(this,t.call(this));return u.blurXFilter=new d.default(r,n,i,a),u.blurYFilter=new p.default(r,n,i,a),u.padding=0,u.resolution=i||l.settings.RESOLUTION,u.quality=n||4,u.blur=r||8,u}return a(e,t),e.prototype.apply=function(t,e,r){var n=t.getRenderTarget(!0);
    this.blurXFilter.apply(t,e,n,!0),this.blurYFilter.apply(t,n,r,!1),t.returnRenderTarget(n)},u(e,[{key:"blur",get:function(){return this.blurXFilter.blur},set:function(t){this.blurXFilter.blur=this.blurYFilter.blur=t,this.padding=2*Math.max(Math.abs(this.blurXFilter.strength),Math.abs(this.blurYFilter.strength))}},{key:"quality",get:function(){return this.blurXFilter.quality},set:function(t){this.blurXFilter.quality=this.blurYFilter.quality=t}},{key:"blurX",get:function(){return this.blurXFilter.blur},set:function(t){this.blurXFilter.blur=t,this.padding=2*Math.max(Math.abs(this.blurXFilter.strength),Math.abs(this.blurYFilter.strength))}},{key:"blurY",get:function(){return this.blurYFilter.blur},set:function(t){this.blurYFilter.blur=t,this.padding=2*Math.max(Math.abs(this.blurXFilter.strength),Math.abs(this.blurYFilter.strength))}}]),e}(l.Filter);r.default=v},{"../../core":64,"./BlurXFilter":143,"./BlurYFilter":144}],143:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=t("../../core"),l=i(h),c=t("./generateBlurVertSource"),d=n(c),f=t("./generateBlurFragSource"),p=n(f),v=t("./getMaxBlurKernelSize"),y=n(v),g=function(t){function e(r,n,i,a){o(this,e),a=a||5;var u=(0,d.default)(a,!0),h=(0,p.default)(a),c=s(this,t.call(this,u,h));return c.resolution=i||l.settings.RESOLUTION,c._quality=0,c.quality=n||4,c.strength=r||8,c.firstRun=!0,c}return a(e,t),e.prototype.apply=function(t,e,r,n){if(this.firstRun){var i=t.renderer.gl,o=(0,y.default)(i);this.vertexSrc=(0,d.default)(o,!0),this.fragmentSrc=(0,p.default)(o),this.firstRun=!1}if(this.uniforms.strength=1/r.size.width*(r.size.width/e.size.width),this.uniforms.strength*=this.strength,this.uniforms.strength/=this.passes,1===this.passes)t.applyFilter(this,e,r,n);else{for(var s=t.getRenderTarget(!0),a=e,u=s,h=0;h<this.passes-1;h++){t.applyFilter(this,a,u,!0);var l=u;u=a,a=l}t.applyFilter(this,a,r,n),t.returnRenderTarget(s)}},u(e,[{key:"blur",get:function(){return this.strength},set:function(t){this.padding=2*Math.abs(t),this.strength=t}},{key:"quality",get:function(){return this._quality},set:function(t){this._quality=t,this.passes=t}}]),e}(l.Filter);r.default=g},{"../../core":64,"./generateBlurFragSource":145,"./generateBlurVertSource":146,"./getMaxBlurKernelSize":147}],144:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=t("../../core"),l=i(h),c=t("./generateBlurVertSource"),d=n(c),f=t("./generateBlurFragSource"),p=n(f),v=t("./getMaxBlurKernelSize"),y=n(v),g=function(t){function e(r,n,i,a){o(this,e),a=a||5;var u=(0,d.default)(a,!1),h=(0,p.default)(a),c=s(this,t.call(this,u,h));return c.resolution=i||l.settings.RESOLUTION,c._quality=0,c.quality=n||4,c.strength=r||8,c.firstRun=!0,c}return a(e,t),e.prototype.apply=function(t,e,r,n){if(this.firstRun){var i=t.renderer.gl,o=(0,y.default)(i);this.vertexSrc=(0,d.default)(o,!1),this.fragmentSrc=(0,p.default)(o),this.firstRun=!1}if(this.uniforms.strength=1/r.size.height*(r.size.height/e.size.height),this.uniforms.strength*=this.strength,this.uniforms.strength/=this.passes,1===this.passes)t.applyFilter(this,e,r,n);else{for(var s=t.getRenderTarget(!0),a=e,u=s,h=0;h<this.passes-1;h++){t.applyFilter(this,a,u,!0);var l=u;u=a,a=l}t.applyFilter(this,a,r,n),t.returnRenderTarget(s)}},u(e,[{key:"blur",get:function(){return this.strength},set:function(t){this.padding=2*Math.abs(t),this.strength=t}},{key:"quality",get:function(){return this._quality},set:function(t){this._quality=t,this.passes=t}}]),e}(l.Filter);r.default=g},{"../../core":64,"./generateBlurFragSource":145,"./generateBlurVertSource":146,"./getMaxBlurKernelSize":147}],145:[function(t,e,r){"use strict";function n(t){for(var e=i[t],r=e.length,n=o,s="",a="gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;",u=void 0,h=0;h<t;h++){var l=a.replace("%index%",h);u=h,h>=r&&(u=t-h-1),l=l.replace("%value%",e[u]),s+=l,s+="\n"}return n=n.replace("%blur%",s),n=n.replace("%size%",t)}r.__esModule=!0,r.default=n;var i={5:[.153388,.221461,.250301],7:[.071303,.131514,.189879,.214607],9:[.028532,.067234,.124009,.179044,.20236],11:[.0093,.028002,.065984,.121703,.175713,.198596],13:[.002406,.009255,.027867,.065666,.121117,.174868,.197641],15:[489e-6,.002403,.009246,.02784,.065602,.120999,.174697,.197448]},o=["varying vec2 vBlurTexCoords[%size%];","uniform sampler2D uSampler;","void main(void)","{","    gl_FragColor = vec4(0.0);","    %blur%","}"].join("\n")},{}],146:[function(t,e,r){"use strict";function n(t,e){var r=Math.ceil(t/2),n=i,o="",s=void 0;s=e?"vBlurTexCoords[%index%] = aTextureCoord + vec2(%sampleIndex% * strength, 0.0);":"vBlurTexCoords[%index%] = aTextureCoord + vec2(0.0, %sampleIndex% * strength);";for(var a=0;a<t;a++){var u=s.replace("%index%",a);u=u.replace("%sampleIndex%",a-(r-1)+".0"),o+=u,o+="\n"}return n=n.replace("%blur%",o),n=n.replace("%size%",t)}r.__esModule=!0,r.default=n;var i=["attribute vec2 aVertexPosition;","attribute vec2 aTextureCoord;","uniform float strength;","uniform mat3 projectionMatrix;","varying vec2 vBlurTexCoords[%size%];","void main(void)","{","gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);","%blur%","}"].join("\n")},{}],147:[function(t,e,r){"use strict";function n(t){for(var e=t.getParameter(t.MAX_VARYING_VECTORS),r=15;r>e;)r-=2;return r}r.__esModule=!0,r.default=n},{}],148:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../../core"),h=n(u),l=(t("path"),function(t){function e(){i(this,e);var r=o(this,t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n"));return r.uniforms.m=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],r.alpha=1,r}return s(e,t),e.prototype._loadMatrix=function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=t;e&&(this._multiply(r,this.uniforms.m,t),r=this._colorMatrix(r)),this.uniforms.m=r},e.prototype._multiply=function(t,e,r){return t[0]=e[0]*r[0]+e[1]*r[5]+e[2]*r[10]+e[3]*r[15],t[1]=e[0]*r[1]+e[1]*r[6]+e[2]*r[11]+e[3]*r[16],t[2]=e[0]*r[2]+e[1]*r[7]+e[2]*r[12]+e[3]*r[17],t[3]=e[0]*r[3]+e[1]*r[8]+e[2]*r[13]+e[3]*r[18],t[4]=e[0]*r[4]+e[1]*r[9]+e[2]*r[14]+e[3]*r[19]+e[4],t[5]=e[5]*r[0]+e[6]*r[5]+e[7]*r[10]+e[8]*r[15],t[6]=e[5]*r[1]+e[6]*r[6]+e[7]*r[11]+e[8]*r[16],t[7]=e[5]*r[2]+e[6]*r[7]+e[7]*r[12]+e[8]*r[17],t[8]=e[5]*r[3]+e[6]*r[8]+e[7]*r[13]+e[8]*r[18],t[9]=e[5]*r[4]+e[6]*r[9]+e[7]*r[14]+e[8]*r[19]+e[9],t[10]=e[10]*r[0]+e[11]*r[5]+e[12]*r[10]+e[13]*r[15],t[11]=e[10]*r[1]+e[11]*r[6]+e[12]*r[11]+e[13]*r[16],t[12]=e[10]*r[2]+e[11]*r[7]+e[12]*r[12]+e[13]*r[17],t[13]=e[10]*r[3]+e[11]*r[8]+e[12]*r[13]+e[13]*r[18],t[14]=e[10]*r[4]+e[11]*r[9]+e[12]*r[14]+e[13]*r[19]+e[14],t[15]=e[15]*r[0]+e[16]*r[5]+e[17]*r[10]+e[18]*r[15],t[16]=e[15]*r[1]+e[16]*r[6]+e[17]*r[11]+e[18]*r[16],t[17]=e[15]*r[2]+e[16]*r[7]+e[17]*r[12]+e[18]*r[17],t[18]=e[15]*r[3]+e[16]*r[8]+e[17]*r[13]+e[18]*r[18],t[19]=e[15]*r[4]+e[16]*r[9]+e[17]*r[14]+e[18]*r[19]+e[19],t},e.prototype._colorMatrix=function(t){var e=new Float32Array(t);return e[4]/=255,e[9]/=255,e[14]/=255,e[19]/=255,e},e.prototype.brightness=function(t,e){var r=[t,0,0,0,0,0,t,0,0,0,0,0,t,0,0,0,0,0,1,0];this._loadMatrix(r,e)},e.prototype.greyscale=function(t,e){var r=[t,t,t,0,0,t,t,t,0,0,t,t,t,0,0,0,0,0,1,0];this._loadMatrix(r,e)},e.prototype.blackAndWhite=function(t){var e=[.3,.6,.1,0,0,.3,.6,.1,0,0,.3,.6,.1,0,0,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.hue=function(t,e){t=(t||0)/180*Math.PI;var r=Math.cos(t),n=Math.sin(t),i=Math.sqrt,o=1/3,s=i(o),a=r+(1-r)*o,u=o*(1-r)-s*n,h=o*(1-r)+s*n,l=o*(1-r)+s*n,c=r+o*(1-r),d=o*(1-r)-s*n,f=o*(1-r)-s*n,p=o*(1-r)+s*n,v=r+o*(1-r),y=[a,u,h,0,0,l,c,d,0,0,f,p,v,0,0,0,0,0,1,0];this._loadMatrix(y,e)},e.prototype.contrast=function(t,e){var r=(t||0)+1,n=-128*(r-1),i=[r,0,0,0,n,0,r,0,0,n,0,0,r,0,n,0,0,0,1,0];this._loadMatrix(i,e)},e.prototype.saturate=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments[1],r=2*t/3+1,n=(r-1)*-.5,i=[r,n,n,0,0,n,r,n,0,0,n,n,r,0,0,0,0,0,1,0];this._loadMatrix(i,e)},e.prototype.desaturate=function(){this.saturate(-1)},e.prototype.negative=function(t){var e=[0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.sepia=function(t){var e=[.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.technicolor=function(t){var e=[1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.polaroid=function(t){var e=[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.toBGR=function(t){var e=[0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.kodachrome=function(t){var e=[1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.browni=function(t){var e=[.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.vintage=function(t){var e=[.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.colorTone=function(t,e,r,n,i){t=t||.2,e=e||.15,r=r||16770432,n=n||3375104;var o=(r>>16&255)/255,s=(r>>8&255)/255,a=(255&r)/255,u=(n>>16&255)/255,h=(n>>8&255)/255,l=(255&n)/255,c=[.3,.59,.11,0,0,o,s,a,t,0,u,h,l,e,0,o-u,s-h,a-l,0,0];this._loadMatrix(c,i)},e.prototype.night=function(t,e){t=t||.1;var r=[t*-2,-t,0,0,0,-t,0,t,0,0,0,t,2*t,0,0,0,0,0,1,0];this._loadMatrix(r,e)},e.prototype.predator=function(t,e){var r=[11.224130630493164*t,-4.794486999511719*t,-2.8746118545532227*t,0*t,.40342438220977783*t,-3.6330697536468506*t,9.193157196044922*t,-2.951810836791992*t,0*t,-1.316135048866272*t,-3.2184197902679443*t,-4.2375030517578125*t,7.476448059082031*t,0*t,.8044459223747253*t,0,0,0,1,0];this._loadMatrix(r,e)},e.prototype.lsd=function(t){var e=[2,-.4,.5,0,0,-.5,2,-.4,0,0,-.4,-.5,3,0,0,0,0,0,1,0];this._loadMatrix(e,t)},e.prototype.reset=function(){var t=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];this._loadMatrix(t,!1)},a(e,[{key:"matrix",get:function(){return this.uniforms.m},set:function(t){this.uniforms.m=t}},{key:"alpha",get:function(){return this.uniforms.uAlpha},set:function(t){this.uniforms.uAlpha=t}}]),e}(h.Filter));r.default=l,l.prototype.grayscale=l.prototype.greyscale},{"../../core":64,path:22}],149:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../../core"),h=n(u),l=(t("path"),function(t){function e(r,n){i(this,e);var s=new h.Matrix;r.renderable=!1;var a=o(this,t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nvoid main(void)\n{\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n   vTextureCoord = aTextureCoord;\n}","varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n   vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n   map -= 0.5;\n   map.xy *= scale;\n\n   gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), filterClamp.xy, filterClamp.zw));\n}\n"));return a.maskSprite=r,a.maskMatrix=s,a.uniforms.mapSampler=r._texture,a.uniforms.filterMatrix=s,a.uniforms.scale={x:1,y:1},null!==n&&void 0!==n||(n=20),a.scale=new h.Point(n,n),a}return s(e,t),e.prototype.apply=function(t,e,r){var n=1/r.destinationFrame.width*(r.size.width/e.size.width);this.uniforms.filterMatrix=t.calculateSpriteMatrix(this.maskMatrix,this.maskSprite),this.uniforms.scale.x=this.scale.x*n,this.uniforms.scale.y=this.scale.y*n,t.applyFilter(this,e,r)},a(e,[{key:"map",get:function(){return this.uniforms.mapSampler},set:function(t){this.uniforms.mapSampler=t}}]),e}(h.Filter));r.default=l},{"../../core":64,path:22}],150:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../../core"),u=n(a),h=(t("path"),function(t){function e(){return i(this,e),o(this,t.call(this,"\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform vec4 filterArea;\n\nvarying vec2 vTextureCoord;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n   vTextureCoord = aTextureCoord;\n\n   vec2 fragCoord = vTextureCoord * filterArea.xy;\n\n   texcoords(fragCoord, filterArea.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}",'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n \n --\n \n From:\n https://github.com/mitsuhiko/webgl-meincraft\n \n Copyright (c) 2011 by Armin Ronacher.\n \n Some rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n \n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec2 fragCoord = vTextureCoord * filterArea.xy;\n\n      vec4 color;\n\n    color = fxaa(uSampler, fragCoord, filterArea.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n'))}return s(e,t),e}(u.Filter));r.default=h},{"../../core":64,path:22}],151:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./fxaa/FXAAFilter");Object.defineProperty(r,"FXAAFilter",{enumerable:!0,get:function(){return n(i).default}});var o=t("./noise/NoiseFilter");Object.defineProperty(r,"NoiseFilter",{enumerable:!0,get:function(){return n(o).default}});var s=t("./displacement/DisplacementFilter");Object.defineProperty(r,"DisplacementFilter",{enumerable:!0,get:function(){return n(s).default}});var a=t("./blur/BlurFilter");Object.defineProperty(r,"BlurFilter",{enumerable:!0,get:function(){return n(a).default}});var u=t("./blur/BlurXFilter");Object.defineProperty(r,"BlurXFilter",{enumerable:!0,get:function(){return n(u).default}});var h=t("./blur/BlurYFilter");Object.defineProperty(r,"BlurYFilter",{enumerable:!0,get:function(){return n(h).default}});var l=t("./colormatrix/ColorMatrixFilter");Object.defineProperty(r,"ColorMatrixFilter",{enumerable:!0,get:function(){return n(l).default}});var c=t("./void/VoidFilter");Object.defineProperty(r,"VoidFilter",{enumerable:!0,get:function(){return n(c).default}})},{"./blur/BlurFilter":142,"./blur/BlurXFilter":143,"./blur/BlurYFilter":144,"./colormatrix/ColorMatrixFilter":148,"./displacement/DisplacementFilter":149,"./fxaa/FXAAFilter":150,"./noise/NoiseFilter":152,"./void/VoidFilter":153}],152:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../../core"),h=n(u),l=(t("path"),function(t){function e(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:.5,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Math.random();i(this,e);var s=o(this,t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n"));return s.noise=r,s.seed=n,s}return s(e,t),a(e,[{key:"noise",get:function(){return this.uniforms.uNoise},set:function(t){this.uniforms.uNoise=t}},{key:"seed",get:function(){return this.uniforms.uSeed},set:function(t){this.uniforms.uSeed=t}}]),e}(h.Filter));r.default=l},{"../../core":64,path:22}],153:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../../core"),u=n(a),h=(t("path"),function(t){function e(){i(this,e);var r=o(this,t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"));return r.glShaderKey="void",r}return s(e,t),e}(u.Filter));r.default=h},{"../../core":64,path:22}],154:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=t("../core"),a=n(s),u=function(){function t(){i(this,t),this.global=new a.Point,this.target=null,this.originalEvent=null,this.identifier=null,this.isPrimary=!1,this.button=0,this.buttons=0,this.width=0,this.height=0,this.tiltX=0,this.tiltY=0,this.pointerType=null,this.pressure=0,this.rotationAngle=0,this.twist=0,this.tangentialPressure=0}return t.prototype.getLocalPosition=function(t,e,r){return t.worldTransform.applyInverse(r||this.global,e)},t.prototype._copyEvent=function(t){t.isPrimary&&(this.isPrimary=!0),this.button=t.button,this.buttons=t.buttons,this.width=t.width,this.height=t.height,this.tiltX=t.tiltX,this.tiltY=t.tiltY,this.pointerType=t.pointerType,this.pressure=t.pressure,this.rotationAngle=t.rotationAngle,this.twist=t.twist||0,this.tangentialPressure=t.tangentialPressure||0},t.prototype._reset=function(){this.isPrimary=!1},o(t,[{key:"pointerId",get:function(){return this.identifier}}]),t}();r.default=u},{"../core":64}],155:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(){n(this,t),this.stopped=!1,this.target=null,this.currentTarget=null,this.type=null,this.data=null}return t.prototype.stopPropagation=function(){this.stopped=!0},t.prototype._reset=function(){this.stopped=!1,this.currentTarget=null,
    this.target=null},t}();r.default=i},{}],156:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},h=t("../core"),l=i(h),c=t("./InteractionData"),d=n(c),f=t("./InteractionEvent"),p=n(f),v=t("./InteractionTrackingData"),y=n(v),g=t("eventemitter3"),m=n(g),_=t("./interactiveTarget"),b=n(_);l.utils.mixins.delayMixin(l.DisplayObject.prototype,b.default);var x="MOUSE",T={target:null,data:{global:null}},w=function(t){function e(r,n){o(this,e);var i=s(this,t.call(this));return n=n||{},i.renderer=r,i.autoPreventDefault=void 0===n.autoPreventDefault||n.autoPreventDefault,i.interactionFrequency=n.interactionFrequency||10,i.mouse=new d.default,i.mouse.identifier=x,i.mouse.global.set(-999999),i.activeInteractionData={},i.activeInteractionData[x]=i.mouse,i.interactionDataPool=[],i.eventData=new p.default,i.interactionDOMElement=null,i.moveWhenInside=!1,i.eventsAdded=!1,i.mouseOverRenderer=!1,i.supportsTouchEvents="ontouchstart"in window,i.supportsPointerEvents=!!window.PointerEvent,i.onPointerUp=i.onPointerUp.bind(i),i.processPointerUp=i.processPointerUp.bind(i),i.onPointerCancel=i.onPointerCancel.bind(i),i.processPointerCancel=i.processPointerCancel.bind(i),i.onPointerDown=i.onPointerDown.bind(i),i.processPointerDown=i.processPointerDown.bind(i),i.onPointerMove=i.onPointerMove.bind(i),i.processPointerMove=i.processPointerMove.bind(i),i.onPointerOut=i.onPointerOut.bind(i),i.processPointerOverOut=i.processPointerOverOut.bind(i),i.onPointerOver=i.onPointerOver.bind(i),i.cursorStyles={default:"inherit",pointer:"pointer"},i.currentCursorMode=null,i.cursor=null,i._tempPoint=new l.Point,i.resolution=1,i.setTargetElement(i.renderer.view,i.renderer.resolution),i}return a(e,t),e.prototype.hitTest=function(t,e){return T.target=null,T.data.global=t,e||(e=this.renderer._lastObjectRendered),this.processInteractive(T,e,null,!0),T.target},e.prototype.setTargetElement=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;this.removeEvents(),this.interactionDOMElement=t,this.resolution=e,this.addEvents()},e.prototype.addEvents=function(){this.interactionDOMElement&&(l.ticker.shared.add(this.update,this,l.UPDATE_PRIORITY.INTERACTION),window.navigator.msPointerEnabled?(this.interactionDOMElement.style["-ms-content-zooming"]="none",this.interactionDOMElement.style["-ms-touch-action"]="none"):this.supportsPointerEvents&&(this.interactionDOMElement.style["touch-action"]="none"),this.supportsPointerEvents?(window.document.addEventListener("pointermove",this.onPointerMove,!0),this.interactionDOMElement.addEventListener("pointerdown",this.onPointerDown,!0),this.interactionDOMElement.addEventListener("pointerleave",this.onPointerOut,!0),this.interactionDOMElement.addEventListener("pointerover",this.onPointerOver,!0),window.addEventListener("pointercancel",this.onPointerCancel,!0),window.addEventListener("pointerup",this.onPointerUp,!0)):(window.document.addEventListener("mousemove",this.onPointerMove,!0),this.interactionDOMElement.addEventListener("mousedown",this.onPointerDown,!0),this.interactionDOMElement.addEventListener("mouseout",this.onPointerOut,!0),this.interactionDOMElement.addEventListener("mouseover",this.onPointerOver,!0),window.addEventListener("mouseup",this.onPointerUp,!0)),this.supportsTouchEvents&&(this.interactionDOMElement.addEventListener("touchstart",this.onPointerDown,!0),this.interactionDOMElement.addEventListener("touchcancel",this.onPointerCancel,!0),this.interactionDOMElement.addEventListener("touchend",this.onPointerUp,!0),this.interactionDOMElement.addEventListener("touchmove",this.onPointerMove,!0)),this.eventsAdded=!0)},e.prototype.removeEvents=function(){this.interactionDOMElement&&(l.ticker.shared.remove(this.update,this),window.navigator.msPointerEnabled?(this.interactionDOMElement.style["-ms-content-zooming"]="",this.interactionDOMElement.style["-ms-touch-action"]=""):this.supportsPointerEvents&&(this.interactionDOMElement.style["touch-action"]=""),this.supportsPointerEvents?(window.document.removeEventListener("pointermove",this.onPointerMove,!0),this.interactionDOMElement.removeEventListener("pointerdown",this.onPointerDown,!0),this.interactionDOMElement.removeEventListener("pointerleave",this.onPointerOut,!0),this.interactionDOMElement.removeEventListener("pointerover",this.onPointerOver,!0),window.removeEventListener("pointercancel",this.onPointerCancel,!0),window.removeEventListener("pointerup",this.onPointerUp,!0)):(window.document.removeEventListener("mousemove",this.onPointerMove,!0),this.interactionDOMElement.removeEventListener("mousedown",this.onPointerDown,!0),this.interactionDOMElement.removeEventListener("mouseout",this.onPointerOut,!0),this.interactionDOMElement.removeEventListener("mouseover",this.onPointerOver,!0),window.removeEventListener("mouseup",this.onPointerUp,!0)),this.supportsTouchEvents&&(this.interactionDOMElement.removeEventListener("touchstart",this.onPointerDown,!0),this.interactionDOMElement.removeEventListener("touchcancel",this.onPointerCancel,!0),this.interactionDOMElement.removeEventListener("touchend",this.onPointerUp,!0),this.interactionDOMElement.removeEventListener("touchmove",this.onPointerMove,!0)),this.interactionDOMElement=null,this.eventsAdded=!1)},e.prototype.update=function(t){if(this._deltaTime+=t,!(this._deltaTime<this.interactionFrequency)&&(this._deltaTime=0,this.interactionDOMElement)){if(this.didMove)return void(this.didMove=!1);this.cursor=null;for(var e in this.activeInteractionData)if(this.activeInteractionData.hasOwnProperty(e)){var r=this.activeInteractionData[e];if(r.originalEvent&&"touch"!==r.pointerType){var n=this.configureInteractionEventForDOMEvent(this.eventData,r.originalEvent,r);this.processInteractive(n,this.renderer._lastObjectRendered,this.processPointerOverOut,!0)}}this.setCursorMode(this.cursor)}},e.prototype.setCursorMode=function(t){if(t=t||"default",this.currentCursorMode!==t){this.currentCursorMode=t;var e=this.cursorStyles[t];if(e)switch("undefined"==typeof e?"undefined":u(e)){case"string":this.interactionDOMElement.style.cursor=e;break;case"function":e(t);break;case"object":Object.assign(this.interactionDOMElement.style,e)}else"string"!=typeof t||Object.prototype.hasOwnProperty.call(this.cursorStyles,t)||(this.interactionDOMElement.style.cursor=t)}},e.prototype.dispatchEvent=function(t,e,r){r.stopped||(r.currentTarget=t,r.type=e,t.emit(e,r),t[e]&&t[e](r))},e.prototype.mapPositionToPoint=function(t,e,r){var n=void 0;n=this.interactionDOMElement.parentElement?this.interactionDOMElement.getBoundingClientRect():{x:0,y:0,width:0,height:0};var i=navigator.isCocoonJS?this.resolution:1/this.resolution;t.x=(e-n.left)*(this.interactionDOMElement.width/n.width)*i,t.y=(r-n.top)*(this.interactionDOMElement.height/n.height)*i},e.prototype.processInteractive=function(t,e,r,n,i){if(!e||!e.visible)return!1;var o=t.data.global;i=e.interactive||i;var s=!1,a=i;if(e.hitArea?a=!1:n&&e._mask&&(e._mask.containsPoint(o)||(n=!1)),e.interactiveChildren&&e.children)for(var u=e.children,h=u.length-1;h>=0;h--){var l=u[h],c=this.processInteractive(t,l,r,n,a);if(c){if(!l.parent)continue;a=!1,c&&(t.target&&(n=!1),s=!0)}}return i&&(n&&!t.target&&(e.hitArea?(e.worldTransform.applyInverse(o,this._tempPoint),e.hitArea.contains(this._tempPoint.x,this._tempPoint.y)&&(s=!0)):e.containsPoint&&e.containsPoint(o)&&(s=!0)),e.interactive&&(s&&!t.target&&(t.target=e),r&&r(t,e,!!s))),s},e.prototype.onPointerDown=function(t){if(!this.supportsTouchEvents||"touch"!==t.pointerType){var e=this.normalizeToPointerData(t);this.autoPreventDefault&&e[0].isNormalized&&t.preventDefault();for(var r=e.length,n=0;n<r;n++){var i=e[n],o=this.getInteractionDataForPointerId(i),s=this.configureInteractionEventForDOMEvent(this.eventData,i,o);if(s.data.originalEvent=t,this.processInteractive(s,this.renderer._lastObjectRendered,this.processPointerDown,!0),this.emit("pointerdown",s),"touch"===i.pointerType)this.emit("touchstart",s);else if("mouse"===i.pointerType||"pen"===i.pointerType){var a=2===i.button;this.emit(a?"rightdown":"mousedown",this.eventData)}}}},e.prototype.processPointerDown=function(t,e,r){var n=t.data,i=t.data.identifier;if(r)if(e.trackedPointers[i]||(e.trackedPointers[i]=new y.default(i)),this.dispatchEvent(e,"pointerdown",t),"touch"===n.pointerType)this.dispatchEvent(e,"touchstart",t);else if("mouse"===n.pointerType||"pen"===n.pointerType){var o=2===n.button;o?e.trackedPointers[i].rightDown=!0:e.trackedPointers[i].leftDown=!0,this.dispatchEvent(e,o?"rightdown":"mousedown",t)}},e.prototype.onPointerComplete=function(t,e,r){for(var n=this.normalizeToPointerData(t),i=n.length,o=t.target!==this.interactionDOMElement?"outside":"",s=0;s<i;s++){var a=n[s],u=this.getInteractionDataForPointerId(a),h=this.configureInteractionEventForDOMEvent(this.eventData,a,u);if(h.data.originalEvent=t,this.processInteractive(h,this.renderer._lastObjectRendered,r,e||!o),this.emit(e?"pointercancel":"pointerup"+o,h),"mouse"===a.pointerType||"pen"===a.pointerType){var l=2===a.button;this.emit(l?"rightup"+o:"mouseup"+o,h)}else"touch"===a.pointerType&&(this.emit(e?"touchcancel":"touchend"+o,h),this.releaseInteractionDataForPointerId(a.pointerId,u))}},e.prototype.onPointerCancel=function(t){this.supportsTouchEvents&&"touch"===t.pointerType||this.onPointerComplete(t,!0,this.processPointerCancel)},e.prototype.processPointerCancel=function(t,e){var r=t.data,n=t.data.identifier;void 0!==e.trackedPointers[n]&&(delete e.trackedPointers[n],this.dispatchEvent(e,"pointercancel",t),"touch"===r.pointerType&&this.dispatchEvent(e,"touchcancel",t))},e.prototype.onPointerUp=function(t){this.supportsTouchEvents&&"touch"===t.pointerType||this.onPointerComplete(t,!1,this.processPointerUp)},e.prototype.processPointerUp=function(t,e,r){var n=t.data,i=t.data.identifier,o=e.trackedPointers[i],s="touch"===n.pointerType,a="mouse"===n.pointerType||"pen"===n.pointerType;if(a){var u=2===n.button,h=y.default.FLAGS,l=u?h.RIGHT_DOWN:h.LEFT_DOWN,c=void 0!==o&&o.flags&l;r?(this.dispatchEvent(e,u?"rightup":"mouseup",t),c&&this.dispatchEvent(e,u?"rightclick":"click",t)):c&&this.dispatchEvent(e,u?"rightupoutside":"mouseupoutside",t),o&&(u?o.rightDown=!1:o.leftDown=!1)}r?(this.dispatchEvent(e,"pointerup",t),s&&this.dispatchEvent(e,"touchend",t),o&&(this.dispatchEvent(e,"pointertap",t),s&&(this.dispatchEvent(e,"tap",t),o.over=!1))):o&&(this.dispatchEvent(e,"pointerupoutside",t),s&&this.dispatchEvent(e,"touchendoutside",t)),o&&o.none&&delete e.trackedPointers[i]},e.prototype.onPointerMove=function(t){if(!this.supportsTouchEvents||"touch"!==t.pointerType){var e=this.normalizeToPointerData(t);"mouse"===e[0].pointerType&&(this.didMove=!0,this.cursor=null);for(var r=e.length,n=0;n<r;n++){var i=e[n],o=this.getInteractionDataForPointerId(i),s=this.configureInteractionEventForDOMEvent(this.eventData,i,o);s.data.originalEvent=t;var a="touch"!==i.pointerType||this.moveWhenInside;this.processInteractive(s,this.renderer._lastObjectRendered,this.processPointerMove,a),this.emit("pointermove",s),"touch"===i.pointerType&&this.emit("touchmove",s),"mouse"!==i.pointerType&&"pen"!==i.pointerType||this.emit("mousemove",s)}"mouse"===e[0].pointerType&&this.setCursorMode(this.cursor)}},e.prototype.processPointerMove=function(t,e,r){var n=t.data,i="touch"===n.pointerType,o="mouse"===n.pointerType||"pen"===n.pointerType;o&&this.processPointerOverOut(t,e,r),this.moveWhenInside&&!r||(this.dispatchEvent(e,"pointermove",t),i&&this.dispatchEvent(e,"touchmove",t),o&&this.dispatchEvent(e,"mousemove",t))},e.prototype.onPointerOut=function(t){if(!this.supportsTouchEvents||"touch"!==t.pointerType){var e=this.normalizeToPointerData(t),r=e[0];"mouse"===r.pointerType&&(this.mouseOverRenderer=!1,this.setCursorMode(null));var n=this.getInteractionDataForPointerId(r),i=this.configureInteractionEventForDOMEvent(this.eventData,r,n);i.data.originalEvent=r,this.processInteractive(i,this.renderer._lastObjectRendered,this.processPointerOverOut,!1),this.emit("pointerout",i),"mouse"===r.pointerType||"pen"===r.pointerType?this.emit("mouseout",i):this.releaseInteractionDataForPointerId(n.identifier)}},e.prototype.processPointerOverOut=function(t,e,r){var n=t.data,i=t.data.identifier,o="mouse"===n.pointerType||"pen"===n.pointerType,s=e.trackedPointers[i];r&&!s&&(s=e.trackedPointers[i]=new y.default(i)),void 0!==s&&(r&&this.mouseOverRenderer?(s.over||(s.over=!0,this.dispatchEvent(e,"pointerover",t),o&&this.dispatchEvent(e,"mouseover",t)),o&&null===this.cursor&&(this.cursor=e.cursor)):s.over&&(s.over=!1,this.dispatchEvent(e,"pointerout",this.eventData),o&&this.dispatchEvent(e,"mouseout",t),s.none&&delete e.trackedPointers[i]))},e.prototype.onPointerOver=function(t){var e=this.normalizeToPointerData(t),r=e[0],n=this.getInteractionDataForPointerId(r),i=this.configureInteractionEventForDOMEvent(this.eventData,r,n);i.data.originalEvent=r,"mouse"===r.pointerType&&(this.mouseOverRenderer=!0),this.emit("pointerover",i),"mouse"!==r.pointerType&&"pen"!==r.pointerType||this.emit("mouseover",i)},e.prototype.getInteractionDataForPointerId=function(t){var e=t.pointerId,r=void 0;return e===x||"mouse"===t.pointerType?r=this.mouse:this.activeInteractionData[e]?r=this.activeInteractionData[e]:(r=this.interactionDataPool.pop()||new d.default,r.identifier=e,this.activeInteractionData[e]=r),r._copyEvent(t),r},e.prototype.releaseInteractionDataForPointerId=function(t){var e=this.activeInteractionData[t];e&&(delete this.activeInteractionData[t],e._reset(),this.interactionDataPool.push(e))},e.prototype.configureInteractionEventForDOMEvent=function(t,e,r){return t.data=r,this.mapPositionToPoint(r.global,e.clientX,e.clientY),navigator.isCocoonJS&&"touch"===e.pointerType&&(r.global.x=r.global.x/this.resolution,r.global.y=r.global.y/this.resolution),"touch"===e.pointerType&&(e.globalX=r.global.x,e.globalY=r.global.y),r.originalEvent=e,t._reset(),t},e.prototype.normalizeToPointerData=function(t){var e=[];if(this.supportsTouchEvents&&t instanceof TouchEvent)for(var r=0,n=t.changedTouches.length;r<n;r++){var i=t.changedTouches[r];"undefined"==typeof i.button&&(i.button=t.touches.length?1:0),"undefined"==typeof i.buttons&&(i.buttons=t.touches.length?1:0),"undefined"==typeof i.isPrimary&&(i.isPrimary=1===t.touches.length&&"touchstart"===t.type),"undefined"==typeof i.width&&(i.width=i.radiusX||1),"undefined"==typeof i.height&&(i.height=i.radiusY||1),"undefined"==typeof i.tiltX&&(i.tiltX=0),"undefined"==typeof i.tiltY&&(i.tiltY=0),"undefined"==typeof i.pointerType&&(i.pointerType="touch"),"undefined"==typeof i.pointerId&&(i.pointerId=i.identifier||0),"undefined"==typeof i.pressure&&(i.pressure=i.force||.5),i.twist=0,i.tangentialPressure=0,"undefined"==typeof i.layerX&&(i.layerX=i.offsetX=i.clientX),"undefined"==typeof i.layerY&&(i.layerY=i.offsetY=i.clientY),i.isNormalized=!0,e.push(i)}else!(t instanceof MouseEvent)||this.supportsPointerEvents&&t instanceof window.PointerEvent?e.push(t):("undefined"==typeof t.isPrimary&&(t.isPrimary=!0),"undefined"==typeof t.width&&(t.width=1),"undefined"==typeof t.height&&(t.height=1),"undefined"==typeof t.tiltX&&(t.tiltX=0),"undefined"==typeof t.tiltY&&(t.tiltY=0),"undefined"==typeof t.pointerType&&(t.pointerType="mouse"),"undefined"==typeof t.pointerId&&(t.pointerId=x),"undefined"==typeof t.pressure&&(t.pressure=.5),t.twist=0,t.tangentialPressure=0,t.isNormalized=!0,e.push(t));return e},e.prototype.destroy=function(){this.removeEvents(),this.removeAllListeners(),this.renderer=null,this.mouse=null,this.eventData=null,this.interactionDOMElement=null,this.onPointerDown=null,this.processPointerDown=null,this.onPointerUp=null,this.processPointerUp=null,this.onPointerCancel=null,this.processPointerCancel=null,this.onPointerMove=null,this.processPointerMove=null,this.onPointerOut=null,this.processPointerOverOut=null,this.onPointerOver=null,this._tempPoint=null},e}(m.default);r.default=w,l.WebGLRenderer.registerPlugin("interaction",w),l.CanvasRenderer.registerPlugin("interaction",w)},{"../core":64,"./InteractionData":154,"./InteractionEvent":155,"./InteractionTrackingData":157,"./interactiveTarget":159,eventemitter3:3}],157:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),o=function(){function t(e){n(this,t),this._pointerId=e,this._flags=t.FLAGS.NONE}return t.prototype._doSet=function(t,e){e?this._flags=this._flags|t:this._flags=this._flags&~t},i(t,[{key:"pointerId",get:function(){return this._pointerId}},{key:"flags",get:function(){return this._flags},set:function(t){this._flags=t}},{key:"none",get:function(){return this._flags===this.constructor.FLAGS.NONE}},{key:"over",get:function(){return 0!==(this._flags&this.constructor.FLAGS.OVER)},set:function(t){this._doSet(this.constructor.FLAGS.OVER,t)}},{key:"rightDown",get:function(){return 0!==(this._flags&this.constructor.FLAGS.RIGHT_DOWN)},set:function(t){this._doSet(this.constructor.FLAGS.RIGHT_DOWN,t)}},{key:"leftDown",get:function(){return 0!==(this._flags&this.constructor.FLAGS.LEFT_DOWN)},set:function(t){this._doSet(this.constructor.FLAGS.LEFT_DOWN,t)}}]),t}();r.default=o,o.FLAGS=Object.freeze({NONE:0,OVER:1,LEFT_DOWN:2,RIGHT_DOWN:4})},{}],158:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./InteractionData");Object.defineProperty(r,"InteractionData",{enumerable:!0,get:function(){return n(i).default}});var o=t("./InteractionManager");Object.defineProperty(r,"InteractionManager",{enumerable:!0,get:function(){return n(o).default}});var s=t("./interactiveTarget");Object.defineProperty(r,"interactiveTarget",{enumerable:!0,get:function(){return n(s).default}})},{"./InteractionData":154,"./InteractionManager":156,"./interactiveTarget":159}],159:[function(t,e,r){"use strict";r.__esModule=!0,r.default={interactive:!1,interactiveChildren:!0,hitArea:null,get buttonMode(){return"pointer"===this.cursor},set buttonMode(t){t?this.cursor="pointer":"pointer"===this.cursor&&(this.cursor=null)},cursor:null,get trackedPointers(){return void 0===this._trackedPointers&&(this._trackedPointers={}),this._trackedPointers},_trackedPointers:void 0}},{}],160:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){t.bitmapFont=h.BitmapText.registerFont(t.data,e)}r.__esModule=!0,r.parse=i,r.default=function(){return function(t,e){if(!t.data||t.type!==u.Resource.TYPE.XML)return void e();if(0===t.data.getElementsByTagName("page").length||0===t.data.getElementsByTagName("info").length||null===t.data.getElementsByTagName("info")[0].getAttribute("face"))return void e();var r=t.isDataUrl?"":s.dirname(t.url);t.isDataUrl&&("."===r&&(r=""),this.baseUrl&&r&&("/"===this.baseUrl.charAt(this.baseUrl.length-1)&&(r+="/"),r=r.replace(this.baseUrl,""))),r&&"/"!==r.charAt(r.length-1)&&(r+="/");var n=r+t.data.getElementsByTagName("page")[0].getAttribute("file");if(a.utils.TextureCache[n])i(t,a.utils.TextureCache[n]),e();else{var o={crossOrigin:t.crossOrigin,loadType:u.Resource.LOAD_TYPE.IMAGE,metadata:t.metadata.imageMetadata,parentResource:t};this.add(t.name+"_image",n,o,function(r){i(t,r.texture),e()})}}};var o=t("path"),s=n(o),a=t("../core"),u=t("resource-loader"),h=t("../extras")},{"../core":64,"../extras":140,path:22,"resource-loader":35}],161:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0,r.shared=r.Resource=r.textureParser=r.getResourcePath=r.spritesheetParser=r.parseBitmapFontData=r.bitmapFontParser=r.Loader=void 0;var i=t("./bitmapFontParser");Object.defineProperty(r,"bitmapFontParser",{enumerable:!0,get:function(){return n(i).default}}),Object.defineProperty(r,"parseBitmapFontData",{enumerable:!0,get:function(){return i.parse}});var o=t("./spritesheetParser");Object.defineProperty(r,"spritesheetParser",{enumerable:!0,get:function(){return n(o).default}}),Object.defineProperty(r,"getResourcePath",{enumerable:!0,get:function(){return o.getResourcePath}});var s=t("./textureParser");Object.defineProperty(r,"textureParser",{enumerable:!0,get:function(){return n(s).default}});var a=t("resource-loader");Object.defineProperty(r,"Resource",{enumerable:!0,get:function(){return a.Resource}});var u=t("../core/Application"),h=n(u),l=t("./loader"),c=n(l);r.Loader=c.default;var d=new c.default;d.destroy=function(){},r.shared=d;var f=h.default.prototype;f._loader=null,Object.defineProperty(f,"loader",{get:function(){if(!this._loader){var t=this._options.sharedLoader;this._loader=t?d:new c.default}return this._loader}}),f._parentDestroy=f.destroy,f.destroy=function(t){this._loader&&(this._loader.destroy(),this._loader=null),this._parentDestroy(t)}},{"../core/Application":42,"./bitmapFontParser":160,"./loader":162,"./spritesheetParser":163,"./textureParser":164,"resource-loader":35}],162:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("resource-loader"),u=n(a),h=t("resource-loader/lib/middlewares/parsing/blob"),l=t("eventemitter3"),c=n(l),d=t("./textureParser"),f=n(d),p=t("./spritesheetParser"),v=n(p),y=t("./bitmapFontParser"),g=n(y),m=function(t){function e(r,n){i(this,e);var s=o(this,t.call(this,r,n));c.default.call(s);for(var a=0;a<e._pixiMiddleware.length;++a)s.use(e._pixiMiddleware[a]());return s.onStart.add(function(t){return s.emit("start",t)}),s.onProgress.add(function(t,e){return s.emit("progress",t,e)}),s.onError.add(function(t,e,r){return s.emit("error",t,e,r)}),s.onLoad.add(function(t,e){return s.emit("load",t,e)}),s.onComplete.add(function(t,e){return s.emit("complete",t,e)}),s}return s(e,t),e.addPixiMiddleware=function(t){e._pixiMiddleware.push(t)},e.prototype.destroy=function(){this.removeAllListeners(),this.reset()},e}(u.default);r.default=m;for(var _ in c.default.prototype)m.prototype[_]=c.default.prototype[_];m._pixiMiddleware=[h.blobMiddlewareFactory,f.default,v.default,g.default];var b=u.default.Resource;b.setExtensionXhrType("fnt",b.XHR_RESPONSE_TYPE.DOCUMENT)},{"./bitmapFontParser":160,"./spritesheetParser":163,"./textureParser":164,eventemitter3:3,"resource-loader":35,"resource-loader/lib/middlewares/parsing/blob":36}],163:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){return t.isDataUrl?t.data.meta.image:a.default.resolve(t.url.replace(e,""),t.data.meta.image)}r.__esModule=!0,r.default=function(){return function(t,e){var r=t.name+"_image";if(!t.data||t.type!==o.Resource.TYPE.JSON||!t.data.frames||this.resources[r])return void e();var n={crossOrigin:t.crossOrigin,loadType:o.Resource.LOAD_TYPE.IMAGE,metadata:t.metadata.imageMetadata,parentResource:t},s=i(t,this.baseUrl);this.add(r,s,n,function(r){var n=new u.Spritesheet(r.texture.baseTexture,t.data,t.url);n.parse(function(){t.spritesheet=n,t.textures=n.textures,e()})})}},r.getResourcePath=i;var o=t("resource-loader"),s=t("url"),a=n(s),u=t("../core")},{"../core":64,"resource-loader":35,url:28}],164:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0,r.default=function(){return function(t,e){t.data&&t.type===i.Resource.TYPE.IMAGE&&(t.texture=s.default.fromLoader(t.data,t.url,t.name)),e()}};var i=t("resource-loader"),o=t("../core/textures/Texture"),s=n(o)},{"../core/textures/Texture":114,"resource-loader":35}],165:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=t("../core"),l=i(h),c=t("../extras/TextureTransform"),d=n(c),f=new l.Point,p=new l.Polygon,v=function(t){function e(r,n,i,a,u){o(this,e);var h=s(this,t.call(this));return h._texture=r,h.uvs=i||new Float32Array([0,0,1,0,1,1,0,1]),h.vertices=n||new Float32Array([0,0,100,0,100,100,0,100]),h.indices=a||new Uint16Array([0,1,3,2]),h.dirty=0,h.indexDirty=0,h.blendMode=l.BLEND_MODES.NORMAL,h.canvasPadding=0,h.drawMode=u||e.DRAW_MODES.TRIANGLE_MESH,h.shader=null,h.tintRgb=new Float32Array([1,1,1]),h._glDatas={},h._uvTransform=new d.default(r),h.uploadUvTransform=!1,h.pluginName="mesh",h}return a(e,t),e.prototype._renderWebGL=function(t){this.refresh(),t.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this)},e.prototype._renderCanvas=function(t){this.refresh(),t.plugins[this.pluginName].render(this)},e.prototype._onTextureUpdate=function(){this._uvTransform.texture=this._texture,this.refresh()},e.prototype.multiplyUvs=function(){this.uploadUvTransform||this._uvTransform.multiplyUvs(this.uvs)},e.prototype.refresh=function(t){this._uvTransform.update(t)&&this._refresh()},e.prototype._refresh=function(){},e.prototype._calculateBounds=function(){this._bounds.addVertices(this.transform,this.vertices,0,this.vertices.length)},e.prototype.containsPoint=function(t){if(!this.getBounds().contains(t.x,t.y))return!1;this.worldTransform.applyInverse(t,f);for(var r=this.vertices,n=p.points,i=this.indices,o=this.indices.length,s=this.drawMode===e.DRAW_MODES.TRIANGLES?3:1,a=0;a+2<o;a+=s){var u=2*i[a],h=2*i[a+1],l=2*i[a+2];if(n[0]=r[u],n[1]=r[u+1],n[2]=r[h],n[3]=r[h+1],n[4]=r[l],n[5]=r[l+1],p.contains(f.x,f.y))return!0}return!1},u(e,[{key:"texture",get:function(){return this._texture},set:function(t){this._texture!==t&&(this._texture=t,t&&(t.baseTexture.hasLoaded?this._onTextureUpdate():t.once("update",this._onTextureUpdate,this)))}},{key:"tint",get:function(){return l.utils.rgb2hex(this.tintRgb)},set:function(t){this.tintRgb=l.utils.hex2rgb(t,this.tintRgb)}}]),e}(l.Container);r.default=v,v.DRAW_MODES={TRIANGLE_MESH:0,TRIANGLES:1}},{"../core":64,"../extras/TextureTransform":135}],166:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("./Plane"),h=n(u),l=10,c=function(t){function e(r,n,s,a,u){i(this,e);var h=o(this,t.call(this,r,4,4));return h._origWidth=r.orig.width,h._origHeight=r.orig.height,h._width=h._origWidth,h._height=h._origHeight,h.leftWidth="undefined"!=typeof n?n:l,h.rightWidth="undefined"!=typeof a?a:l,h.topHeight="undefined"!=typeof s?s:l,h.bottomHeight="undefined"!=typeof u?u:l,h.refresh(!0),h}return s(e,t),e.prototype.updateHorizontalVertices=function(){var t=this.vertices;t[9]=t[11]=t[13]=t[15]=this._topHeight,t[17]=t[19]=t[21]=t[23]=this._height-this._bottomHeight,t[25]=t[27]=t[29]=t[31]=this._height},e.prototype.updateVerticalVertices=function(){var t=this.vertices;t[2]=t[10]=t[18]=t[26]=this._leftWidth,t[4]=t[12]=t[20]=t[28]=this._width-this._rightWidth,t[6]=t[14]=t[22]=t[30]=this._width},e.prototype._renderCanvas=function(t){var e=t.context;e.globalAlpha=this.worldAlpha;var r=this.worldTransform,n=t.resolution;t.roundPixels?e.setTransform(r.a*n,r.b*n,r.c*n,r.d*n,r.tx*n|0,r.ty*n|0):e.setTransform(r.a*n,r.b*n,r.c*n,r.d*n,r.tx*n,r.ty*n);var i=this._texture.baseTexture,o=i.source,s=i.width,a=i.height;this.drawSegment(e,o,s,a,0,1,10,11),this.drawSegment(e,o,s,a,2,3,12,13),this.drawSegment(e,o,s,a,4,5,14,15),this.drawSegment(e,o,s,a,8,9,18,19),this.drawSegment(e,o,s,a,10,11,20,21),this.drawSegment(e,o,s,a,12,13,22,23),this.drawSegment(e,o,s,a,16,17,26,27),this.drawSegment(e,o,s,a,18,19,28,29),this.drawSegment(e,o,s,a,20,21,30,31)},e.prototype.drawSegment=function(t,e,r,n,i,o,s,a){var u=this.uvs,h=this.vertices,l=(u[s]-u[i])*r,c=(u[a]-u[o])*n,d=h[s]-h[i],f=h[a]-h[o];l<1&&(l=1),c<1&&(c=1),d<1&&(d=1),f<1&&(f=1),t.drawImage(e,u[i]*r,u[o]*n,l,c,h[i],h[o],d,f)},e.prototype._refresh=function(){t.prototype._refresh.call(this);var e=this.uvs,r=this._texture;this._origWidth=r.orig.width,this._origHeight=r.orig.height;var n=1/this._origWidth,i=1/this._origHeight;e[0]=e[8]=e[16]=e[24]=0,e[1]=e[3]=e[5]=e[7]=0,e[6]=e[14]=e[22]=e[30]=1,e[25]=e[27]=e[29]=e[31]=1,e[2]=e[10]=e[18]=e[26]=n*this._leftWidth,e[4]=e[12]=e[20]=e[28]=1-n*this._rightWidth,e[9]=e[11]=e[13]=e[15]=i*this._topHeight,e[17]=e[19]=e[21]=e[23]=1-i*this._bottomHeight,this.updateHorizontalVertices(),this.updateVerticalVertices(),this.dirty=!0,this.multiplyUvs()},a(e,[{key:"width",get:function(){return this._width},set:function(t){this._width=t,this._refresh()}},{key:"height",get:function(){return this._height},set:function(t){this._height=t,this._refresh()}},{key:"leftWidth",get:function(){return this._leftWidth},set:function(t){this._leftWidth=t,this._refresh()}},{key:"rightWidth",get:function(){return this._rightWidth},set:function(t){this._rightWidth=t,this._refresh()}},{key:"topHeight",get:function(){return this._topHeight},set:function(t){this._topHeight=t,this._refresh();
}},{key:"bottomHeight",get:function(){return this._bottomHeight},set:function(t){this._bottomHeight=t,this._refresh()}}]),e}(h.default);r.default=c},{"./Plane":167}],167:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("./Mesh"),u=n(a),h=function(t){function e(r,n,s){i(this,e);var a=o(this,t.call(this,r));return a._ready=!0,a.verticesX=n||10,a.verticesY=s||10,a.drawMode=u.default.DRAW_MODES.TRIANGLES,a.refresh(),a}return s(e,t),e.prototype._refresh=function(){for(var t=this._texture,e=this.verticesX*this.verticesY,r=[],n=[],i=[],o=[],s=this.verticesX-1,a=this.verticesY-1,u=t.width/s,h=t.height/a,l=0;l<e;l++){var c=l%this.verticesX,d=l/this.verticesX|0;r.push(c*u,d*h),i.push(c/s,d/a)}for(var f=s*a,p=0;p<f;p++){var v=p%s,y=p/s|0,g=y*this.verticesX+v,m=y*this.verticesX+v+1,_=(y+1)*this.verticesX+v,b=(y+1)*this.verticesX+v+1;o.push(g,m,_),o.push(m,b,_)}this.vertices=new Float32Array(r),this.uvs=new Float32Array(i),this.colors=new Float32Array(n),this.indices=new Uint16Array(o),this.indexDirty=!0,this.multiplyUvs()},e.prototype._onTextureUpdate=function(){u.default.prototype._onTextureUpdate.call(this),this._ready&&this.refresh()},e}(u.default);r.default=h},{"./Mesh":165}],168:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("./Mesh"),u=n(a),h=function(t){function e(r,n){i(this,e);var s=o(this,t.call(this,r));return s.points=n,s.vertices=new Float32Array(4*n.length),s.uvs=new Float32Array(4*n.length),s.colors=new Float32Array(2*n.length),s.indices=new Uint16Array(2*n.length),s.autoUpdate=!0,s.refresh(),s}return s(e,t),e.prototype._refresh=function(){var t=this.points;if(!(t.length<1)&&this._texture._uvs){this.vertices.length/4!==t.length&&(this.vertices=new Float32Array(4*t.length),this.uvs=new Float32Array(4*t.length),this.colors=new Float32Array(2*t.length),this.indices=new Uint16Array(2*t.length));var e=this.uvs,r=this.indices,n=this.colors;e[0]=0,e[1]=0,e[2]=0,e[3]=1,n[0]=1,n[1]=1,r[0]=0,r[1]=1;for(var i=t.length,o=1;o<i;o++){var s=4*o,a=o/(i-1);e[s]=a,e[s+1]=0,e[s+2]=a,e[s+3]=1,s=2*o,n[s]=1,n[s+1]=1,s=2*o,r[s]=s,r[s+1]=s+1}this.dirty++,this.indexDirty++,this.multiplyUvs(),this.refreshVertices()}},e.prototype.refreshVertices=function(){var t=this.points;if(!(t.length<1))for(var e=t[0],r=void 0,n=0,i=0,o=this.vertices,s=t.length,a=0;a<s;a++){var u=t[a],h=4*a;r=a<t.length-1?t[a+1]:u,i=-(r.x-e.x),n=r.y-e.y;var l=10*(1-a/(s-1));l>1&&(l=1);var c=Math.sqrt(n*n+i*i),d=this._texture.height/2;n/=c,i/=c,n*=d,i*=d,o[h]=u.x+n,o[h+1]=u.y+i,o[h+2]=u.x-n,o[h+3]=u.y-i,e=u}},e.prototype.updateTransform=function(){this.autoUpdate&&this.refreshVertices(),this.containerUpdateTransform()},e}(u.default);r.default=h},{"./Mesh":165}],169:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var s=t("../../core"),a=i(s),u=t("../Mesh"),h=n(u),l=function(){function t(e){o(this,t),this.renderer=e}return t.prototype.render=function(t){var e=this.renderer,r=e.context,n=t.worldTransform,i=e.resolution;e.roundPixels?r.setTransform(n.a*i,n.b*i,n.c*i,n.d*i,n.tx*i|0,n.ty*i|0):r.setTransform(n.a*i,n.b*i,n.c*i,n.d*i,n.tx*i,n.ty*i),e.setBlendMode(t.blendMode),t.drawMode===h.default.DRAW_MODES.TRIANGLE_MESH?this._renderTriangleMesh(t):this._renderTriangles(t)},t.prototype._renderTriangleMesh=function(t){for(var e=t.vertices.length/2,r=0;r<e-2;r++){var n=2*r;this._renderDrawTriangle(t,n,n+2,n+4)}},t.prototype._renderTriangles=function(t){for(var e=t.indices,r=e.length,n=0;n<r;n+=3){var i=2*e[n],o=2*e[n+1],s=2*e[n+2];this._renderDrawTriangle(t,i,o,s)}},t.prototype._renderDrawTriangle=function(t,e,r,n){var i=this.renderer.context,o=t.uvs,s=t.vertices,a=t._texture;if(a.valid){var u=a.baseTexture,h=u.source,l=u.width,c=u.height,d=void 0,f=void 0,p=void 0,v=void 0,y=void 0,g=void 0;if(t.uploadUvTransform){var m=t._uvTransform.mapCoord;d=(o[e]*m.a+o[e+1]*m.c+m.tx)*u.width,f=(o[r]*m.a+o[r+1]*m.c+m.tx)*u.width,p=(o[n]*m.a+o[n+1]*m.c+m.tx)*u.width,v=(o[e]*m.b+o[e+1]*m.d+m.ty)*u.height,y=(o[r]*m.b+o[r+1]*m.d+m.ty)*u.height,g=(o[n]*m.b+o[n+1]*m.d+m.ty)*u.height}else d=o[e]*u.width,f=o[r]*u.width,p=o[n]*u.width,v=o[e+1]*u.height,y=o[r+1]*u.height,g=o[n+1]*u.height;var _=s[e],b=s[r],x=s[n],T=s[e+1],w=s[r+1],E=s[n+1];if(t.canvasPadding>0){var S=t.canvasPadding/t.worldTransform.a,O=t.canvasPadding/t.worldTransform.d,P=(_+b+x)/3,M=(T+w+E)/3,C=_-P,R=T-M,A=Math.sqrt(C*C+R*R);_=P+C/A*(A+S),T=M+R/A*(A+O),C=b-P,R=w-M,A=Math.sqrt(C*C+R*R),b=P+C/A*(A+S),w=M+R/A*(A+O),C=x-P,R=E-M,A=Math.sqrt(C*C+R*R),x=P+C/A*(A+S),E=M+R/A*(A+O)}i.save(),i.beginPath(),i.moveTo(_,T),i.lineTo(b,w),i.lineTo(x,E),i.closePath(),i.clip();var I=d*y+v*p+f*g-y*p-v*f-d*g,D=_*y+v*x+b*g-y*x-v*b-_*g,L=d*b+_*p+f*x-b*p-_*f-d*x,N=d*y*x+v*b*p+_*f*g-_*y*p-v*f*x-d*b*g,F=T*y+v*E+w*g-y*E-v*w-T*g,B=d*w+T*p+f*E-w*p-T*f-d*E,k=d*y*E+v*w*p+T*f*g-T*y*p-v*f*E-d*w*g;i.transform(D/I,F/I,L/I,B/I,N/I,k/I),i.drawImage(h,0,0,l*u.resolution,c*u.resolution,0,0,l,c),i.restore()}},t.prototype.renderMeshFlat=function(t){var e=this.renderer.context,r=t.vertices,n=r.length/2;e.beginPath();for(var i=1;i<n-2;++i){var o=2*i,s=r[o],a=r[o+1],u=r[o+2],h=r[o+3],l=r[o+4],c=r[o+5];e.moveTo(s,a),e.lineTo(u,h),e.lineTo(l,c)}e.fillStyle="#FF0000",e.fill(),e.closePath()},t.prototype.destroy=function(){this.renderer=null},t}();r.default=l,a.CanvasRenderer.registerPlugin("mesh",l)},{"../../core":64,"../Mesh":165}],170:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./Mesh");Object.defineProperty(r,"Mesh",{enumerable:!0,get:function(){return n(i).default}});var o=t("./webgl/MeshRenderer");Object.defineProperty(r,"MeshRenderer",{enumerable:!0,get:function(){return n(o).default}});var s=t("./canvas/CanvasMeshRenderer");Object.defineProperty(r,"CanvasMeshRenderer",{enumerable:!0,get:function(){return n(s).default}});var a=t("./Plane");Object.defineProperty(r,"Plane",{enumerable:!0,get:function(){return n(a).default}});var u=t("./NineSlicePlane");Object.defineProperty(r,"NineSlicePlane",{enumerable:!0,get:function(){return n(u).default}});var h=t("./Rope");Object.defineProperty(r,"Rope",{enumerable:!0,get:function(){return n(h).default}})},{"./Mesh":165,"./NineSlicePlane":166,"./Plane":167,"./Rope":168,"./canvas/CanvasMeshRenderer":169,"./webgl/MeshRenderer":171}],171:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u=t("../../core"),h=i(u),l=t("pixi-gl-core"),c=n(l),d=t("../Mesh"),f=n(d),p=(t("path"),h.Matrix.IDENTITY),v=function(t){function e(r){o(this,e);var n=s(this,t.call(this,r));return n.shader=null,n}return a(e,t),e.prototype.onContextChange=function(){var t=this.renderer.gl;this.shader=new h.Shader(t,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n","varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n")},e.prototype.render=function(t){var e=this.renderer,r=e.gl,n=t._texture;if(n.valid){var i=t._glDatas[e.CONTEXT_UID];i||(e.bindVao(null),i={shader:this.shader,vertexBuffer:c.default.GLBuffer.createVertexBuffer(r,t.vertices,r.STREAM_DRAW),uvBuffer:c.default.GLBuffer.createVertexBuffer(r,t.uvs,r.STREAM_DRAW),indexBuffer:c.default.GLBuffer.createIndexBuffer(r,t.indices,r.STATIC_DRAW),vao:null,dirty:t.dirty,indexDirty:t.indexDirty},i.vao=new c.default.VertexArrayObject(r).addIndex(i.indexBuffer).addAttribute(i.vertexBuffer,i.shader.attributes.aVertexPosition,r.FLOAT,!1,8,0).addAttribute(i.uvBuffer,i.shader.attributes.aTextureCoord,r.FLOAT,!1,8,0),t._glDatas[e.CONTEXT_UID]=i),e.bindVao(i.vao),t.dirty!==i.dirty&&(i.dirty=t.dirty,i.uvBuffer.upload(t.uvs)),t.indexDirty!==i.indexDirty&&(i.indexDirty=t.indexDirty,i.indexBuffer.upload(t.indices)),i.vertexBuffer.upload(t.vertices),e.bindShader(i.shader),i.shader.uniforms.uSampler=e.bindTexture(n),e.state.setBlendMode(h.utils.correctBlendMode(t.blendMode,n.baseTexture.premultipliedAlpha)),i.shader.uniforms.uTransform&&(t.uploadUvTransform?i.shader.uniforms.uTransform=t._uvTransform.mapCoord.toArray(!0):i.shader.uniforms.uTransform=p.toArray(!0)),i.shader.uniforms.translationMatrix=t.worldTransform.toArray(!0),i.shader.uniforms.uColor=h.utils.premultiplyRgba(t.tintRgb,t.worldAlpha,i.shader.uniforms.uColor,n.baseTexture.premultipliedAlpha);var o=t.drawMode===f.default.DRAW_MODES.TRIANGLE_MESH?r.TRIANGLE_STRIP:r.TRIANGLES;i.vao.draw(o,t.indices.length,0)}},e}(h.ObjectRenderer);r.default=v,h.WebGLRenderer.registerPlugin("mesh",v)},{"../../core":64,"../Mesh":165,path:22,"pixi-gl-core":12}],172:[function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=t("../core"),h=n(u),l=t("../core/utils"),c=function(t){function e(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1500,n=arguments[1],s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16384;i(this,e);var a=o(this,t.call(this)),u=16384;return s>u&&(s=u),s>r&&(s=r),a._properties=[!1,!0,!1,!1,!1],a._maxSize=r,a._batchSize=s,a._glBuffers={},a._bufferToUpdate=0,a.interactiveChildren=!1,a.blendMode=h.BLEND_MODES.NORMAL,a.roundPixels=!0,a.baseTexture=null,a.setProperties(n),a._tint=0,a.tintRgb=new Float32Array(4),a.tint=16777215,a}return s(e,t),e.prototype.setProperties=function(t){t&&(this._properties[0]="scale"in t?!!t.scale:this._properties[0],this._properties[1]="position"in t?!!t.position:this._properties[1],this._properties[2]="rotation"in t?!!t.rotation:this._properties[2],this._properties[3]="uvs"in t?!!t.uvs:this._properties[3],this._properties[4]="alpha"in t?!!t.alpha:this._properties[4])},e.prototype.updateTransform=function(){this.displayObjectUpdateTransform()},e.prototype.renderWebGL=function(t){var e=this;this.visible&&!(this.worldAlpha<=0)&&this.children.length&&this.renderable&&(this.baseTexture||(this.baseTexture=this.children[0]._texture.baseTexture,this.baseTexture.hasLoaded||this.baseTexture.once("update",function(){return e.onChildrenChange(0)})),t.setObjectRenderer(t.plugins.particle),t.plugins.particle.render(this))},e.prototype.onChildrenChange=function(t){var e=Math.floor(t/this._batchSize);e<this._bufferToUpdate&&(this._bufferToUpdate=e)},e.prototype.renderCanvas=function(t){if(this.visible&&!(this.worldAlpha<=0)&&this.children.length&&this.renderable){var e=t.context,r=this.worldTransform,n=!0,i=0,o=0,s=0,a=0,u=t.blendModes[this.blendMode];u!==e.globalCompositeOperation&&(e.globalCompositeOperation=u),e.globalAlpha=this.worldAlpha,this.displayObjectUpdateTransform();for(var h=0;h<this.children.length;++h){var l=this.children[h];if(l.visible){var c=l._texture.frame;if(e.globalAlpha=this.worldAlpha*l.alpha,l.rotation%(2*Math.PI)===0)n&&(e.setTransform(r.a,r.b,r.c,r.d,r.tx*t.resolution,r.ty*t.resolution),n=!1),i=l.anchor.x*(-c.width*l.scale.x)+l.position.x+.5,o=l.anchor.y*(-c.height*l.scale.y)+l.position.y+.5,s=c.width*l.scale.x,a=c.height*l.scale.y;else{n||(n=!0),l.displayObjectUpdateTransform();var d=l.worldTransform;t.roundPixels?e.setTransform(d.a,d.b,d.c,d.d,d.tx*t.resolution|0,d.ty*t.resolution|0):e.setTransform(d.a,d.b,d.c,d.d,d.tx*t.resolution,d.ty*t.resolution),i=l.anchor.x*-c.width+.5,o=l.anchor.y*-c.height+.5,s=c.width,a=c.height}var f=l._texture.baseTexture.resolution;e.drawImage(l._texture.baseTexture.source,c.x*f,c.y*f,c.width*f,c.height*f,i*t.resolution,o*t.resolution,s*t.resolution,a*t.resolution)}}}},e.prototype.destroy=function(e){if(t.prototype.destroy.call(this,e),this._buffers)for(var r=0;r<this._buffers.length;++r)this._buffers[r].destroy();this._properties=null,this._buffers=null},a(e,[{key:"tint",get:function(){return this._tint},set:function(t){this._tint=t,(0,l.hex2rgb)(t,this.tintRgb)}}]),e}(h.Container);r.default=c},{"../core":64,"../core/utils":123}],173:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./ParticleContainer");Object.defineProperty(r,"ParticleContainer",{enumerable:!0,get:function(){return n(i).default}});var o=t("./webgl/ParticleRenderer");Object.defineProperty(r,"ParticleRenderer",{enumerable:!0,get:function(){return n(o).default}})},{"./ParticleContainer":172,"./webgl/ParticleRenderer":175}],174:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var o=t("pixi-gl-core"),s=n(o),a=t("../../core/utils/createIndicesForQuads"),u=n(a),h=function(){function t(e,r,n,o){i(this,t),this.gl=e,this.vertSize=2,this.vertByteSize=4*this.vertSize,this.size=o,this.dynamicProperties=[],this.staticProperties=[];for(var s=0;s<r.length;++s){var a=r[s];a={attribute:a.attribute,size:a.size,uploadFunction:a.uploadFunction,offset:a.offset},n[s]?this.dynamicProperties.push(a):this.staticProperties.push(a)}this.staticStride=0,this.staticBuffer=null,this.staticData=null,this.dynamicStride=0,this.dynamicBuffer=null,this.dynamicData=null,this.initBuffers()}return t.prototype.initBuffers=function(){var t=this.gl,e=0;this.indices=(0,u.default)(this.size),this.indexBuffer=s.default.GLBuffer.createIndexBuffer(t,this.indices,t.STATIC_DRAW),this.dynamicStride=0;for(var r=0;r<this.dynamicProperties.length;++r){var n=this.dynamicProperties[r];n.offset=e,e+=n.size,this.dynamicStride+=n.size}this.dynamicData=new Float32Array(this.size*this.dynamicStride*4),this.dynamicBuffer=s.default.GLBuffer.createVertexBuffer(t,this.dynamicData,t.STREAM_DRAW);var i=0;this.staticStride=0;for(var o=0;o<this.staticProperties.length;++o){var a=this.staticProperties[o];a.offset=i,i+=a.size,this.staticStride+=a.size}this.staticData=new Float32Array(this.size*this.staticStride*4),this.staticBuffer=s.default.GLBuffer.createVertexBuffer(t,this.staticData,t.STATIC_DRAW),this.vao=new s.default.VertexArrayObject(t).addIndex(this.indexBuffer);for(var h=0;h<this.dynamicProperties.length;++h){var l=this.dynamicProperties[h];this.vao.addAttribute(this.dynamicBuffer,l.attribute,t.FLOAT,!1,4*this.dynamicStride,4*l.offset)}for(var c=0;c<this.staticProperties.length;++c){var d=this.staticProperties[c];this.vao.addAttribute(this.staticBuffer,d.attribute,t.FLOAT,!1,4*this.staticStride,4*d.offset)}},t.prototype.uploadDynamic=function(t,e,r){for(var n=0;n<this.dynamicProperties.length;n++){var i=this.dynamicProperties[n];i.uploadFunction(t,e,r,this.dynamicData,this.dynamicStride,i.offset)}this.dynamicBuffer.upload()},t.prototype.uploadStatic=function(t,e,r){for(var n=0;n<this.staticProperties.length;n++){var i=this.staticProperties[n];i.uploadFunction(t,e,r,this.staticData,this.staticStride,i.offset)}this.staticBuffer.upload()},t.prototype.destroy=function(){this.dynamicProperties=null,this.dynamicData=null,this.dynamicBuffer.destroy(),this.staticProperties=null,this.staticData=null,this.staticBuffer.destroy()},t}();r.default=h},{"../../core/utils/createIndicesForQuads":121,"pixi-gl-core":12}],175:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var u=t("../../core"),h=i(u),l=t("./ParticleShader"),c=n(l),d=t("./ParticleBuffer"),f=n(d),p=function(t){function e(r){o(this,e);var n=s(this,t.call(this,r));return n.shader=null,n.indexBuffer=null,n.properties=null,n.tempMatrix=new h.Matrix,n.CONTEXT_UID=0,n}return a(e,t),e.prototype.onContextChange=function(){var t=this.renderer.gl;this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.shader=new c.default(t),this.properties=[{attribute:this.shader.attributes.aVertexPosition,size:2,uploadFunction:this.uploadVertices,offset:0},{attribute:this.shader.attributes.aPositionCoord,size:2,uploadFunction:this.uploadPosition,offset:0},{attribute:this.shader.attributes.aRotation,size:1,uploadFunction:this.uploadRotation,offset:0},{attribute:this.shader.attributes.aTextureCoord,size:2,uploadFunction:this.uploadUvs,offset:0},{attribute:this.shader.attributes.aColor,size:1,uploadFunction:this.uploadAlpha,offset:0}]},e.prototype.start=function(){this.renderer.bindShader(this.shader)},e.prototype.render=function(t){var e=t.children,r=t._maxSize,n=t._batchSize,i=this.renderer,o=e.length;if(0!==o){o>r&&(o=r);var s=t._glBuffers[i.CONTEXT_UID];s||(s=t._glBuffers[i.CONTEXT_UID]=this.generateBuffers(t));var a=e[0]._texture.baseTexture;this.renderer.setBlendMode(h.utils.correctBlendMode(t.blendMode,a.premultipliedAlpha));var u=i.gl,l=t.worldTransform.copy(this.tempMatrix);l.prepend(i._activeRenderTarget.projectionMatrix),this.shader.uniforms.projectionMatrix=l.toArray(!0),this.shader.uniforms.uColor=h.utils.premultiplyRgba(t.tintRgb,t.worldAlpha,this.shader.uniforms.uColor,a.premultipliedAlpha),this.shader.uniforms.uSampler=i.bindTexture(a);for(var c=0,d=0;c<o;c+=n,d+=1){var f=o-c;f>n&&(f=n);var p=s[d];p.uploadDynamic(e,c,f),t._bufferToUpdate===d&&(p.uploadStatic(e,c,f),t._bufferToUpdate=d+1),i.bindVao(p.vao),p.vao.draw(u.TRIANGLES,6*f)}}},e.prototype.generateBuffers=function(t){for(var e=this.renderer.gl,r=[],n=t._maxSize,i=t._batchSize,o=t._properties,s=0;s<n;s+=i)r.push(new f.default(e,this.properties,o,i));return r},e.prototype.uploadVertices=function(t,e,r,n,i,o){for(var s=0,a=0,u=0,h=0,l=0;l<r;++l){var c=t[e+l],d=c._texture,f=c.scale.x,p=c.scale.y,v=d.trim,y=d.orig;v?(a=v.x-c.anchor.x*y.width,s=a+v.width,h=v.y-c.anchor.y*y.height,u=h+v.height):(s=y.width*(1-c.anchor.x),a=y.width*-c.anchor.x,u=y.height*(1-c.anchor.y),h=y.height*-c.anchor.y),n[o]=a*f,n[o+1]=h*p,n[o+i]=s*f,n[o+i+1]=h*p,n[o+2*i]=s*f,n[o+2*i+1]=u*p,n[o+3*i]=a*f,n[o+3*i+1]=u*p,o+=4*i}},e.prototype.uploadPosition=function(t,e,r,n,i,o){for(var s=0;s<r;s++){var a=t[e+s].position;n[o]=a.x,n[o+1]=a.y,n[o+i]=a.x,n[o+i+1]=a.y,n[o+2*i]=a.x,n[o+2*i+1]=a.y,n[o+3*i]=a.x,n[o+3*i+1]=a.y,o+=4*i}},e.prototype.uploadRotation=function(t,e,r,n,i,o){for(var s=0;s<r;s++){var a=t[e+s].rotation;n[o]=a,n[o+i]=a,n[o+2*i]=a,n[o+3*i]=a,o+=4*i}},e.prototype.uploadUvs=function(t,e,r,n,i,o){for(var s=0;s<r;++s){var a=t[e+s]._texture._uvs;a?(n[o]=a.x0,n[o+1]=a.y0,n[o+i]=a.x1,n[o+i+1]=a.y1,n[o+2*i]=a.x2,n[o+2*i+1]=a.y2,n[o+3*i]=a.x3,n[o+3*i+1]=a.y3,o+=4*i):(n[o]=0,n[o+1]=0,n[o+i]=0,n[o+i+1]=0,n[o+2*i]=0,n[o+2*i+1]=0,n[o+3*i]=0,n[o+3*i+1]=0,o+=4*i)}},e.prototype.uploadAlpha=function(t,e,r,n,i,o){for(var s=0;s<r;s++){var a=t[e+s].alpha;n[o]=a,n[o+i]=a,n[o+2*i]=a,n[o+3*i]=a,o+=4*i}},e.prototype.destroy=function(){this.renderer.gl&&this.renderer.gl.deleteBuffer(this.indexBuffer),t.prototype.destroy.call(this),this.shader.destroy(),this.indices=null,this.tempMatrix=null},e}(h.ObjectRenderer);r.default=p,h.WebGLRenderer.registerPlugin("particle",p)},{"../../core":64,"./ParticleBuffer":174,"./ParticleShader":176}],176:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.__esModule=!0;var a=t("../../core/Shader"),u=n(a),h=function(t){function e(r){return i(this,e),o(this,t.call(this,r,["attribute vec2 aVertexPosition;","attribute vec2 aTextureCoord;","attribute float aColor;","attribute vec2 aPositionCoord;","attribute vec2 aScale;","attribute float aRotation;","uniform mat3 projectionMatrix;","varying vec2 vTextureCoord;","varying float vColor;","void main(void){","   vec2 v = aVertexPosition;","   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);","   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);","   v = v + aPositionCoord;","   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);","   vTextureCoord = aTextureCoord;","   vColor = aColor;","}"].join("\n"),["varying vec2 vTextureCoord;","varying float vColor;","uniform sampler2D uSampler;","uniform vec4 uColor;","void main(void){","  vec4 color = texture2D(uSampler, vTextureCoord) * vColor * uColor;","  if (color.a == 0.0) discard;","  gl_FragColor = color;","}"].join("\n")))}return s(e,t),e}(u.default);r.default=h},{"../../core/Shader":43}],177:[function(t,e,r){"use strict";Math.sign||(Math.sign=function(t){return t=Number(t),0===t||isNaN(t)?t:t>0?1:-1})},{}],178:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}var i=t("object-assign"),o=n(i);Object.assign||(Object.assign=o.default)},{"object-assign":5}],179:[function(t,e,r){"use strict";t("./Object.assign"),t("./requestAnimationFrame"),t("./Math.sign"),window.ArrayBuffer||(window.ArrayBuffer=Array),window.Float32Array||(window.Float32Array=Array),window.Uint32Array||(window.Uint32Array=Array),window.Uint16Array||(window.Uint16Array=Array)},{"./Math.sign":177,"./Object.assign":178,"./requestAnimationFrame":180}],180:[function(t,e,r){(function(t){"use strict";var e=16;Date.now&&Date.prototype.getTime||(Date.now=function(){return(new Date).getTime()}),t.performance&&t.performance.now||!function(){var e=Date.now();t.performance||(t.performance={}),t.performance.now=function(){return Date.now()-e}}();for(var r=Date.now(),n=["ms","moz","webkit","o"],i=0;i<n.length&&!t.requestAnimationFrame;++i){var o=n[i];t.requestAnimationFrame=t[o+"RequestAnimationFrame"],t.cancelAnimationFrame=t[o+"CancelAnimationFrame"]||t[o+"CancelRequestAnimationFrame"]}t.requestAnimationFrame||(t.requestAnimationFrame=function(t){if("function"!=typeof t)throw new TypeError(t+"is not a function");var n=Date.now(),i=e+r-n;return i<0&&(i=0),r=n,setTimeout(function(){r=Date.now(),t(performance.now())},i)}),t.cancelAnimationFrame||(t.cancelAnimationFrame=function(t){return clearTimeout(t)})}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],181:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){var r=!1;if(t&&t._textures&&t._textures.length)for(var n=0;n<t._textures.length;n++)if(t._textures[n]instanceof p.Texture){var i=t._textures[n].baseTexture;e.indexOf(i)===-1&&(e.push(i),r=!0)}return r}function a(t,e){return t instanceof p.BaseTexture&&(e.indexOf(t)===-1&&e.push(t),!0)}function u(t,e){if(t._texture&&t._texture instanceof p.Texture){var r=t._texture.baseTexture;return e.indexOf(r)===-1&&e.push(r),!0}return!1}function h(t,e){return e instanceof p.Text&&(e.updateText(!0),!0)}function l(t,e){if(e instanceof p.TextStyle){var r=e.toFontString();return p.TextMetrics.measureFont(r),!0}return!1}function c(t,e){if(t instanceof p.Text){e.indexOf(t.style)===-1&&e.push(t.style),e.indexOf(t)===-1&&e.push(t);var r=t._texture.baseTexture;return e.indexOf(r)===-1&&e.push(r),!0}return!1}function d(t,e){return t instanceof p.TextStyle&&(e.indexOf(t)===-1&&e.push(t),!0)}r.__esModule=!0;var f=t("../core"),p=i(f),v=t("./limiters/CountLimiter"),y=n(v),g=p.ticker.shared;p.settings.UPLOADS_PER_FRAME=4;var m=function(){function t(e){var r=this;o(this,t),this.limiter=new y.default(p.settings.UPLOADS_PER_FRAME),this.renderer=e,this.uploadHookHelper=null,this.queue=[],this.addHooks=[],this.uploadHooks=[],this.completes=[],this.ticking=!1,this.delayedTick=function(){r.queue&&r.prepareItems()},this.registerFindHook(c),this.registerFindHook(d),this.registerFindHook(s),this.registerFindHook(a),this.registerFindHook(u),this.registerUploadHook(h),this.registerUploadHook(l)}return t.prototype.upload=function(t,e){"function"==typeof t&&(e=t,t=null),t&&this.add(t),this.queue.length?(e&&this.completes.push(e),this.ticking||(this.ticking=!0,g.addOnce(this.tick,this,p.UPDATE_PRIORITY.UTILITY))):e&&e()},t.prototype.tick=function(){setTimeout(this.delayedTick,0)},t.prototype.prepareItems=function(){for(this.limiter.beginFrame();this.queue.length&&this.limiter.allowedToUpload();){var t=this.queue[0],e=!1;if(t&&!t._destroyed)for(var r=0,n=this.uploadHooks.length;r<n;r++)if(this.uploadHooks[r](this.uploadHookHelper,t)){this.queue.shift(),e=!0;break}e||this.queue.shift()}if(this.queue.length)g.addOnce(this.tick,this,p.UPDATE_PRIORITY.UTILITY);else{this.ticking=!1;var i=this.completes.slice(0);this.completes.length=0;for(var o=0,s=i.length;o<s;o++)i[o]()}},t.prototype.registerFindHook=function(t){return t&&this.addHooks.push(t),this},t.prototype.registerUploadHook=function(t){return t&&this.uploadHooks.push(t),this},t.prototype.add=function(t){for(var e=0,r=this.addHooks.length;e<r&&!this.addHooks[e](t,this.queue);e++);if(t instanceof p.Container)for(var n=t.children.length-1;n>=0;n--)this.add(t.children[n]);return this},t.prototype.destroy=function(){this.ticking&&g.remove(this.tick,this),this.ticking=!1,this.addHooks=null,this.uploadHooks=null,this.renderer=null,this.completes=null,this.queue=null,this.limiter=null,this.uploadHookHelper=null},t}();r.default=m},{"../core":64,"./limiters/CountLimiter":184}],182:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function u(t,e){if(e instanceof l.BaseTexture){var r=e.source,n=0===r.width?t.canvas.width:Math.min(t.canvas.width,r.width),i=0===r.height?t.canvas.height:Math.min(t.canvas.height,r.height);return t.ctx.drawImage(r,0,0,n,i,0,0,t.canvas.width,t.canvas.height),!0}return!1}r.__esModule=!0;var h=t("../../core"),l=i(h),c=t("../BasePrepare"),d=n(c),f=16,p=function(t){function e(r){o(this,e);var n=s(this,t.call(this,r));return n.uploadHookHelper=n,n.canvas=document.createElement("canvas"),n.canvas.width=f,n.canvas.height=f,n.ctx=n.canvas.getContext("2d"),n.registerUploadHook(u),n}return a(e,t),e.prototype.destroy=function(){t.prototype.destroy.call(this),this.ctx=null,this.canvas=null},e}(d.default);r.default=p,l.CanvasRenderer.registerPlugin("prepare",p)},{"../../core":64,"../BasePrepare":181}],183:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0;var i=t("./webgl/WebGLPrepare");Object.defineProperty(r,"webgl",{enumerable:!0,get:function(){return n(i).default}});var o=t("./canvas/CanvasPrepare");Object.defineProperty(r,"canvas",{enumerable:!0,get:function(){return n(o).default}});var s=t("./BasePrepare");Object.defineProperty(r,"BasePrepare",{enumerable:!0,get:function(){return n(s).default}});var a=t("./limiters/CountLimiter");Object.defineProperty(r,"CountLimiter",{enumerable:!0,get:function(){return n(a).default}});var u=t("./limiters/TimeLimiter");Object.defineProperty(r,"TimeLimiter",{enumerable:!0,get:function(){return n(u).default}})},{"./BasePrepare":181,"./canvas/CanvasPrepare":182,"./limiters/CountLimiter":184,"./limiters/TimeLimiter":185,"./webgl/WebGLPrepare":186}],184:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function");
}r.__esModule=!0;var i=function(){function t(e){n(this,t),this.maxItemsPerFrame=e,this.itemsLeft=0}return t.prototype.beginFrame=function(){this.itemsLeft=this.maxItemsPerFrame},t.prototype.allowedToUpload=function(){return this.itemsLeft-- >0},t}();r.default=i},{}],185:[function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.__esModule=!0;var i=function(){function t(e){n(this,t),this.maxMilliseconds=e,this.frameStart=0}return t.prototype.beginFrame=function(){this.frameStart=Date.now()},t.prototype.allowedToUpload=function(){return Date.now()-this.frameStart<this.maxMilliseconds},t}();r.default=i},{}],186:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function u(t,e){return e instanceof d.BaseTexture&&(e._glTextures[t.CONTEXT_UID]||t.textureManager.updateTexture(e),!0)}function h(t,e){return e instanceof d.Graphics&&((e.dirty||e.clearDirty||!e._webGL[t.plugins.graphics.CONTEXT_UID])&&t.plugins.graphics.updateGraphics(e),!0)}function l(t,e){return t instanceof d.Graphics&&(e.push(t),!0)}r.__esModule=!0;var c=t("../../core"),d=i(c),f=t("../BasePrepare"),p=n(f),v=function(t){function e(r){o(this,e);var n=s(this,t.call(this,r));return n.uploadHookHelper=n.renderer,n.registerFindHook(l),n.registerUploadHook(u),n.registerUploadHook(h),n}return a(e,t),e}(p.default);r.default=v,d.WebGLRenderer.registerPlugin("prepare",v)},{"../../core":64,"../BasePrepare":181}],187:[function(t,e,r){(function(e){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t){return t&&t.__esModule?t:{default:t}}r.__esModule=!0,r.loader=r.prepare=r.particles=r.mesh=r.loaders=r.interaction=r.filters=r.extras=r.extract=r.accessibility=void 0;var o=t("./polyfill");Object.keys(o).forEach(function(t){"default"!==t&&"__esModule"!==t&&Object.defineProperty(r,t,{enumerable:!0,get:function(){return o[t]}})});var s=t("./core");Object.keys(s).forEach(function(t){"default"!==t&&"__esModule"!==t&&Object.defineProperty(r,t,{enumerable:!0,get:function(){return s[t]}})});var a=t("./deprecation"),u=i(a),h=t("./accessibility"),l=n(h),c=t("./extract"),d=n(c),f=t("./extras"),p=n(f),v=t("./filters"),y=n(v),g=t("./interaction"),m=n(g),_=t("./loaders"),b=n(_),x=t("./mesh"),T=n(x),w=t("./particles"),E=n(w),S=t("./prepare"),O=n(S);s.utils.mixins.performMixins();var P=b.shared||null;r.accessibility=l,r.extract=d,r.extras=p,r.filters=y,r.interaction=m,r.loaders=b,r.mesh=T,r.particles=E,r.prepare=O,r.loader=P,"function"==typeof u.default&&(0,u.default)(r),e.PIXI=r}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./accessibility":41,"./core":64,"./deprecation":129,"./extract":131,"./extras":140,"./filters":151,"./interaction":158,"./loaders":161,"./mesh":170,"./particles":173,"./polyfill":179,"./prepare":183}]},{},[187])(187)});
//# sourceMappingURL=pixi.min.js.map


// sourceMappingURL=pixi.min.js.map
//  pixi-particles - v2.1.5
//  Compiled Tue, 14 Mar 2017 22:08:59 UTC

!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var i;i="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,i.pixiParticles=t()}}(function(){var define,module,exports;return function t(i,e,s){function a(n,o){if(!e[n]){if(!i[n]){var h="function"==typeof require&&require;if(!o&&h)return h(n,!0);if(r)return r(n,!0);var l=new Error("Cannot find module '"+n+"'");throw l.code="MODULE_NOT_FOUND",l}var p=e[n]={exports:{}};i[n][0].call(p.exports,function(t){var e=i[n][1][t];return a(e?e:t)},p,p.exports,t,i,e,s)}return e[n].exports}for(var r="function"==typeof require&&require,n=0;n<s.length;n++)a(s[n]);return a}({1:[function(t,i,e){"use strict";var s=t("./ParticleUtils"),a=t("./Particle"),r=PIXI.Texture,n=function(t){a.call(this,t),this.textures=null,this.duration=0,this.framerate=0,this.elapsed=0,this.loop=!1},o=a.prototype,h=n.prototype=Object.create(o);h.init=function(){this.Particle_init(),this.elapsed=0,this.framerate<0&&(this.duration=this.maxLife,this.framerate=this.textures.length/this.duration)},h.applyArt=function(t){this.textures=t.textures,this.framerate=t.framerate,this.duration=t.duration,this.loop=t.loop},h.update=function(t){if(this.Particle_update(t)>=0){this.elapsed+=t,this.elapsed>this.duration&&(this.loop?this.elapsed=this.elapsed%this.duration:this.elapsed=this.duration-1e-6);var i=this.elapsed*this.framerate+1e-7|0;this.texture=this.textures[i]||s.EMPTY_TEXTURE}},h.Particle_destroy=a.prototype.destroy,h.destroy=function(){this.Particle_destroy(),this.textures=null},n.parseArt=function(t){var i,e,s,a,n,o,h=[];for(i=0;i<t.length;++i){for(e=t[i],t[i]=h={},h.textures=o=[],a=e.textures,s=0;s<a.length;++s)if(n=a[s],"string"==typeof n)o.push(r.fromImage(n));else if(n instanceof r)o.push(n);else{var l=n.count||1;for(n="string"==typeof n.texture?r.fromImage(n.texture):n.texture;l>0;--l)o.push(n)}"matchLife"==e.framerate?(h.framerate=-1,h.duration=0,h.loop=!1):(h.loop=!!e.loop,h.framerate=e.framerate>0?e.framerate:60,h.duration=o.length/h.framerate)}return t},i.exports=n},{"./Particle":3,"./ParticleUtils":4}],2:[function(t,i,e){"use strict";var s=t("./ParticleUtils"),a=t("./Particle"),r=PIXI.particles.ParticleContainer||PIXI.ParticleContainer,n=PIXI.ticker.shared,o=function(t,i,e){this._particleConstructor=a,this.particleImages=null,this.startAlpha=1,this.endAlpha=1,this.startSpeed=0,this.endSpeed=0,this.minimumSpeedMultiplier=1,this.acceleration=null,this.maxSpeed=NaN,this.startScale=1,this.endScale=1,this.minimumScaleMultiplier=1,this.startColor=null,this.endColor=null,this.minLifetime=0,this.maxLifetime=0,this.minStartRotation=0,this.maxStartRotation=0,this.noRotation=!1,this.minRotationSpeed=0,this.maxRotationSpeed=0,this.particleBlendMode=0,this.customEase=null,this.extraData=null,this._frequency=1,this.maxParticles=1e3,this.emitterLifetime=-1,this.spawnPos=null,this.spawnType=null,this._spawnFunc=null,this.spawnRect=null,this.spawnCircle=null,this.particlesPerWave=1,this.particleSpacing=0,this.angleStart=0,this.rotation=0,this.ownerPos=null,this._prevEmitterPos=null,this._prevPosIsValid=!1,this._posChanged=!1,this._parentIsPC=!1,this._parent=null,this.addAtBack=!1,this.particleCount=0,this._emit=!1,this._spawnTimer=0,this._emitterLife=-1,this._activeParticlesFirst=null,this._activeParticlesLast=null,this._poolFirst=null,this._origConfig=null,this._origArt=null,this._autoUpdate=!1,this._destroyWhenComplete=!1,this.parent=t,i&&e&&this.init(i,e),this.recycle=this.recycle,this.update=this.update,this.rotate=this.rotate,this.updateSpawnPos=this.updateSpawnPos,this.updateOwnerPos=this.updateOwnerPos},h=o.prototype={},l=new PIXI.Point;Object.defineProperty(h,"frequency",{get:function(){return this._frequency},set:function(t){"number"==typeof t&&t>0?this._frequency=t:this._frequency=1}}),Object.defineProperty(h,"particleConstructor",{get:function(){return this._particleConstructor},set:function(t){if(t!=this._particleConstructor){this._particleConstructor=t,this.cleanup();for(var i=this._poolFirst;i;i=i.next)i.destroy();this._poolFirst=null,this._origConfig&&this._origArt&&this.init(this._origArt,this._origConfig)}}}),Object.defineProperty(h,"parent",{get:function(){return this._parent},set:function(t){if(this._parentIsPC)for(var i=this._poolFirst;i;i=i.next)i.parent&&i.parent.removeChild(i);this.cleanup(),this._parent=t,this._parentIsPC=r&&t&&t instanceof r}}),h.init=function(t,i){if(t&&i){this.cleanup(),this._origConfig=i,this._origArt=t,t=Array.isArray(t)?t.slice():[t];var e=this._particleConstructor;this.particleImages=e.parseArt?e.parseArt(t):t,i.alpha?(this.startAlpha=i.alpha.start,this.endAlpha=i.alpha.end):this.startAlpha=this.endAlpha=1,i.speed?(this.startSpeed=i.speed.start,this.endSpeed=i.speed.end,this.minimumSpeedMultiplier=i.speed.minimumSpeedMultiplier||1):(this.minimumSpeedMultiplier=1,this.startSpeed=this.endSpeed=0);var a=i.acceleration;a&&(a.x||a.y)?(this.endSpeed=this.startSpeed,this.acceleration=new PIXI.Point(a.x,a.y),this.maxSpeed=i.maxSpeed||NaN):this.acceleration=new PIXI.Point,i.scale?(this.startScale=i.scale.start,this.endScale=i.scale.end,this.minimumScaleMultiplier=i.scale.minimumScaleMultiplier||1):this.startScale=this.endScale=this.minimumScaleMultiplier=1,i.color&&(this.startColor=s.hexToRGB(i.color.start),i.color.start!=i.color.end?this.endColor=s.hexToRGB(i.color.end):this.endColor=null),i.startRotation?(this.minStartRotation=i.startRotation.min,this.maxStartRotation=i.startRotation.max):this.minStartRotation=this.maxStartRotation=0,i.noRotation&&(this.minStartRotation||this.maxStartRotation)?this.noRotation=!!i.noRotation:this.noRotation=!1,i.rotationSpeed?(this.minRotationSpeed=i.rotationSpeed.min,this.maxRotationSpeed=i.rotationSpeed.max):this.minRotationSpeed=this.maxRotationSpeed=0,this.minLifetime=i.lifetime.min,this.maxLifetime=i.lifetime.max,this.particleBlendMode=s.getBlendMode(i.blendMode),i.ease?this.customEase="function"==typeof i.ease?i.ease:s.generateEase(i.ease):this.customEase=null,e.parseData?this.extraData=e.parseData(i.extraData):this.extraData=i.extraData||null,this.spawnRect=this.spawnCircle=null,this.particlesPerWave=1,this.particleSpacing=0,this.angleStart=0;var r;switch(i.spawnType){case"rect":this.spawnType="rect",this._spawnFunc=this._spawnRect;var n=i.spawnRect;this.spawnRect=new PIXI.Rectangle(n.x,n.y,n.w,n.h);break;case"circle":this.spawnType="circle",this._spawnFunc=this._spawnCircle,r=i.spawnCircle,this.spawnCircle=new PIXI.Circle(r.x,r.y,r.r);break;case"ring":this.spawnType="ring",this._spawnFunc=this._spawnRing,r=i.spawnCircle,this.spawnCircle=new PIXI.Circle(r.x,r.y,r.r),this.spawnCircle.minRadius=r.minR;break;case"burst":this.spawnType="burst",this._spawnFunc=this._spawnBurst,this.particlesPerWave=i.particlesPerWave,this.particleSpacing=i.particleSpacing,this.angleStart=i.angleStart?i.angleStart:0;break;case"point":this.spawnType="point",this._spawnFunc=this._spawnPoint;break;default:this.spawnType="point",this._spawnFunc=this._spawnPoint}this.frequency=i.frequency,this.emitterLifetime=i.emitterLifetime||-1,this.maxParticles=i.maxParticles>0?i.maxParticles:1e3,this.addAtBack=!!i.addAtBack,this.rotation=0,this.ownerPos=new PIXI.Point,this.spawnPos=new PIXI.Point(i.pos.x,i.pos.y),this._prevEmitterPos=this.spawnPos.clone(),this._prevPosIsValid=!1,this._spawnTimer=0,this.emit=void 0===i.emit||!!i.emit,this.autoUpdate=void 0!==i.autoUpdate&&!!i.autoUpdate}},h.recycle=function(t){t.next&&(t.next.prev=t.prev),t.prev&&(t.prev.next=t.next),t==this._activeParticlesLast&&(this._activeParticlesLast=t.prev),t==this._activeParticlesFirst&&(this._activeParticlesFirst=t.next),t.prev=null,t.next=this._poolFirst,this._poolFirst=t,this._parentIsPC?(t.alpha=0,t.visible=!1):t.parent&&t.parent.removeChild(t),--this.particleCount},h.rotate=function(t){if(this.rotation!=t){var i=t-this.rotation;this.rotation=t,s.rotatePoint(i,this.spawnPos),this._posChanged=!0}},h.updateSpawnPos=function(t,i){this._posChanged=!0,this.spawnPos.x=t,this.spawnPos.y=i},h.updateOwnerPos=function(t,i){this._posChanged=!0,this.ownerPos.x=t,this.ownerPos.y=i},h.resetPositionTracking=function(){this._prevPosIsValid=!1},Object.defineProperty(h,"emit",{get:function(){return this._emit},set:function(t){this._emit=!!t,this._emitterLife=this.emitterLifetime}}),Object.defineProperty(h,"autoUpdate",{get:function(){return this._autoUpdate},set:function(t){this._autoUpdate&&!t?n.remove(this.update,this):!this._autoUpdate&&t&&n.add(this.update,this),this._autoUpdate=!!t}}),h.playOnceAndDestroy=function(){this.autoUpdate=!0,this.emit=!0,this._destroyWhenComplete=!0},h.update=function(t){if(this._autoUpdate&&(t=t/PIXI.settings.TARGET_FPMS/1e3),this._parent){var i,e,s;for(e=this._activeParticlesFirst;e;e=s)s=e.next,e.update(t);var a,r;this._prevPosIsValid&&(a=this._prevEmitterPos.x,r=this._prevEmitterPos.y);var n=this.ownerPos.x+this.spawnPos.x,o=this.ownerPos.y+this.spawnPos.y;if(this._emit)for(this._spawnTimer-=t;this._spawnTimer<=0;){if(this._emitterLife>0&&(this._emitterLife-=this._frequency,this._emitterLife<=0)){this._spawnTimer=0,this._emitterLife=0,this.emit=!1;break}if(this.particleCount>=this.maxParticles)this._spawnTimer+=this._frequency;else{var h;if(h=this.minLifetime==this.maxLifetime?this.minLifetime:Math.random()*(this.maxLifetime-this.minLifetime)+this.minLifetime,-this._spawnTimer<h){var l,p;if(this._prevPosIsValid&&this._posChanged){var c=1+this._spawnTimer/t;l=(n-a)*c+a,p=(o-r)*c+r}else l=n,p=o;i=0;for(var d=Math.min(this.particlesPerWave,this.maxParticles-this.particleCount);i<d;++i){var u,m;if(this._poolFirst?(u=this._poolFirst,this._poolFirst=this._poolFirst.next,u.next=null):u=new this.particleConstructor(this),this.particleImages.length>1?u.applyArt(this.particleImages.random()):u.applyArt(this.particleImages[0]),u.startAlpha=this.startAlpha,u.endAlpha=this.endAlpha,1!=this.minimumSpeedMultiplier?(m=Math.random()*(1-this.minimumSpeedMultiplier)+this.minimumSpeedMultiplier,u.startSpeed=this.startSpeed*m,u.endSpeed=this.endSpeed*m):(u.startSpeed=this.startSpeed,u.endSpeed=this.endSpeed),u.acceleration.x=this.acceleration.x,u.acceleration.y=this.acceleration.y,u.maxSpeed=this.maxSpeed,1!=this.minimumScaleMultiplier?(m=Math.random()*(1-this.minimumScaleMultiplier)+this.minimumScaleMultiplier,u.startScale=this.startScale*m,u.endScale=this.endScale*m):(u.startScale=this.startScale,u.endScale=this.endScale),u.startColor=this.startColor,u.endColor=this.endColor,this.minRotationSpeed==this.maxRotationSpeed?u.rotationSpeed=this.minRotationSpeed:u.rotationSpeed=Math.random()*(this.maxRotationSpeed-this.minRotationSpeed)+this.minRotationSpeed,u.noRotation=this.noRotation,u.maxLife=h,u.blendMode=this.particleBlendMode,u.ease=this.customEase,u.extraData=this.extraData,this._spawnFunc(u,l,p,i),u.init(),u.update(-this._spawnTimer),this._parentIsPC&&u.parent){var f=this._parent.children;if(f[0]==u)f.shift();else if(f[f.length-1]==u)f.pop();else{var P=f.indexOf(u);f.splice(P,1)}this.addAtBack?f.unshift(u):f.push(u)}else this.addAtBack?this._parent.addChildAt(u,0):this._parent.addChild(u);this._activeParticlesLast?(this._activeParticlesLast.next=u,u.prev=this._activeParticlesLast,this._activeParticlesLast=u):this._activeParticlesLast=this._activeParticlesFirst=u,++this.particleCount}}this._spawnTimer+=this._frequency}}this._posChanged&&(this._prevEmitterPos.x=n,this._prevEmitterPos.y=o,this._prevPosIsValid=!0,this._posChanged=!1),!this._destroyWhenComplete||this._emit||this._activeParticlesFirst||this.destroy()}},h._spawnPoint=function(t,i,e){this.minStartRotation==this.maxStartRotation?t.rotation=this.minStartRotation+this.rotation:t.rotation=Math.random()*(this.maxStartRotation-this.minStartRotation)+this.minStartRotation+this.rotation,t.position.x=i,t.position.y=e},h._spawnRect=function(t,i,e){this.minStartRotation==this.maxStartRotation?t.rotation=this.minStartRotation+this.rotation:t.rotation=Math.random()*(this.maxStartRotation-this.minStartRotation)+this.minStartRotation+this.rotation,l.x=Math.random()*this.spawnRect.width+this.spawnRect.x,l.y=Math.random()*this.spawnRect.height+this.spawnRect.y,0!==this.rotation&&s.rotatePoint(this.rotation,l),t.position.x=i+l.x,t.position.y=e+l.y},h._spawnCircle=function(t,i,e){this.minStartRotation==this.maxStartRotation?t.rotation=this.minStartRotation+this.rotation:t.rotation=Math.random()*(this.maxStartRotation-this.minStartRotation)+this.minStartRotation+this.rotation,l.x=Math.random()*this.spawnCircle.radius,l.y=0,s.rotatePoint(360*Math.random(),l),l.x+=this.spawnCircle.x,l.y+=this.spawnCircle.y,0!==this.rotation&&s.rotatePoint(this.rotation,l),t.position.x=i+l.x,t.position.y=e+l.y},h._spawnRing=function(t,i,e){var a=this.spawnCircle;this.minStartRotation==this.maxStartRotation?t.rotation=this.minStartRotation+this.rotation:t.rotation=Math.random()*(this.maxStartRotation-this.minStartRotation)+this.minStartRotation+this.rotation,a.minRadius==a.radius?l.x=Math.random()*(a.radius-a.minRadius)+a.minRadius:l.x=a.radius,l.y=0;var r=360*Math.random();t.rotation+=r,s.rotatePoint(r,l),l.x+=this.spawnCircle.x,l.y+=this.spawnCircle.y,0!==this.rotation&&s.rotatePoint(this.rotation,l),t.position.x=i+l.x,t.position.y=e+l.y},h._spawnBurst=function(t,i,e,s){0===this.particleSpacing?t.rotation=360*Math.random():t.rotation=this.angleStart+this.particleSpacing*s+this.rotation,t.position.x=i,t.position.y=e},h.cleanup=function(){var t,i;for(t=this._activeParticlesFirst;t;t=i)i=t.next,this.recycle(t),t.parent&&t.parent.removeChild(t);this._activeParticlesFirst=this._activeParticlesLast=null,this.particleCount=0},h.destroy=function(){this.autoUpdate=!1,this.cleanup();for(var t,i=this._poolFirst;i;i=t)t=i.next,i.destroy();this._poolFirst=this._parent=this.particleImages=this.spawnPos=this.ownerPos=this.startColor=this.endColor=this.customEase=null},i.exports=o},{"./Particle":3,"./ParticleUtils":4}],3:[function(t,i,e){var s=t("./ParticleUtils"),a=PIXI.Sprite,r=function(t){a.call(this),this.emitter=t,this.anchor.x=this.anchor.y=.5,this.velocity=new PIXI.Point,this.maxLife=0,this.age=0,this.ease=null,this.extraData=null,this.startAlpha=0,this.endAlpha=0,this.startSpeed=0,this.endSpeed=0,this.acceleration=new PIXI.Point,this.maxSpeed=NaN,this.startScale=0,this.endScale=0,this.startColor=null,this._sR=0,this._sG=0,this._sB=0,this.endColor=null,this._eR=0,this._eG=0,this._eB=0,this._doAlpha=!1,this._doScale=!1,this._doSpeed=!1,this._doAcceleration=!1,this._doColor=!1,this._doNormalMovement=!1,this._oneOverLife=0,this.next=null,this.prev=null,this.init=this.init,this.Particle_init=this.Particle_init,this.update=this.update,this.Particle_update=this.Particle_update,this.applyArt=this.applyArt,this.kill=this.kill},n=r.prototype=Object.create(a.prototype);n.init=n.Particle_init=function(){this.age=0,this.velocity.x=this.startSpeed,this.velocity.y=0,s.rotatePoint(this.rotation,this.velocity),this.noRotation?this.rotation=0:this.rotation*=s.DEG_TO_RADS,this.rotationSpeed*=s.DEG_TO_RADS,this.alpha=this.startAlpha,this.scale.x=this.scale.y=this.startScale,this.startColor&&(this._sR=this.startColor[0],this._sG=this.startColor[1],this._sB=this.startColor[2],this.endColor&&(this._eR=this.endColor[0],this._eG=this.endColor[1],this._eB=this.endColor[2])),this._doAlpha=this.startAlpha!=this.endAlpha,this._doSpeed=this.startSpeed!=this.endSpeed,this._doScale=this.startScale!=this.endScale,this._doColor=!!this.endColor,this._doAcceleration=0!==this.acceleration.x||0!==this.acceleration.y,this._doNormalMovement=this._doSpeed||0!==this.startSpeed||this._doAcceleration,this._oneOverLife=1/this.maxLife,this.tint=s.combineRGBComponents(this._sR,this._sG,this._sB),this.visible=!0},n.applyArt=function(t){this.texture=t||s.EMPTY_TEXTURE},n.update=n.Particle_update=function(t){if(this.age+=t,this.age>=this.maxLife)return this.kill(),-1;var i=this.age*this._oneOverLife;if(this.ease&&(i=4==this.ease.length?this.ease(i,0,1,1):this.ease(i)),this._doAlpha&&(this.alpha=(this.endAlpha-this.startAlpha)*i+this.startAlpha),this._doScale){var e=(this.endScale-this.startScale)*i+this.startScale;this.scale.x=this.scale.y=e}if(this._doNormalMovement){if(this._doSpeed){var a=(this.endSpeed-this.startSpeed)*i+this.startSpeed;s.normalize(this.velocity),s.scaleBy(this.velocity,a)}else if(this._doAcceleration&&(this.velocity.x+=this.acceleration.x*t,this.velocity.y+=this.acceleration.y*t,this.maxSpeed)){var r=s.length(this.velocity);r>this.maxSpeed&&s.scaleBy(this.velocity,this.maxSpeed/r)}this.position.x+=this.velocity.x*t,this.position.y+=this.velocity.y*t}if(this._doColor){var n=(this._eR-this._sR)*i+this._sR,o=(this._eG-this._sG)*i+this._sG,h=(this._eB-this._sB)*i+this._sB;this.tint=s.combineRGBComponents(n,o,h)}return 0!==this.rotationSpeed?this.rotation+=this.rotationSpeed*t:this.acceleration&&!this.noRotation&&(this.rotation=Math.atan2(this.velocity.y,this.velocity.x)),i},n.kill=function(){this.emitter.recycle(this)},n.Sprite_Destroy=a.prototype.destroy,n.destroy=function(){this.parent&&this.parent.removeChild(this),this.Sprite_Destroy&&this.Sprite_Destroy(),this.emitter=this.velocity=this.startColor=this.endColor=this.ease=this.next=this.prev=null},r.parseArt=function(t){var i;for(i=t.length;i>=0;--i)"string"==typeof t[i]&&(t[i]=PIXI.Texture.fromImage(t[i]));if(s.verbose)for(i=t.length-1;i>0;--i)if(t[i].baseTexture!=t[i-1].baseTexture){window.console&&console.warn("PixiParticles: using particle textures from different images may hinder performance in WebGL");break}return t},r.parseData=function(t){return t},i.exports=r},{"./ParticleUtils":4}],4:[function(t,i,e){"use strict";var s=PIXI.BLEND_MODES||PIXI.blendModes,a=PIXI.Texture,r={};r.verbose=!1;var n=r.DEG_TO_RADS=Math.PI/180,o=r.EMPTY_TEXTURE=a.EMPTY;o.on=o.destroy=o.once=o.emit=function(){},r.rotatePoint=function(t,i){if(t){t*=n;var e=Math.sin(t),s=Math.cos(t),a=i.x*s-i.y*e,r=i.x*e+i.y*s;i.x=a,i.y=r}},r.combineRGBComponents=function(t,i,e){return t<<16|i<<8|e},r.normalize=function(t){var i=1/r.length(t);t.x*=i,t.y*=i},r.scaleBy=function(t,i){t.x*=i,t.y*=i},r.length=function(t){return Math.sqrt(t.x*t.x+t.y*t.y)},r.hexToRGB=function(t,i){i?i.length=0:i=[],"#"==t.charAt(0)?t=t.substr(1):0===t.indexOf("0x")&&(t=t.substr(2));var e;return 8==t.length&&(e=t.substr(0,2),t=t.substr(2)),i.push(parseInt(t.substr(0,2),16)),i.push(parseInt(t.substr(2,2),16)),i.push(parseInt(t.substr(4,2),16)),e&&i.push(parseInt(e,16)),i},r.generateEase=function(t){var i=t.length,e=1/i,s=function(s){var a,r,n=i*s|0;return a=(s-n*e)*i,r=t[n]||t[i-1],r.s+a*(2*(1-a)*(r.cp-r.s)+a*(r.e-r.s))};return s},r.getBlendMode=function(t){if(!t)return s.NORMAL;for(t=t.toUpperCase();t.indexOf(" ")>=0;)t=t.replace(" ","_");return s[t]||s.NORMAL},i.exports=r},{}],5:[function(require,module,exports){"use strict";var ParticleUtils=require("./ParticleUtils"),Particle=require("./Particle"),PathParticle=function(t){Particle.call(this,t),this.path=null,this.initialRotation=0,this.initialPosition=new PIXI.Point,this.movement=0},s=Particle.prototype,p=PathParticle.prototype=Object.create(s),helperPoint=new PIXI.Point;p.init=function(){this.initialRotation=this.rotation,this.Particle_init(),this.path=this.extraData.path,this._doNormalMovement=!this.path,this.movement=0,this.initialPosition.x=this.position.x,this.initialPosition.y=this.position.y};for(var MATH_FUNCS=["pow","sqrt","abs","floor","round","ceil","E","PI","sin","cos","tan","asin","acos","atan","atan2","log"],WHITELISTER="[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]",index=MATH_FUNCS.length-1;index>=0;--index)WHITELISTER+="|"+MATH_FUNCS[index];WHITELISTER=new RegExp(WHITELISTER,"g");var parsePath=function(pathString){for(var rtn,matches=pathString.match(WHITELISTER),i=matches.length-1;i>=0;--i)MATH_FUNCS.indexOf(matches[i])>=0&&(matches[i]="Math."+matches[i]);return pathString=matches.join(""),eval("rtn = function(x){ return "+pathString+"; };"),rtn};p.update=function(t){var i=this.Particle_update(t);if(i>=0&&this.path){var e=(this.endSpeed-this.startSpeed)*i+this.startSpeed;this.movement+=e*t,helperPoint.x=this.movement,helperPoint.y=this.path(this.movement),ParticleUtils.rotatePoint(this.initialRotation,helperPoint),this.position.x=this.initialPosition.x+helperPoint.x,this.position.y=this.initialPosition.y+helperPoint.y}},p.Particle_destroy=Particle.prototype.destroy,p.destroy=function(){this.Particle_destroy(),this.path=this.initialPosition=null},PathParticle.parseArt=function(t){return Particle.parseArt(t)},PathParticle.parseData=function(t){var i={};if(t&&t.path)try{i.path=parsePath(t.path)}catch(t){ParticleUtils.verbose&&console.error("PathParticle: error in parsing path expression"),i.path=null}else ParticleUtils.verbose&&console.error("PathParticle requires a path string in extraData!"),i.path=null;return i},module.exports=PathParticle},{"./Particle":3,"./ParticleUtils":4}],6:[function(t,i,e){},{}],7:[function(t,i,e){t("./polyfills.js"),e.ParticleUtils=t("./ParticleUtils.js"),e.Particle=t("./Particle.js"),e.Emitter=t("./Emitter.js"),e.PathParticle=t("./PathParticle.js"),e.AnimatedParticle=t("./AnimatedParticle.js"),t("./deprecation.js")},{"./AnimatedParticle.js":1,"./Emitter.js":2,"./Particle.js":3,"./ParticleUtils.js":4,"./PathParticle.js":5,"./deprecation.js":6,"./polyfills.js":8}],8:[function(t,i,e){Array.prototype.shuffle||Object.defineProperty(Array.prototype,"shuffle",{enumerable:!1,writable:!1,value:function(){for(var t,i,e=this.length;e;t=Math.floor(Math.random()*e),i=this[--e],this[e]=this[t],this[t]=i);return this}}),Array.prototype.random||Object.defineProperty(Array.prototype,"random",{enumerable:!1,writable:!1,value:function(){return this[Math.floor(Math.random()*this.length)]}})},{}],9:[function(t,i,e){"use strict";var s="undefined"!=typeof window?window:GLOBAL;if(s.PIXI.particles||(s.PIXI.particles={}),"undefined"!=typeof i&&i.exports)"undefined"==typeof PIXI&&t("pixi.js"),i.exports=s.PIXI.particles||a;else if("undefined"==typeof PIXI)throw"pixi-particles requires pixi.js to be loaded first";var a=t("./particles");for(var r in a)s.PIXI.particles[r]=a[r]},{"./particles":7,"pixi.js":void 0}]},{},[9])(9)});

var __extends=this&&this.__extends||function(){var t=Object.setPrototypeOf;return function(e,n){function o(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}(),INTERACTION_EVENTS=["pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","mouseover","mouseenter","mousedown","mousemove","mouseup","mousecancel","mouseout","mouseleave","touchover","touchenter","touchdown","touchmove","touchup","touchcancel","touchout","touchleave"],MultiStyleText=function(t){function e(e,n){var o=t.call(this,e)||this;return o.styles=n,INTERACTION_EVENTS.forEach(function(t){o.on(t,function(t){return o.handleInteraction(t)})}),o}return __extends(e,t),e.prototype.handleInteraction=function(t){var e=t,n=t.data.getLocalPosition(this),o=this.hitboxes.reduce(function(t,e){return void 0!==t?t:e.hitbox.contains(n.x,n.y)?e:void 0},void 0);e.targetTag=void 0===o?void 0:o.tag},Object.defineProperty(e.prototype,"styles",{set:function(t){this.textStyles={},this.textStyles["default"]=this.assign({},e.DEFAULT_TAG_STYLE);for(var n in t)"default"===n?this.assign(this.textStyles["default"],t[n]):this.textStyles[n]=this.assign({},t[n]);this._style=new PIXI.TextStyle(this.textStyles["default"]),this.dirty=!0},enumerable:!0,configurable:!0}),e.prototype.setTagStyle=function(t,e){t in this.textStyles?this.assign(this.textStyles[t],e):this.textStyles[t]=this.assign({},e),this._style=new PIXI.TextStyle(this.textStyles["default"]),this.dirty=!0},e.prototype.deleteTagStyle=function(t){"default"===t?this.textStyles["default"]=this.assign({},e.DEFAULT_TAG_STYLE):delete this.textStyles[t],this._style=new PIXI.TextStyle(this.textStyles["default"]),this.dirty=!0},e.prototype.getTagRegex=function(t,e){var n=Object.keys(this.textStyles).join("|");n=t?"("+n+")":"(?:"+n+")";var o="<"+n+"(?:\\s+[A-Za-z0-9_\\-]+=(?:\"(?:[^\"]+|\\\\\")*\"|'(?:[^']+|\\\\')*'))*\\s*>|</"+n+"\\s*>";return e&&(o="("+o+")"),new RegExp(o,"g")},e.prototype.getPropertyRegex=function(){return new RegExp("([A-Za-z0-9_\\-]+)=(?:\"((?:[^\"]+|\\\\\")*)\"|'((?:[^']+|\\\\')*)')","g")},e.prototype._getTextDataPerLine=function(t){for(var e=[],n=this.getTagRegex(!0,!1),o=[this.assign({},this.textStyles["default"])],i=[{name:"default",properties:{}}],s=0;s<t.length;s++){for(var r=[],a=[],h=void 0;h=n.exec(t[s]);)a.push(h);if(0===a.length)r.push(this.createTextData(t[s],o[o.length-1],i[i.length-1]));else{for(var l=0,c=0;c<a.length;c++){if(a[c].index>l&&r.push(this.createTextData(t[s].substring(l,a[c].index),o[o.length-1],i[i.length-1])),"/"===a[c][0][1])o.length>1&&(o.pop(),i.pop());else{o.push(this.assign({},o[o.length-1],this.textStyles[a[c][1]]));for(var x={},d=this.getPropertyRegex(),u=void 0;u=d.exec(a[c][0]);)x[u[1]]=u[2]||u[3];i.push({name:a[c][1],properties:x})}l=a[c].index+a[c][0].length}l<t[s].length&&r.push(this.createTextData(t[s].substring(l),o[o.length-1],i[i.length-1]))}e.push(r)}return e},e.prototype.getFontString=function(t){return new PIXI.TextStyle(t).toFontString()},e.prototype.createTextData=function(t,e,n){return{text:t,style:e,width:0,height:0,fontProperties:void 0,tag:n}},e.prototype.getDropShadowPadding=function(){var t=this,e=0,n=0;return Object.keys(this.textStyles).forEach(function(o){var i=t.textStyles[o],s=i.dropShadowDistance,r=i.dropShadowBlur;e=Math.max(e,s||0),n=Math.max(n,r||0)}),e+n},e.prototype.updateText=function(){var t=this;if(this.dirty){this.hitboxes=[],this.texture.baseTexture.resolution=this.resolution;var n=this.textStyles,o=this.text;this._style.wordWrap&&(o=this.wordWrap(this.text));for(var i=o.split(/(?:\r\n|\r|\n)/),s=this._getTextDataPerLine(i),r=[],a=[],h=[],l=0,c=0;c<i.length;c++){for(var x=0,d=0,u=0,g=0;g<s[c].length;g++){var p=s[c][g].style;this.context.font=this.getFontString(p),s[c][g].width=this.context.measureText(s[c][g].text).width,0===s[c][g].text.length&&(s[c][g].width+=(s[c][g].text.length-1)*p.letterSpacing,g>0&&(x+=p.letterSpacing/2),g<s[c].length-1&&(x+=p.letterSpacing/2)),x+=s[c][g].width,s[c][g].fontProperties=PIXI.TextMetrics.measureFont(this.context.font),s[c][g].height=s[c][g].fontProperties.fontSize+s[c][g].style.strokeThickness,"number"==typeof p.valign?(d=Math.min(d,p.valign-s[c][g].fontProperties.descent),u=Math.max(u,p.valign+s[c][g].fontProperties.ascent)):(d=Math.min(d,-s[c][g].fontProperties.descent),u=Math.max(u,s[c][g].fontProperties.ascent))}r[c]=x,a[c]=d,h[c]=u,l=Math.max(l,x)}var f=Object.keys(n).map(function(t){return n[t]}),y=f.reduce(function(t,e){return Math.max(t,e.strokeThickness||0)},0),b=this.getDropShadowPadding(),v=h.reduce(function(t,e){return t+e},0)-a.reduce(function(t,e){return t+e},0),S=l+y+2*b,T=v+2*b;this.canvas.width=(S+this.context.lineWidth)*this.resolution,this.canvas.height=T*this.resolution,this.context.scale(this.resolution,this.resolution),this.context.textBaseline="alphabetic",this.context.lineJoin="round";for(var w=b,m=[],c=0;c<s.length;c++){var k=s[c],P=void 0;switch(this._style.align){case"left":P=b;break;case"center":P=b+(l-r[c])/2;break;case"right":P=b+l-r[c]}for(var g=0;g<k.length;g++){var I=k[g],_=I.style,O=I.text,E=I.fontProperties,F=I.width,A=(I.height,I.tag);P+=y/2;var D=y/2+w+E.ascent;switch(_.valign){case"top":break;case"baseline":D+=h[c]-E.ascent;break;case"middle":D+=(h[c]-a[c]-E.ascent-E.descent)/2;break;case"bottom":D+=h[c]-a[c]-E.ascent-E.descent;break;default:D+=h[c]-E.ascent-_.valign}if(0===_.letterSpacing)m.push({text:O,style:_,x:P,y:D,width:F,ascent:E.ascent,descent:E.descent,tag:A}),P+=k[g].width;else{this.context.font=this.getFontString(k[g].style);for(var W=0;W<O.length;W++)(W>0||g>0)&&(P+=_.letterSpacing/2),m.push({text:O.charAt(W),style:_,x:P,y:D,width:F,ascent:E.ascent,descent:E.descent,tag:A}),P+=this.context.measureText(O.charAt(W)).width,(W<O.length-1||g<k.length-1)&&(P+=_.letterSpacing/2)}P-=y/2}w+=h[c]-a[c]}this.context.save(),m.forEach(function(e){var n=e.style,o=e.text,i=e.x,s=e.y;if(n.dropShadow){t.context.font=t.getFontString(n);var r=n.dropShadowColor;"number"==typeof r&&(r=PIXI.utils.hex2string(r)),t.context.shadowColor=r,t.context.shadowBlur=n.dropShadowBlur,t.context.shadowOffsetX=Math.cos(n.dropShadowAngle)*n.dropShadowDistance*t.resolution,t.context.shadowOffsetY=Math.sin(n.dropShadowAngle)*n.dropShadowDistance*t.resolution,t.context.fillText(o,i,s)}}),this.context.restore(),m.forEach(function(n){var o=n.style,i=n.text,s=n.x,r=n.y,a=n.width,h=n.ascent,l=n.descent,c=n.tag;t.context.font=t.getFontString(o);var x=o.stroke;"number"==typeof x&&(x=PIXI.utils.hex2string(x)),t.context.strokeStyle=x,t.context.lineWidth=o.strokeThickness;var d=o.fill;if("number"==typeof d)d=PIXI.utils.hex2string(d);else if(Array.isArray(d))for(var u=0;u<d.length;u++){var g=d[u];"number"==typeof g&&(d[u]=PIXI.utils.hex2string(g))}t.context.fillStyle=t._generateFillStyle(new PIXI.TextStyle(o),[i]),o.stroke&&o.strokeThickness&&t.context.strokeText(i,s,r),o.fill&&t.context.fillText(i,s,r);var p=-t._style.padding-t.getDropShadowPadding();t.hitboxes.push({tag:c,hitbox:new PIXI.Rectangle(s+p,r-h+p,a,h+l)});var f=void 0===o.debug?e.debugOptions.spans.enabled:o.debug;f&&(t.context.lineWidth=1,e.debugOptions.spans.bounding&&(t.context.fillStyle=e.debugOptions.spans.bounding,t.context.strokeStyle=e.debugOptions.spans.bounding,t.context.beginPath(),t.context.rect(s,r-h,a,h+l),t.context.fill(),t.context.stroke(),t.context.stroke()),e.debugOptions.spans.baseline&&(t.context.strokeStyle=e.debugOptions.spans.baseline,t.context.beginPath(),t.context.moveTo(s,r),t.context.lineTo(s+a,r),t.context.closePath(),t.context.stroke()),e.debugOptions.spans.top&&(t.context.strokeStyle=e.debugOptions.spans.top,t.context.beginPath(),t.context.moveTo(s,r-h),t.context.lineTo(s+a,r-h),t.context.closePath(),t.context.stroke()),e.debugOptions.spans.bottom&&(t.context.strokeStyle=e.debugOptions.spans.bottom,t.context.beginPath(),t.context.moveTo(s,r+l),t.context.lineTo(s+a,r+l),t.context.closePath(),t.context.stroke()),e.debugOptions.spans.text&&(t.context.fillStyle="#ffffff",t.context.strokeStyle="#000000",t.context.lineWidth=2,t.context.font="8px monospace",t.context.strokeText(c.name,s,r-h+8),t.context.fillText(c.name,s,r-h+8),t.context.strokeText(a.toFixed(2)+"x"+(h+l).toFixed(2),s,r-h+16),t.context.fillText(a.toFixed(2)+"x"+(h+l).toFixed(2),s,r-h+16)))}),e.debugOptions.objects.enabled&&(e.debugOptions.objects.bounding&&(this.context.fillStyle=e.debugOptions.objects.bounding,this.context.beginPath(),this.context.rect(0,0,S,T),this.context.fill()),e.debugOptions.objects.text&&(this.context.fillStyle="#ffffff",this.context.strokeStyle="#000000",this.context.lineWidth=2,this.context.font="8px monospace",this.context.strokeText(S.toFixed(2)+"x"+T.toFixed(2),0,8,S),this.context.fillText(S.toFixed(2)+"x"+T.toFixed(2),0,8,S))),this.updateTexture()}},e.prototype.wordWrap=function(t){var e="",n=this.getTagRegex(!0,!0),o=t.split("\n"),i=this._style.wordWrapWidth,s=[this.assign({},this.textStyles["default"])];this.context.font=this.getFontString(this.textStyles["default"]);for(var r=0;r<o.length;r++){for(var a=i,h=o[r].split(n),l=!0,c=0;c<h.length;c++)if(n.test(h[c]))e+=h[c],"/"===h[c][1]?(c+=2,s.pop()):(c++,s.push(this.assign({},s[s.length-1],this.textStyles[h[c]])),c++),this.context.font=this.getFontString(s[s.length-1]);else for(var x=h[c].split(" "),d=0;d<x.length;d++){var u=this.context.measureText(x[d]).width;if(this._style.breakWords&&u>a){var g=x[d].split("");d>0&&(e+=" ",a-=this.context.measureText(" ").width);for(var p=0;p<g.length;p++){var f=this.context.measureText(g[p]).width;f>a?(e+="\n"+g[p],a=i-f):(e+=g[p],a-=f)}}else if(this._style.breakWords)e+=x[d],a-=u;else{var y=u+(d>0?this.context.measureText(" ").width:0);y>a?(l||(e+="\n"),e+=x[d],a=i-u):(a-=y,d>0&&(e+=" "),e+=x[d])}l=!1}r<o.length-1&&(e+="\n")}return e},e.prototype.updateTexture=function(){var t=this._texture,e=this.getDropShadowPadding();t.baseTexture.hasLoaded=!0,t.baseTexture.resolution=this.resolution,t.baseTexture.realWidth=this.canvas.width,t.baseTexture.realHeight=this.canvas.height,t.baseTexture.width=this.canvas.width/this.resolution,t.baseTexture.height=this.canvas.height/this.resolution,t.trim.width=t.frame.width=this.canvas.width/this.resolution,t.trim.height=t.frame.height=this.canvas.height/this.resolution,t.trim.x=-this._style.padding-e,t.trim.y=-this._style.padding-e,t.orig.width=t.frame.width-2*(this._style.padding+e),t.orig.height=t.frame.height-2*(this._style.padding+e),this._onTextureUpdate(),t.baseTexture.emit("update",t.baseTexture),this.dirty=!1},e.prototype.assign=function(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];for(var o=0,i=e;o<i.length;o++){var s=i[o];for(var r in s)t[r]=s[r]}return t},e.DEFAULT_TAG_STYLE={align:"left",breakWords:!1,dropShadow:!1,dropShadowAngle:Math.PI/6,dropShadowBlur:0,dropShadowColor:"#000000",dropShadowDistance:5,fill:"black",fillGradientType:PIXI.TEXT_GRADIENT.LINEAR_VERTICAL,fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",letterSpacing:0,lineHeight:0,lineJoin:"miter",miterLimit:10,padding:0,stroke:"black",strokeThickness:0,textBaseline:"alphabetic",valign:"baseline",wordWrap:!1,wordWrapWidth:100},e.debugOptions={spans:{enabled:!1,baseline:"#44BB44",top:"#BB4444",bottom:"#4444BB",bounding:"rgba(255, 255, 255, 0.1)",text:!0},objects:{enabled:!1,bounding:"rgba(255, 255, 255, 0.05)",text:!0}},e}(PIXI.Text);// *********************************
// CoolGames Builder JavaScript file
// *********************************

/*
 CryptoJS v3.1.2
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
        /**
         * CryptoJS namespace.
         */
        var C = {};

        /**
         * Library namespace.
         */
        var C_lib = C.lib = {};

        /**
         * Base object for prototypal inheritance.
         */
        var Base = C_lib.Base = (function () {
            function F() {}

            return {
                /**
                 * Creates a new object that inherits from this object.
                 *
                 * @param {Object} overrides Properties to copy into the new object.
                 *
                 * @return {Object} The new object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
                 */
                extend: function (overrides) {
                    // Spawn
                    F.prototype = this;
                    var subtype = new F();

                    // Augment
                    if (overrides) {
                        subtype.mixIn(overrides);
                    }

                    // Create default initializer
                    if (!subtype.hasOwnProperty('init')) {
                        subtype.init = function () {
                            subtype.$super.init.apply(this, arguments);
                        };
                    }

                    // Initializer's prototype is the subtype object
                    subtype.init.prototype = subtype;

                    // Reference supertype
                    subtype.$super = this;

                    return subtype;
                },

                /**
                 * Extends this object and runs the init method.
                 * Arguments to create() will be passed to init().
                 *
                 * @return {Object} The new object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var instance = MyType.create();
                 */
                create: function () {
                    var instance = this.extend();
                    instance.init.apply(instance, arguments);

                    return instance;
                },

                /**
                 * Initializes a newly created object.
                 * Override this method to add some logic when your objects are created.
                 *
                 * @example
                 *
                 *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
                 */
                init: function () {
                },

                /**
                 * Copies properties into this object.
                 *
                 * @param {Object} properties The properties to mix in.
                 *
                 * @example
                 *
                 *     MyType.mixIn({
             *         field: 'value'
             *     });
                 */
                mixIn: function (properties) {
                    for (var propertyName in properties) {
                        if (properties.hasOwnProperty(propertyName)) {
                            this[propertyName] = properties[propertyName];
                        }
                    }

                    // IE won't copy toString using the loop above
                    if (properties.hasOwnProperty('toString')) {
                        this.toString = properties.toString;
                    }
                },

                /**
                 * Creates a copy of this object.
                 *
                 * @return {Object} The clone.
                 *
                 * @example
                 *
                 *     var clone = instance.clone();
                 */
                clone: function () {
                    return this.init.prototype.extend(this);
                }
            };
        }());

        /**
         * An array of 32-bit words.
         *
         * @property {Array} words The array of 32-bit words.
         * @property {number} sigBytes The number of significant bytes in this word array.
         */
        var WordArray = C_lib.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of 32-bit words.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.create();
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
             */
            init: function (words, sigBytes) {
                words = this.words = words || [];

                if (sigBytes != undefined) {
                    this.sigBytes = sigBytes;
                } else {
                    this.sigBytes = words.length * 4;
                }
            },

            /**
             * Converts this word array to a string.
             *
             * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
             *
             * @return {string} The stringified word array.
             *
             * @example
             *
             *     var string = wordArray + '';
             *     var string = wordArray.toString();
             *     var string = wordArray.toString(CryptoJS.enc.Utf8);
             */
            toString: function (encoder) {
                return (encoder || Hex).stringify(this);
            },

            /**
             * Concatenates a word array to this word array.
             *
             * @param {WordArray} wordArray The word array to append.
             *
             * @return {WordArray} This word array.
             *
             * @example
             *
             *     wordArray1.concat(wordArray2);
             */
            concat: function (wordArray) {
                // Shortcuts
                var thisWords = this.words;
                var thatWords = wordArray.words;
                var thisSigBytes = this.sigBytes;
                var thatSigBytes = wordArray.sigBytes;

                // Clamp excess bits
                this.clamp();

                // Concat
                if (thisSigBytes % 4) {
                    // Copy one byte at a time
                    for (var i = 0; i < thatSigBytes; i++) {
                        var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                    }
                } else if (thatWords.length > 0xffff) {
                    // Copy one word at a time
                    for (var i = 0; i < thatSigBytes; i += 4) {
                        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                    }
                } else {
                    // Copy all words at once
                    thisWords.push.apply(thisWords, thatWords);
                }
                this.sigBytes += thatSigBytes;

                // Chainable
                return this;
            },

            /**
             * Removes insignificant bits.
             *
             * @example
             *
             *     wordArray.clamp();
             */
            clamp: function () {
                // Shortcuts
                var words = this.words;
                var sigBytes = this.sigBytes;

                // Clamp
                words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
                words.length = Math.ceil(sigBytes / 4);
            },

            /**
             * Creates a copy of this word array.
             *
             * @return {WordArray} The clone.
             *
             * @example
             *
             *     var clone = wordArray.clone();
             */
            clone: function () {
                var clone = Base.clone.call(this);
                clone.words = this.words.slice(0);

                return clone;
            },

            /**
             * Creates a word array filled with random bytes.
             *
             * @param {number} nBytes The number of random bytes to generate.
             *
             * @return {WordArray} The random word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.random(16);
             */
            random: function (nBytes) {
                var words = [];
                for (var i = 0; i < nBytes; i += 4) {
                    words.push((Math.random() * 0x100000000) | 0);
                }

                return new WordArray.init(words, nBytes);
            }
        });

        /**
         * Encoder namespace.
         */
        var C_enc = C.enc = {};

        /**
         * Hex encoding strategy.
         */
        var Hex = C_enc.Hex = {
            /**
             * Converts a word array to a hex string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The hex string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
             */
            stringify: function (wordArray) {
                // Shortcuts
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;

                // Convert
                var hexChars = [];
                for (var i = 0; i < sigBytes; i++) {
                    var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    hexChars.push((bite >>> 4).toString(16));
                    hexChars.push((bite & 0x0f).toString(16));
                }

                return hexChars.join('');
            },

            /**
             * Converts a hex string to a word array.
             *
             * @param {string} hexStr The hex string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
             */
            parse: function (hexStr) {
                // Shortcut
                var hexStrLength = hexStr.length;

                // Convert
                var words = [];
                for (var i = 0; i < hexStrLength; i += 2) {
                    words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                }

                return new WordArray.init(words, hexStrLength / 2);
            }
        };

        /**
         * Latin1 encoding strategy.
         */
        var Latin1 = C_enc.Latin1 = {
            /**
             * Converts a word array to a Latin1 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Latin1 string.
             *
             * @static
             *
             * @example
             *
             *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
             */
            stringify: function (wordArray) {
                // Shortcuts
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;

                // Convert
                var latin1Chars = [];
                for (var i = 0; i < sigBytes; i++) {
                    var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    latin1Chars.push(String.fromCharCode(bite));
                }

                return latin1Chars.join('');
            },

            /**
             * Converts a Latin1 string to a word array.
             *
             * @param {string} latin1Str The Latin1 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
             */
            parse: function (latin1Str) {
                // Shortcut
                var latin1StrLength = latin1Str.length;

                // Convert
                var words = [];
                for (var i = 0; i < latin1StrLength; i++) {
                    words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
                }

                return new WordArray.init(words, latin1StrLength);
            }
        };

        /**
         * UTF-8 encoding strategy.
         */
        var Utf8 = C_enc.Utf8 = {
            /**
             * Converts a word array to a UTF-8 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-8 string.
             *
             * @static
             *
             * @example
             *
             *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
             */
            stringify: function (wordArray) {
                try {
                    return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                } catch (e) {
                    throw new Error('Malformed UTF-8 data');
                }
            },

            /**
             * Converts a UTF-8 string to a word array.
             *
             * @param {string} utf8Str The UTF-8 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
             */
            parse: function (utf8Str) {
                return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
            }
        };

        /**
         * Abstract buffered block algorithm template.
         *
         * The property blockSize must be implemented in a concrete subtype.
         *
         * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
         */
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
            /**
             * Resets this block algorithm's data buffer to its initial state.
             *
             * @example
             *
             *     bufferedBlockAlgorithm.reset();
             */
            reset: function () {
                // Initial values
                this._data = new WordArray.init();
                this._nDataBytes = 0;
            },

            /**
             * Adds new data to this block algorithm's buffer.
             *
             * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
             *
             * @example
             *
             *     bufferedBlockAlgorithm._append('data');
             *     bufferedBlockAlgorithm._append(wordArray);
             */
            _append: function (data) {
                // Convert string to WordArray, else assume WordArray already
                if (typeof data == 'string') {
                    data = Utf8.parse(data);
                }

                // Append
                this._data.concat(data);
                this._nDataBytes += data.sigBytes;
            },

            /**
             * Processes available data blocks.
             *
             * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
             *
             * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
             *
             * @return {WordArray} The processed data.
             *
             * @example
             *
             *     var processedData = bufferedBlockAlgorithm._process();
             *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
             */
            _process: function (doFlush) {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var dataSigBytes = data.sigBytes;
                var blockSize = this.blockSize;
                var blockSizeBytes = blockSize * 4;

                // Count blocks ready
                var nBlocksReady = dataSigBytes / blockSizeBytes;
                if (doFlush) {
                    // Round up to include partial blocks
                    nBlocksReady = Math.ceil(nBlocksReady);
                } else {
                    // Round down to include only full blocks,
                    // less the number of blocks that must remain in the buffer
                    nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                }

                // Count words ready
                var nWordsReady = nBlocksReady * blockSize;

                // Count bytes ready
                var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

                // Process blocks
                if (nWordsReady) {
                    for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                        // Perform concrete-algorithm logic
                        this._doProcessBlock(dataWords, offset);
                    }

                    // Remove processed words
                    var processedWords = dataWords.splice(0, nWordsReady);
                    data.sigBytes -= nBytesReady;
                }

                // Return processed words
                return new WordArray.init(processedWords, nBytesReady);
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = bufferedBlockAlgorithm.clone();
             */
            clone: function () {
                var clone = Base.clone.call(this);
                clone._data = this._data.clone();

                return clone;
            },

            _minBufferSize: 0
        });

        /**
         * Abstract hasher template.
         *
         * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
         */
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             */
            cfg: Base.extend(),

            /**
             * Initializes a newly created hasher.
             *
             * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
             *
             * @example
             *
             *     var hasher = CryptoJS.algo.SHA256.create();
             */
            init: function (cfg) {
                // Apply config defaults
                this.cfg = this.cfg.extend(cfg);

                // Set initial values
                this.reset();
            },

            /**
             * Resets this hasher to its initial state.
             *
             * @example
             *
             *     hasher.reset();
             */
            reset: function () {
                // Reset data buffer
                BufferedBlockAlgorithm.reset.call(this);

                // Perform concrete-hasher logic
                this._doReset();
            },

            /**
             * Updates this hasher with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {Hasher} This hasher.
             *
             * @example
             *
             *     hasher.update('message');
             *     hasher.update(wordArray);
             */
            update: function (messageUpdate) {
                // Append
                this._append(messageUpdate);

                // Update the hash
                this._process();

                // Chainable
                return this;
            },

            /**
             * Finalizes the hash computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The hash.
             *
             * @example
             *
             *     var hash = hasher.finalize();
             *     var hash = hasher.finalize('message');
             *     var hash = hasher.finalize(wordArray);
             */
            finalize: function (messageUpdate) {
                // Final message update
                if (messageUpdate) {
                    this._append(messageUpdate);
                }

                // Perform concrete-hasher logic
                var hash = this._doFinalize();

                return hash;
            },

            blockSize: 512/32,

            /**
             * Creates a shortcut function to a hasher's object interface.
             *
             * @param {Hasher} hasher The hasher to create a helper for.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
             */
            _createHelper: function (hasher) {
                return function (message, cfg) {
                    return new hasher.init(cfg).finalize(message);
                };
            },

            /**
             * Creates a shortcut function to the HMAC's object interface.
             *
             * @param {Hasher} hasher The hasher to use in this HMAC helper.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
             */
            _createHmacHelper: function (hasher) {
                return function (message, key) {
                    return new C_algo.HMAC.init(hasher, key).finalize(message);
                };
            }
        });

        /**
         * Algorithm namespace.
         */
        var C_algo = C.algo = {};

        return C;
    }(Math));

// window["Crypto"] = CryptoJS;

/*
 CryptoJS v3.1.2
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var C_algo = C.algo;

    /**
     * HMAC algorithm.
     */
    var HMAC = C_algo.HMAC = Base.extend({
        /**
         * Initializes a newly created HMAC.
         *
         * @param {Hasher} hasher The hash algorithm to use.
         * @param {WordArray|string} key The secret key.
         *
         * @example
         *
         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
         */
        init: function (hasher, key) {
            // Init hasher
            hasher = this._hasher = new hasher.init();

            // Convert string to WordArray, else assume WordArray already
            if (typeof key == 'string') {
                key = Utf8.parse(key);
            }

            // Shortcuts
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;

            // Allow arbitrary length keys
            if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
            }

            // Clamp excess bits
            key.clamp();

            // Clone key for inner and outer pads
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();

            // Shortcuts
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;

            // XOR keys with pad constants
            for (var i = 0; i < hasherBlockSize; i++) {
                oKeyWords[i] ^= 0x5c5c5c5c;
                iKeyWords[i] ^= 0x36363636;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this HMAC to its initial state.
         *
         * @example
         *
         *     hmacHasher.reset();
         */
        reset: function () {
            // Shortcut
            var hasher = this._hasher;

            // Reset
            hasher.reset();
            hasher.update(this._iKey);
        },

        /**
         * Updates this HMAC with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {HMAC} This HMAC instance.
         *
         * @example
         *
         *     hmacHasher.update('message');
         *     hmacHasher.update(wordArray);
         */
        update: function (messageUpdate) {
            this._hasher.update(messageUpdate);

            // Chainable
            return this;
        },

        /**
         * Finalizes the HMAC computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The HMAC.
         *
         * @example
         *
         *     var hmac = hmacHasher.finalize();
         *     var hmac = hmacHasher.finalize('message');
         *     var hmac = hmacHasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Shortcut
            var hasher = this._hasher;

            // Compute HMAC
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

            return hmac;
        }
    });
}());

/*
 CryptoJS v3.1.2
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Initialization and round constants tables
    var H = [];
    var K = [];

    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }

            return true;
        }

        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }

        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                nPrime++;
            }

            n++;
        }
    }());

    // Reusable object
    var W = [];

    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];

            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var gamma0x = W[i - 15];
                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                        ((gamma0x << 14) | (gamma0x >>> 18)) ^
                        (gamma0x >>> 3);

                    var gamma1x = W[i - 2];
                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                        ((gamma1x << 13) | (gamma1x >>> 19)) ^
                        (gamma1x >>> 10);

                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }

                var ch  = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);

                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */
    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
}(Math));

/*
 CryptoJS v3.1.2
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());
(function(scope){
var CryptoJS=CryptoJS||function(e,n){var t={},i=t.lib={},r=function(){},s=i.Base={extend:function(e){r.prototype=this;var n=new r;return e&&n.mixIn(e),n.hasOwnProperty("init")||(n.init=function(){n.$super.init.apply(this,arguments)}),n.init.prototype=n,n.$super=this,n},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var n in e)e.hasOwnProperty(n)&&(this[n]=e[n]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},o=i.WordArray=s.extend({init:function(e,n){e=this.words=e||[],this.sigBytes=void 0!=n?n:4*e.length},toString:function(e){return(e||u).stringify(this)},concat:function(e){var n=this.words,t=e.words,i=this.sigBytes;if(e=e.sigBytes,this.clamp(),i%4)for(var r=0;r<e;r++)n[i+r>>>2]|=(t[r>>>2]>>>24-r%4*8&255)<<24-(i+r)%4*8;else if(65535<t.length)for(r=0;r<e;r+=4)n[i+r>>>2]=t[r>>>2];else n.push.apply(n,t);return this.sigBytes+=e,this},clamp:function(){var n=this.words,t=this.sigBytes;n[t>>>2]&=4294967295<<32-t%4*8,n.length=e.ceil(t/4)},clone:function(){var e=s.clone.call(this);return e.words=this.words.slice(0),e},random:function(n){for(var t=[],i=0;i<n;i+=4)t.push(4294967296*e.random()|0);return new o.init(t,n)}}),a=t.enc={},u=a.Hex={stringify:function(e){var n=e.words;e=e.sigBytes;for(var t=[],i=0;i<e;i++){var r=n[i>>>2]>>>24-i%4*8&255;t.push((r>>>4).toString(16)),t.push((15&r).toString(16))}return t.join("")},parse:function(e){for(var n=e.length,t=[],i=0;i<n;i+=2)t[i>>>3]|=parseInt(e.substr(i,2),16)<<24-i%8*4;return new o.init(t,n/2)}},c=a.Latin1={stringify:function(e){var n=e.words;e=e.sigBytes;for(var t=[],i=0;i<e;i++)t.push(String.fromCharCode(n[i>>>2]>>>24-i%4*8&255));return t.join("")},parse:function(e){for(var n=e.length,t=[],i=0;i<n;i++)t[i>>>2]|=(255&e.charCodeAt(i))<<24-i%4*8;return new o.init(t,n)}},d=a.Utf8={stringify:function(e){try{return decodeURIComponent(escape(c.stringify(e)))}catch(e){throw Error("Malformed UTF-8 data")}},parse:function(e){return c.parse(unescape(encodeURIComponent(e)))}},l=i.BufferedBlockAlgorithm=s.extend({reset:function(){this._data=new o.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=d.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(n){var t=this._data,i=t.words,r=t.sigBytes,s=this.blockSize,a=r/(4*s),a=n?e.ceil(a):e.max((0|a)-this._minBufferSize,0);if(n=a*s,r=e.min(4*n,r),n){for(var u=0;u<n;u+=s)this._doProcessBlock(i,u);u=i.splice(0,n),t.sigBytes-=r}return new o.init(u,r)},clone:function(){var e=s.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});i.Hasher=l.extend({cfg:s.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){l.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(e){return function(n,t){return new e.init(t).finalize(n)}},_createHmacHelper:function(e){return function(n,t){return new f.HMAC.init(e,t).finalize(n)}}});var f=t.algo={};return t}(Math);!function(e){for(var n=CryptoJS,t=n.lib,i=t.WordArray,r=t.Hasher,t=n.algo,s=[],o=[],a=function(e){return 4294967296*(e-(0|e))|0},u=2,c=0;64>c;){var d;e:{d=u;for(var l=e.sqrt(d),f=2;f<=l;f++)if(!(d%f)){d=!1;break e}d=!0}d&&(8>c&&(s[c]=a(e.pow(u,.5))),o[c]=a(e.pow(u,1/3)),c++),u++}var v=[],t=t.SHA256=r.extend({_doReset:function(){this._hash=new i.init(s.slice(0))},_doProcessBlock:function(e,n){for(var t=this._hash.words,i=t[0],r=t[1],s=t[2],a=t[3],u=t[4],c=t[5],d=t[6],l=t[7],f=0;64>f;f++){if(16>f)v[f]=0|e[n+f];else{var g=v[f-15],m=v[f-2];v[f]=((g<<25|g>>>7)^(g<<14|g>>>18)^g>>>3)+v[f-7]+((m<<15|m>>>17)^(m<<13|m>>>19)^m>>>10)+v[f-16]}g=l+((u<<26|u>>>6)^(u<<21|u>>>11)^(u<<7|u>>>25))+(u&c^~u&d)+o[f]+v[f],m=((i<<30|i>>>2)^(i<<19|i>>>13)^(i<<10|i>>>22))+(i&r^i&s^r&s),l=d,d=c,c=u,u=a+g|0,a=s,s=r,r=i,i=g+m|0}t[0]=t[0]+i|0,t[1]=t[1]+r|0,t[2]=t[2]+s|0,t[3]=t[3]+a|0,t[4]=t[4]+u|0,t[5]=t[5]+c|0,t[6]=t[6]+d|0,t[7]=t[7]+l|0},_doFinalize:function(){var n=this._data,t=n.words,i=8*this._nDataBytes,r=8*n.sigBytes;return t[r>>>5]|=128<<24-r%32,t[14+(r+64>>>9<<4)]=e.floor(i/4294967296),t[15+(r+64>>>9<<4)]=i,n.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=r.clone.call(this);return e._hash=this._hash.clone(),e}});n.SHA256=r._createHelper(t),n.HmacSHA256=r._createHmacHelper(t)}(Math),function(){var e=CryptoJS,n=e.enc.Utf8;e.algo.HMAC=e.lib.Base.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=n.parse(t));var i=e.blockSize,r=4*i;t.sigBytes>r&&(t=e.finalize(t)),t.clamp();for(var s=this._oKey=t.clone(),o=this._iKey=t.clone(),a=s.words,u=o.words,c=0;c<i;c++)a[c]^=1549556828,u[c]^=909522486;s.sigBytes=o.sigBytes=r,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var n=this._hasher;return e=n.finalize(e),n.reset(),n.finalize(this._oKey.clone().concat(e))}})}(),function(){var e=CryptoJS,n=e.lib.WordArray;e.enc.Base64={stringify:function(e){var n=e.words,t=e.sigBytes,i=this._map;e.clamp(),e=[];for(var r=0;r<t;r+=3)for(var s=(n[r>>>2]>>>24-r%4*8&255)<<16|(n[r+1>>>2]>>>24-(r+1)%4*8&255)<<8|n[r+2>>>2]>>>24-(r+2)%4*8&255,o=0;4>o&&r+.75*o<t;o++)e.push(i.charAt(s>>>6*(3-o)&63));if(n=i.charAt(64))for(;e.length%4;)e.push(n);return e.join("")},parse:function(e){var t=e.length,i=this._map,r=i.charAt(64);r&&-1!=(r=e.indexOf(r))&&(t=r);for(var r=[],s=0,o=0;o<t;o++)if(o%4){var a=i.indexOf(e.charAt(o-1))<<o%4*2,u=i.indexOf(e.charAt(o))>>>6-o%4*2;r[s>>>2]|=(a|u)<<24-s%4*8,s++}return n.create(r,s)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}();var gameanalytics;!function(e){!function(e){e[e.Undefined=0]="Undefined",e[e.Debug=1]="Debug",e[e.Info=2]="Info",e[e.Warning=3]="Warning",e[e.Error=4]="Error",e[e.Critical=5]="Critical"}(e.EGAErrorSeverity||(e.EGAErrorSeverity={}));!function(e){e[e.Undefined=0]="Undefined",e[e.Male=1]="Male",e[e.Female=2]="Female"}(e.EGAGender||(e.EGAGender={}));!function(e){e[e.Undefined=0]="Undefined",e[e.Start=1]="Start",e[e.Complete=2]="Complete",e[e.Fail=3]="Fail"}(e.EGAProgressionStatus||(e.EGAProgressionStatus={}));!function(e){e[e.Undefined=0]="Undefined",e[e.Source=1]="Source",e[e.Sink=2]="Sink"}(e.EGAResourceFlowType||(e.EGAResourceFlowType={}));!function(e){!function(e){e[e.Undefined=0]="Undefined",e[e.Rejected=1]="Rejected"}(e.EGASdkErrorType||(e.EGASdkErrorType={}));!function(e){e[e.NoResponse=0]="NoResponse",e[e.BadResponse=1]="BadResponse",e[e.RequestTimeout=2]="RequestTimeout",e[e.JsonEncodeFailed=3]="JsonEncodeFailed",e[e.JsonDecodeFailed=4]="JsonDecodeFailed",e[e.InternalServerError=5]="InternalServerError",e[e.BadRequest=6]="BadRequest",e[e.Unauthorized=7]="Unauthorized",e[e.UnknownResponseCode=8]="UnknownResponseCode",e[e.Ok=9]="Ok"}(e.EGAHTTPApiResponse||(e.EGAHTTPApiResponse={}))}(e.http||(e.http={}))}(gameanalytics||(gameanalytics={}));var EGAErrorSeverity=gameanalytics.EGAErrorSeverity,EGAGender=gameanalytics.EGAGender,EGAProgressionStatus=gameanalytics.EGAProgressionStatus,EGAResourceFlowType=gameanalytics.EGAResourceFlowType,gameanalytics;!function(e){!function(e){var n;!function(e){e[e.Error=0]="Error",e[e.Warning=1]="Warning",e[e.Info=2]="Info",e[e.Debug=3]="Debug"}(n||(n={}));var t=function(){function e(){e.debugEnabled=!1}return e.setInfoLog=function(n){e.instance.infoLogEnabled=n},e.setVerboseLog=function(n){e.instance.infoLogVerboseEnabled=n},e.i=function(t){if(e.instance.infoLogEnabled){var i="Info/"+e.Tag+": "+t;e.instance.sendNotificationMessage(i,n.Info)}},e.w=function(t){var i="Warning/"+e.Tag+": "+t;e.instance.sendNotificationMessage(i,n.Warning)},e.e=function(t){var i="Error/"+e.Tag+": "+t;e.instance.sendNotificationMessage(i,n.Error)},e.ii=function(t){if(e.instance.infoLogVerboseEnabled){var i="Verbose/"+e.Tag+": "+t;e.instance.sendNotificationMessage(i,n.Info)}},e.d=function(t){if(e.debugEnabled){var i="Debug/"+e.Tag+": "+t;e.instance.sendNotificationMessage(i,n.Debug)}},e.prototype.sendNotificationMessage=function(e,t){switch(t){case n.Error:console.error(e);break;case n.Warning:console.warn(e);break;case n.Debug:"function"==typeof console.debug?console.debug(e):console.log(e);break;case n.Info:console.log(e)}},e}();t.instance=new t,t.Tag="GameAnalytics",e.GALogger=t}(e.logging||(e.logging={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(n){var t=e.logging.GALogger,i=function(){function e(){}return e.getHmac=function(e,n){var t=CryptoJS.HmacSHA256(n,e);return CryptoJS.enc.Base64.stringify(t)},e.stringMatch=function(e,n){return!(!e||!n)&&n.test(e)},e.joinStringArray=function(e,n){for(var t="",i=0,r=e.length;i<r;i++)i>0&&(t+=n),t+=e[i];return t},e.stringArrayContainsString=function(e,n){if(0===e.length)return!1;for(var t in e)if(e[t]===n)return!0;return!1},e.encode64=function(n){n=encodeURI(n);var t,i,r,s,o,a="",u=0,c=0,d=0;do{t=n.charCodeAt(d++),i=n.charCodeAt(d++),u=n.charCodeAt(d++),r=t>>2,s=(3&t)<<4|i>>4,o=(15&i)<<2|u>>6,c=63&u,isNaN(i)?o=c=64:isNaN(u)&&(c=64),a=a+e.keyStr.charAt(r)+e.keyStr.charAt(s)+e.keyStr.charAt(o)+e.keyStr.charAt(c),t=i=u=0,r=s=o=c=0}while(d<n.length);return a},e.decode64=function(n){var i,r,s,o,a,u="",c=0,d=0,l=0;/[^A-Za-z0-9\+\/\=]/g.exec(n)&&t.w("There were invalid base64 characters in the input text. Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='. Expect errors in decoding."),n=n.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{s=e.keyStr.indexOf(n.charAt(l++)),o=e.keyStr.indexOf(n.charAt(l++)),a=e.keyStr.indexOf(n.charAt(l++)),d=e.keyStr.indexOf(n.charAt(l++)),i=s<<2|o>>4,r=(15&o)<<4|a>>2,c=(3&a)<<6|d,u+=String.fromCharCode(i),64!=a&&(u+=String.fromCharCode(r)),64!=d&&(u+=String.fromCharCode(c)),i=r=c=0,s=o=a=d=0}while(l<n.length);return decodeURI(u)},e.timeIntervalSince1970=function(){var e=new Date;return Math.round(e.getTime()/1e3)},e.createGuid=function(){return(e.s4()+e.s4()+"-"+e.s4()+"-4"+e.s4().substr(0,3)+"-"+e.s4()+"-"+e.s4()+e.s4()+e.s4()).toLowerCase()},e.s4=function(){return(65536*(1+Math.random())|0).toString(16).substring(1)},e}();i.keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",n.GAUtilities=i}(e.utilities||(e.utilities={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(n){var t=e.logging.GALogger,i=e.http.EGASdkErrorType,r=e.utilities.GAUtilities,s=function(){function n(){}return n.validateBusinessEvent=function(e,i,r,s,o){return n.validateCurrency(e)?n.validateShortString(r,!0)?n.validateEventPartLength(s,!1)?n.validateEventPartCharacters(s)?n.validateEventPartLength(o,!1)?!!n.validateEventPartCharacters(o)||(t.i("Validation fail - business event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "+o),!1):(t.i("Validation fail - business event - itemId. Cannot be (null), empty or above 64 characters. String: "+o),!1):(t.i("Validation fail - business event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "+s),!1):(t.i("Validation fail - business event - itemType: Cannot be (null), empty or above 64 characters. String: "+s),!1):(t.i("Validation fail - business event - cartType. Cannot be above 32 length. String: "+r),!1):(t.i("Validation fail - business event - currency: Cannot be (null) and need to be A-Z, 3 characters and in the standard at openexchangerates.org. Failed currency: "+e),!1)},n.validateResourceEvent=function(i,s,o,a,u,c,d){return i==e.EGAResourceFlowType.Undefined?(t.i("Validation fail - resource event - flowType: Invalid flow type."),!1):s?r.stringArrayContainsString(c,s)?o>0?a?n.validateEventPartLength(a,!1)?n.validateEventPartCharacters(a)?r.stringArrayContainsString(d,a)?n.validateEventPartLength(u,!1)?!!n.validateEventPartCharacters(u)||(t.i("Validation fail - resource event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "+u),!1):(t.i("Validation fail - resource event - itemId: Cannot be (null), empty or above 64 characters. String: "+u),!1):(t.i("Validation fail - resource event - itemType: Not found in list of pre-defined available resource itemTypes. String: "+a),!1):(t.i("Validation fail - resource event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "+a),!1):(t.i("Validation fail - resource event - itemType: Cannot be (null), empty or above 64 characters. String: "+a),!1):(t.i("Validation fail - resource event - itemType: Cannot be (null)"),!1):(t.i("Validation fail - resource event - amount: Float amount cannot be 0 or negative. Value: "+o),!1):(t.i("Validation fail - resource event - currency: Not found in list of pre-defined available resource currencies. String: "+s),!1):(t.i("Validation fail - resource event - currency: Cannot be (null)"),!1)},n.validateProgressionEvent=function(i,r,s,o){if(i==e.EGAProgressionStatus.Undefined)return t.i("Validation fail - progression event: Invalid progression status."),!1;if(o&&!s&&r)return t.i("Validation fail - progression event: 03 found but 01+02 are invalid. Progression must be set as either 01, 01+02 or 01+02+03."),!1;if(s&&!r)return t.i("Validation fail - progression event: 02 found but not 01. Progression must be set as either 01, 01+02 or 01+02+03"),!1;if(!r)return t.i("Validation fail - progression event: progression01 not valid. Progressions must be set as either 01, 01+02 or 01+02+03"),!1;if(!n.validateEventPartLength(r,!1))return t.i("Validation fail - progression event - progression01: Cannot be (null), empty or above 64 characters. String: "+r),!1;if(!n.validateEventPartCharacters(r))return t.i("Validation fail - progression event - progression01: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "+r),!1;if(s){if(!n.validateEventPartLength(s,!0))return t.i("Validation fail - progression event - progression02: Cannot be empty or above 64 characters. String: "+s),!1;if(!n.validateEventPartCharacters(s))return t.i("Validation fail - progression event - progression02: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "+s),!1}if(o){if(!n.validateEventPartLength(o,!0))return t.i("Validation fail - progression event - progression03: Cannot be empty or above 64 characters. String: "+o),!1;if(!n.validateEventPartCharacters(o))return t.i("Validation fail - progression event - progression03: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "+o),!1}return!0},n.validateDesignEvent=function(e,i){return n.validateEventIdLength(e)?!!n.validateEventIdCharacters(e)||(t.i("Validation fail - design event - eventId: Non valid characters. Only allowed A-z, 0-9, -_., ()!?. String: "+e),!1):(t.i("Validation fail - design event - eventId: Cannot be (null) or empty. Only 5 event parts allowed seperated by :. Each part need to be 32 characters or less. String: "+e),!1)},n.validateErrorEvent=function(i,r){return i==e.EGAErrorSeverity.Undefined?(t.i("Validation fail - error event - severity: Severity was unsupported value."),!1):!!n.validateLongString(r,!0)||(t.i("Validation fail - error event - message: Message cannot be above 8192 characters."),!1)},n.validateSdkErrorEvent=function(e,r,s){return!!n.validateKeys(e,r)&&(s!==i.Undefined||(t.i("Validation fail - sdk error event - type: Type was unsupported value."),!1))},n.validateKeys=function(e,n){return!(!r.stringMatch(e,/^[A-z0-9]{32}$/)||!r.stringMatch(n,/^[A-z0-9]{40}$/))},n.validateCurrency=function(e){return!!e&&!!r.stringMatch(e,/^[A-Z]{3}$/)},n.validateEventPartLength=function(e,n){return!(!n||e)||!!e&&!(e.length>64)},n.validateEventPartCharacters=function(e){return!!r.stringMatch(e,/^[A-Za-z0-9\s\-_\.\(\)\!\?]{1,64}$/)},n.validateEventIdLength=function(e){return!!e&&!!r.stringMatch(e,/^[^:]{1,64}(?::[^:]{1,64}){0,4}$/)},n.validateEventIdCharacters=function(e){return!!e&&!!r.stringMatch(e,/^[A-Za-z0-9\s\-_\.\(\)\!\?]{1,64}(:[A-Za-z0-9\s\-_\.\(\)\!\?]{1,64}){0,4}$/)},n.validateAndCleanInitRequestResponse=function(e){if(null==e)return t.w("validateInitRequestResponse failed - no response dictionary."),null;var n={};try{n.enabled=e.enabled}catch(e){return t.w("validateInitRequestResponse failed - invalid type in 'enabled' field."),null}try{var i=e.server_ts;if(!(i>0))return t.w("validateInitRequestResponse failed - invalid value in 'server_ts' field."),null;n.server_ts=i}catch(n){return t.w("validateInitRequestResponse failed - invalid type in 'server_ts' field. type="+typeof e.server_ts+", value="+e.server_ts+", "+n),null}return n},n.validateBuild=function(e){return!!n.validateShortString(e,!1)},n.validateSdkWrapperVersion=function(e){return!!r.stringMatch(e,/^(unity|unreal|gamemaker|cocos2d|construct) [0-9]{0,5}(\.[0-9]{0,5}){0,2}$/)},n.validateEngineVersion=function(e){return!(!e||!r.stringMatch(e,/^(unity|unreal|gamemaker|cocos2d|construct) [0-9]{0,5}(\.[0-9]{0,5}){0,2}$/))},n.validateUserId=function(e){return!!n.validateString(e,!1)||(t.i("Validation fail - user id: id cannot be (null), empty or above 64 characters."),!1)},n.validateShortString=function(e,n){return!(!n||e)||!(!e||e.length>32)},n.validateString=function(e,n){return!(!n||e)||!(!e||e.length>64)},n.validateLongString=function(e,n){return!(!n||e)||!(!e||e.length>8192)},n.validateConnectionType=function(e){return r.stringMatch(e,/^(wwan|wifi|lan|offline)$/)},n.validateCustomDimensions=function(e){return n.validateArrayOfStrings(20,32,!1,"custom dimensions",e)},n.validateResourceCurrencies=function(e){if(!n.validateArrayOfStrings(20,64,!1,"resource currencies",e))return!1;for(var i=0;i<e.length;++i)if(!r.stringMatch(e[i],/^[A-Za-z]+$/))return t.i("resource currencies validation failed: a resource currency can only be A-Z, a-z. String was: "+e[i]),!1;return!0},n.validateResourceItemTypes=function(e){if(!n.validateArrayOfStrings(20,32,!1,"resource item types",e))return!1;for(var i=0;i<e.length;++i)if(!n.validateEventPartCharacters(e[i]))return t.i("resource item types validation failed: a resource item type cannot contain other characters than A-z, 0-9, -_., ()!?. String was: "+e[i]),!1;return!0},n.validateDimension01=function(e,n){return!e||!!r.stringArrayContainsString(n,e)},n.validateDimension02=function(e,n){return!e||!!r.stringArrayContainsString(n,e)},n.validateDimension03=function(e,n){return!e||!!r.stringArrayContainsString(n,e)},n.validateArrayOfStrings=function(e,n,i,r,s){var o=r;if(o||(o="Array"),!s)return t.i(o+" validation failed: array cannot be null. "),!1;if(0==i&&0==s.length)return t.i(o+" validation failed: array cannot be empty. "),!1;if(e>0&&s.length>e)return t.i(o+" validation failed: array cannot exceed "+e+" values. It has "+s.length+" values."),!1;for(var a=0;a<s.length;++a){var u=s[a]?s[a].length:0;if(0===u)return t.i(o+" validation failed: contained an empty string. Array="+JSON.stringify(s)),!1;if(n>0&&u>n)return t.i(o+" validation failed: a string exceeded max allowed length (which is: "+n+"). String was: "+s[a]),!1}return!0},n.validateFacebookId=function(e){return!!n.validateString(e,!1)||(t.i("Validation fail - facebook id: id cannot be (null), empty or above 64 characters."),!1)},n.validateGender=function(n){if(isNaN(Number(e.EGAGender[n]))){if(n==e.EGAGender.Undefined||n!=e.EGAGender.Male&&n!=e.EGAGender.Female)return t.i("Validation fail - gender: Has to be 'male' or 'female'. Was: "+n),!1}else if(n==e.EGAGender[e.EGAGender.Undefined]||n!=e.EGAGender[e.EGAGender.Male]&&n!=e.EGAGender[e.EGAGender.Female])return t.i("Validation fail - gender: Has to be 'male' or 'female'. Was: "+n),!1;return!0},n.validateBirthyear=function(e){return!(e<0||e>9999)||(t.i("Validation fail - birthYear: Cannot be (null) or invalid range."),!1)},n.validateClientTs=function(e){return!(e<-4294967294||e>4294967294)},n}();n.GAValidator=s}(e.validators||(e.validators={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(e){var n=function(){function e(e,n,t){this.name=e,this.value=n,this.version=t}return e}();e.NameValueVersion=n;var t=function(){function e(e,n){this.name=e,this.version=n}return e}();e.NameVersion=t;var i=function(){function e(){}return e.touch=function(){},e.getRelevantSdkVersion=function(){return e.sdkGameEngineVersion?e.sdkGameEngineVersion:e.sdkWrapperVersion},e.getConnectionType=function(){return e.connectionType},e.updateConnectionType=function(){navigator.onLine?"ios"===e.buildPlatform||"android"===e.buildPlatform?e.connectionType="wwan":e.connectionType="lan":e.connectionType="offline"},e.getOSVersionString=function(){return e.buildPlatform+" "+e.osVersionPair.version},e.runtimePlatformToString=function(){return e.osVersionPair.name},e.getBrowserVersionString=function(){var e,n=navigator.userAgent,t=n.match(/(opera|chrome|safari|firefox|ubrowser|msie|trident(?=\/))\/?\s*(\d+)/i)||[];if(/trident/i.test(t[1]))return e=/\brv[ :]+(\d+)/g.exec(n)||[],"IE "+(e[1]||"");if("Chrome"===t[1]&&null!=(e=n.match(/\b(OPR|Edge|UBrowser)\/(\d+)/)))return e.slice(1).join(" ").replace("OPR","Opera").replace("UBrowser","UC").toLowerCase();var i=t[2]?[t[1],t[2]]:[navigator.appName,navigator.appVersion,"-?"];return null!=(e=n.match(/version\/(\d+)/i))&&i.splice(1,1,e[1]),i.join(" ").toLowerCase()},e.getDeviceModel=function(){return"unknown"},e.getDeviceManufacturer=function(){return"unknown"},e.matchItem=function(e,n){var i,r,s,o,a,u=new t("unknown","0.0.0"),c=0,d=0;for(c=0;c<n.length;c+=1)if(i=new RegExp(n[c].value,"i"),i.test(e)){if(r=new RegExp(n[c].version+"[- /:;]([\\d._]+)","i"),s=e.match(r),a="",s&&s[1]&&(o=s[1]),o){var l=o.split(/[._]+/);for(d=0;d<Math.min(l.length,3);d+=1)a+=l[d]+(d<Math.min(l.length,3)-1?".":"")}else a="0.0.0";return u.name=n[c].name,u.version=a,u}return u},e}();i.sdkWrapperVersion="javascript 2.1.0",i.osVersionPair=i.matchItem([navigator.platform,navigator.userAgent,navigator.appVersion,navigator.vendor,window.opera].join(" "),[new n("windows_phone","Windows Phone","OS"),new n("windows","Win","NT"),new n("ios","iPhone","OS"),new n("ios","iPad","OS"),new n("ios","iPod","OS"),new n("android","Android","Android"),new n("blackBerry","BlackBerry","/"),new n("mac_osx","Mac","OS X"),new n("tizen","Tizen","Tizen"),new n("linux","Linux","rv")]),i.buildPlatform=i.runtimePlatformToString(),i.deviceModel=i.getDeviceModel(),i.deviceManufacturer=i.getDeviceManufacturer(),i.osVersion=i.getOSVersionString(),i.browserVersion=i.getBrowserVersionString(),i.maxSafeInteger=Math.pow(2,53)-1,e.GADevice=i}(e.device||(e.device={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(e){var n=function(){function e(n){this.deadline=n,this.ignore=!1,this.async=!1,this.running=!1,this.id=++e.idCounter}return e}();n.idCounter=0,e.TimedBlock=n}(e.threading||(e.threading={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(e){var n=function(){function e(e){this.comparer=e,this._subQueues={},this._sortedKeys=[]}return e.prototype.enqueue=function(e,n){-1===this._sortedKeys.indexOf(e)&&this.addQueueOfPriority(e),this._subQueues[e].push(n)},e.prototype.addQueueOfPriority=function(e){var n=this;this._sortedKeys.push(e),this._sortedKeys.sort(function(e,t){return n.comparer.compare(e,t)}),this._subQueues[e]=[]},e.prototype.peek=function(){if(this.hasItems())return this._subQueues[this._sortedKeys[0]][0];throw new Error("The queue is empty")},e.prototype.hasItems=function(){return this._sortedKeys.length>0},e.prototype.dequeue=function(){if(this.hasItems())return this.dequeueFromHighPriorityQueue();throw new Error("The queue is empty")},e.prototype.dequeueFromHighPriorityQueue=function(){var e=this._sortedKeys[0],n=this._subQueues[e].shift();return 0===this._subQueues[e].length&&(this._sortedKeys.shift(),delete this._subQueues[e]),n},e}();e.PriorityQueue=n}(e.threading||(e.threading={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(n){var t,i=e.logging.GALogger;!function(e){e[e.Equal=0]="Equal",e[e.LessOrEqual=1]="LessOrEqual",e[e.NotEqual=2]="NotEqual"}(t=n.EGAStoreArgsOperator||(n.EGAStoreArgsOperator={}));var r;!function(e){e[e.Events=0]="Events",e[e.Sessions=1]="Sessions",e[e.Progression=2]="Progression"}(r=n.EGAStore||(n.EGAStore={}));var s=function(){function e(){this.eventsStore=[],this.sessionsStore=[],this.progressionStore=[],this.storeItems={};try{"object"==typeof localStorage?(localStorage.setItem("testingLocalStorage","yes"),localStorage.removeItem("testingLocalStorage"),e.storageAvailable=!0):e.storageAvailable=!1}catch(e){}}return e.isStorageAvailable=function(){return e.storageAvailable},e.isStoreTooLargeForEvents=function(){return e.instance.eventsStore.length+e.instance.sessionsStore.length>e.MaxNumberOfEntries},e.select=function(n,i,r,s){void 0===i&&(i=[]),void 0===r&&(r=!1),void 0===s&&(s=0);var o=e.getStore(n);if(!o)return null;for(var a=[],u=0;u<o.length;++u){for(var c=o[u],d=!0,l=0;l<i.length;++l){var f=i[l];if(c[f[0]])switch(f[1]){case t.Equal:d=c[f[0]]==f[2];break;case t.LessOrEqual:d=c[f[0]]<=f[2];break;case t.NotEqual:d=c[f[0]]!=f[2];break;default:d=!1}else d=!1;if(!d)break}d&&a.push(c)}return r&&a.sort(function(e,n){return e.client_ts-n.client_ts}),s>0&&a.length>s&&(a=a.slice(0,s+1)),a},e.update=function(n,i,r){void 0===r&&(r=[]);var s=e.getStore(n);if(!s)return!1;for(var o=0;o<s.length;++o){for(var a=s[o],u=!0,c=0;c<r.length;++c){var d=r[c];if(a[d[0]])switch(d[1]){case t.Equal:u=a[d[0]]==d[2];break;case t.LessOrEqual:u=a[d[0]]<=d[2];break;case t.NotEqual:u=a[d[0]]!=d[2];break;default:u=!1}else u=!1;if(!u)break}if(u)for(var c=0;c<i.length;++c){var l=i[c];a[l[0]]=l[1]}}return!0},e.delete=function(n,i){var r=e.getStore(n);if(r)for(var s=0;s<r.length;++s){for(var o=r[s],a=!0,u=0;u<i.length;++u){var c=i[u];if(o[c[0]])switch(c[1]){case t.Equal:a=o[c[0]]==c[2];break;case t.LessOrEqual:a=o[c[0]]<=c[2];break;case t.NotEqual:a=o[c[0]]!=c[2];break;default:a=!1}else a=!1;if(!a)break}a&&(r.splice(s,1),--s)}},e.insert=function(n,t,i,r){void 0===i&&(i=!1),void 0===r&&(r=null);var s=e.getStore(n);if(s)if(i){if(!r)return;for(var o=!1,a=0;a<s.length;++a){var u=s[a];if(u[r]==t[r]){for(var c in t)u[c]=t[c];o=!0;break}}o||s.push(t)}else s.push(t)},e.save=function(){if(!e.isStorageAvailable())return void i.w("Storage is not available, cannot save.");localStorage.setItem(e.KeyPrefix+e.EventsStoreKey,JSON.stringify(e.instance.eventsStore)),localStorage.setItem(e.KeyPrefix+e.SessionsStoreKey,JSON.stringify(e.instance.sessionsStore)),localStorage.setItem(e.KeyPrefix+e.ProgressionStoreKey,JSON.stringify(e.instance.progressionStore)),localStorage.setItem(e.KeyPrefix+e.ItemsStoreKey,JSON.stringify(e.instance.storeItems))},e.load=function(){if(!e.isStorageAvailable())return void i.w("Storage is not available, cannot load.");try{e.instance.eventsStore=JSON.parse(localStorage.getItem(e.KeyPrefix+e.EventsStoreKey)),e.instance.eventsStore||(e.instance.eventsStore=[])}catch(n){i.w("Load failed for 'events' store. Using empty store."),e.instance.eventsStore=[]}try{e.instance.sessionsStore=JSON.parse(localStorage.getItem(e.KeyPrefix+e.SessionsStoreKey)),e.instance.sessionsStore||(e.instance.sessionsStore=[])}catch(n){i.w("Load failed for 'sessions' store. Using empty store."),e.instance.sessionsStore=[]}try{e.instance.progressionStore=JSON.parse(localStorage.getItem(e.KeyPrefix+e.ProgressionStoreKey)),e.instance.progressionStore||(e.instance.progressionStore=[])}catch(n){i.w("Load failed for 'progression' store. Using empty store."),e.instance.progressionStore=[]}try{e.instance.storeItems=JSON.parse(localStorage.getItem(e.KeyPrefix+e.ItemsStoreKey)),e.instance.storeItems||(e.instance.storeItems={})}catch(n){i.w("Load failed for 'items' store. Using empty store."),e.instance.progressionStore=[]}},e.setItem=function(n,t){var i=e.KeyPrefix+n;t?e.instance.storeItems[i]=t:i in e.instance.storeItems&&delete e.instance.storeItems[i]},e.getItem=function(n){var t=e.KeyPrefix+n;return t in e.instance.storeItems?e.instance.storeItems[t]:null},e.getStore=function(n){switch(n){case r.Events:return e.instance.eventsStore;case r.Sessions:return e.instance.sessionsStore;case r.Progression:return e.instance.progressionStore;default:return i.w("GAStore.getStore(): Cannot find store: "+n),null}},e}();s.instance=new s,s.MaxNumberOfEntries=2e3,s.KeyPrefix="GA::",s.EventsStoreKey="ga_event",s.SessionsStoreKey="ga_session",s.ProgressionStoreKey="ga_progression",s.ItemsStoreKey="ga_items",n.GAStore=s}(e.store||(e.store={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(n){var t=e.validators.GAValidator,i=e.utilities.GAUtilities,r=e.logging.GALogger,s=e.store.GAStore,o=e.device.GADevice,a=e.store.EGAStore,u=e.store.EGAStoreArgsOperator,c=function(){function n(){this.availableCustomDimensions01=[],this.availableCustomDimensions02=[],this.availableCustomDimensions03=[],this.availableResourceCurrencies=[],this.availableResourceItemTypes=[],this.sdkConfigDefault={},this.sdkConfig={},this.progressionTries={}}return n.setUserId=function(e){n.instance.userId=e,n.cacheIdentifier()},n.getIdentifier=function(){return n.instance.identifier},n.isInitialized=function(){return n.instance.initialized},n.setInitialized=function(e){n.instance.initialized=e},n.getSessionStart=function(){return n.instance.sessionStart},n.getSessionNum=function(){return n.instance.sessionNum},n.getTransactionNum=function(){return n.instance.transactionNum},n.getSessionId=function(){return n.instance.sessionId},n.getCurrentCustomDimension01=function(){return n.instance.currentCustomDimension01},n.getCurrentCustomDimension02=function(){return n.instance.currentCustomDimension02},n.getCurrentCustomDimension03=function(){return n.instance.currentCustomDimension03},n.getGameKey=function(){return n.instance.gameKey},n.getGameSecret=function(){return n.instance.gameSecret},n.getAvailableCustomDimensions01=function(){return n.instance.availableCustomDimensions01},n.setAvailableCustomDimensions01=function(e){t.validateCustomDimensions(e)&&(n.instance.availableCustomDimensions01=e,n.validateAndFixCurrentDimensions(),r.i("Set available custom01 dimension values: ("+i.joinStringArray(e,", ")+")"))},n.getAvailableCustomDimensions02=function(){return n.instance.availableCustomDimensions02},n.setAvailableCustomDimensions02=function(e){t.validateCustomDimensions(e)&&(n.instance.availableCustomDimensions02=e,n.validateAndFixCurrentDimensions(),r.i("Set available custom02 dimension values: ("+i.joinStringArray(e,", ")+")"))},n.getAvailableCustomDimensions03=function(){return n.instance.availableCustomDimensions03},n.setAvailableCustomDimensions03=function(e){t.validateCustomDimensions(e)&&(n.instance.availableCustomDimensions03=e,n.validateAndFixCurrentDimensions(),r.i("Set available custom03 dimension values: ("+i.joinStringArray(e,", ")+")"))},n.getAvailableResourceCurrencies=function(){return n.instance.availableResourceCurrencies},n.setAvailableResourceCurrencies=function(e){t.validateResourceCurrencies(e)&&(n.instance.availableResourceCurrencies=e,r.i("Set available resource currencies: ("+i.joinStringArray(e,", ")+")"))},n.getAvailableResourceItemTypes=function(){return n.instance.availableResourceItemTypes},n.setAvailableResourceItemTypes=function(e){t.validateResourceItemTypes(e)&&(n.instance.availableResourceItemTypes=e,r.i("Set available resource item types: ("+i.joinStringArray(e,", ")+")"))},n.getBuild=function(){return n.instance.build},n.setBuild=function(e){n.instance.build=e,r.i("Set build version: "+e)},n.getUseManualSessionHandling=function(){return n.instance.useManualSessionHandling},n.prototype.setDefaultId=function(e){this.defaultUserId=e||"",n.cacheIdentifier()},n.getDefaultId=function(){return n.instance.defaultUserId},n.getSdkConfig=function(){var e,t=0;for(var i in n.instance.sdkConfig)0===t&&(e=i),++t;if(e&&t>0)return n.instance.sdkConfig;var e,t=0;for(var i in n.instance.sdkConfigCached)0===t&&(e=i),++t;return e&&t>0?n.instance.sdkConfigCached:n.instance.sdkConfigDefault},n.isEnabled=function(){var e=n.getSdkConfig()
;return(!e.enabled||"false"!=e.enabled)&&!!n.instance.initAuthorized},n.setCustomDimension01=function(e){n.instance.currentCustomDimension01=e,s.setItem(n.Dimension01Key,e),r.i("Set custom01 dimension value: "+e)},n.setCustomDimension02=function(e){n.instance.currentCustomDimension02=e,s.setItem(n.Dimension02Key,e),r.i("Set custom02 dimension value: "+e)},n.setCustomDimension03=function(e){n.instance.currentCustomDimension03=e,s.setItem(n.Dimension03Key,e),r.i("Set custom03 dimension value: "+e)},n.setFacebookId=function(e){n.instance.facebookId=e,s.setItem(n.FacebookIdKey,e),r.i("Set facebook id: "+e)},n.setGender=function(t){n.instance.gender=isNaN(Number(e.EGAGender[t]))?e.EGAGender[t].toString().toLowerCase():e.EGAGender[e.EGAGender[t]].toString().toLowerCase(),s.setItem(n.GenderKey,n.instance.gender),r.i("Set gender: "+n.instance.gender)},n.setBirthYear=function(e){n.instance.birthYear=e,s.setItem(n.BirthYearKey,e.toString()),r.i("Set birth year: "+e)},n.incrementSessionNum=function(){var e=n.getSessionNum()+1;n.instance.sessionNum=e},n.incrementTransactionNum=function(){var e=n.getTransactionNum()+1;n.instance.transactionNum=e},n.incrementProgressionTries=function(e){var t=n.getProgressionTries(e)+1;n.instance.progressionTries[e]=t;var i={};i.progression=e,i.tries=t,s.insert(a.Progression,i,!0,"progression")},n.getProgressionTries=function(e){return e in n.instance.progressionTries?n.instance.progressionTries[e]:0},n.clearProgressionTries=function(e){e in n.instance.progressionTries&&delete n.instance.progressionTries[e];var t=[];t.push(["progression",u.Equal,e]),s.delete(a.Progression,t)},n.setKeys=function(e,t){n.instance.gameKey=e,n.instance.gameSecret=t},n.setManualSessionHandling=function(e){n.instance.useManualSessionHandling=e,r.i("Use manual session handling: "+e)},n.getEventAnnotations=function(){var e={};e.v=2,e.user_id=n.instance.identifier,e.client_ts=n.getClientTsAdjusted(),e.sdk_version=o.getRelevantSdkVersion(),e.os_version=o.osVersion,e.manufacturer=o.deviceManufacturer,e.device=o.deviceModel,e.browser_version=o.browserVersion,e.platform=o.buildPlatform,e.session_id=n.instance.sessionId,e[n.SessionNumKey]=n.instance.sessionNum;var i=o.getConnectionType();return t.validateConnectionType(i)&&(e.connection_type=i),o.gameEngineVersion&&(e.engine_version=o.gameEngineVersion),n.instance.build&&(e.build=n.instance.build),n.instance.facebookId&&(e[n.FacebookIdKey]=n.instance.facebookId),n.instance.gender&&(e[n.GenderKey]=n.instance.gender),0!=n.instance.birthYear&&(e[n.BirthYearKey]=n.instance.birthYear),e},n.getSdkErrorEventAnnotations=function(){var e={};e.v=2,e.category=n.CategorySdkError,e.sdk_version=o.getRelevantSdkVersion(),e.os_version=o.osVersion,e.manufacturer=o.deviceManufacturer,e.device=o.deviceModel,e.platform=o.buildPlatform;var i=o.getConnectionType();return t.validateConnectionType(i)&&(e.connection_type=i),o.gameEngineVersion&&(e.engine_version=o.gameEngineVersion),e},n.getInitAnnotations=function(){var e={};return e.sdk_version=o.getRelevantSdkVersion(),e.os_version=o.osVersion,e.platform=o.buildPlatform,e},n.getClientTsAdjusted=function(){var e=i.timeIntervalSince1970(),r=e+n.instance.clientServerTimeOffset;return t.validateClientTs(r)?r:e},n.sessionIsStarted=function(){return 0!=n.instance.sessionStart},n.cacheIdentifier=function(){n.instance.userId?n.instance.identifier=n.instance.userId:n.instance.defaultUserId&&(n.instance.identifier=n.instance.defaultUserId)},n.ensurePersistedStates=function(){s.isStorageAvailable()&&s.load();var e=n.instance;e.setDefaultId(null!=s.getItem(n.DefaultUserIdKey)?s.getItem(n.DefaultUserIdKey):i.createGuid()),e.sessionNum=null!=s.getItem(n.SessionNumKey)?Number(s.getItem(n.SessionNumKey)):0,e.transactionNum=null!=s.getItem(n.TransactionNumKey)?Number(s.getItem(n.TransactionNumKey)):0,e.facebookId?s.setItem(n.FacebookIdKey,e.facebookId):(e.facebookId=null!=s.getItem(n.FacebookIdKey)?s.getItem(n.FacebookIdKey):"",e.facebookId),e.gender?s.setItem(n.GenderKey,e.gender):(e.gender=null!=s.getItem(n.GenderKey)?s.getItem(n.GenderKey):"",e.gender),e.birthYear&&0!=e.birthYear?s.setItem(n.BirthYearKey,e.birthYear.toString()):(e.birthYear=null!=s.getItem(n.BirthYearKey)?Number(s.getItem(n.BirthYearKey)):0,e.birthYear),e.currentCustomDimension01?s.setItem(n.Dimension01Key,e.currentCustomDimension01):(e.currentCustomDimension01=null!=s.getItem(n.Dimension01Key)?s.getItem(n.Dimension01Key):"",e.currentCustomDimension01),e.currentCustomDimension02?s.setItem(n.Dimension02Key,e.currentCustomDimension02):(e.currentCustomDimension02=null!=s.getItem(n.Dimension02Key)?s.getItem(n.Dimension02Key):"",e.currentCustomDimension02),e.currentCustomDimension03?s.setItem(n.Dimension03Key,e.currentCustomDimension03):(e.currentCustomDimension03=null!=s.getItem(n.Dimension03Key)?s.getItem(n.Dimension03Key):"",e.currentCustomDimension03);var t=null!=s.getItem(n.SdkConfigCachedKey)?s.getItem(n.SdkConfigCachedKey):"";if(t){var r=JSON.parse(i.decode64(t));r&&(e.sdkConfigCached=r)}var o=s.select(a.Progression);if(o)for(var u=0;u<o.length;++u){var c=o[u];c&&(e.progressionTries[c.progression]=c.tries)}},n.calculateServerTimeOffset=function(e){return e-i.timeIntervalSince1970()},n.validateAndFixCurrentDimensions=function(){t.validateDimension01(n.getCurrentCustomDimension01(),n.getAvailableCustomDimensions01())||n.setCustomDimension01(""),t.validateDimension02(n.getCurrentCustomDimension02(),n.getAvailableCustomDimensions02())||n.setCustomDimension02(""),t.validateDimension03(n.getCurrentCustomDimension03(),n.getAvailableCustomDimensions03())||n.setCustomDimension03("")},n}();c.CategorySdkError="sdk_error",c.instance=new c,c.DefaultUserIdKey="default_user_id",c.SessionNumKey="session_num",c.TransactionNumKey="transaction_num",c.FacebookIdKey="facebook_id",c.GenderKey="gender",c.BirthYearKey="birth_year",c.Dimension01Key="dimension01",c.Dimension02Key="dimension02",c.Dimension03Key="dimension03",c.SdkConfigCachedKey="sdk_config_cached",n.GAState=c}(e.state||(e.state={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(n){var t=e.utilities.GAUtilities,i=e.logging.GALogger,r=function(){function e(){}return e.execute=function(n,r,s,o){if(e.countMap[r]||(e.countMap[r]=0),!(e.countMap[r]>=e.MaxCount)){var a=t.getHmac(o,s),u=new XMLHttpRequest;u.onreadystatechange=function(){if(4===u.readyState){if(!u.responseText)return;if(200!=u.status)return void i.w("sdk error failed. response code not 200. status code: "+u.status+", description: "+u.statusText+", body: "+u.responseText);e.countMap[r]=e.countMap[r]+1}},u.open("POST",n,!0),u.setRequestHeader("Content-Type","application/json"),u.setRequestHeader("Authorization",a);try{u.send(s)}catch(e){console.error(e)}}},e}();r.MaxCount=10,r.countMap={},n.SdkErrorTask=r}(e.tasks||(e.tasks={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(n){var t=e.state.GAState,i=e.logging.GALogger,r=e.utilities.GAUtilities,s=e.validators.GAValidator,o=e.tasks.SdkErrorTask,a=function(){function e(){this.protocol="https",this.hostName="api.gameanalytics.com",this.version="v2",this.baseUrl=this.protocol+"://"+this.hostName+"/"+this.version,this.initializeUrlPath="init",this.eventsUrlPath="events",this.useGzip=!1}return e.prototype.requestInit=function(i){var r=t.getGameKey(),s=this.baseUrl+"/"+r+"/"+this.initializeUrlPath,o=t.getInitAnnotations(),a=JSON.stringify(o);if(!a)return void i(n.EGAHTTPApiResponse.JsonEncodeFailed,null);var u=this.createPayloadData(a,this.useGzip),c=[];c.push(a),e.sendRequest(s,u,c,this.useGzip,e.initRequestCallback,i)},e.prototype.sendEventsInArray=function(i,r,s){if(0!=i.length){var o=t.getGameKey(),a=this.baseUrl+"/"+o+"/"+this.eventsUrlPath,u=JSON.stringify(i);if(!u)return void s(n.EGAHTTPApiResponse.JsonEncodeFailed,null,r,i.length);var c=this.createPayloadData(u,this.useGzip),d=[];d.push(u),d.push(r),d.push(i.length.toString()),e.sendRequest(a,c,d,this.useGzip,e.sendEventInArrayRequestCallback,s)}},e.prototype.sendSdkErrorEvent=function(n){var r=t.getGameKey(),a=t.getGameSecret();if(s.validateSdkErrorEvent(r,a,n)){var u=this.baseUrl+"/"+r+"/"+this.eventsUrlPath,c="",d=t.getSdkErrorEventAnnotations(),l=e.sdkErrorTypeToString(n);d.type=l;var f=[];if(f.push(d),!(c=JSON.stringify(f)))return void i.w("sendSdkErrorEvent: JSON encoding failed.");o.execute(u,n,c,a)}},e.sendEventInArrayRequestCallback=function(t,i,r,s){void 0===s&&(s=null);var o=(s[0],s[1],s[2]),a=parseInt(s[3]),u="",c=0;u=t.responseText,c=t.status;var d=e.instance.processRequestResponse(c,t.statusText,u,"Events");if(d!=n.EGAHTTPApiResponse.Ok&&d!=n.EGAHTTPApiResponse.BadRequest)return void r(d,null,o,a);var l=u?JSON.parse(u):{};if(null==l)return void r(n.EGAHTTPApiResponse.JsonDecodeFailed,null,o,a);n.EGAHTTPApiResponse.BadRequest,r(d,l,o,a)},e.sendRequest=function(e,n,i,s,o,a){var u=new XMLHttpRequest,c=t.getGameSecret(),d=r.getHmac(c,n),l=[];l.push(d);for(var f in i)l.push(i[f]);if(u.onreadystatechange=function(){4===u.readyState&&o(u,e,a,l)},u.open("POST",e,!0),u.setRequestHeader("Content-Type","text/plain"),u.setRequestHeader("Authorization",d),s)throw new Error("gzip not supported");try{u.send(n)}catch(e){console.error(e.stack)}},e.initRequestCallback=function(t,i,r,o){void 0===o&&(o=null);var a=(o[0],o[1],""),u=0;a=t.responseText,u=t.status;var c=a?JSON.parse(a):{},d=e.instance.processRequestResponse(u,t.statusText,a,"Init");if(d!=n.EGAHTTPApiResponse.Ok&&d!=n.EGAHTTPApiResponse.BadRequest)return void r(d,null);if(null==c)return void r(n.EGAHTTPApiResponse.JsonDecodeFailed,null);if(d===n.EGAHTTPApiResponse.BadRequest)return void r(d,null);var l=s.validateAndCleanInitRequestResponse(c);if(!l)return void r(n.EGAHTTPApiResponse.BadResponse,null);r(n.EGAHTTPApiResponse.Ok,l)},e.prototype.createPayloadData=function(e,n){if(n)throw new Error("gzip not supported");return e},e.prototype.processRequestResponse=function(e,t,i,r){return i?200===e?n.EGAHTTPApiResponse.Ok:0===e||401===e?n.EGAHTTPApiResponse.Unauthorized:400===e?n.EGAHTTPApiResponse.BadRequest:500===e?n.EGAHTTPApiResponse.InternalServerError:n.EGAHTTPApiResponse.UnknownResponseCode:n.EGAHTTPApiResponse.NoResponse},e.sdkErrorTypeToString=function(e){switch(e){case n.EGASdkErrorType.Rejected:return"rejected";default:return""}},e}();a.instance=new a,n.GAHTTPApi=a}(e.http||(e.http={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(n){var t=e.store.GAStore,i=e.store.EGAStore,r=e.store.EGAStoreArgsOperator,s=e.state.GAState,o=e.logging.GALogger,a=e.utilities.GAUtilities,u=e.http.EGAHTTPApiResponse,c=e.http.GAHTTPApi,d=e.validators.GAValidator,l=e.http.EGASdkErrorType,f=function(){function n(){}return n.addSessionStartEvent=function(){var e={};e.category=n.CategorySessionStart,s.incrementSessionNum(),t.setItem(s.SessionNumKey,s.getSessionNum().toString()),n.addDimensionsToEvent(e),n.addEventToStore(e),o.i("Add SESSION START event"),n.processEvents(n.CategorySessionStart,!1)},n.addSessionEndEvent=function(){var e=s.getSessionStart(),t=s.getClientTsAdjusted(),i=t-e;i<0&&(o.w("Session length was calculated to be less then 0. Should not be possible. Resetting to 0."),i=0);var r={};r.category=n.CategorySessionEnd,r.length=i,n.addDimensionsToEvent(r),n.addEventToStore(r),o.i("Add SESSION END event."),n.processEvents("",!1)},n.addBusinessEvent=function(e,i,r,a,u){if(void 0===u&&(u=null),!d.validateBusinessEvent(e,i,u,r,a))return void c.instance.sendSdkErrorEvent(l.Rejected);var f={};s.incrementTransactionNum(),t.setItem(s.TransactionNumKey,s.getTransactionNum().toString()),f.event_id=r+":"+a,f.category=n.CategoryBusiness,f.currency=e,f.amount=i,f[s.TransactionNumKey]=s.getTransactionNum(),u&&(f.cart_type=u),n.addDimensionsToEvent(f),o.i("Add BUSINESS event: {currency:"+e+", amount:"+i+", itemType:"+r+", itemId:"+a+", cartType:"+u+"}"),n.addEventToStore(f)},n.addResourceEvent=function(t,i,r,a,u){if(!d.validateResourceEvent(t,i,r,a,u,s.getAvailableResourceCurrencies(),s.getAvailableResourceItemTypes()))return void c.instance.sendSdkErrorEvent(l.Rejected);t===e.EGAResourceFlowType.Sink&&(r*=-1);var f={},v=n.resourceFlowTypeToString(t);f.event_id=v+":"+i+":"+a+":"+u,f.category=n.CategoryResource,f.amount=r,n.addDimensionsToEvent(f),o.i("Add RESOURCE event: {currency:"+i+", amount:"+r+", itemType:"+a+", itemId:"+u+"}"),n.addEventToStore(f)},n.addProgressionEvent=function(t,i,r,a,u,f){var v=n.progressionStatusToString(t);if(!d.validateProgressionEvent(t,i,r,a))return void c.instance.sendSdkErrorEvent(l.Rejected);var g,m={};g=r?a?i+":"+r+":"+a:i+":"+r:i,m.category=n.CategoryProgression,m.event_id=v+":"+g;var p=0;f&&t!=e.EGAProgressionStatus.Start&&(m.score=u),t===e.EGAProgressionStatus.Fail&&s.incrementProgressionTries(g),t===e.EGAProgressionStatus.Complete&&(s.incrementProgressionTries(g),p=s.getProgressionTries(g),m.attempt_num=p,s.clearProgressionTries(g)),n.addDimensionsToEvent(m),o.i("Add PROGRESSION event: {status:"+v+", progression01:"+i+", progression02:"+r+", progression03:"+a+", score:"+u+", attempt:"+p+"}"),n.addEventToStore(m)},n.addDesignEvent=function(e,t,i){if(!d.validateDesignEvent(e,t))return void c.instance.sendSdkErrorEvent(l.Rejected);var r={};r.category=n.CategoryDesign,r.event_id=e,i&&(r.value=t),o.i("Add DESIGN event: {eventId:"+e+", value:"+t+"}"),n.addEventToStore(r)},n.addErrorEvent=function(e,t){var i=n.errorSeverityToString(e);if(!d.validateErrorEvent(e,t))return void c.instance.sendSdkErrorEvent(l.Rejected);var r={};r.category=n.CategoryError,r.severity=i,r.message=t,o.i("Add ERROR event: {severity:"+i+", message:"+t+"}"),n.addEventToStore(r)},n.processEvents=function(e,s){try{var u=a.createGuid();s&&(n.cleanupEvents(),n.fixMissingSessionEndEvents());var d=[];d.push(["status",r.Equal,"new"]);var l=[];l.push(["status",r.Equal,"new"]),e&&(d.push(["category",r.Equal,e]),l.push(["category",r.Equal,e]));var f=[];f.push(["status",u]);var v=t.select(i.Events,d);if(!v||0==v.length)return void o.i("Event queue: No events to send");if(v.length>n.MaxEventCount){if(!(v=t.select(i.Events,d,!0,n.MaxEventCount)))return;var g=v[v.length-1],m=g.client_ts;if(d.push(["client_ts",r.LessOrEqual,m]),!(v=t.select(i.Events,d)))return;l.push(["client_ts",r.LessOrEqual,m])}if(o.i("Event queue: Sending "+v.length+" events."),!t.update(i.Events,f,l))return;for(var p=[],h=0;h<v.length;++h){var y=v[h],S=JSON.parse(a.decode64(y.event));0!=S.length&&p.push(S)}c.instance.sendEventsInArray(p,u,n.processEventsCallback)}catch(e){o.e("Error during ProcessEvents(): "+e.stack)}},n.processEventsCallback=function(e,s,a,c){var d=[];if(d.push(["status",r.Equal,a]),e===u.Ok)t.delete(i.Events,d),o.i("Event queue: "+c+" events sent.");else if(e===u.NoResponse){var l=[];l.push(["status","new"]),o.w("Event queue: Failed to send events to collector - Retrying next time"),t.update(i.Events,l,d)}else{if(s){var f,v=0;for(var g in s)0==v&&(f=s[g]),++v;e===u.BadRequest&&f.constructor===Array?o.w("Event queue: "+c+" events sent. "+v+" events failed GA server validation."):o.w("Event queue: Failed to send events.")}else o.w("Event queue: Failed to send events.");t.delete(i.Events,d)}n.updateSessionStore()},n.cleanupEvents=function(){t.update(i.Events,[["status","new"]])},n.fixMissingSessionEndEvents=function(){var e=[];e.push(["session_id",r.NotEqual,s.getSessionId()]);var u=t.select(i.Sessions,e);if(u&&0!=u.length){o.i(u.length+" session(s) located with missing session_end event.");for(var c=0;c<u.length;++c){var d=JSON.parse(a.decode64(u[c].event)),l=d.client_ts,f=u[c].timestamp,v=l-f;v=Math.max(0,v),d.category=n.CategorySessionEnd,d.length=v,n.addEventToStore(d)}}},n.addEventToStore=function(e){if(!s.isInitialized())return void o.w("Could not add event: SDK is not initialized");try{if(t.isStoreTooLargeForEvents()&&!a.stringMatch(e.category,/^(user|session_end|business)$/))return void o.w("Database too large. Event has been blocked.");var u=s.getEventAnnotations(),c=a.encode64(JSON.stringify(u));for(var d in e)u[d]=e[d];var l=JSON.stringify(u);o.ii("Event added to queue: "+l);var f={};f.status="new",f.category=u.category,f.session_id=u.session_id,f.client_ts=u.client_ts,f.event=a.encode64(JSON.stringify(u)),t.insert(i.Events,f),e.category==n.CategorySessionEnd?t.delete(i.Sessions,[["session_id",r.Equal,u.session_id]]):(f={},f.session_id=u.session_id,f.timestamp=s.getSessionStart(),f.event=c,t.insert(i.Sessions,f,!0,"session_id")),t.isStorageAvailable()&&t.save()}catch(d){o.e("addEventToStore: error"),o.e(d.stack)}},n.updateSessionStore=function(){if(s.sessionIsStarted()){var e={};e.session_id=s.instance.sessionId,e.timestamp=s.getSessionStart(),e.event=a.encode64(JSON.stringify(s.getEventAnnotations())),t.insert(i.Sessions,e,!0,"session_id"),t.isStorageAvailable()&&t.save()}},n.addDimensionsToEvent=function(e){e&&(s.getCurrentCustomDimension01()&&(e.custom_01=s.getCurrentCustomDimension01()),s.getCurrentCustomDimension02()&&(e.custom_02=s.getCurrentCustomDimension02()),s.getCurrentCustomDimension03()&&(e.custom_03=s.getCurrentCustomDimension03()))},n.resourceFlowTypeToString=function(n){return n==e.EGAResourceFlowType.Source||n==e.EGAResourceFlowType[e.EGAResourceFlowType.Source]?"Source":n==e.EGAResourceFlowType.Sink||n==e.EGAResourceFlowType[e.EGAResourceFlowType.Sink]?"Sink":""},n.progressionStatusToString=function(n){return n==e.EGAProgressionStatus.Start||n==e.EGAProgressionStatus[e.EGAProgressionStatus.Start]?"Start":n==e.EGAProgressionStatus.Complete||n==e.EGAProgressionStatus[e.EGAProgressionStatus.Complete]?"Complete":n==e.EGAProgressionStatus.Fail||n==e.EGAProgressionStatus[e.EGAProgressionStatus.Fail]?"Fail":""},n.errorSeverityToString=function(n){return n==e.EGAErrorSeverity.Debug||n==e.EGAErrorSeverity[e.EGAErrorSeverity.Debug]?"debug":n==e.EGAErrorSeverity.Info||n==e.EGAErrorSeverity[e.EGAErrorSeverity.Info]?"info":n==e.EGAErrorSeverity.Warning||n==e.EGAErrorSeverity[e.EGAErrorSeverity.Warning]?"warning":n==e.EGAErrorSeverity.Error||n==e.EGAErrorSeverity[e.EGAErrorSeverity.Error]?"error":n==e.EGAErrorSeverity.Critical||n==e.EGAErrorSeverity[e.EGAErrorSeverity.Critical]?"critical":""},n}();f.instance=new f,f.CategorySessionStart="user",f.CategorySessionEnd="session_end",f.CategoryDesign="design",f.CategoryBusiness="business",f.CategoryProgression="progression",f.CategoryResource="resource",f.CategoryError="error",f.MaxEventCount=500,n.GAEvents=f}(e.events||(e.events={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){!function(n){var t=e.logging.GALogger,i=e.state.GAState,r=e.events.GAEvents,s=function(){function e(){this.blocks=new n.PriorityQueue({compare:function(e,n){return e-n}}),this.id2TimedBlockMap={},e.startThread()}return e.createTimedBlock=function(e){void 0===e&&(e=0);var t=new Date;return t.setSeconds(t.getSeconds()+e),new n.TimedBlock(t)},e.performTaskOnGAThread=function(t,i){void 0===i&&(i=0);var r=new Date;r.setSeconds(r.getSeconds()+i);var s=new n.TimedBlock(r);s.block=t,e.instance.id2TimedBlockMap[s.id]=s,e.instance.addTimedBlock(s)},e.performTimedBlockOnGAThread=function(n){e.instance.id2TimedBlockMap[n.id]=n,e.instance.addTimedBlock(n)},e.scheduleTimer=function(t,i){var r=new Date;r.setSeconds(r.getSeconds()+t);var s=new n.TimedBlock(r);return s.block=i,e.instance.id2TimedBlockMap[s.id]=s,e.instance.addTimedBlock(s),s.id},e.getTimedBlockById=function(n){return n in e.instance.id2TimedBlockMap?e.instance.id2TimedBlockMap[n]:null},e.ensureEventQueueIsRunning=function(){e.instance.keepRunning=!0,e.instance.isRunning||(e.instance.isRunning=!0,e.scheduleTimer(e.ProcessEventsIntervalInSeconds,e.processEventQueue))},e.endSessionAndStopQueue=function(){i.isInitialized()&&(t.i("Ending session."),e.stopEventQueue(),i.isEnabled()&&i.sessionIsStarted()&&(r.addSessionEndEvent(),i.instance.sessionStart=0))},e.stopEventQueue=function(){e.instance.keepRunning=!1},e.ignoreTimer=function(n){n in e.instance.id2TimedBlockMap&&(e.instance.id2TimedBlockMap[n].ignore=!0)},e.setEventProcessInterval=function(n){n>0&&(e.ProcessEventsIntervalInSeconds=n)},e.prototype.addTimedBlock=function(e){this.blocks.enqueue(e.deadline.getTime(),e)},e.run=function(){clearTimeout(e.runTimeoutId);try{for(var n;n=e.getNextBlock();)if(!n.ignore)if(n.async){if(!n.running){n.running=!0,n.block();break}}else n.block();return void(e.runTimeoutId=setTimeout(e.run,e.ThreadWaitTimeInMs))}catch(e){t.e("Error on GA thread"),t.e(e.stack)}},e.startThread=function(){e.runTimeoutId=setTimeout(e.run,0)},e.getNextBlock=function(){var n=new Date;return e.instance.blocks.hasItems()&&e.instance.blocks.peek().deadline.getTime()<=n.getTime()?e.instance.blocks.peek().async&&e.instance.blocks.peek().running?e.instance.blocks.peek():e.instance.blocks.dequeue():null},e.processEventQueue=function(){r.processEvents("",!0),e.instance.keepRunning?e.scheduleTimer(e.ProcessEventsIntervalInSeconds,e.processEventQueue):e.instance.isRunning=!1},e}();s.instance=new s,s.ThreadWaitTimeInMs=1e3,s.ProcessEventsIntervalInSeconds=8,n.GAThreading=s}(e.threading||(e.threading={}))}(gameanalytics||(gameanalytics={}));var gameanalytics;!function(e){var n=e.threading.GAThreading,t=e.logging.GALogger,i=e.store.GAStore,r=e.state.GAState,s=e.http.GAHTTPApi,o=e.device.GADevice,a=e.validators.GAValidator,u=e.http.EGAHTTPApiResponse,c=e.utilities.GAUtilities,d=e.events.GAEvents,l=function(){function l(){}return l.init=function(){if(o.touch(),l.methodMap.configureAvailableCustomDimensions01=l.configureAvailableCustomDimensions01,l.methodMap.configureAvailableCustomDimensions02=l.configureAvailableCustomDimensions02,l.methodMap.configureAvailableCustomDimensions03=l.configureAvailableCustomDimensions03,l.methodMap.configureAvailableResourceCurrencies=l.configureAvailableResourceCurrencies,l.methodMap.configureAvailableResourceItemTypes=l.configureAvailableResourceItemTypes,l.methodMap.configureBuild=l.configureBuild,l.methodMap.configureSdkGameEngineVersion=l.configureSdkGameEngineVersion,l.methodMap.configureGameEngineVersion=l.configureGameEngineVersion,l.methodMap.configureUserId=l.configureUserId,l.methodMap.initialize=l.initialize,l.methodMap.addBusinessEvent=l.addBusinessEvent,l.methodMap.addResourceEvent=l.addResourceEvent,l.methodMap.addProgressionEvent=l.addProgressionEvent,l.methodMap.addDesignEvent=l.addDesignEvent,l.methodMap.addErrorEvent=l.addErrorEvent,l.methodMap.addErrorEvent=l.addErrorEvent,l.methodMap.setEnabledInfoLog=l.setEnabledInfoLog,l.methodMap.setEnabledVerboseLog=l.setEnabledVerboseLog,l.methodMap.setEnabledManualSessionHandling=l.setEnabledManualSessionHandling,l.methodMap.setCustomDimension01=l.setCustomDimension01,l.methodMap.setCustomDimension02=l.setCustomDimension02,l.methodMap.setCustomDimension03=l.setCustomDimension03,l.methodMap.setFacebookId=l.setFacebookId,l.methodMap.setGender=l.setGender,l.methodMap.setBirthYear=l.setBirthYear,l.methodMap.setEventProcessInterval=l.setEventProcessInterval,l.methodMap.startSession=l.startSession,l.methodMap.endSession=l.endSession,l.methodMap.onStop=l.onStop,l.methodMap.onResume=l.onResume,"undefined"!=typeof window&&void 0!==window.GameAnalytics&&void 0!==window.GameAnalytics.q){var e=window.GameAnalytics.q;for(var n in e)l.gaCommand.apply(null,e[n])}},l.gaCommand=function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];n.length>0&&n[0]in e.GameAnalytics.methodMap&&(n.length>1?e.GameAnalytics.methodMap[n[0]].apply(null,Array.prototype.slice.call(n,1)):e.GameAnalytics.methodMap[n[0]]())},l.configureAvailableCustomDimensions01=function(e){void 0===e&&(e=[]),n.performTaskOnGAThread(function(){if(l.isSdkReady(!0,!1))return void t.w("Available custom dimensions must be set before SDK is initialized");r.setAvailableCustomDimensions01(e)})},l.configureAvailableCustomDimensions02=function(e){void 0===e&&(e=[]),n.performTaskOnGAThread(function(){if(l.isSdkReady(!0,!1))return void t.w("Available custom dimensions must be set before SDK is initialized");r.setAvailableCustomDimensions02(e)})},l.configureAvailableCustomDimensions03=function(e){void 0===e&&(e=[]),n.performTaskOnGAThread(function(){if(l.isSdkReady(!0,!1))return void t.w("Available custom dimensions must be set before SDK is initialized");r.setAvailableCustomDimensions03(e)})},l.configureAvailableResourceCurrencies=function(e){void 0===e&&(e=[]),n.performTaskOnGAThread(function(){if(l.isSdkReady(!0,!1))return void t.w("Available resource currencies must be set before SDK is initialized");r.setAvailableResourceCurrencies(e)})},l.configureAvailableResourceItemTypes=function(e){void 0===e&&(e=[]),n.performTaskOnGAThread(function(){if(l.isSdkReady(!0,!1))return void t.w("Available resource item types must be set before SDK is initialized");r.setAvailableResourceItemTypes(e)})},l.configureBuild=function(e){void 0===e&&(e=""),n.performTaskOnGAThread(function(){return l.isSdkReady(!0,!1)?void t.w("Build version must be set before SDK is initialized."):a.validateBuild(e)?void r.setBuild(e):void t.i("Validation fail - configure build: Cannot be null, empty or above 32 length. String: "+e)})},l.configureSdkGameEngineVersion=function(e){void 0===e&&(e=""),n.performTaskOnGAThread(function(){if(!l.isSdkReady(!0,!1))return a.validateSdkWrapperVersion(e)?void(o.sdkGameEngineVersion=e):void t.i("Validation fail - configure sdk version: Sdk version not supported. String: "+e)})},l.configureGameEngineVersion=function(e){void 0===e&&(e=""),n.performTaskOnGAThread(function(){if(!l.isSdkReady(!0,!1))return a.validateEngineVersion(e)?void(o.gameEngineVersion=e):void t.i("Validation fail - configure game engine version: Game engine version not supported. String: "+e)})},l.configureUserId=function(e){void 0===e&&(e=""),n.performTaskOnGAThread(function(){return l.isSdkReady(!0,!1)?void t.w("A custom user id must be set before SDK is initialized."):a.validateUserId(e)?void r.setUserId(e):void t.i("Validation fail - configure user_id: Cannot be null, empty or above 64 length. Will use default user_id method. Used string: "+e)})},l.initialize=function(e,i){void 0===e&&(e=""),void 0===i&&(i=""),o.updateConnectionType();var s=n.createTimedBlock();s.async=!0,l.initTimedBlockId=s.id,s.block=function(){return l.isSdkReady(!0,!1)?void t.w("SDK already initialized. Can only be called once."):a.validateKeys(e,i)?(r.setKeys(e,i),void l.internalInitialize()):void t.w("SDK failed initialize. Game key or secret key is invalid. Can only contain characters A-z 0-9, gameKey is 32 length, gameSecret is 40 length. Failed keys - gameKey: "+e+", secretKey: "+i)},n.performTimedBlockOnGAThread(s)},l.addBusinessEvent=function(e,t,i,r,s){void 0===e&&(e=""),void 0===t&&(t=0),void 0===i&&(i=""),void 0===r&&(r=""),void 0===s&&(s=""),o.updateConnectionType(),n.performTaskOnGAThread(function(){l.isSdkReady(!0,!0,"Could not add business event")&&d.addBusinessEvent(e,t,i,r,s)})},l.addResourceEvent=function(t,i,r,s,a){void 0===t&&(t=e.EGAResourceFlowType.Undefined),void 0===i&&(i=""),void 0===r&&(r=0),void 0===s&&(s=""),void 0===a&&(a=""),o.updateConnectionType(),n.performTaskOnGAThread(function(){l.isSdkReady(!0,!0,"Could not add resource event")&&d.addResourceEvent(t,i,r,s,a)})},l.addProgressionEvent=function(t,i,r,s,a){void 0===t&&(t=e.EGAProgressionStatus.Undefined),void 0===i&&(i=""),void 0===r&&(r=""),void 0===s&&(s=""),o.updateConnectionType(),n.performTaskOnGAThread(function(){if(l.isSdkReady(!0,!0,"Could not add progression event")){var e=void 0!==a;d.addProgressionEvent(t,i,r,s,e?a:0,e)}})},l.addDesignEvent=function(e,t){o.updateConnectionType(),n.performTaskOnGAThread(function(){if(l.isSdkReady(!0,!0,"Could not add design event")){var n=void 0!==t;d.addDesignEvent(e,n?t:0,n)}})},l.addErrorEvent=function(t,i){void 0===t&&(t=e.EGAErrorSeverity.Undefined),void 0===i&&(i=""),o.updateConnectionType(),n.performTaskOnGAThread(function(){l.isSdkReady(!0,!0,"Could not add error event")&&d.addErrorEvent(t,i)})},l.setEnabledInfoLog=function(e){void 0===e&&(e=!1),n.performTaskOnGAThread(function(){e?(t.setInfoLog(e),t.i("Info logging enabled")):(t.i("Info logging disabled"),t.setInfoLog(e))})},l.setEnabledVerboseLog=function(e){void 0===e&&(e=!1),n.performTaskOnGAThread(function(){e?(t.setVerboseLog(e),t.i("Verbose logging enabled")):(t.i("Verbose logging disabled"),t.setVerboseLog(e))})},l.setEnabledManualSessionHandling=function(e){void 0===e&&(e=!1),n.performTaskOnGAThread(function(){r.setManualSessionHandling(e)})},l.setCustomDimension01=function(e){void 0===e&&(e=""),n.performTaskOnGAThread(function(){if(!a.validateDimension01(e,r.getAvailableCustomDimensions01()))return void t.w("Could not set custom01 dimension value to '"+e+"'. Value not found in available custom01 dimension values");r.setCustomDimension01(e)})},l.setCustomDimension02=function(e){void 0===e&&(e=""),n.performTaskOnGAThread(function(){if(!a.validateDimension02(e,r.getAvailableCustomDimensions02()))return void t.w("Could not set custom02 dimension value to '"+e+"'. Value not found in available custom02 dimension values");r.setCustomDimension02(e)})},l.setCustomDimension03=function(e){void 0===e&&(e=""),n.performTaskOnGAThread(function(){if(!a.validateDimension03(e,r.getAvailableCustomDimensions03()))return void t.w("Could not set custom03 dimension value to '"+e+"'. Value not found in available custom03 dimension values");r.setCustomDimension03(e)})},l.setFacebookId=function(e){void 0===e&&(e=""),n.performTaskOnGAThread(function(){a.validateFacebookId(e)&&r.setFacebookId(e)})},l.setGender=function(t){void 0===t&&(t=e.EGAGender.Undefined),n.performTaskOnGAThread(function(){a.validateGender(t)&&r.setGender(t)})},l.setBirthYear=function(e){void 0===e&&(e=0),n.performTaskOnGAThread(function(){a.validateBirthyear(e)&&r.setBirthYear(e)})},l.setEventProcessInterval=function(e){n.performTaskOnGAThread(function(){n.setEventProcessInterval(e)})},l.startSession=function(){if(r.getUseManualSessionHandling()){if(!r.isInitialized())return;var e=n.createTimedBlock();e.async=!0,l.initTimedBlockId=e.id,e.block=function(){r.isEnabled()&&r.sessionIsStarted()&&n.endSessionAndStopQueue(),l.resumeSessionAndStartQueue()},n.performTimedBlockOnGAThread(e)}},l.endSession=function(){r.getUseManualSessionHandling()&&l.onStop()},l.onStop=function(){n.performTaskOnGAThread(function(){try{n.endSessionAndStopQueue()}catch(e){}})},l.onResume=function(){var e=n.createTimedBlock();e.async=!0,l.initTimedBlockId=e.id,e.block=function(){l.resumeSessionAndStartQueue()},n.performTimedBlockOnGAThread(e)},l.internalInitialize=function(){r.ensurePersistedStates(),i.setItem(r.DefaultUserIdKey,r.getDefaultId()),r.setInitialized(!0),l.newSession(),r.isEnabled()&&n.ensureEventQueueIsRunning()},l.newSession=function(){t.i("Starting a new session."),r.validateAndFixCurrentDimensions(),s.instance.requestInit(l.startNewSessionCallback)},l.startNewSessionCallback=function(e,s){if(e===u.Ok&&s){var o=0;if(s.server_ts){var a=s.server_ts;o=r.calculateServerTimeOffset(a)}s.time_offset=o,i.setItem(r.SdkConfigCachedKey,c.encode64(JSON.stringify(s))),r.instance.sdkConfigCached=s,r.instance.sdkConfig=s,r.instance.initAuthorized=!0}else e==u.Unauthorized?(t.w("Initialize SDK failed - Unauthorized"),r.instance.initAuthorized=!1):(e===u.NoResponse||e===u.RequestTimeout?t.i("Init call (session start) failed - no response. Could be offline or timeout."):e===u.BadResponse||e===u.JsonEncodeFailed||e===u.JsonDecodeFailed?t.i("Init call (session start) failed - bad response. Could be bad response from proxy or GA servers."):e!==u.BadRequest&&e!==u.UnknownResponseCode||t.i("Init call (session start) failed - bad request or unknown response."),null==r.instance.sdkConfig?null!=r.instance.sdkConfigCached?(t.i("Init call (session start) failed - using cached init values."),r.instance.sdkConfig=r.instance.sdkConfigCached):(t.i("Init call (session start) failed - using default init values."),r.instance.sdkConfig=r.instance.sdkConfigDefault):t.i("Init call (session start) failed - using cached init values."),r.instance.initAuthorized=!0)
;if(r.instance.clientServerTimeOffset=r.instance.sdkConfig.time_offset?r.instance.sdkConfig.time_offset:0,!r.isEnabled())return t.w("Could not start session: SDK is disabled."),void n.stopEventQueue();n.ensureEventQueueIsRunning();var f=c.createGuid();r.instance.sessionId=f,r.instance.sessionStart=r.getClientTsAdjusted(),d.addSessionStartEvent(),n.getTimedBlockById(l.initTimedBlockId).running=!1,l.initTimedBlockId=-1},l.resumeSessionAndStartQueue=function(){r.isInitialized()&&(t.i("Resuming session."),r.sessionIsStarted()||l.newSession())},l.isSdkReady=function(e,n,i){return void 0===n&&(n=!0),void 0===i&&(i=""),i&&(i+=": "),e&&!r.isInitialized()?(n&&t.w(i+"SDK is not initialized"),!1):!(e&&!r.isEnabled())||(n&&t.w(i+"SDK is disabled"),!1)},l}();l.initTimedBlockId=-1,l.methodMap={},e.GameAnalytics=l}(gameanalytics||(gameanalytics={})),gameanalytics.GameAnalytics.init();var GameAnalytics=gameanalytics.GameAnalytics.gaCommand;
scope.gameanalytics=gameanalytics;
scope.GameAnalytics=GameAnalytics;
})(this);
/* global define, module, require */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['crypto-js', 'ws'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // Node. Export.
        module.exports = factory(require('crypto-js'), require('ws'));
    } else {
        // Browser globals (root is window)
        root.GameSparks = factory(root.Crypto, root.WebSocket || root.MozWebSocket);
    }
}(this, function(CryptoJS, WebSocket) {

    var GameSparks = function() {};

    GameSparks.prototype = {

        init: function(options) {
            this.options = options;
            this.socketUrl = options.url;

            this.pendingRequests = {};
            this.requestCounter = 0;

            this.connect();
        },

        initPreview: function(options) {
            options.url = 'wss://preview.gamesparks.net/ws/' + options.key;
            this.init(options);
        },

        initLive: function(options) {
            options.url = 'wss://service.gamesparks.net/ws/' + options.key;
            this.init(options);
        },

        reset: function() {
            this.initialised = false;
            this.connected = false;
            this.error = false;
            this.disconnected = false;

            if (this.webSocket != null){
                this.webSocket.onclose = null;
                this.webSocket.close();
            }
        },

        connect: function() {
            this.reset();

            try {
                this.webSocket = new WebSocket(this.socketUrl);
                this.webSocket.onopen = this.onWebSocketOpen.bind(this);
                this.webSocket.onclose = this.onWebSocketClose.bind(this);
                this.webSocket.onerror = this.onWebSocketError.bind(this);
                this.webSocket.onmessage = this.onWebSocketMessage.bind(this);
            } catch(e) {
                this.log(e.message);
            }
        },

        disconnect: function() {
            if (this.webSocket && this.connected) {
                this.disconnected = true;
                this.webSocket.close();
            }
        },

        onWebSocketOpen: function(ev) {
            this.log('WebSocket onOpen');

            if (this.options.onOpen) {
                this.options.onOpen(ev);
            }

            this.connected = true;
        },

        onWebSocketClose: function(ev) {
            this.log('WebSocket onClose');

            if (this.options.onClose) {
                this.options.onClose(ev);
            }

            this.connected = false;

            // Attemp a re-connection if not in error state or deliberately disconnected.
            if (!this.error && !this.disconnected) {
                this.connect();
            }
        },

        onWebSocketError: function(ev) {

            this.log('WebSocket onError: Sorry, but there is some problem with your socket or the server is down');

            if (this.options.onError) {
                this.options.onError(ev);
            }

            // Reset the socketUrl to the original.
            this.socketUrl = this.options.url;

            this.error = true;
        },

        onWebSocketMessage: function(message) {
            this.log('WebSocket onMessage: ' + message.data);

            var result;
            try {
                result = JSON.parse(message.data);
            } catch (e) {
                this.log('An error ocurred while parsing the JSON Data: ' + message + '; Error: ' + e);
                return;
            }

            if (this.options.onMessage) {
                this.options.onMessage(result);
            }

            // Extract any auth token.
            if (result['authToken']) {
                this.authToken = result['authToken'];
                delete result['authToken'];
            }

            if (result['connectUrl']) {
                // Any time a connectUrl is in the response we should update and reconnect.
                this.socketUrl = result['connectUrl'];
                this.connect();
            }

            var resultType = result['@class'];

            if (resultType === '.AuthenticatedConnectResponse') {
                this.handshake(result);
            } else if (resultType.match(/Response$/)){
                if (result['requestId']) {
                    var requestId = result['requestId'];
                    delete result['requestId'];

                    if (this.pendingRequests[requestId]) {
                        this.pendingRequests[requestId](result);
                        this.pendingRequests[requestId] = null;
                    }
                }
            }

        },

        handshake: function(result) {

            if (result['nonce']) {

                var hmac;

                if (this.options["onNonce"]) {
                    hmac = this.options.onNonce(result['nonce']);
                } else {
                    hmac = window.Crypto.enc.Base64.stringify(window.Crypto.HmacSHA256(result['nonce'], this.options.secret));
                }

                var toSend = {
                    '@class' : '.AuthenticatedConnectRequest',
                    hmac : hmac
                };

                if (this.authToken) {
                    toSend.authToken = this.authToken;
                }

                if (this.sessionId) {
                    toSend.sessionId = this.sessionId;
                }

                const browserData = this.getBrowserData();
                toSend.platform = browserData.browser;
                toSend.os = browserData.operatingSystem;

                this.webSocketSend(toSend);

            } else if (result['sessionId']) {
                this.sessionId = result['sessionId'];
                this.initialised = true;

                if (this.options.onInit) {
                    this.options.onInit();
                }

                this.keepAliveInterval = window.setInterval(this.keepAlive.bind(this), 30000);
            }
        },

        keepAlive: function() {
            if (this.initialised && this.connected) {
                this.webSocket.send(' ');
            }
        },

        send: function(requestType, onResponse){
            this.sendWithData(requestType, {}, onResponse);
        },

        sendWithData: function(requestType, json, onResponse) {
            if (!this.initialised) {
                onResponse({ error: 'NOT_INITIALISED' });
                return;
            }

            // Ensure requestType starts with a dot.
            if (requestType.indexOf('.') !== 0) {
                requestType = '.' + requestType;
            }

            json['@class'] = requestType;

            json.requestId = (new Date()).getTime() + "_" + (++this.requestCounter);

            if (onResponse != null) {
                this.pendingRequests[json.requestId] = onResponse;
                // Time out handler.
                setTimeout((function() {
                    if (this.pendingRequests[json.requestId]) {
                        this.pendingRequests[json.requestId]({ error: 'NO_RESPONSE' });
                    }
                }).bind(this), 32000);
            }

            this.webSocketSend(json);
        },

        webSocketSend: function(data) {

            if (this.options.onSend) {
                this.options.onSend(data);
            }

            var requestString = JSON.stringify(data);
            this.log('WebSocket send: ' + requestString);
            this.webSocket.send(requestString);
        },

        getSocketUrl: function() {
            return this.socketUrl;
        },

        getSessionId: function() {
            return this.sessionId;
        },

        getAuthToken: function() {
            return this.authToken;
        },

        setAuthToken: function(authToken) {
            this.authToken = authToken;
        },

        isConnected: function() {
            return this.connected;
        },

        log: function(message) {
            if (this.options.logger) {
                this.options.logger(message);
            }
        },

        getBrowserData: function() {

            var browsers = [
                {
                    string: navigator.userAgent,
                    subString: 'Chrome',
                    identity: 'Chrome'
                },
                {   string: navigator.userAgent,
                    subString: 'OmniWeb',
                    versionSearch: 'OmniWeb/',
                    identity: 'OmniWeb'
                },
                {
                    string: navigator.vendor,
                    subString: 'Apple',
                    identity: 'Safari',
                    versionSearch: 'Version'
                },
                {
                    prop: window.opera,
                    identity: 'Opera',
                    versionSearch: 'Version'
                },
                {
                    string: navigator.vendor,
                    subString: 'iCab',
                    identity: 'iCab'
                },
                {
                    string: navigator.vendor,
                    subString: 'KDE',
                    identity: 'Konqueror'
                },
                {
                    string: navigator.userAgent,
                    subString: 'Firefox',
                    identity: 'Firefox'
                },
                {
                    string: navigator.vendor,
                    subString: 'Camino',
                    identity: 'Camino'
                },
                {
                    string: navigator.userAgent,
                    subString: 'Netscape',
                    identity: 'Netscape'
                },
                {
                    string: navigator.userAgent,
                    subString: 'MSIE',
                    identity: 'Explorer',
                    versionSearch: 'MSIE'
                },
                {
                    string: navigator.userAgent,
                    subString: 'Gecko',
                    identity: 'Mozilla',
                    versionSearch: 'rv'
                },
                {
                    string: navigator.userAgent,
                    subString: 'Mozilla',
                    identity: 'Netscape',
                    versionSearch: 'Mozilla'
                }
            ];

            var operatingSystems = [
                {
                    string: navigator.platform,
                    subString: 'Win',
                    identity: 'Windows'
                },
                {
                    string: navigator.platform,
                    subString: 'Mac',
                    identity: 'Mac'
                },
                {
                    string: navigator.userAgent,
                    subString: 'iPhone',
                    identity: 'iPhone/iPod'
                },
                {
                    string: navigator.platform,
                    subString: 'Linux',
                    identity: 'Linux'
                }
            ];

            function searchForIdentity(data) {
                for (var i = 0; i < data.length; i++) {
                    var string = data[i].string;
                    var prop = data[i].prop;

                    if (string) {
                        // Look for the sub string in the string.
                        if (string.indexOf(data[i].subString) !== -1) {
                            return data[i].identity;
                        }
                    } else if (prop) {
                        return data[i].identity;
                    }
                }
            }

            return {
                browser: searchForIdentity(browsers),
                operatingSystem: searchForIdentity(operatingSystems)
            };
        }
    };

    return GameSparks;

}));

//var GameSparks = function() {};
GameSparks.prototype.acceptChallengeRequest = function(challengeInstanceId, message, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["message"] = message;
    gamesparks.sendWithData("AcceptChallengeRequest", request, onResponse);
}
GameSparks.prototype.accountDetailsRequest = function(onResponse )
{
    var request = {};
    gamesparks.sendWithData("AccountDetailsRequest", request, onResponse);
}
GameSparks.prototype.analyticsRequest = function(data, end, key, start, onResponse )
{
    var request = {};
    request["data"] = data;
    request["end"] = end;
    request["key"] = key;
    request["start"] = start;
    gamesparks.sendWithData("AnalyticsRequest", request, onResponse);
}
GameSparks.prototype.aroundMeLeaderboardRequest = function(count, friendIds, leaderboardShortCode, social, onResponse )
{
    var request = {};
    request["count"] = count;
    request["friendIds"] = friendIds;
    request["leaderboardShortCode"] = leaderboardShortCode;
    request["social"] = social;
    gamesparks.sendWithData("AroundMeLeaderboardRequest", request, onResponse);
}
GameSparks.prototype.authenticationRequest = function(password, userName, onResponse )
{
    var request = {};
    request["password"] = password;
    request["userName"] = userName;
    gamesparks.sendWithData("AuthenticationRequest", request, onResponse);
}
GameSparks.prototype.buyVirtualGoodsRequest = function(currencyType, quantity, shortCode, onResponse )
{
    var request = {};
    request["currencyType"] = currencyType;
    request["quantity"] = quantity;
    request["shortCode"] = shortCode;
    gamesparks.sendWithData("BuyVirtualGoodsRequest", request, onResponse);
}
GameSparks.prototype.changeUserDetailsRequest = function(displayName, onResponse )
{
    var request = {};
    request["displayName"] = displayName;
    gamesparks.sendWithData("ChangeUserDetailsRequest", request, onResponse);
}
GameSparks.prototype.chatOnChallengeRequest = function(challengeInstanceId, message, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["message"] = message;
    gamesparks.sendWithData("ChatOnChallengeRequest", request, onResponse);
}
GameSparks.prototype.consumeVirtualGoodRequest = function(quantity, shortCode, onResponse )
{
    var request = {};
    request["quantity"] = quantity;
    request["shortCode"] = shortCode;
    gamesparks.sendWithData("ConsumeVirtualGoodRequest", request, onResponse);
}
GameSparks.prototype.createChallengeRequest = function(accessType, challengeMessage, challengeShortCode, currency1Wager, currency2Wager, currency3Wager, currency4Wager, currency5Wager, currency6Wager, endTime, expiryTime, maxAttempts, maxPlayers, minPlayers, silent, startTime, usersToChallenge, onResponse )
{
    var request = {};
    request["accessType"] = accessType;
    request["challengeMessage"] = challengeMessage;
    request["challengeShortCode"] = challengeShortCode;
    request["currency1Wager"] = currency1Wager;
    request["currency2Wager"] = currency2Wager;
    request["currency3Wager"] = currency3Wager;
    request["currency4Wager"] = currency4Wager;
    request["currency5Wager"] = currency5Wager;
    request["currency6Wager"] = currency6Wager;
    request["endTime"] = endTime;
    request["expiryTime"] = expiryTime;
    request["maxAttempts"] = maxAttempts;
    request["maxPlayers"] = maxPlayers;
    request["minPlayers"] = minPlayers;
    request["silent"] = silent;
    request["startTime"] = startTime;
    request["usersToChallenge"] = usersToChallenge;
    gamesparks.sendWithData("CreateChallengeRequest", request, onResponse);
}
GameSparks.prototype.declineChallengeRequest = function(challengeInstanceId, message, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["message"] = message;
    gamesparks.sendWithData("DeclineChallengeRequest", request, onResponse);
}
GameSparks.prototype.deviceAuthenticationRequest = function(deviceId, deviceModel, deviceName, deviceOS, deviceType, operatingSystem, onResponse )
{
    var request = {};
    request["deviceId"] = deviceId;
    request["deviceModel"] = deviceModel;
    request["deviceName"] = deviceName;
    request["deviceOS"] = deviceOS;
    request["deviceType"] = deviceType;
    request["operatingSystem"] = operatingSystem;
    gamesparks.sendWithData("DeviceAuthenticationRequest", request, onResponse);
}
GameSparks.prototype.dismissMessageRequest = function(messageId, onResponse )
{
    var request = {};
    request["messageId"] = messageId;
    gamesparks.sendWithData("DismissMessageRequest", request, onResponse);
}
GameSparks.prototype.endSessionRequest = function(onResponse )
{
    var request = {};
    gamesparks.sendWithData("EndSessionRequest", request, onResponse);
}
GameSparks.prototype.facebookConnectRequest = function(accessToken, code, onResponse )
{
    var request = {};
    request["accessToken"] = accessToken;
    request["code"] = code;
    gamesparks.sendWithData("FacebookConnectRequest", request, onResponse);
}
GameSparks.prototype.findChallengeRequest = function(accessType, count, offset, onResponse )
{
    var request = {};
    request["accessType"] = accessType;
    request["count"] = count;
    request["offset"] = offset;
    gamesparks.sendWithData("FindChallengeRequest", request, onResponse);
}
GameSparks.prototype.getChallengeRequest = function(challengeInstanceId, message, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["message"] = message;
    gamesparks.sendWithData("GetChallengeRequest", request, onResponse);
}
GameSparks.prototype.getDownloadableRequest = function(shortCode, onResponse )
{
    var request = {};
    request["shortCode"] = shortCode;
    gamesparks.sendWithData("GetDownloadableRequest", request, onResponse);
}
GameSparks.prototype.getMessageRequest = function(messageId, onResponse )
{
    var request = {};
    request["messageId"] = messageId;
    gamesparks.sendWithData("GetMessageRequest", request, onResponse);
}
GameSparks.prototype.getRunningTotalsRequest = function(friendIds, shortCode, onResponse )
{
    var request = {};
    request["friendIds"] = friendIds;
    request["shortCode"] = shortCode;
    gamesparks.sendWithData("GetRunningTotalsRequest", request, onResponse);
}
GameSparks.prototype.getUploadUrlRequest = function(uploadData, onResponse )
{
    var request = {};
    request["uploadData"] = uploadData;
    gamesparks.sendWithData("GetUploadUrlRequest", request, onResponse);
}
GameSparks.prototype.getUploadedRequest = function(uploadId, onResponse )
{
    var request = {};
    request["uploadId"] = uploadId;
    gamesparks.sendWithData("GetUploadedRequest", request, onResponse);
}
GameSparks.prototype.googlePlayBuyGoodsRequest = function(currencyCode, signature, signedData, subUnitPrice, onResponse )
{
    var request = {};
    request["currencyCode"] = currencyCode;
    request["signature"] = signature;
    request["signedData"] = signedData;
    request["subUnitPrice"] = subUnitPrice;
    gamesparks.sendWithData("GooglePlayBuyGoodsRequest", request, onResponse);
}
GameSparks.prototype.iOSBuyGoodsRequest = function(currencyCode, receipt, sandbox, subUnitPrice, onResponse )
{
    var request = {};
    request["currencyCode"] = currencyCode;
    request["receipt"] = receipt;
    request["sandbox"] = sandbox;
    request["subUnitPrice"] = subUnitPrice;
    gamesparks.sendWithData("IOSBuyGoodsRequest", request, onResponse);
}
GameSparks.prototype.joinChallengeRequest = function(challengeInstanceId, message, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["message"] = message;
    gamesparks.sendWithData("JoinChallengeRequest", request, onResponse);
}
GameSparks.prototype.leaderboardDataRequest = function(challengeInstanceId, entryCount, friendIds, leaderboardShortCode, offset, social, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["entryCount"] = entryCount;
    request["friendIds"] = friendIds;
    request["leaderboardShortCode"] = leaderboardShortCode;
    request["offset"] = offset;
    request["social"] = social;
    gamesparks.sendWithData("LeaderboardDataRequest", request, onResponse);
}
GameSparks.prototype.listAchievementsRequest = function(onResponse )
{
    var request = {};
    gamesparks.sendWithData("ListAchievementsRequest", request, onResponse);
}
GameSparks.prototype.listChallengeRequest = function(entryCount, offset, shortCode, state, onResponse )
{
    var request = {};
    request["entryCount"] = entryCount;
    request["offset"] = offset;
    request["shortCode"] = shortCode;
    request["state"] = state;
    gamesparks.sendWithData("ListChallengeRequest", request, onResponse);
}
GameSparks.prototype.listChallengeTypeRequest = function(onResponse )
{
    var request = {};
    gamesparks.sendWithData("ListChallengeTypeRequest", request, onResponse);
}
GameSparks.prototype.listGameFriendsRequest = function(onResponse )
{
    var request = {};
    gamesparks.sendWithData("ListGameFriendsRequest", request, onResponse);
}
GameSparks.prototype.listInviteFriendsRequest = function(onResponse )
{
    var request = {};
    gamesparks.sendWithData("ListInviteFriendsRequest", request, onResponse);
}
GameSparks.prototype.listLeaderboardsRequest = function(onResponse )
{
    var request = {};
    gamesparks.sendWithData("ListLeaderboardsRequest", request, onResponse);
}
GameSparks.prototype.listMessageRequest = function(entryCount, offset, onResponse )
{
    var request = {};
    request["entryCount"] = entryCount;
    request["offset"] = offset;
    gamesparks.sendWithData("ListMessageRequest", request, onResponse);
}
GameSparks.prototype.listMessageSummaryRequest = function(entryCount, offset, onResponse )
{
    var request = {};
    request["entryCount"] = entryCount;
    request["offset"] = offset;
    gamesparks.sendWithData("ListMessageSummaryRequest", request, onResponse);
}
GameSparks.prototype.listVirtualGoodsRequest = function(onResponse )
{
    var request = {};
    gamesparks.sendWithData("ListVirtualGoodsRequest", request, onResponse);
}
GameSparks.prototype.logChallengeEventRequest = function(challengeInstanceId, eventKey, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["eventKey"] = eventKey;
    gamesparks.sendWithData("LogChallengeEventRequest", request, onResponse);
}
GameSparks.prototype.logEventRequest = function(eventKey, onResponse )
{
    var request = {};
    request["eventKey"] = eventKey;
    gamesparks.sendWithData("LogEventRequest", request, onResponse);
}
GameSparks.prototype.pushRegistrationRequest = function(deviceOS, pushId, onResponse )
{
    var request = {};
    request["deviceOS"] = deviceOS;
    request["pushId"] = pushId;
    gamesparks.sendWithData("PushRegistrationRequest", request, onResponse);
}
GameSparks.prototype.registrationRequest = function(displayName, password, userName, onResponse )
{
    var request = {};
    request["displayName"] = displayName;
    request["password"] = password;
    request["userName"] = userName;
    gamesparks.sendWithData("RegistrationRequest", request, onResponse);
}
GameSparks.prototype.sendFriendMessageRequest = function(friendIds, message, onResponse )
{
    var request = {};
    request["friendIds"] = friendIds;
    request["message"] = message;
    gamesparks.sendWithData("SendFriendMessageRequest", request, onResponse);
}
GameSparks.prototype.socialLeaderboardDataRequest = function(challengeInstanceId, entryCount, friendIds, leaderboardShortCode, offset, social, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["entryCount"] = entryCount;
    request["friendIds"] = friendIds;
    request["leaderboardShortCode"] = leaderboardShortCode;
    request["offset"] = offset;
    request["social"] = social;
    gamesparks.sendWithData("SocialLeaderboardDataRequest", request, onResponse);
}
GameSparks.prototype.twitterConnectRequest = function(accessSecret, accessToken, onResponse )
{
    var request = {};
    request["accessSecret"] = accessSecret;
    request["accessToken"] = accessToken;
    gamesparks.sendWithData("TwitterConnectRequest", request, onResponse);
}
GameSparks.prototype.windowsBuyGoodsRequest = function(currencyCode, receipt, subUnitPrice, onResponse )
{
    var request = {};
    request["currencyCode"] = currencyCode;
    request["receipt"] = receipt;
    request["subUnitPrice"] = subUnitPrice;
    gamesparks.sendWithData("WindowsBuyGoodsRequest", request, onResponse);
}
GameSparks.prototype.withdrawChallengeRequest = function(challengeInstanceId, message, onResponse )
{
    var request = {};
    request["challengeInstanceId"] = challengeInstanceId;
    request["message"] = message;
    gamesparks.sendWithData("WithdrawChallengeRequest", request, onResponse);
}

//******************************************************
//*****    Global Initialization
//******************************************************

    var mainCanvasId = "canvasBackground";
    var mainCanvas = document.getElementById(mainCanvasId);

    var testMode = false;

    var builderVersion = "2.0.0.0";    // Version of the builder when building the solution
    var buildDate = "02-02-2022";    // Date when building the solution
    var buildTime = "14:40:55";    // Time when building the solution
    var buildTags = ["flow_standard", "env_dev", "ui", "flow_temp", "flow_bs", "portrait", "facebookInstant4", "final", "framework4", "cheats"];    // Tags used in this build

//******************************************************
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//*****    The Basic Engine
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//******************************************************

/////////////////////////////////////////////////////////////
// tbBrowser: Browser detection functionality
//
// Copyright 2013-2014 CoolGames
// Last Changed: 18-11-2014
/////////////////////////////////////////////////////////////

var TBBrowser = function(userAgent) {
	"use strict";

	this.userAgent = userAgent;
	if (this.userAgent === undefined) {
		this.userAgent = (navigator !== undefined) ? navigator.userAgent : '';
	}
	this.detect();
};

TBBrowser.prototype.getFirstMatch = function(regex) {
	"use strict";
	var match = this.userAgent.match(regex);
	return (match && match.length > 1 && match[1]) || '';
};

TBBrowser.prototype.detect = function() {
	"use strict";
	var iosdevice = this.getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(),
		likeAndroid = /like android/i.test(this.userAgent),
		android = !likeAndroid && /android/i.test(this.userAgent),
		versionIdentifier = this.getFirstMatch(/version\/(\d+(\.\d+)?)/i),
		tablet = /tablet/i.test(this.userAgent),
		mobile = !tablet && /[^-]mobi/i.test(this.userAgent);

	this.browser = {};
	this.os = {};
	this.features = {};

	//Opera
	if (/opera|opr/i.test(this.userAgent)) {
		this.name = 'Opera';
		this.browser.opera = true;
		this.browser.version = versionIdentifier || this.getFirstMatch(/(?:opera|opr)[\s\/](\d+(\.\d+)?)/i);
	}
	//Windows Phone
	else if (/windows phone/i.test(this.userAgent)) {
		this.name = 'Windows Phone';
		this.os.windowsphone = true;
		this.browser.msie = true;
		this.browser.version = this.getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
	}
	//Internet Explorer
	else if (/msie|trident/i.test(this.userAgent)) {
		this.name = 'Internet Explorer';
		this.browser.msie = true;
		this.browser.version = this.getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i);
	}
	//Chrome
	else if (/chrome|crios|crmo/i.test(this.userAgent)) {
		this.name = 'Chrome';
		this.browser.chrome = true;
		this.browser.version = this.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i);
	}
	//iOS
	else if (iosdevice) {
		this.name = iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod';
		if (versionIdentifier) {
			this.browser.version = versionIdentifier;
		}
	}
	//Sailfish
	else if (/sailfish/i.test(this.userAgent)) {
		this.name = 'Sailfish';
		this.browser.sailfish = true;
		this.browser.version = this.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i);
	}
	//SeaMonkey
	else if (/seamonkey\//i.test(this.userAgent)) {
		this.name = 'SeaMonkey';
		this.browser.seamonkey = true;
		this.browser.version = this.getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i);
	}
	//Firefox
	else if (/firefox|iceweasel/i.test(this.userAgent)) {
		this.name = 'Firefox';
		this.browser.firefox = true;
		this.browser.version = this.getFirstMatch(/(?:firefox|iceweasel)[ \/](\d+(\.\d+)?)/i);
		if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(this.userAgent)) {
			this.os.firefoxos = true;
		}
	}
	//Amazon Silk
	else if (/silk/i.test(this.userAgent)) {
		this.name = 'Amazon Silk';
		this.browser.silk = true;
		this.browser.version = this.getFirstMatch(/silk\/(\d+(\.\d+)?)/i);
	}
	//Android
	else if (android) {
		this.name = 'Android';
		this.browser.stockandroid = true;
		this.browser.version = versionIdentifier;
	}
	//PhantomJS
	else if (/phantom/i.test(this.userAgent)) {
		this.name = 'PhantomJS';
		this.browser.phantom = true;
		this.browser.version = this.getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i);
	}
	//BlackBerry
	else if (/blackberry|\bbb\d+/i.test(this.userAgent) || /rim\stablet/i.test(this.userAgent)) {
		this.name = 'BlackBerry';
		this.browser.blackberry = true;
		this.browser.version = versionIdentifier || this.getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i);
	}
	//WebOS
	else if (/(web|hpw)os/i.test(this.userAgent)) {
		this.name = 'WebOS';
		this.browser.webos = true;
		this.browser.version = versionIdentifier || this.getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i);
		if (/touchpad\//i.test(this.userAgent)) {
			this.features.touchpad = true;
		}
	}
	//Bada
	else if (/bada/i.test(this.userAgent)) {
		this.name = 'Bada';
		this.browser.bada = true;
		this.browser.version = this.getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i);
	}
	//Tizen
	else if (/tizen/i.test(this.userAgent)) {
		this.name = 'Tizen';
		this.browser.tizen = true;
		this.browser.version = this.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier;
	}
	//Safari
	else if (/safari/i.test(this.userAgent)) {
		this.name = 'Safari';
		this.browser.safari = true;
		this.browser.version = versionIdentifier;
	}
	//Unknown!
	else {
		// Do nothing
	}

	//Set webkit or gecko flag for browsers based on these engines
	if (/(apple)?webkit/i.test(this.userAgent)) {
		this.name = this.name || "Webkit";
		this.browser.webkit = true;
		if (!this.browser.version && versionIdentifier) {
			this.browser.version = versionIdentifier;
		}
	}
	else if (!this.opera && /gecko\//i.test(this.userAgent)) {
		this.name = this.name || "Gecko";
		this.browser.gecko = true;
		this.browser.version = this.browser.version || this.getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
	}

	//Set OS flags for platforms that have multiple browsers
	if (android || this.silk) {
		this.os.android = true;
	}
	else if (iosdevice) {
		this.os.ios = true;
	}

	//OS version extraction
	var osVersion = '';
	if (iosdevice) {
		osVersion = this.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
		osVersion = osVersion.replace(/[_\s]/g, '.');
	}
	else if (android) {
		osVersion = this.getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
	}
	else if (this.windowsphone) {
		osVersion = this.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
	}
	else if (this.webos) {
		osVersion = this.getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
	}
	else if (this.blackberry) {
		osVersion = this.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
	}
	else if (this.bada) {
		osVersion = this.getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
	}
	else if (this.tizen) {
		osVersion = this.getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
	}

	if (osVersion) {
		this.os.version = osVersion;
	}

	//Device type extraction
	var osMajorVersion = osVersion.split('.')[0];
	if (tablet || iosdevice == 'ipad' || (android && (osMajorVersion == 3 || (osMajorVersion == 4 && !mobile))) || this.silk) {
		this.features.tablet = true;
	}
	else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || this.blackberry || this.webos || this.bada) {
		this.features.mobile = true;
	}

	// Graded Browser Support
	// http://developer.yahoo.com/yui/articles/gbs
	this.grade = {a: false, c: false, x: false};
	if ((this.msie && this.browser.version >= 10) ||
		(this.chrome && this.browser.version >= 20) ||
		(this.firefox && this.browser.version >= 20.0) ||
		(this.safari && this.browser.version >= 6) ||
		(this.opera && this.browser.version >= 10.0) ||
		(this.ios && this.os.version && this.os.version.split(".")[0] >= 6)) {
		this.grade.a = true;
	}
	else if ((this.msie && this.browser.version < 10) ||
		(this.chrome && this.browser.version < 20) ||
		(this.firefox && this.browser.version < 20.0) ||
		(this.safari && this.browser.version < 6) ||
		(this.opera && this.browser.version < 10.0) ||
		(this.ios && this.os.version && this.os.version.split(".")[0] < 6) ) {
		this.grade.c = true;
	}
	else {
		this.grade.x = true;
	}

	try {
		this.browser.versionAsNumber = this.browser.version ? parseFloat(this.browser.version.match(/\d+(\.\d+)?/)[0], 10) : 0;
	}
	catch (e) {
		this.browser.versionAsNumber = 0;
	}

	try {
		this.os.versionAsNumber = this.os.version ? parseFloat(this.os.version.match(/\d+(\.\d+)?/)[0], 10) : 0;
	}
	catch (e) {
		this.os.versionAsNumber = 0;
	}

};
var tbBrowser = new TBBrowser();

/////////////////////////////////////////////////////////////
// tbMath: The engine part dealing mathematical calculations
//		It contains classes dealing with vectors, bounding boxes
//		random number, etc.
//
// Copyright 2013-2015 CoolGames
// Last Changed: 08-06-2015
/////////////////////////////////////////////////////////////

//
// The math class tbMath that extends the Math class with other useful methods
//

var TBMath = function() {
	"use strict";
};

TBMath.prototype.degToRad = function(degrees) {
	"use strict";
	return Math.PI * degrees/180;
};

TBMath.prototype.radToDeg = function(rad) {
	"use strict";
	return 180*rad/Math.PI;
};

TBMath.prototype.distance = function(x1, y1, x2, y2) {
	"use strict";
	return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
};

TBMath.prototype.direction = function(x1, y1, x2, y2) {
	"use strict";
	var xx = x2-x1, yy = y2-y1;
	return tbMath.radToDeg(Math.atan2(-yy, xx));
};

TBMath.prototype.projectionX = function(direction, length) {
	"use strict";
	return length * Math.cos(tbMath.degToRad(direction));
};

TBMath.prototype.projectionY = function(direction, length) {
	"use strict";
	return - length * Math.sin(tbMath.degToRad(direction));
};

var tbMath = new TBMath();


//
// The vector class tbVector
//

var tbVector = function(x,y) {
	"use strict";
	this.x = x;
	this.y = y;
};

function tbVectorFromPolar(direction, length) {
	"use strict";
	var x = length * Math.cos(tbMath.degToRad(direction)),
		y = - length * Math.sin(tbMath.degToRad(direction));
	return new tbVector(x,y);
}

tbVector.prototype.assignVector = function(v) {
	"use strict";
	this.x = v.x;
	this.y = v.y;
};

tbVector.prototype.assignXY = function(x, y) {
	"use strict";
	this.x = x;
	this.y = y;
};

tbVector.prototype.assign = function(vector_or_x, undefined_or_y) {
	"use strict";
	if (undefined_or_y === undefined) {
		this.x = vector_or_x.x;
		this.y = vector_or_x.y;
	}
	else {
		this.x = vector_or_x;
		this.y = undefined_or_y;
	}
};

tbVector.prototype.magnitude = function() {
	"use strict";
	return Math.sqrt(this.x*this.x + this.y*this.y);
};

tbVector.prototype.length = function() {
	"use strict";
	return Math.sqrt(this.x*this.x + this.y*this.y);
};

tbVector.prototype.lengthSquared = function() {
	"use strict";
	return this.x*this.x + this.y*this.y;
};

tbVector.prototype.distanceSquared = function(other) {
	"use strict";
	var dx = (this.x - other.x),
		dy = (this.y - other.y);
	return dx * dx + dy * dy;
};

tbVector.prototype.distance = function(other) {
	"use strict";
	var dx = (this.x - other.x),
		dy = (this.y - other.y);
	return Math.sqrt(dx * dx + dy * dy);
};

tbVector.prototype.distanceSquaredXY = function(x, y) {
	"use strict";
	var dx = (this.x - x),
		dy = (this.y - y);
	return dx * dx + dy * dy;
};

tbVector.prototype.distanceXY = function(x, y) {
	"use strict";
	var dx = (this.x - x),
		dy = (this.y - y);
	return Math.sqrt(dx * dx + dy * dy);
};

tbVector.prototype.direction = function() {
	"use strict";
	return tbMath.radToDeg(Math.atan2(-this.y, this.x));
};

tbVector.prototype.clone = function() {
	"use strict";
	return new tbVector(this.x, this.y);
};

tbVector.prototype.add = function(vector) {
	"use strict";
	return new tbVector(this.x + vector.x, this.y + vector.y);
};

tbVector.prototype.addDirect = function(vector) {
	"use strict";
	this.x += vector.x;
	this.y += vector.y;
};

tbVector.prototype.subtract = function(vector) {
	"use strict";
	return new tbVector(this.x - vector.x, this.y - vector.y);
};

tbVector.prototype.subtractDirect = function(vector) {
	"use strict";
	this.x -= vector.x;
	this.y -= vector.y;
};

tbVector.prototype.negate = function() {
	"use strict";
	return new tbVector(-this.x, -this.y);
};

tbVector.prototype.negateDirect = function() {
	"use strict";
	this.x = -this.x;
	this.y = -this.y;
};

tbVector.prototype.scale = function(scalar) {
	"use strict";
	return new tbVector(scalar * this.x, scalar * this.y);
};

tbVector.prototype.scaleDirect = function(scalar) {
	"use strict";
	this.x *= scalar;
	this.y *= scalar;
};

tbVector.prototype.multiply = function(vector) {
	"use strict";
	return new tbVector(vector.x * this.x, vector.y * this.y);
};

tbVector.prototype.multiplyDirect = function(vector) {
	"use strict";
	this.x *= vector.x;
	this.y *= vector.y;
};

tbVector.prototype.rotate = function(angle) {
	"use strict";
	var s = Math.sin(angle*Math.PI/180),
		c = Math.cos(angle*Math.PI/180);
	return new tbVector(c * this.x + s * this.y, -s * this.x + c * this.y);
};

tbVector.prototype.rotateDirect = function(angle) {
	"use strict";
	var s = Math.sin(angle*Math.PI/180),
		c = Math.cos(angle*Math.PI/180),
		x = this.x;
	this.x = c * this.x + s * this.y;
	this.y = -s * x + c * this.y;
};

tbVector.prototype.dot = function(vector) {
	"use strict";
	return (this.x * vector.x + this.y * vector.y);
};

tbVector.prototype.perpendicular = function() {
	"use strict";
	return new tbVector(this.y, -this.x);
};

tbVector.prototype.perpendicularDirect = function() {
	"use strict";
	var x = this.x;
	this.x = this.y;
	this.y = -x;
};

tbVector.prototype.normalize = function() {
	"use strict";
	var m = this.magnitude();
	if (m === 0) {
		return new tbVector(0, 0);
	}
	return new tbVector(this.x / m, this.y / m);
};

tbVector.prototype.normalizeDirect = function() {
	"use strict";
	var m = this.magnitude();
	if (m === 0) {
		this.x = 0; this.y = 0;
		return;
	}
	this.x /= m;
	this.y /= m;
};

tbVector.prototype.normal = function() {
	"use strict";
	return (this.perpendicular()).normalize();
};

tbVector.prototype.normalDirect = function() {
	"use strict";
	this.perpendicularDirect();
	this.normalizeDirect();
};

tbVector.prototype.draw = function(x, y, color) {
	"use strict";
	var sc = Math.min(8,this.length()/4),
		vec1 = this.subtract(this.normalize().scale(2*sc)),
		vec2 = vec1.add(this.normal().scale(sc)),
		vec3 = vec1.add(this.normal().scale(-sc)),
		context = tbGraphics.context;
	context.strokeStyle = color;
	context.beginPath();
	context.moveTo(x, y);
	context.lineTo(x + vec1.x, y + vec1.y);
	context.lineTo(x + vec2.x, y + vec2.y);
	context.lineTo(x + this.x, y + this.y);
	context.lineTo(x + vec3.x, y + vec3.y);
	context.lineTo(x + vec1.x, y + vec1.y);
	context.stroke();
};


//
// A random number generator class
// Uses a linear congruential generator using GCC's constants
//

var useOldRandomNumberConstants = false;

// The constructor
var tbRandom = function(seed) {
	"use strict";
	if (useOldRandomNumberConstants) {
		// This version does not work correctly because JavaScript does not support 64-bit integers
		this.m = 0x80000000;		// 2**31;
		this.a = 1103515245;
		this.c = 12345;
	} else {
		this.m = 4294967296;		// 2**32;
		this.a = 1664525;
		this.c = 1013904223;
	}
	if (seed === undefined) {
		this.state = Math.floor(Math.random() * (this.m-1));
	} else {
		this.state = seed;
	}
};

// returns integer in range [0,2^31> (but with weak randomness in lower bits). Don't use directly
tbRandom.prototype._next = function() {
	"use strict";
	this.state = (this.a * this.state + this.c) % this.m;
	return this.state;
};

// returns a clone of the object
tbRandom.prototype.clone = function() {
	"use strict";
	var res = new tbRandom();
	res.m = this.m;
	res.a = this.a;
	res.c = this.c;
	res.state = this.state;
	return res;
};

// returns real in range [0,n>
tbRandom.prototype.random = function(n) {
	"use strict";
	var nn = 1;
	if (n !== undefined) { nn = n; }
	return nn*(this._next() / this.m);
};

// returns integer in range [0,n]
tbRandom.prototype.iRandom = function(n) {
	"use strict";
	var nn = 1;
	if (n !== undefined) { nn = n; }
	return Math.floor(this.random(nn+1));
};

// returns real in range [n1,n2>
tbRandom.prototype.randomRange = function(n1,n2) {
	"use strict";
	return n1 + this.random(n2-n1);
};

// returns integer in range [n1,n2]
tbRandom.prototype.iRandomRange = function(n1,n2) {
	"use strict";
	return n1 + this.iRandom(n2-n1);
};

// Returns randomly one of the arguments
tbRandom.prototype.choice = function() {
	"use strict";
	if (arguments.length === 0) { return 0; }
	return arguments[this.iRandomRange(0, arguments.length-1)];
};

// We define one global random number generator
var defaultRandom = new tbRandom();
/////////////////////////////////////////////////////////////
// tbPlatforms: Contains objects for device detection and
//              platform specific options
//
// Copyright 2013-2014 CoolGames
// Last Changed: 16-7-2014
/////////////////////////////////////////////////////////////


var tbPlatforms = {

	// Enable or disable platform specific hacks
	// TODO: default is true, but it should be based on detected device
	Hacks: {
		// On our Android 4.1 Sony test device, the context is not properly reset each frame
		// therefore, we add a hack to the tbGraphics.clear function by drawing an invisible
		// line
		ANDROID_41_CONTEXT_RESET_BUG: true,

		// If we use Cordova to build an app on iOS, the game becomes slow if images are loaded
		// that are not used. This hack enabled immediate use of an image after it is loaded
		DRAW_IMAGE_AFTER_LOADING: false
	}
};/////////////////////////////////////////////////////////////
// tbLoader: The engine part dealing with loading
//
// Copyright 2013-2015 CoolGames
// Last Changed: 9-6-2015
/////////////////////////////////////////////////////////////

// The constructor for the loader object
var TBLoader = function() {
	"use strict";
	this._location = "";				// Location of the data files
	this._loading = [];					// Whether this moment is being loaded or has been loaded before
	this._total = [];					// Total number of items to be loaded for each moment
	this._loaded  = [];					// Number of items that are loaded for each moment
	this._failed = [];					// Number of items that failed for each moment
	this._items = [];					// The items to be loaded for each moment
	this.addMoment("start");
	this.addMoment("load");
	this.addMoment("game");
};

// Set the data location
TBLoader.prototype.setDataLocation = function(location) { 
	"use strict";
	this._location = location;
	if (this._location !== "" && this._location[this._location.length-1] !== "/") {
		this._location += "/";
	}
};

// Get the data location
TBLoader.prototype.getDataLocation = function() { 
	"use strict";
	return this._location;
};

// Initialize a moment
TBLoader.prototype.addMoment = function(moment) { 
	"use strict";
	if (this._items[moment]) { return; }			// It already exists
	this._total[moment] = 0;
	this._loaded[moment] = 0;
	this._failed[moment] = 0;
	this._items[moment] = [];
	this._loading[moment] = false;
};

TBLoader.prototype.exist = function(moment) {
    "use strict";
    if (this._items[moment] && this._items[moment].length > 0) {
    	return true;
    }
    return false;
};

// Return total number of items to load for the moment
TBLoader.prototype.total = function(moment) { 
	"use strict";
	if (!this._items[moment]) { return 0; }
	return this._total[moment];
};

// Return number of loaded items for the moment
TBLoader.prototype.loaded = function(moment) { 
	"use strict";
	if (!this._items[moment]) { return 0; }
	return this._loaded[moment];
};

// Return number of failed items for the moment
TBLoader.prototype.failed = function(moment) { 
	"use strict";
	if (!this._items[moment]) { return 0; }
	return this._failed[moment];
};

// Return whether all items are loaded for the moment
TBLoader.prototype.complete = function(moment) { 
	"use strict";
	if (!this._items[moment]) { return true; }
	return (this._loaded[moment] + this._failed[moment] === this._total[moment]);
};

// Return percentage of items that are loaded for the moment
TBLoader.prototype.percentage = function(moment) { 
	"use strict";
	if (!this._items[moment] || this._total[moment] === 0) { return 100; }
	return (100*(this._loaded[moment] + this._failed[moment]) / this._total[moment]);
};

// Report that a resource is correctly loaded
TBLoader.prototype.loadComplete = function(moment) {
	"use strict";
	this._loaded[moment] += 1;
	if (this.complete(moment)) {
		tbGame.addSpecial("Load Complete", { moment: moment} ); 
	}
};

// Report that a resource failed to load
TBLoader.prototype.loadFailed = function(moment) {
	"use strict";
	this._failed[moment] += 1;
	tbGame.addSpecial("Load Failed", { moment: moment} ); 
};

// Add a resource to be loaded, number indicated the number of subresources
TBLoader.prototype.addResource = function(resource, moment, number) {
	"use strict";
	if (!this._items[moment]) {
		this.addMoment(moment);
	}
	this._items[moment].push(resource);
	this._total[moment] += number;
};

//check if textures are loaded for spine
TBLoader.prototype.checkSpineLoad = function(){
	if(!this._items["spine"]){
		return;
	}

    for (i =0 ; i < this._items["spine"].length; i += 1) {
        if(this._items["spine"][i].checkTexture()){
            this._items["spine"][i].startLoading();
		};
    }
};

// start the actual loading for the moment
TBLoader.prototype.startLoading = function(moment) {
	"use strict";
	var i;
	// Check whether it is or has already been loaded
	if (this._loading[moment]) { return; }
	this._loading[moment] = true;
	// If nothing to load, generate event and return
	if (!this._items[moment] || this._items[moment].length === 0) {
		tbGame.addSpecial("Load Complete", { moment: moment} );
		return;
	}
	// Start loading the items
	for (i =0 ; i < this._items[moment].length; i += 1) {
		this._items[moment][i].startLoading(moment, this._location);
	}
};
	
// Create the loader
var tbLoader = new TBLoader();
/////////////////////////////////////////////////////////////
// tbGraphics: The engine part dealing with graphics
//
// Copyright 2013-2015 CoolGames
// Last Changed: 28-06-2015
/////////////////////////////////////////////////////////////

//
// GRAPHICS
//

// The constructor for the graphics object
var TBGraphics = function(mainCanvas) {
	"use strict";
	this.canvas = undefined;					// The current draw canvas
	this.fontCanvas = undefined;
	this.context = undefined;					// The current drawing context
	this.fontContext = undefined;
	this.width = 0;								// The width of the current canvas
	this.height = 0;							// The height of the current canvas
	this.canvasCollection = [];
	this.gl = null;
	this.webGLAvailable = false;				// Availability of WebGL

	//PIXI Container
	this.mainContainer = new PIXI["Container"]();
};

// Set the current canvas by id
TBGraphics.prototype.setCanvasId = function(id) {
	"use strict";
	this.canvas = document.getElementById(id);
	this.setCanvas(this.canvas);
};

// Set the current canvas
TBGraphics.prototype.setCanvas = function(canvas, is2D) {
    "use strict";

    if (this.webGLAvailable) {
        this.canvas = canvas;
        this.context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        this.fontContext = this.fontCanvas.getContext("2d");
        this.width = canvas.width;
        this.height = canvas.height;
    } else {
        this.canvas = canvas;
        this.context = canvas.getContext("2d");
        this.fontContext = this.context;
        this.width = canvas.width;
        this.height = canvas.height;
    }
};
// Clear the current canvas to transparent
TBGraphics.prototype.clear = function() {
	"use strict";

	if(this.webGLAvailable) {
		// Clear the color as well as the depth buffer.
		//this.context.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
		//if(this.fontContext.clearRect){
		//	this.fontContext.clearRect(0, 0, this.width, this.height);
		//}
	} else {
		this.context.clearRect(0, 0, this.width, this.height);
		// On Android 4.1 do a hack to force clearing
		if (tbPlatforms.Hacks.ANDROID_41_CONTEXT_RESET_BUG) {
			this.context.beginPath();
			this.context.moveTo(0, 0);
			this.context.lineTo(-1, -1);
			this.context.closePath();
			this.context.stroke();
		}
	}
};

// Clear the current canvas to the indicated color
TBGraphics.prototype.clearColor = function(color) {
	"use strict";
	if(this.webGLAvailable){

	} else {
		var oldColor = this.context.fillStyle;
		this.context.fillStyle = color;
		this.context.fillRect(0, 0, this.width, this.height);
		this.context.fillStyle = oldColor;
	}
};

// Draw a rectangle
TBGraphics.prototype.drawRectangle = function(x, y, w, h, fillColor, strokeColor, lineThickness, alpha) {
	"use strict";
    var rectangle = new PIXI["Graphics"]();

    if(fillColor){
        rectangle["beginFill"](fillColor);
    }

    if(strokeColor){
        lineThickness = lineThickness ? lineThickness : 1;
        rectangle["lineStyle"](lineThickness, strokeColor, 1);
    }

    rectangle["drawRect"](0, 0, w, h);

    rectangle["endFill"]();

    rectangle["x"] = x ? x : 0;

    rectangle["y"] = y ? y : 0;

    rectangle["alpha"] = alpha ? alpha : 1;

    return rectangle;
};

// Draw a rounded rectangle
TBGraphics.prototype.drawRoundedRectangle = function(x, y, w, h, r, fillColor, strokeColor, lineThickness, alpha) {
	"use strict";
    var roundedRectangle = new PIXI["Graphics"]();

    if(fillColor){
        roundedRectangle["beginFill"](fillColor);
    }

    if(strokeColor){
    	lineThickness = lineThickness ? lineThickness : 1;
        roundedRectangle["lineStyle"](lineThickness, strokeColor, 1);
    }

    roundedRectangle["drawRoundedRect"](0, 0, w, h, r);

    roundedRectangle["endFill"]();

    roundedRectangle["x"] = x ? x : 0;

    roundedRectangle["y"] = y ? y : 0;

    roundedRectangle["alpha"] = alpha ? alpha : 1;

    return roundedRectangle;
};

// Draw a disk
TBGraphics.prototype.drawDisk = function(x, y, r, fillColor, strokeColor, lineThickness) {
	"use strict";
    var circle = new PIXI["Graphics"]();

    if(fillColor){
        circle["beginFill"](fillColor);
    }

    if(strokeColor){
        lineThickness = lineThickness ? lineThickness : 1;
        circle["lineStyle"](lineThickness, strokeColor, 1);
    }

    circle["drawCircle"](0, 0, r);

    circle["endFill"]();

    circle["x"] = x ? x : 0;

    circle["y"] = y ? y : 0;

    return circle;
};

// Draw an ellipse
TBGraphics.prototype.drawEllipse = function(x, y, rx, ry, fillColor, strokeColor, lineThickness) {
	"use strict";
    var ellipse = new PIXI["Graphics"]();

    if(fillColor){
        ellipse["beginFill"](fillColor);
    }

    if(strokeColor){
        lineThickness = lineThickness ? lineThickness : 1;
        ellipse["lineStyle"](lineThickness, strokeColor, 1);
    }

    ellipse["drawEllipse"](0, 0, rx, ry);

    ellipse["endFill"]();

    ellipse["x"] = x ? x : 0;

    ellipse["y"] = y ? y : 0;

    return ellipse;
};

// Draw a line
TBGraphics.prototype.drawLine = function(x1, y1, x2, y2, strokeColor, lineThickness) {
	"use strict";
	var line = new PIXI["Graphics"]();

    if(strokeColor){
        lineThickness = lineThickness ? lineThickness : 1;
        line["lineStyle"](lineThickness, strokeColor, 1);
    }

    line["moveTo"](0, 0);

    line["lineTo"](x2, y2);

    line["x"] = x1;

    line["y"] = y1;

    return line;

};

// Draw a triangle
TBGraphics.prototype.drawTriangle = function(x1, y1, x2, y2, x3, y3, fillColor, strokeColor, lineThickness) {
	"use strict";
    var triangle = new PIXI["Graphics"]();

    if(fillColor){
        triangle["beginFill"](fillColor);
    }

    if(strokeColor){
        lineThickness = lineThickness ? lineThickness : 1;
        triangle["lineStyle"](lineThickness, strokeColor, 1);
    }

    triangle["moveTo"](0, 0);

    triangle["lineTo"](x2, y2);

    triangle["lineTo"](x3, y3);

    triangle["lineTo"](0, 0);

    triangle["endFill"]();

    triangle["x"] = x1;

    triangle["y"] = y1;

    return triangle;
};

// Draw a polygon
TBGraphics.prototype.drawPolygon = function(x, y, fillColor, strokeColor, width) {
	"use strict";

};

// Draw a polyline
TBGraphics.prototype.drawPolyLine = function(x, y, strokeColor, width) {
	"use strict";

};

// Draw a text
TBGraphics.prototype.drawText = function(text, x, y, fillColor, font, strokeColor, width) {
	"use strict";
};

// Return the width of a text
TBGraphics.prototype.textWidth = function(text, font) {
	"use strict";
	if(this.webGLAvailable){
		console.log("Not available in WebGL");
		return;
	}

	this.context.font = font;
	return this.context.measureText(text).width;
};

TBGraphics.prototype.toLocal = function(referenceObject, pointToTransform) {
    "use strict";

    if(referenceObject instanceof tbContainer) {
        if (referenceObject.container) {
			var pixiPoint = new PIXI["Point"](pointToTransform.x, pointToTransform.y);
        	var ret = referenceObject.container["toLocal"](pixiPoint);

        	return new tbVector(ret.x, ret.y);
        }
    } else {
        console.log("toLocal only available for Containers");
	}

};

TBGraphics.prototype.toGlobal = function(referenceObject, pointToTransform) {
    "use strict";

    if(referenceObject instanceof tbContainer) {
        if (referenceObject.container) {
            var pixiPoint = new PIXI["Point"](pointToTransform.x, pointToTransform.y);
            var ret = referenceObject.container["toGlobal"](pixiPoint);

            return new tbVector(ret.x, ret.y);
        }
    } else if(referenceObject && referenceObject["toGlobal"]) {
        var pixiPoint = new PIXI["Point"](pointToTransform.x, pointToTransform.y);
    	var ret = referenceObject["toGlobal"](pixiPoint);

		return new tbVector(ret.x, ret.y);
	} else {
            console.log("toLocal only available for Containers")
    };


};


// Create the graphics object
var tbGraphics = new TBGraphics(mainCanvas);


//
// TEXTURES
//

// The constructor for the texture
var tbTexture = function(name, number, loading) {
	"use strict";
	this.name = name;
	this.number = 1;
	this.loading = loading;
	this.didLoad = false;
	this.bitmaps = [];
	this.textures = [];
	this.filenames = [];
	this.sprite = undefined;
	tbLoader.addResource(this, this.loading, this.number);
    this.cache = PIXI["utils"]["TextureCache"];
    this.loader = new PIXI["loaders"]["Loader"]();
};

// Callback when a bitmap is correctly loaded
tbTexture.prototype._bitmapLoaded = function(moment) {
	"use strict";
	tbLoader.loadComplete(moment);
};

// Callback when a bitmap failed to load
tbTexture.prototype._bitmapFailed = function(moment) {
	"use strict";
	tbLoader.loadFailed(moment);
};

// Start the loading of the texture, location is the added location part
tbTexture.prototype.startLoading = function(moment, location) {
	"use strict";
	var self = this;

    this.loader.add(this.filenames)
			.load(function(e){
                	self.didLoad = true;
                	tbLoader.loadComplete(self.loading);
                	tbLoaderManager.createSprites(self);
			});
};

// Return whether correctly loaded
tbTexture.prototype.complete = function() {
	"use strict";
	var i;
	for (i = 0; i<this.bitmaps.length; i += 1) {
		if (!this.bitmaps[i].complete || this.bitmaps[i].width === 0) {
			return false;
		}
	}
	return true;
};

// Adds a bitmap to the texture
tbTexture.prototype.addBitmap = function(number, filename) {
	"use strict";
    // var self = this;
    this.filenames.push(filename);
};

tbTexture.prototype.loadedTexture = function(){
    "use stict";
};

// Adds an existing image to the texture
tbTexture.prototype.addImage = function(number, image) {
	"use strict";
	if (number >= 0 && number < this.number) {
		this.bitmaps[number] = image;
		this.filenames[number] = "";
	}
};

// Draws the source part of the texture at the destination
tbTexture.prototype.drawPart = function(number, sx, sy, sw, sh, dx, dy, dw, dh) {
	"use strict";
};

tbTexture.prototype._addImage = function(){
	"use strict";
};

tbTexture.prototype.textureLoaded = function(loader, resources){
	"use strict";
};

tbTexture.prototype.bindTexture = function (canvas, texture){
	"use strict";
};

tbTexture.prototype.drawWebGL = function(tex, sx, sy, sw, sh, dx, dy, dw, dh){
	"use strict";
};

tbTexture.prototype.makeIdentity = function () {
    "use strict";
};

tbTexture.prototype.make2DProjection = function(width, height, depth) {
    "use strict";
	// Note: This matrix flips the Y axis so 0 is at the top.
};

tbTexture.prototype.makeTranslation = function (tx, ty, tz) {
    "use strict";
};

tbTexture.prototype.makeXRotation = function (angleInRadians) {
    "use strict";
};

tbTexture.prototype.makeYRotation = function (angleInRadians) {
    "use strict";
};

tbTexture.prototype.makeZRotation = function (angleInRadians) {
    "use strict";
};

tbTexture.prototype.makeScale = function (sx, sy, sz) {
    "use strict";
};

tbTexture.prototype.matrixMultiply = function(a, b) {
    "use strict";
};



//
// IMAGES
//

// The constructor for the image
var tbImage = function(texture, subImageAmount, parent, pivot){//name, texture, number, width, height, xOrigin, yOrigin, combinedWidth, combinedHeight, perRow) {
	"use strict";
	this.name = "";
	this.subImages = parent ? parent.subImages : [];
	this.texture = texture ? texture : parent.texture;
	this.subImageAmount = subImageAmount ? subImageAmount : parent.subImageAmount;
	this.resources = PIXI["loader"]["resources"];
    this.cache = PIXI["utils"]["TextureCache"];
	this.sprite = undefined;
	this.sprites = [];
	this.animation = undefined;
	this.frames = [];
	this.rect = undefined;
	this.tex = undefined;
	this.added = false;
	this.x = 0;
	this.y = 0;
    this.xOrigin = pivot ? pivot["x"] : 0;
	this.yOrigin = pivot ? pivot["y"] : 0;
	this.rotation = 0;
	this.width = parent ? parent.width : 0;
    this.height = parent ? parent.height : 0;
    this.scaleX = parent ? parent.scaleX : 1;
    this.scaleY = parent ? parent.scaleY : 1;
    this.xOrigin = parent ? parent.xOrigin : this.xOrigin;
    this.yOrigin = parent ? parent.yOrigin : this.yOrigin;
	this.doRendered = false;
	this.alpha = 1;

	if(parent === undefined){
    	tbLoaderManager.addImage(this);
	} else {
		this.addSprite();
	}

    //tbLoaderManager.addTBImage(this);
};

// Adds a subimage for the image
tbImage.prototype.addImage = function(name, number) {//number, texnumb, x, y, w, h, xOff, yOff) {
	"use strict";
	var subImage = {
		name: name,
		number: number
	};

	this.subImages.push(subImage);
};

tbImage.prototype.addSprite = function(){
	"use strict";
	if(this.added){
		return;
	}

	// if(this.subImages.length === 1 && this.cache[this.subImages[0].name]){
	var texture = this.cache[this.subImages[0].name];

	if(!texture){
		texture = this.texture;
	}

	this.sprite = new PIXI["Sprite"](texture);
    this.width = this.sprite["width"];
    this.height = this.sprite["height"];
    this.sprite["pivot"]["x"] = this.xOrigin;
    this.sprite["pivot"]["y"] = this.yOrigin;
    this.name = this.subImages[0].name;

		// this.added = true;
	// } else if(this.subImages.length > 1) {
	if(this.subImages.length > 1) {

		// console.log('i want to see this');

		for(var i = 0; i < this.subImages.length; i++){
			if(this.cache[this.subImages[i].name]){
				var tmpSprite = new PIXI["Sprite"](this.cache[this.subImages[i].name]);

				if(i === 0){
					this.width = tmpSprite["width"];
					this.height = tmpSprite["height"];
                }

                tmpSprite["pivot"]["x"] = this.xOrigin;
                tmpSprite["pivot"]["y"] = this.yOrigin;

				this.sprites.push(tmpSprite);
			}
		}
	}
	this.added = true;
};

tbImage.prototype.gotoAndStop = function(frame){
	
	var frameSprite = this.sprites[frame];
	var texture = frameSprite.texture;

	this.changeFrame(texture);
}


tbImage.prototype.specialAdd = function(xOrigin, yOrigin){
	"use strict";
	if(xOrigin !== undefined){this.xOrigin = xOrigin;}
	if(yOrigin !== undefined){this.yOrigin = yOrigin;}

    this.sprite = new PIXI["Sprite"](this.texture);
    this.width = this.sprite["width"];
    this.height = this.sprite["height"];
    this.sprite["pivot"]["x"] = this.xOrigin;
    this.sprite["pivot"]["y"] = this.yOrigin;
};

tbImage.prototype.getTexture = function(sprite){
	"use strict";
	if(sprite){
        var tmpTexture = sprite["texture"];

        return tmpTexture;
	}
};

tbImage.prototype.getNineSlice = function(index, l, t, r, b) {
	"use strict";
	var _index = index ? index : 0;

    if(this.subImages.length > 0) {
        if (this.frames.length === 0) {
            for (var i = 0; i < this.subImages.length; i++) {
                this.frames.push(PIXI["Texture"]["fromFrame"](this.subImages[i].name));
            }
        }
    }

	if(this.frames.length > 0 && this.frames[_index]){
		var slice = new tbNineSlice(this.frames[_index], l, t, r, b);

		return slice;
	} else {
		console.log("Nine Slice Error");
	}
};

tbImage.prototype.getAnimation = function(x, y, loop, onComplete){
	"use strict";
	this.x = x,
	this.y = y,
	loop = (loop === undefined) ? true : loop,
	onComplete = onComplete ? onComplete : null;
	var self = this;

	if(this.subImages.length > 1){

		if(this.frames.length === 0){
			for(var i = 0; i < this.subImages.length; i++) {
                this.frames.push(PIXI["Texture"]["fromFrame"](this.subImages[i].name));
            }
		}

		if(!this.animation){

			this.animation = new tbSpriteAnimation(this.frames);

			this.animation.setPosition(this.x, this.y);

            this.animation.setLoop(loop);

            this.animation.setOnComplete(onComplete);
		}

		return this.animation;
	} else {
		console.log("No Animation attached");
	}
};

tbImage.prototype.setPosition = function(x, y){
	"use strict";
	this.x = x;
	this.y = y;

	if(this.sprite && !this.sprite["_destroyed"]) {
		this.sprite["position"]["set"](this.x, this.y);
	}
};

tbImage.prototype.setDimensions = function(w, h){
    "use strict";
    this.width = w
    this.height = h;

    if(this.sprite && !this.sprite["_destroyed"]) {
        this.sprite["width"] = this.width;
        this.sprite["height"] = this.height;
    }
};

tbImage.prototype.setRotation = function(r) {
    "use strict";

    if(this.sprite && !this.sprite["_destroyed"]){
    	this.sprite["rotation"] = r;
        this.rotation = r;
	}
};

tbImage.prototype.setScale = function (x, y) {
    "use strict";
    this.scaleX = x;
    this.scaleY = y;

    if (this.sprite) {
        this.sprite["scale"]["x"] = this.scaleX;
        this.sprite["scale"]["y"] = this.scaleY;
    }
};

tbImage.prototype.setAlpha = function(alpha) {
	"use strict";
	this.alpha = alpha;

	if(this.alpha > 1){
		this.alpha = 1;
	} else if (this.alpha < 0){
		this.alpha = 0;
	}

	this.sprite["alpha"] = this.alpha;
};

tbImage.prototype.show = function() {
    "use strict";
    if (this.sprite){
        this.sprite["visible"] = true;
    }
};

tbImage.prototype.hide = function() {
    "use strict";
    if (this.sprite){
        this.sprite["visible"] = false;
    }
};

tbImage.prototype.getFrame = function(at, _new) {
	"use strict";

	var _at = at ? at : 0;

    if(_new && this.subImages.length > 0){
       	var frame;

		if(this.subImages[_at]){
       		frame = new PIXI["Sprite"](this.cache[this.subImages[_at].name]);
		}

		return frame;
    } else if(this.sprites && this.sprites[_at]) {
    	return this.sprites[_at];
    } else if(this.sprite && !this.sprite["_destroyed"]) {
    	return this.sprite;
	} else {
        console.log("No sprites attached");
	}
};

tbImage.prototype.changeFrame = function (texture) {
	"use strict";
	if(texture){
		this.sprite["texture"] = texture;
	}
};

tbImage.prototype.clone = function(){
    "use strict";

    var _sprite = new tbImage(undefined, undefined, this);

	return _sprite;
};

tbImage.prototype.addChild = function(obj){
	"use strict";
	var _obj;

	if(obj instanceof tbImage){
		if(obj.sprite){
			_obj = obj.sprite;
		}
	} else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
	} else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
		_obj = obj;
	}

	if(_obj){
		if(this.sprite && !this.sprite["_destroyed"]){
			this.sprite["addChild"](_obj);
		} else {
			console.log("No sprites attached");
		}
	}
};

tbImage.prototype.removeChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.sprite && !this.sprite["_destroyed"]){
            this.sprite["removeChild"](_obj);
        } else {
            console.log("No sprites attached");
        }
    }
};

tbImage.prototype.add = function(container){
	"use strict";
	var obj;

	if(this.sprite && !this.sprite["_destroyed"]){
		obj = this.sprite;
	} else {
		console.log("No sprites attached");
	}

	if(obj){
		if(container && container["addChild"]){
			container["addChild"](obj);
		} else {
			tgfGraphics.addChild(obj);
		}
	}
};

tbImage.prototype.remove = function(container){
    "use strict";
    var obj;
	var _container;

    if(this.sprite && !this.sprite["_destroyed"]){
        obj = this.sprite;
		_container = obj["parent"];
    } else {
        console.log("No sprites attached");
    }

    if(obj){
        if(_container && _container["removeChild"]){
            _container["removeChild"](obj);
        } else {
            tgfGraphics.removeChild(obj);
        }
    }
};

tbImage.prototype.free = function(alsoChildren){
    "use strict";
	
	if (typeof alsoChildren === "undefined") {
		alsoChildren = true;
	}
	
	var options = {"children": alsoChildren,
		"texture": false,
		"baseTexture": false}

    if(this.sprite && !this.sprite["_destroyed"]){
		this.sprite["destroy"](options);
		this.sprite = null;
	}

	if (this.sprites && this.sprites.length > 0) {
		for (var i = 0; i < this.sprites.length; i ++) {
			this.sprites[i]["destroy"](options);
		}
		this.sprites = [];
	}
};

tbImage.prototype.setTint = function(tint){
    "use strict";
    if (this.sprite && tint){
    	this.sprite["tint"] = tint;
	}
};

tbImage.prototype.setBlendmode = function(blendMode) {
	"use strict";
	if (this.sprite && blendMode){
		this.sprite.blendMode = blendMode;
	}
};

tbImage.prototype.setMask = function(mask){
    "use strict";
   	if (this.sprite && mask){
        this.sprite["mask"] = mask;
    }
};

tbImage.prototype.frameTint = function(tint, index){
    "use strict";
    var _index = index ? index : 0;

    if(this.frames && this.frames[_index] && tint){
    	this.frames[_index]["tint"] = tint;
	}
};

tbImage.prototype.frameMask = function(mask, index){
    "use strict";
    var _index = index ? index : 0;

    if(this.frames && this.frames[_index] && mask){
        this.frames[_index]["mask"] = mask;
    }
};

tbImage.prototype.getTiling = function(width, height){
	"use strict";
	if(this.subImages.lenght === 0){
		console.log("No image available");
		return;
	}

	var tiling  = new tbTiling(this.cache[this.subImages[0].name] , width, height);

	return tiling;
};

tbImage.prototype.setBlur = function(value) {
	"use strict";
	var _value = value ? value : 0;

	if(this.sprite && !this.sprite["_destroyed"]){
		var filter = new PIXI["filters"]["BlurFilter"]();

		filter["blur"] = _value;

		this.sprite["filters"] = [filter];
	}
};

tbImage.prototype.setCallback = function(call, onDown) {
    "use strict";
   if(this.sprite && !this.sprite["_destroyed"] && call){
       	this.sprite["interactive"] = true;
   		if(onDown){
   			this.sprite["on"]('pointerdown', call);
		} else {
            this.sprite["on"]('pointerup', call);
		}
   }
};

tbImage.prototype.cancelCallback = function(call) {
    "use strict";
    if(this.sprite && !this.sprite["_destroyed"] && call && this.sprite["interactive"]){
		this.sprite["on"]('pointerupoutside', call);
    }
};

// Create an image, loaded from a file
function tbImageLoad(name, filename, width, height, xOrigin, yOrigin) {
	"use strict";
	// var tex, img;
	// tex = new tbTexture(name + "_Texture", 1, name);
	// tex.addBitmap(0,filename);
	// img = new tbImage(name, tex, 1, width, height, xOrigin, yOrigin, width, height, 1);
	// img.addImage(0, 0, 0, 0, width, height, 0, 0);
	// tbLoader.startLoading(name);
	// return img;
}

// Create an image with subimages, loaded from a file
function tbImageLoadExt(name, filename, total, perRow, width, height, xOrigin, yOrigin) {
	"use strict";
	// var tex, img, i;
	// tex = new tbTexture(name + "_Texture", 1, name);
	// tex.addBitmap(0,filename);
	// img = new tbImage(name, tex, total, width, height, xOrigin, yOrigin, perRow * width, (1 + Math.floor((total-1) / perRow)) * height, perRow);
	// for (i=0; i<total; i += 1) {
	// 	img.addImage(i, 0, (i % perRow)*width, (Math.floor(i / perRow))*height, width, height, 0, 0);
	// }
	// tbLoader.startLoading(name);
	// return img;
}

// Create an image, from an Image
function tbImageFromImage(name, image, width, height, xOrigin, yOrigin) {
	"use strict";
	//TODO fix to work with pixi

	// var tex, img;
	// tex = new tbTexture(name + "_Texture", 1, name);
	// tex.addImage(0,image);
	// img = new tbImage(name, tex, 1, width, height, xOrigin, yOrigin, width, height, 1);
	// img.addImage(0, 0, 0, 0, width, height, 0, 0);
	// return img;

	// var loader =  new PIXI["loaders"]["Loader"]();
    //
	// loader["add"](name, url, "onComplete": function(){
	// 	console.log("Loaded from url");
	// });

    var base = new PIXI["BaseTexture"](image),
        texture = new PIXI["Texture"](base);

	var img = new tbImage(texture, 1);
	img.addImage(name, 0);

	img.specialAdd(xOrigin, yOrigin);

	return img;
}

// Create an image with subimages, from an Image
function tbImageFromImageExt(name, image, total, perRow, width, height, xOrigin, yOrigin) {
	"use strict";
	// var tex, img, i;
	// tex = new tbTexture(name + "_Texture", 1, name);
	// tex.addImage(0,image);
	// img = new tbImage(name, tex, total, width, height, xOrigin, yOrigin, perRow * width, (1 + Math.floor((total-1) / perRow)) * height, perRow);
	// for (i=0; i<total; i += 1) {
	// 	img.addImage(i, 0, (i % perRow)*width, (Math.floor(i / perRow))*height, width, height, 0, 0);
	// }
	// return img;
}

// Return whether correctly loaded
tbImage.prototype.complete = function() {
	"use strict";
	return this.texture.complete();
};

// Draws subimage number at the destination
tbImage.prototype.drawSimple = function(number, dx, dy) {
	"use strict";
	// Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Draw it
	// this.texture.drawPart(this.subTexIndex[number],
	// 	this.subX[number], this.subY[number], this.subW[number], this.subH[number],
	// 	dx-this.xOrigin+this.subXOff[number], dy-this.yOrigin+this.subYOff[number]);
};

// Draws subimage number at the destination with an alpha setting
tbImage.prototype.drawAlpha = function(number, dx, dy, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha;
	// context.globalAlpha = alpha;
	// // Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Draw it
	// this.texture.drawPart(this.subTexIndex[number],
	// 	this.subX[number], this.subY[number], this.subW[number], this.subH[number],
	// 	dx-this.xOrigin+this.subXOff[number], dy-this.yOrigin+this.subYOff[number]);
	// // Restore alpha
	// context.globalAlpha = oldalpha;
};

// Draws subimage number at the destination transformed and with an alpha setting
tbImage.prototype.drawExt = function(number, dx, dy, xScale, yScale, angle, alpha) {
	"use strict";
	// var context = tbGraphics.context;
	// // Solve problem with 0 scale
	// if (Math.abs(xScale) < 0.0001 || Math.abs(yScale) < 0.0001) { return; }
	// // Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Set the transformation and alpha
	// context.save();
	// context.translate(dx,dy);
	// context.rotate(-angle * Math.PI/180);     // from degrees to radians and counter-clockwise
	// context.scale(xScale,yScale);
	// context.globalAlpha = alpha;
	// // Draw it
	// this.texture.drawPart(this.subTexIndex[number],
	// 	this.subX[number], this.subY[number], this.subW[number], this.subH[number],
	// 	this.subXOff[number]-this.xOrigin, this.subYOff[number]-this.yOrigin);
	// // Restore transformation and alpha
	// context.restore();
};

// Draws subimage number in the region
tbImage.prototype.drawStretched = function(number, dx, dy, dw, dh, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha,
	// 	scx, scy;
	// if (this.width === 0 || this.height === 0) { return; }
	// // Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Set alpha
	// context.globalAlpha = alpha;
	// // Draw it
	// scx = dw / this.width;
	// scy = dh / this.height;
	// this.texture.drawPart(this.subTexIndex[number],
	// 	this.subX[number], this.subY[number], this.subW[number], this.subH[number],
	// 	dx+scx*this.subXOff[number], dy+scy*this.subYOff[number], scx*this.subW[number], scy*this.subH[number]);
	// // Restore alpha
	// context.globalAlpha = oldalpha;
};


// Draws subimage number in nine-sliced to fill the region
tbImage.prototype.drawNineSlice = function(number, dx, dy, dw, dh, alpha, leftSize, rightSize, topSize, bottomSize) {
	"use strict";

	//TODO NOTE ////////////////////////////////
	//TODO Maybe add PIXI NineSlice here???  ///
	//TODO /////////////////////////////////////


	// var sw0, sw1, sw2, sx0, sx1, sx2, sh0, sh1, sh2, sy0, sy1, sy2, sw, sh,
	// 	dw0, dw1, dw2, dx0, dx1, dx2, dh0, dh1, dh2, dy0, dy1, dy2;
	// if (this.width === 0 || this.height === 0) { return; }
	// // Get the correct size of the pieces when not defined
	// if (leftSize === undefined) { leftSize = Math.floor(this.width / 3); }
	// if (rightSize === undefined) { rightSize = Math.floor(this.width / 3); }
	// if (topSize === undefined) { topSize = Math.floor(this.height / 3); }
	// if (bottomSize === undefined) { bottomSize = Math.floor(this.height / 3); }
	// // Correct sizes when small
	// if (dw < leftSize + rightSize) {
	// 	leftSize = Math.round(leftSize * dw / (leftSize + rightSize));
	// 	rightSize = dw - leftSize;
	// }
	// if (dh < topSize + bottomSize) {
	// 	topSize = Math.round(topSize * dh / (topSize + bottomSize));
	// 	bottomSize = dh - topSize;
	// }
	// // Determine positions and size of the pieces in the image
	// sw = this.width; sw0 = leftSize; sw1 = this.width - leftSize - rightSize; sw2 = rightSize;
	// sx0 = 0; sx1 = sw0; sx2 = sw0 + sw1;
	// sh = this.height; sh0 = topSize; sh1 = this.height - topSize - bottomSize; sh2 = bottomSize;
	// sy0 = 0; sy1 = sh0; sy2 = sh0 + sh1;
	// // Determine positions and size of the pieces in the destination
	// dw0 = leftSize; dw1 = dw - leftSize - rightSize; dw2 = rightSize;
	// dx0 = dx; dx1 = dx + dw0; dx2 = dx + dw0 + dw1;
	// dh0 = topSize; dh1 = dh - topSize - bottomSize; dh2 = bottomSize;
	// dy0 = dy; dy1 = dy + dh0; dy2 = dy + dh0 + dh1;
	// // Now draw it, looking at the various cases
	// if (dw === this.width && dh === this.height) {
	// 	this.drawAlpha(number, dx + this.xOrigin, dy + this.yOrigin, alpha);
	// } else if (dh === this.height) {
	// 	this.drawPartStretched(number, sx1, sy0, sw1, sh, dx1, dy0, dw1, dh, alpha);
	// 	this.drawPart(number, sx0, sy0, sw0, sh, dx0, dy0, alpha);
	// 	this.drawPart(number, sx2, sy0, sw2, sh, dx2, dy0, alpha);
	// } else if (dw === this.width) {
	// 	this.drawPartStretched(number, sx0, sy1, sw, sh1, dx0, dy1, dw, dh1, alpha);
	// 	this.drawPart(number, sx0, sy0, sw, sh0, dx0, dy0, alpha);
	// 	this.drawPart(number, sx0, sy2, sw, sh2, dx0, dy2, alpha);
	// } else {
	// 	// middle piece
	// 	this.drawPartStretched(number, sx1, sy1, sw1, sh1, dx1, dy1, dw1, dh1, alpha);
	// 	// side pieces
	// 	this.drawPartStretched(number, sx1, sy0, sw1, sh0, dx1, dy0, dw1, dh0, alpha);
	// 	this.drawPartStretched(number, sx0, sy1, sw0, sh1, dx0, dy1, dw0, dh1, alpha);
	// 	this.drawPartStretched(number, sx2, sy1, sw2, sh1, dx2, dy1, dw2, dh1, alpha);
	// 	this.drawPartStretched(number, sx1, sy2, sw1, sh2, dx1, dy2, dw1, dh2, alpha);
	// 	// corner pieces
	// 	this.drawPart(number, sx0, sy0, sw0, sh0, dx0, dy0, alpha);
	// 	this.drawPart(number, sx0, sy2, sw0, sh2, dx0, dy2, alpha);
	// 	this.drawPart(number, sx2, sy0, sw2, sh0, dx2, dy0, alpha);
	// 	this.drawPart(number, sx2, sy2, sw2, sh2, dx2, dy2, alpha);
	// }
};

// Draw a number of copies of the image
tbImage.prototype.drawMultiple = function(number, hNumb, vNumb, dx, dy, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha,
	// 	subx, suby, subw, subh, xx, yy, i, j;
	// // Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Set alpha
	// context.globalAlpha = alpha;
	// // Draw it
	// subx = this.subX[number]; suby = this.subY[number]; subw = this.subW[number]; subh = this.subH[number];
	// xx = dx-this.xOrigin+this.subXOff[number];
	// yy = dy-this.yOrigin+this.subYOff[number];
	// for (i=0; i<hNumb; i += 1) {
	// 	for (j=0; j<vNumb; j += 1) {
	// 		this.texture.drawPart(this.subTexIndex[number],subx,suby,subw,subh,xx+i*this.width,yy+j*this.height);
	// 	}
	// }
	// // Restore alpha
	// context.globalAlpha = oldalpha;
};

// Draw a number of copies of the image with a transformation
tbImage.prototype.drawMultipleExt = function(number, hNumb, vNumb, dx, dy, xScale, yScale, angle, alpha) {
	"use strict";
	// var xinc = xScale*this.width,
	// 	yinc = yScale*this.height,
	// 	hxinc = xinc*Math.cos(angle*Math.PI/180),
	// 	hyinc = -xinc*Math.sin(angle*Math.PI/180),
	// 	vxinc = yinc*Math.sin(angle*Math.PI/180),
	// 	vyinc = yinc*Math.cos(angle*Math.PI/180),
	// 	i, j;
	// for (i=0; i<hNumb; i += 1) {
	// 	for (j=0; j<vNumb; j += 1) {
	// 		this.drawExt(number,dx+i*hxinc+j*vxinc,dy+i*hyinc+j*vyinc,xScale,yScale,angle,alpha);
	// 	}
	// }
};

// Draw the image tiled in an area with an offset
tbImage.prototype.drawTiledOffset = function(number, xOff, yOff, dx, dy, dw, dh, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha,
	// 	xx, yy, nx, ny, xdest, ydest, subx, suby, subw, subh, i, j;
	// if (this.width === 0 || this.height === 0) { return; }
	// // Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Set alpha
	// context.globalAlpha = alpha;
	// // Draw it
	// xx = Math.round(xOff-this.xOrigin) % this.width;
	// if (xx > 0) { xx -= this.width; }
	// yy = Math.round(yOff-this.yOrigin) % this.height;
	// if (yy > 0) { yy -= this.height; }
	// nx = Math.ceil((dw-xx)/this.width);
	// ny = Math.ceil((dh-yy)/this.height);
	// xx += dx+this.subXOff[number];
	// yy += dy+this.subYOff[number];
	// for (i=0; i<nx; i += 1) {
	// 	for (j=0; j<ny; j += 1)
	// 	{
	// 		subx = this.subX[number]; suby = this.subY[number]; subw = this.subW[number]; subh = this.subH[number];
	// 		xdest = xx+i*this.width;
	// 		ydest = yy+j*this.height;
	// 		if (xdest < dx) { subx += dx-xdest; subw -= dx-xdest; xdest = dx; }
	// 		if (xdest+subw >= dx+dw) { subw = dx+dw-xdest; }
	// 		if (ydest < dy) { suby += dy-ydest; subh -= dy-ydest; ydest = dy; }
	// 		if (ydest+subh >= dy+dh) { subh = dy+dh-ydest; }
	// 		if (subw > 0 && subh > 0) {
	// 			this.texture.drawPart(this.subTexIndex[number],subx,suby,subw,subh,xdest,ydest);
	// 		}
	// 	}
	// }
	// // Restore alpha
	// context.globalAlpha = oldalpha;
};

// Draw the image tiled in an area
tbImage.prototype.drawTiled = function(number, dx, dy, dw, dh, alpha) {
	"use strict";
	// this.drawTiledOffset(number, 0, 0, dx, dy, dw, dh, alpha);
};

// Draws part of subimage number at the destination with an alpha setting
tbImage.prototype.drawPart = function(number, sx, sy, sw, sh, dx, dy, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha,
	// 	subx, suby, subw, subh;
	// // Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Check whether there is anything to draw
	// subx = this.subXOff[number]; suby = this.subYOff[number]; subw = this.subW[number]; subh = this.subH[number];
	// sx -= subx; sy -= suby;
	// if (sx+sw <= 0 || sy+sh <= 0 || sx >= subw || sy >= subh) { return; }
	// // Handle case when sx,sy does not lie inside the area
	// if (sx<0) { sw += sx; dx -= sx; sx = 0; }
	// if (sy<0) { sh += sy; dy -= sy; sy = 0; }
	// // Handle case when it sticks out of the area
	// if (sx+sw > subw) { sw = subw-sx; }
	// if (sy+sh > subh) { sh = subh-sy;	}
	// // Set alpha
	// context.globalAlpha = alpha;
	// // Draw it
	// this.texture.drawPart(this.subTexIndex[number],
	// 	this.subX[number]+sx, this.subY[number]+sy, sw, sh, dx, dy);
	// // Restore alpha
	// context.globalAlpha = oldalpha;
};

// Draw the image part tiled in an area with an offset
tbImage.prototype.drawPartTiledOffset = function(number, xOff, yOff, sx, sy, sw, sh, dx, dy, dw, dh, alpha) {
	"use strict";
	// var xx, yy, nx, ny, xdest, ydest, subx, suby, subw, subh, i, j;
	// if (sw <= 0 || sh <= 0) { return; }
	// xx = Math.round(xOff) % sw;
	// if (xx > 0) { xx -= sw; }
	// yy = Math.round(yOff) % sh;
	// if (yy > 0) { yy -= sh; }
	// nx = Math.ceil((dw-xx)/sw);
	// ny = Math.ceil((dh-yy)/sh);
	// xx += dx;
	// yy += dy;
	// for (i=0; i<nx; i += 1) {
	// 	for (j=0; j<ny; j += 1) {
	// 		subx = sx; suby = sy; subw = sw; subh = sh;
	// 		xdest = xx+i*sw;
	// 		ydest = yy+j*sh;
	// 		if (xdest < dx) { subx += dx-xdest; subw -= dx-xdest; xdest = dx; }
	// 		if (xdest+subw >= dx+dw) { subw = dx+dw-xdest; }
	// 		if (ydest < dy) { suby += dy-ydest; subh -= dy-ydest; ydest = dy; }
	// 		if (ydest+subh >= dy+dh) { subh = dy+dh-ydest; }
	// 		if (subw > 0 && subh > 0) {
	// 			this.drawPart(number,subx,suby,subw,subh,xdest,ydest,alpha);
	// 		}
	// 	}
	// }
};

// Draw part of the image tiled in an area
tbImage.prototype.drawPartTiled = function(number, sx, sy, sw, sh, dx, dy, dw, dh, alpha) {
	"use strict";
	// this.drawPartTiledOffset(number, 0, 0, sx, sy, sw, sh, dx, dy, dw, dh, alpha);
};

// Draws part of subimage number stretched in the destination rectangle with an alpha setting
tbImage.prototype.drawPartStretched = function(number, sx, sy, sw, sh, dx, dy, dw, dh, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha,
	// 	scx, scy, subx, suby, subw, subh;
	// // Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Check whether there is anything to draw
	// scx = dw / sw;
	// scy = dh / sh;
	// subx = this.subXOff[number]; suby = this.subYOff[number]; subw = this.subW[number]; subh = this.subH[number];
	// sx -= subx; sy -= suby;
	// if (sx+sw <= 0 || sy+sh <= 0 || sx >= subw || sy >= subh) { return; }
	// // Handle case when sx,sy does not lie inside the area
	// if (sx<0) { sw += sx; dw += scx*sx; dx -= scx*sx; sx = 0; }
	// if (sy<0) { sh += sy; dh += scy*sy; dy -= scy*sy; sy = 0; }
	// // Handle case when it sticks out of the area
	// if (sx+sw > subw) {dw -= scx*(sw-subw+sx); sw = subw-sx; }
	// if (sy+sh > subh) {dh -= scy*(sh-subh+sy); sh = subh-sy; }
	// // Set alpha
	// context.globalAlpha = alpha;
	// // Draw it
	// this.texture.drawPart(this.subTexIndex[number],
	// 	this.subX[number]+sx, this.subY[number]+sy, sw, sh, dx, dy, dw, dh);
	// // Restore alpha
	// context.globalAlpha = oldalpha;
};

// Draws part of subimage number at the destination transformed with an alpha setting
tbImage.prototype.drawPartExt = function(number, sx, sy, sw, sh, dx, dy, xScale, yScale, angle, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	newx, newy, subx, suby, subw, subh;
	// // Solve problem with 0 scale
	// if (Math.round(sw) === 0 || Math.round(sh) === 0) { return; }
	// if (Math.abs(xScale) < 0.0001 || Math.abs(yScale) < 0.0001) { return; }
	// // Get the number in range
	// number = (Math.round(number) % this.number + this.number) % this.number;
	// // Check whether there is anything to draw
	// subx = this.subXOff[number]; suby = this.subYOff[number]; subw = this.subW[number]; subh = this.subH[number];
	// newx = 0; newy = 0;
	// sx -= subx; sy -= suby;
	// if (sx+sw <= 0 || sy+sh <= 0 || sx >= subw || sy >= subh) { return; }
	// // Handle case when sx,sy does not lie inside the area
	// if (sx<0) { sw += sx; newx -= sx; sx = 0; }
	// if (sy<0) { sh += sy; newy -= sy; sy = 0; }
	// // Handle case when it sticks out of the area
	// if (sx+sw > subw) { sw = subw-sx; }
	// if (sy+sh > subh) { sh = subh-sy;	}
	// // Set the transformation and alpha
	// context.save();
	// context.translate(dx,dy);
	// context.rotate(-angle * Math.PI/180);     // from degrees to radians and counter-clockwise
	// context.scale(xScale,yScale);
	// context.globalAlpha = alpha;
	// // Draw it
	// this.texture.drawPart(this.subTexIndex[number],
	// 	this.subX[number]+sx, this.subY[number]+sy, sw, sh, newx, newy);
	// // Restore transformation and alpha
	// context.restore();
};

// Draws the combined at the destination
tbImage.prototype.drawCombinedSimple = function(dx, dy) {
	"use strict";
	// var n, xx, yy;
	// // Draw it
	// for (n = 0; n < this.number; n += 1) {
	// 	xx = dx + this.width * (n % this.perRow);
	// 	yy = dy + this.height * Math.floor(n / this.perRow);
	// 	this.texture.drawPart(this.subTexIndex[n],
	// 		this.subX[n], this.subY[n], this.subW[n], this.subH[n],
	// 		xx-this.xOrigin+this.subXOff[n], yy-this.yOrigin+this.subYOff[n]);
	// }
};

// Draws the combined image at the destination with an alpha setting
tbImage.prototype.drawCombinedAlpha = function(dx, dy, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha,
	// 	n, xx, yy;
	// // Set the alpha
	// context.globalAlpha = alpha;
	// // Draw it
	// for (n = 0; n < this.number; n += 1) {
	// 	xx = dx + this.width * (n % this.perRow);
	// 	yy = dy + this.height * Math.floor(n / this.perRow);
	// 	this.texture.drawPart(this.subTexIndex[n],
	// 		this.subX[n], this.subY[n], this.subW[n], this.subH[n],
	// 		xx-this.xOrigin+this.subXOff[n], yy-this.yOrigin+this.subYOff[n]);
	// }
	// // Restore alpha
	// context.globalAlpha = oldalpha;
};

// Draws the combined image at the destination transformed and with an alpha setting
tbImage.prototype.drawCombinedExt = function(dx, dy, xScale, yScale, angle, alpha) {
	"use strict";
	// var context = tbGraphics.context;
	// // Solve problem with 0 scale
	// if (Math.abs(xScale) < 0.0001 || Math.abs(yScale) < 0.0001) { return; }
	// // Set the transformation and alpha
	// context.save();
	// context.translate(dx, dy);
	// context.rotate(-angle * Math.PI/180);     // from degrees to radians and counter-clockwise
	// context.scale(xScale, yScale);
	// context.globalAlpha = alpha;
	// // Draw it
	// this.drawCombinedSimple(0, 0);
	// // Restore transformation
	// context.restore();
};

// Draws the combined image in the region
tbImage.prototype.drawCombinedStretched = function(dx, dy, dw, dh, alpha) {
	"use strict";
	// var scx, scy;
	// if (this.combinedWidth === 0 || this.combinedHeight === 0) { return; }
	// scx = dw / this.combinedWidth;
	// scy = dh / this.combinedHeight;
	// this.drawCombinedExt(dx+this.xOrigin*scx, dy+this.yOrigin*scy, scx, scy, 0, alpha);
};

// Draws part of the combined image at the destination with an alpha setting
tbImage.prototype.drawCombinedPart = function(sx, sy, sw, sh, dx, dy, alpha) {
	"use strict";
	// var n, xx, yy;
	// // Check whether there is anything to draw and, if so, call normal methods
	// for (n = 0; n < this.number; n += 1) {
	// 	xx = this.width * (n % this.perRow);
	// 	yy = this.height * Math.floor(n / this.perRow);
	// 	if (xx > sx + sw) { continue; }
	// 	if (xx+this.width < sx) { continue; }
	// 	if (yy > sy + sh) { continue; }
	// 	if (yy+this.height < sy) { continue; }
	// 	this.drawPart(n, sx-xx, sy-yy, sw, sh, dx, dy, alpha);
	// }
};

// Draws part of the combined image stretched in the destination rectangle with an alpha setting
tbImage.prototype.drawCombinedPartStretched = function(sx, sy, sw, sh, dx, dy, dw, dh, alpha) {
	"use strict";
	// var n, xx, yy;
	// // Check whether there is anything to draw and, if so, call normal methods
	// for (n = 0; n < this.number; n += 1) {
	// 	xx = this.width * (n % this.perRow);
	// 	yy = this.height * Math.floor(n / this.perRow);
	// 	if (xx > sx + sw) { continue; }
	// 	if (xx+this.width < sx) { continue; }
	// 	if (yy > sy + sh) { continue; }
	// 	if (yy+this.height < sy) { continue; }
	// 	this.drawPartStretched(n, sx-xx, sy-yy, sw, sh, dx, dy, dw, dh, alpha);
	// }
};

//
//  TILING SPRITES
//

var tbTiling = function(sprite, width, height){
	"use strict";
	this.x = 0;
	this.y = 0;
	this.offsetX = 0;
	this.offsetY = 0;
	this.scaleX = 1;
	this.scaleY = 1;
	this.alpha = 1;
	this.width = width;
	this.height = height;
	this.sprite = new PIXI["extras"]["TilingSprite"](sprite, this.width, this.height);
};

tbTiling.prototype.setPosition = function(x, y){
	"use strict";
    this.x = x;
    this.y = y;

    if(this.sprite && !this.sprite["_destroyed"]){
        this.sprite["x"] = this.x;
        this.sprite["y"] = this.y;
    }
};

tbTiling.prototype.setScale = function(x, y){
    "use strict";
    this.scaleX = x;
    this.scaleY = y;

    if(this.sprite && !this.sprite["_destroyed"]){
        this.sprite["tileScale"]["x"] = this.scaleX;
        this.sprite["tileScale"]["y"] = this.scaleY;
    }
};

tbTiling.prototype.setDimensions = function(w, h){
    "use strict";
    this.width = w;
    this.height = h;

    if(this.sprite && !this.sprite["_destroyed"]) {
        this.sprite["width"] = this.width;
        this.sprite["height"] = this.height;
    }
};

tbTiling.prototype.setOffset = function(x, y){
    "use strict";
    this.offsetX = x;
    this.offsetY = y;

    if(this.sprite && !this.sprite["_destroyed"]){
        this.sprite["tilePosition"]["x"] = this.offsetX;
        this.sprite["tilePosition"]["y"] = this.offsetY;
    }
};

tbTiling.prototype.setAlpha = function(alpha) {
    "use strict";
    this.alpha = alpha;

    if(this.alpha > 1){
        this.alpha = 1;
    } else if (this.alpha < 0){
        this.alpha = 0;
    }

    this.sprite["alpha"] = this.alpha;
};

tbTiling.prototype.addChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.sprite && !this.sprite["_destroyed"]){
            this.sprite["addChild"](_obj);
        } else {
            console.log("No sprites attached");
        }
    }
};

tbTiling.prototype.removeChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.sprite && !this.sprite["_destroyed"]){
            this.sprite["removeChild"](_obj);
        } else {
            console.log("No sprites attached");
        }
    }
};

tbTiling.prototype.add = function(container){
    "use strict";
    var obj;

    if(this.sprite && !this.sprite["_destroyed"]){
        obj = this.sprite;
    } else {
        console.log("No sprites attached");
    }

    if(obj){
        if(container && container["addChild"]){
            container["addChild"](obj);
        } else {
            tgfGraphics.addChild(obj);
        }
    }
};

tbTiling.prototype.remove = function(container){
    "use strict";
    var obj;

    if(this.sprite && !this.sprite["_destroyed"]){
        obj = this.sprite;
    } else {
        console.log("No sprites attached");
    }

    if(obj){
        if(container && container["removeChild"]){
            container["removeChild"](obj);
        } else {
            tgfGraphics.removeChild(obj);
        }
    }
};

tbTiling.prototype.free = function(alsoChildren){
    "use strict";
	
	if (typeof alsoChildren === "undefined") {
		alsoChildren = true;
	}

    var options = {"children": alsoChildren,
        "texture": false,
        "baseTexture": false};
	
    if(this.sprite && !this.sprite["_destroyed"]){
        this.sprite["destroy"](options);
		this.sprite = null;
    }
};

tbTiling.prototype.setTint = function(tint){
    "use strict";
    if (this.sprite && tint){
        this.sprite["tint"] = tint;
    }
};

tbTiling.prototype.setMask = function(mask){
    "use strict";
    if (this.sprite && mask){
        this.sprite["mask"] = mask;
    }
};

tbTiling.prototype.setBlur = function(value) {
    "use strict";
    var _value = value ? value : 0;

    if(this.sprite && !this.sprite["_destroyed"]){
        var filter = new PIXI["filters"]["BlurFilter"]();

        filter["blur"] = _value;

        this.sprite["filters"] = [filter];
    }
};

//
//  SPRITE ANIMATION
//

var tbSpriteAnimation = function(frames){
    "use strict";
    this.x = 0;
    this.y = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.frames = frames;
    this.width = 0;
    this.height = 0;
    this.speed = 1;
    this.alpha = 1;

    this._init();
};

tbSpriteAnimation.prototype._init = function(){
	"use strict";
	if(this.frames){
		this.animation = new PIXI["extras"]["AnimatedSprite"](this.frames);
		this.width = this.animation["width"];
		this.height = this.animation["height"];
	}
};

tbSpriteAnimation.prototype.clone = function(){
    "use strict";
    if(this.frames){
        var nAnimation = new tbSpriteAnimation(this.frames);
        return nAnimation;
    }
};

tbSpriteAnimation.prototype.play = function(){
    "use strict";
    if(this.animation){
        this.animation["play"]();
    }
};

tbSpriteAnimation.prototype.stop = function(){
    "use strict";
    if(this.animation){
        this.animation["stop"]();
    }
};

tbSpriteAnimation.prototype.setPosition = function(x, y){
    "use strict";
    this.x = x;
    this.y = y;

    if(this.animation){
        this.animation["x"] = this.x;
        this.animation["y"] = this.y;
    }
};

tbSpriteAnimation.prototype.setScale = function(x, y){
    "use strict";
    this.scaleX = x;
    this.scaleY = y;

    if(this.animation){
        this.animation["scale"]["x"] = this.scaleX;
        this.animation["scale"]["y"] = this.scaleY;
    }
};

tbSpriteAnimation.prototype.setAlpha = function(alpha) {
    "use strict";
    this.alpha = alpha;

    if(this.alpha > 1){
        this.alpha = 1;
    } else if (this.alpha < 0){
        this.alpha = 0;
    }

    this.animation["alpha"] = this.alpha;
};

tbSpriteAnimation.prototype.setSpeed = function(speed) {
    "use strict";
    this.speed = speed ? speed : this.speed;

    if(this.animation){
        this.animation["animationSpeed"] = this.speed;
    }
};


tbSpriteAnimation.prototype.setLoop = function(loop) {
	"use strict";
	if(this.animation && loop) {
        this.animation["loop"] = loop;
    }
};

tbSpriteAnimation.prototype.setOnComplete = function(callback) {
	"use strict";
	if(this.animation && callback){
    	this.animation["onComplete"] = callback;
	}
};

tbSpriteAnimation.prototype.addChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.animation){
            this.animation["addChild"](_obj);
        } else {
            console.log("No sprites attached");
        }
    }
};

tbSpriteAnimation.prototype.removeChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
       if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.animation){
            this.animation["removeChild"](_obj);
        } else {
            console.log("No sprites attached");
        }
    }
};

tbSpriteAnimation.prototype.add = function(container){
    "use strict";
    var obj;

    if(this.animation){
        obj = this.animation;
    } else {
        console.log("No animation attached");
    }

    if(obj){
        if(container && container["addChild"]){
            container["addChild"](obj);
        } else {
            tgfGraphics.addChild(obj);
        }
    }
};

tbSpriteAnimation.prototype.remove = function(container){
    "use strict";
    var obj;

    if(this.animation){
        obj = this.animation;
    } else {
        console.log("No animation attached");
    }

    if(obj){
        if(container && container["removeChild"]){
            container["removeChild"](obj);
        } else {
            tgfGraphics.removeChild(obj);
        }
    }
};

tbSpriteAnimation.prototype.free = function(alsoChildren){
    "use strict";
	
	if (typeof alsoChildren === "undefined") {
		alsoChildren = true;
	}

    var options = {"children": alsoChildren,
        "texture": false,
        "baseTexture": false};
	
    if(this.animation){
        this.animation["destroy"](options);
		this.animation = null;
    }
};

tbSpriteAnimation.prototype.setTint = function(tint){
    "use strict";
    if (this.animation && tint){
        this.animation["tint"] = tint;
    }
};

tbSpriteAnimation.prototype.setMask = function(mask){
    "use strict";
    if (this.animation && mask){
        this.animation["mask"] = mask;
    }
};

/////
/////  PIXI CONTAINER
////

var tbContainer = function(width, height){
	"use strict";
	this.width = width ? width : 100;
    this.height = height ? height : 100;
    this.x = 0;
    this.y = 0;
    this.pivotX = 0;
    this.pivotY = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.alpha = 1;
	this.container = new PIXI["Container"]();

	this.setSize(this.width, this.height);
};

tbContainer.prototype.setPivot = function(x, y) {
    "use strict";
    this.pivotX = x;
    this.pivotY = y;

    this.container["pivot"]["x"] = this.pivotX;
    this.container["pivot"]["y"] = this.pivotY;
};

tbContainer.prototype.setSize = function(width, height) {
	"use strict";
    this.width = width;
    this.height = height;

    this.container["width"] = this.width;
    this.container["height"] = this.height;
};

tbContainer.prototype.setPosition = function(x, y) {
    "use strict";
    this.x = x;
    this.y = y;

	if(this.container){
		this.container["x"] = this.x;
		this.container["y"] = this.y;
	}
};

tbContainer.prototype.setScale = function(x, y) {
    "use strict";
    this.scaleX = x;
    this.scaleY = y;

    if(this.container){
        this.container["scale"]["x"] = this.scaleX;
        this.container["scale"]["y"] = this.scaleY;
    }
};

tbContainer.prototype.setRotation = function(r) {
    "use strict";

    if(this.container){
        this.container["rotation"] = r;
        this.rotation = r;
    }
};

tbContainer.prototype.show = function(){
    "use strict";
    if (this.container){
        this.container["visible"] = true;
    }
};

tbContainer.prototype.hide = function(){
    "use strict";
    if (this.container){
        this.container["visible"] = false;
    }
};

tbContainer.prototype.setTint = function(tint){
    "use strict";
    if (this.container && tint){
        this.container["tint"] = tint;
    }
};

tbContainer.prototype.setMask = function(mask){
    "use strict";
    if (this.container && mask){
        this.container["mask"] = mask;
    }
};

tbContainer.prototype.setAlpha = function(alpha) {
    "use strict";
    this.alpha = alpha;

    if(this.alpha > 1){
        this.alpha = 1;
    } else if (this.alpha < 0){
        this.alpha = 0;
    }

    this.container["alpha"] = this.alpha;
};

tbContainer.prototype.addChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else if(obj instanceof tbTiling){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbContainer){
        if(obj.container){
            _obj = obj.container;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.container){
            this.container["addChild"](_obj);
        } else {
            console.log("No container attached");
        }
    }
};

tbContainer.prototype.removeChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else if(obj instanceof tbTiling){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbContainer){
        if(obj.container){
            _obj = obj.container;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.container){
            this.container["removeChild"](_obj);
        } else {
            console.log("No container attached");
        }
    }
};

tbContainer.prototype.add = function(container){
    "use strict";
    var obj;

    if(this.container){
        obj = this.container;
    } else {
        console.log("No container attached");
    }

    if(obj){
        if(container && container["addChild"]){
            container["addChild"](obj);
        } else {
            tgfGraphics.addChild(obj);
        }
    }
};

tbContainer.prototype.remove = function(container){
    "use strict";
    var obj;

    if(this.container){
        obj = this.container;
    } else {
        console.log("No container attached");
    }

    if(obj){
        if(container && container["removeChild"]){
            container["removeChild"](obj);
        } else {
            tgfGraphics.removeChild(obj);
        }
    }
};

tbContainer.prototype.free = function(alsoChildren){
    "use strict";
	
	if (typeof alsoChildren === "undefined") {
		alsoChildren = true;
	}	

    var options = {"children": alsoChildren,
					"texture": false,
					"baseTexture": false};
	
    if(this.container){
        this.container["destroy"](options);
		this.container = null;
    }
};

////
////  Nine Slice
////

var tbNineSlice = function(frame, l, t, r, b){
	"use strict";
	this.leftWidth = l ? l : tgfScale(10);
	this.topHeight = t ? t : tgfScale(10);
	this.rightWidth = r ? r : tgfScale(10);
	this.bottomHeight = b ? b : tgfScale(10);

	this.x = 0;
	this.y = 0;
	this.frame = frame;
	this.image = undefined;
	this.alpha = 1;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;

    this.width = this.frame.width ? this.frame.width : 0;
	this.height = this.frame.height ? this.frame.height : 0;

	this._init();
};

tbNineSlice.prototype._init = function() {
	"use strict";
	if(this.frame){
        this.image = new PIXI["mesh"]["NineSlicePlane"](this.frame, this.leftWidth, this.topHeight, this.rightWidth, this.bottomHeight);
	}
};

tbNineSlice.prototype.setPosition = function(x, y) {
	"use strict";
    this.x = x;
    this.y = y;

    if(this.image){
        this.image["x"] = this.x;
        this.image["y"] = this.y;
    }
};

tbNineSlice.prototype.setDimensions = function(w, h) {
    "use strict";
    this.width = w;
    this.height = h;

    if(this.image){
        this.image["width"] = this.width;
        this.image["height"] = this.height;
    }
};

tbNineSlice.prototype.setAlpha = function(alpha) {
    "use strict";
    this.alpha = alpha;

    if(this.alpha > 1){
        this.alpha = 1;
    } else if (this.alpha < 0){
        this.alpha = 0;
    }

    this.image["alpha"] = this.alpha;
};

tbNineSlice.prototype.changeFrame = function (texture) {
    "use strict";
    if(texture){
        this.image["texture"] = texture;
        this.setDimensions();
        this.image["refresh"]();
    }
};

tbNineSlice.prototype.setTint = function(tint){
    "use strict";
    if (this.image && tint){
        this.image["tint"] = tint;
    }
};

tbNineSlice.prototype.setMask = function(mask){
    "use strict";
    if (this.image && mask){
        this.image["mask"] = mask;
    }
};

tbNineSlice.prototype.setScale = function (x, y) {
    "use strict";
    this.scaleX = x;
    this.scaleY = y;

    if (this.image) {
        this.image["scale"]["x"] = this.scaleX;
        this.image["scale"]["y"] = this.scaleY;
    }
};

tbNineSlice.prototype.setRotation = function(r) {
    "use strict";

    if(this.image){
        this.image["rotation"] = r;
        this.rotation = r;
    }
};

tbNineSlice.prototype.show = function() {
    "use strict";
    if (this.image){
        this.image["visible"] = true;
    }
};

tbNineSlice.prototype.hide = function() {
    "use strict";
    if (this.image){
        this.image["visible"] = false;
    }
};

tbNineSlice.prototype.setCallback = function(call, onDown) {
    "use strict";
    if(this.image && call){
        this.image["interactive"] = true;
        if(onDown){
            this.image["on"]('pointerdown', call);
        } else {
            this.image["on"]('pointerup', call);
        }
    }
};

tbNineSlice.prototype.cancelCallback = function(call) {
    "use strict";
    if(this.image && call && this.image["interactive"]){
		this.image["on"]('pointerupoutside', call);
    }
};

tbNineSlice.prototype.add = function(container){
    "use strict";
    var obj;

    if(this.image){
        obj = this.image;
    } else {
        console.log("No container attached");
    }

    if(obj){
        if(container && container["addChild"]){
            container["addChild"](obj);
        } else {
            tgfGraphics.addChild(obj);
        }
    }
};

tbNineSlice.prototype.remove = function(container){
    "use strict";
    var obj;

    if(this.image){
        obj = this.image;
    } else {
        console.log("No container attached");
    }

    if(obj){
        if(container && container["removeChild"]){
            container["removeChild"](obj);
        } else {
            tgfGraphics.removeChild(obj);
        }
    }
};

tbNineSlice.prototype.free = function(alsoChildren){
    "use strict";
	
	if (typeof alsoChildren === "undefined") {
		alsoChildren = true;
	}

    var options = {"children": alsoChildren,
        "texture": false,
        "baseTexture": false};
	
    if(this.image){
        this.image["destroy"](options);
		this.image = null;
    }
};

tbNineSlice.prototype.addChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.image){
            this.image["addChild"](_obj);
        } else {
            console.log("No image attached");
        }
    }
};

tbNineSlice.prototype.removeChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.image){
            this.image["removeChild"](_obj);
        } else {
            console.log("No image attached");
        }
    }
};

//
// PARTICLE
//

var tbParticle = function(container, particleJSON, images, trail) {
	"use strict";
	this.baseContainer = new tbContainer();
    container.addChild(this.baseContainer);
	this.container = container.container;
	this.particleJSON = JSON.parse(particleJSON.json);
	this.emitter = undefined;
	this.images = images;
	this.looping = true;
	this.callback = null;
	this.isAlive = false;
	this.rotation = 0;
	this.scale = 1;
	this.isTrail = (trail === undefined) ? false : true;

	this.x = 0;
	this.y = 0;

	this.init();
};

tbParticle.prototype.init = function() {
	"use strict";
	var _images = [];

	for(var i = 0; i < this.images.length; i++){
		_images.push(this.images[i].getFrame().texture);
	}

	this.emitter = new PIXI["particles"]["Emitter"](
        this.baseContainer.container,
		_images,
		this.particleJSON
	);

	this.x = this.emitter["spawnPos"]["x"];
	this.y = this.emitter["spawnPos"]["y"];
	this.rotation = this.emitter["rotation"];

	if(this.emitter["emitterLifetime"] > 0) {
		this.looping = false;
	}
};

tbParticle.prototype.show = function(){
    "use strict";
    this.emitter["emit"] = true;
    this.isAlive = true;
};

tbParticle.prototype.hide = function(){
    "use strict";
    this.emitter["emit"] = false;
    this.isAlive = false;
};

tbParticle.prototype.reset = function(){
    "use strict";
    this.emitter["emit"] = true;
    this.isAlive = true;
    this.emitter["_emitterLife"] = 0;
};


tbParticle.prototype.update = function(timePassed){
	"use strict";
	if(!this.isAlive){
		return;
	}

	var secondsPassed = timePassed / 1000;

	this.emitter["update"](secondsPassed);

	if(!this.looping && this.emitter["particleCount"] === 0 && this.callback){
		this.callback();
		this.destroy();
		this.isAlive = false;
	}
};

tbParticle.prototype.setPosition = function(x, y){
	"use strict";
	this.x = x;
	this.y = y;

	if(this.isTrail){
    	this.emitter["updateSpawnPos"](x, y);
	} else {
    	this.baseContainer.setPosition(x, y);
	}
};


tbParticle.prototype.setMove = function(x, y){
    "use strict";
	if(this.isTrail){
		this.emitter["updateSpawnPos"](x, y);
	}
};

tbParticle.prototype.setCallback = function (call) {
	"use strict";
	this.callback = call;
};

tbParticle.prototype.destroy = function(){
    "use strict";
	this.emitter["destroy"]();
	this.container.removeChild(this.baseContainer);
};

tbParticle.prototype.setRotation = function(r){
	"use strict";
    this.rotation = r;

	this.emitter["rotate"](r);
};

tbParticle.prototype.setScale = function(s){
    "use strict";
    this.scale = s;

    if(this.isTrail){
        this.emitter["startScale"] *= this.scale;
        this.emitter["endScale"] *= this.scale;
	} else {
		this.baseContainer.setScale(this.scale, this.scale);
	}
};

//TODO Add more functionality //


//
// SURFACES
//

// The constructor for the surface object
var tbSurface = function(width, height) {
	"use strict";
    // this.canvas = document.createElement('canvas');
    // this.context = this.canvas.getContext("2d");
    // this.width = width;
    // this.height = height;
    // this.xOrigin = 0;
    // this.yOrigin = 0;
    // this.canvas.width = width;
    // this.canvas.height = height;
    // // this.clear();
    // this.oldCanvas = undefined;
};

// Change the size of the surface
tbSurface.prototype.changeSize = function(width, height) {
	"use strict";
	// this.width = width;
	// this.height = height;
	// this.canvas.width = width;
	// this.canvas.height = height;
	// this.clear();
};

// Return a copy (clone) of the surface
tbSurface.prototype.clone = function() {
	"use strict";
	// var surf = new tbSurface(this.width, this.height);
	// surf.xOrigin = this.xOrigin;
	// surf.yOrigin = this.yOrigin;
	// // surf.setTarget();
	// // this.drawSimple(0,0);
	// // surf.resetTarget();
	// return surf;
};

// Set the surface as render target
tbSurface.prototype.setTarget = function() {
	"use strict";
	// this.oldCanvas = tbGraphics.canvas;
	// if(tbGraphics.webGLAvailable){
	// 	tbGraphics.setCanvas(tbGraphics.canvas);
	// } else {
	// 	tbGraphics.setCanvas(this.canvas);
	// }
};

// Resets the render target to the previous one
tbSurface.prototype.resetTarget = function() {
	"use strict";
	// if (tbGraphics.canvas !== this.canvas) { return; }
	// if (this.oldCanvas === undefined) { return; }
	// tbGraphics.setCanvas(this.oldCanvas);
	// this.oldCanvas = undefined;
};

// Clear the surface to transparent
tbSurface.prototype.clear = function() {
	"use strict";
	// this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
};

// Clear the surface to the indicated color
tbSurface.prototype.clearColor = function(color) {
	"use strict";
	// this.context.fillStyle = color;
	// this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
};

// Draws the surface at the destination location
tbSurface.prototype.drawSimple = function(dx,dy) {
	"use strict";
	// tbGraphics.context.drawImage(this.canvas, dx - this.xOrigin, dy - this.yOrigin);
};

// Draws the surface at the destination with an alpha setting
tbSurface.prototype.drawAlpha = function(dx, dy, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha;
	// context.globalAlpha = alpha;
	// tbGraphics.context.drawImage(this.canvas, dx - this.xOrigin, dy - this.yOrigin);
	// context.globalAlpha = oldalpha;
};

// Draws the surface at the destination transformed and with an alpha setting
tbSurface.prototype.drawExt = function(dx, dy, xScale, yScale, angle, alpha) {
	"use strict";
	// var context = tbGraphics.context;
	// // Solve problem with 0 scale
	// if (Math.abs(xScale) < 0.0001 || Math.abs(yScale) < 0.0001) { return; }
	// context.save();
	// context.translate(dx, dy);
	// context.rotate(-angle * Math.PI/180);
	// context.scale(xScale, yScale);
	// context.globalAlpha = alpha;
	// tbGraphics.context.drawImage(this.canvas, -this.xOrigin, -this.yOrigin);
	// context.restore();
};

// Draws the surface in the region
tbSurface.prototype.drawStretched = function(dx, dy, dw, dh, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha;
	// if (this.width === 0 || this.height === 0) { return; }
	// if (Math.round(dw) === 0 || Math.round(dh) === 0) { return; }
	// context.globalAlpha = alpha;
	// tbGraphics.context.drawImage(this.canvas, dx, dy, dw, dh);
	// context.globalAlpha = oldalpha;
};



// Draws the surface in nine-sliced to fill the region
tbSurface.prototype.drawNineSlice = function(dx, dy, dw, dh, alpha, leftSize, rightSize, topSize, bottomSize) {
	"use strict";
	// var sw0, sw1, sw2, sx0, sx1, sx2, sh0, sh1, sh2, sy0, sy1, sy2, sw, sh,
	// 	dw0, dw1, dw2, dx0, dx1, dx2, dh0, dh1, dh2, dy0, dy1, dy2;
	// if (this.width === 0 || this.height === 0) { return; }
	// // Get the correct size of the pieces when not defined
	// if (leftSize === undefined) { leftSize = Math.floor(this.width / 3); }
	// if (rightSize === undefined) { rightSize = Math.floor(this.width / 3); }
	// if (topSize === undefined) { topSize = Math.floor(this.height / 3); }
	// if (bottomSize === undefined) { bottomSize = Math.floor(this.height / 3); }
	// // Correct sizes when small
	// if (dw < leftSize + rightSize) {
	// 	leftSize = Math.round(leftSize * dw / (leftSize + rightSize));
	// 	rightSize = dw - leftSize;
	// }
	// if (dh < topSize + bottomSize) {
	// 	topSize = Math.round(topSize * dh / (topSize + bottomSize));
	// 	bottomSize = dh - topSize;
	// }
	// // Determine positions and size of the pieces in the image
	// sw = this.width; sw0 = leftSize; sw1 = this.width - leftSize - rightSize; sw2 = rightSize;
	// sx0 = 0; sx1 = sw0; sx2 = sw0 + sw1;
	// sh = this.height; sh0 = topSize; sh1 = this.height - topSize - bottomSize; sh2 = bottomSize;
	// sy0 = 0; sy1 = sh0; sy2 = sh0 + sh1;
	// // Determine positions and size of the pieces in the destination
	// dw0 = leftSize; dw1 = dw - leftSize - rightSize; dw2 = rightSize;
	// dx0 = dx; dx1 = dx + dw0; dx2 = dx + dw0 + dw1;
	// dh0 = topSize; dh1 = dh - topSize - bottomSize; dh2 = bottomSize;
	// dy0 = dy; dy1 = dy + dh0; dy2 = dy + dh0 + dh1;
	// // Now draw it, looking at the various cases
	// if (dw === this.width && dh === this.height) {
	// 	this.drawAlpha(dx + this.xOrigin, dy + this.yOrigin, alpha);
	// } else if (dh === this.height) {
	// 	this.drawPartStretched(sx1, sy0, sw1, sh, dx1, dy0, dw1, dh, alpha);
	// 	this.drawPart(sx0, sy0, sw0, sh, dx0, dy0, alpha);
	// 	this.drawPart(sx2, sy0, sw2, sh, dx2, dy0, alpha);
	// } else if (dw === this.width) {
	// 	this.drawPartStretched(sx0, sy1, sw, sh1, dx0, dy1, dw, dh1, alpha);
	// 	this.drawPart(sx0, sy0, sw, sh0, dx0, dy0, alpha);
	// 	this.drawPart(sx0, sy2, sw, sh2, dx0, dy2, alpha);
	// } else {
	// 	// middle piece
	// 	this.drawPartStretched(sx1, sy1, sw1, sh1, dx1, dy1, dw1, dh1, alpha);
	// 	// side pieces
	// 	this.drawPartStretched(sx1, sy0, sw1, sh0, dx1, dy0, dw1, dh0, alpha);
	// 	this.drawPartStretched(sx0, sy1, sw0, sh1, dx0, dy1, dw0, dh1, alpha);
	// 	this.drawPartStretched(sx2, sy1, sw2, sh1, dx2, dy1, dw2, dh1, alpha);
	// 	this.drawPartStretched(sx1, sy2, sw1, sh2, dx1, dy2, dw1, dh2, alpha);
	// 	// corner pieces
	// 	this.drawPart(sx0, sy0, sw0, sh0, dx0, dy0, alpha);
	// 	this.drawPart(sx0, sy2, sw0, sh2, dx0, dy2, alpha);
	// 	this.drawPart(sx2, sy0, sw2, sh0, dx2, dy0, alpha);
	// 	this.drawPart(sx2, sy2, sw2, sh2, dx2, dy2, alpha);
	// }
};

// Draw a number of copies of the surface
tbSurface.prototype.drawMultiple = function(hNumb, vNumb, dx, dy, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha,
	// 	i, j;
	// context.globalAlpha = alpha;
	// for (i=0; i<hNumb; i += 1) {
	// 	for (j=0; j<vNumb; j += 1) {
	// 		tbGraphics.context.drawImage(this.canvas,
	// 			dx - this.xOrigin + i*this.width, dy - this.yOrigin + j*this.height);
	// 	}
	// }
	// context.globalAlpha = oldalpha;
};

// Draw a number of copies of the surface with a transformation
tbSurface.prototype.drawMultipleExt = function(hNumb, vNumb, dx, dy, xScale, yScale, angle, alpha) {
	"use strict";
	// var xinc = xScale*this.width,
	// 	yinc = yScale*this.height,
	// 	hxinc = xinc*Math.cos(angle*Math.PI/180),
	// 	hyinc = -xinc*Math.sin(angle*Math.PI/180),
	// 	vxinc = yinc*Math.sin(angle*Math.PI/180),
	// 	vyinc = yinc*Math.cos(angle*Math.PI/180),
	// 	i, j;
	// for (i=0; i<hNumb; i += 1) {
	// 	for (j=0; j<vNumb; j += 1) {
	// 		this.drawExt(dx+i*hxinc+j*vxinc,dy+i*hyinc+j*vyinc,xScale,yScale,angle,alpha);
	// 	}
	// }
};

// Draws the surface tiled in an area with an offset
tbSurface.prototype.drawTiledOffset = function(xOff, yOff, dx, dy, dw, dh, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha,
	// 	xx, yy, nx, ny, xdest, ydest, subx, suby, subw, subh, i, j;
	// if (this.width === 0 || this.height === 0) { return; }
	// context.globalAlpha = alpha;
	// // Draw it
	// xx = Math.round(xOff-this.xOrigin) % this.width;
	// if (xx > 0) { xx -= this.width; }
	// yy = Math.round(yOff-this.yOrigin) % this.height;
	// if (yy > 0) { yy -= this.height; }
	// nx = Math.ceil((dw-xx)/this.width);
	// ny = Math.ceil((dh-yy)/this.height);
	// xx += dx;
	// yy += dy;
	// for (i=0; i<nx; i += 1) {
	// 	for (j=0; j<ny; j += 1) {
	// 		subx = 0; suby = 0; subw = this.width; subh = this.height;
	// 		xdest = xx+i*this.width;
	// 		ydest = yy+j*this.height;
	// 		if (xdest < dx) { subx += dx-xdest; subw -= dx-xdest; xdest = dx; }
	// 		if (xdest+subw >= dx+dw) { subw = dx+dw-xdest; }
	// 		if (ydest < dy) { suby += dy-ydest; subh -= dy-ydest; ydest = dy; }
	// 		if (ydest+subh >= dy+dh) { subh = dy+dh-ydest; }
	// 		if (subw > 0 && subh > 0) {
	// 			tbGraphics.context.drawImage(this.canvas,subx,suby,subw,subh,xdest,ydest,subw,subh);
	// 		}
	// 	}
	// }
	// context.globalAlpha = oldalpha;
};

// Draws the surface tiles in an area
tbSurface.prototype.drawTiled = function(dx, dy, dw, dh, alpha) {
	"use strict";
	// this.drawTiledOffset(0, 0, dx, dy, dw, dh, alpha);
};

// Draws part of the surface at the destination with an alpha setting
tbSurface.prototype.drawPart = function(sx, sy, sw, sh, dx, dy, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha;
	// if (sw <= 0 || sh <= 0) { return; }
	// if (sx+sw > this.width) { sw = this.width - sx; }
	// if (sy+sh > this.height) { sh = this.height - sy; }
	// context.globalAlpha = alpha;
	// tbGraphics.context.drawImage(this.canvas,sx, sy, sw, sh, dx, dy, sw, sh);
	// context.globalAlpha = oldalpha;
};

// Draw the surface part tiled in an area with an offset
tbSurface.prototype.drawPartTiledOffset = function(xOff, yOff, sx, sy, sw, sh, dx, dy, dw, dh, alpha) {
	"use strict";
	// var xx, yy, nx, ny, xdest, ydest, subx, suby, subw, subh, i, j;
	// if (sw <= 0 || sh <= 0) { return; }
	// if (sx+sw > this.width) { sw = this.width - sx; }
	// if (sy+sh > this.height) { sh = this.height - sy; }
	// xx = Math.round(xOff) % sw;
	// if (xx > 0) { xx -= sw; }
	// yy = Math.round(yOff) % sh;
	// if (yy > 0) { yy -= sh; }
	// nx = Math.ceil((dw-xx)/sw);
	// ny = Math.ceil((dh-yy)/sh);
	// xx += dx;
	// yy += dy;
	// for (i=0; i<nx; i += 1) {
	// 	for (j=0; j<ny; j += 1) {
	// 		subx = sx; suby = sy; subw = sw; subh = sh;
	// 		xdest = xx+i*sw;
	// 		ydest = yy+j*sh;
	// 		if (xdest < dx) { subx += dx-xdest; subw -= dx-xdest; xdest = dx; }
	// 		if (xdest+subw >= dx+dw) { subw = dx+dw-xdest; }
	// 		if (ydest < dy) { suby += dy-ydest; subh -= dy-ydest; ydest = dy; }
	// 		if (ydest+subh >= dy+dh) { subh = dy+dh-ydest; }
	// 		if (subw > 0 && subh > 0) {
	// 			this.drawPart(subx,suby,subw,subh,xdest,ydest,alpha);
	// 		}
	// 	}
	// }
};

// Draw part of the surface tiled in an area
tbSurface.prototype.drawPartTiled = function(sx, sy, sw, sh, dx, dy, dw, dh, alpha) {
	"use strict";
	// this.drawPartTiledOffset(0, 0, sx, sy, sw, sh, dx, dy, dw, dh, alpha);
};

// Draws part of the surface stretched in the destination rectangle with an alpha setting
tbSurface.prototype.drawPartStretched = function(sx, sy, sw, sh, dx, dy, dw, dh, alpha) {
	"use strict";
	// var context = tbGraphics.context,
	// 	oldalpha = context.globalAlpha;
	// if (sw <= 0 || sh <= 0) { return; }
	// if (sx+sw > this.width) { sw = this.width - sx; }
	// if (sy+sh > this.height) { sh = this.height - sy; }
	// if (Math.round(dw) === 0 || Math.round(dh) === 0) { return; }
	// context.globalAlpha = alpha;
	// tbGraphics.context.drawImage(this.canvas,sx, sy, sw, sh, dx, dy, dw, dh);
	// context.globalAlpha = oldalpha;
};

// Draws part of the surface at the destination transformed with an alpha setting
tbSurface.prototype.drawPartExt = function(sx, sy, sw, sh, dx, dy, xScale, yScale, angle, alpha) {
	"use strict";
	// var context = tbGraphics.context;
	// // Solve problem with 0 scale
	// if (sw <= 0 || sh <= 0) { return; }
	// if (sx+sw > this.width) { sw = this.width - sx; }
	// if (sy+sh > this.height) { sh = this.height - sy; }
	// if (Math.abs(xScale) < 0.0001 || Math.abs(yScale) < 0.0001) { return; }
	// context.save();
	// context.translate(dx,dy);
	// context.rotate(-angle * Math.PI/180);
	// context.scale(xScale, yScale);
	// context.globalAlpha = alpha;
	// tbGraphics.context.drawImage(this.canvas,sx, sy, sw, sh, 0, 0, sw, sh);
	// context.restore();
};

///////////////////////////////////////////////////////////////////////////
//			LOADING MANAGER
///////////////////////////////////////////////////////////////////////////

var TBLoaderManager = function(){
    "use strict";
    this.texturesLoading = 0;
    this.names = [];
    this.paths = [];
    this.loading = [];
    this.textures = [];
    this.refs = [];
    this.json = [];
    this.images = [];
    this.allTextures = {};
    this.tbImagesCollection = [];
    this.resources = PIXI["loader"]["resources"];
    this.cache = PIXI["utils"]["TextureCache"];
    this.spineAnimations = 0;
};

TBLoaderManager.prototype.addTextures = function(){
    "use strict";
    // var self = this;
};

TBLoaderManager.prototype.addJson = function(){
    "use strict";

};

TBLoaderManager.prototype.addTBImage = function(image){
	"use strict";
	if(image && image instanceof tbImage){
        this.tbImagesCollection.push(image);
	}
};

TBLoaderManager.prototype.createSprites = function(texture){
	"use strict";

	for(var i = 0; i < this.images.length; i++){
		if(this.images[i].texture.name === texture.name){
			this.images[i].addSprite();
		}
	}
};

TBLoaderManager.prototype.addSpine = function(){
	"use strict";
    this.spineAnimations++;
};

TBLoaderManager.prototype.loadedSpine = function(){
	"use strict";
    this.spineAnimations--;

	tbLoader.loadComplete("spine");
};

TBLoaderManager.prototype.addImage = function(context, texture){
    "use strict";

    this.images.push(context);
};



var tbLoaderManager = new TBLoaderManager();/////////////////////////////////////////////////////////////
// tbFont: The engine part dealing with bitmap and vector fonts
//
// Copyright 2013-2014 CoolGames
// Last Changed: 16-07-2014
/////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////
// BITMAP FONTS
//////////////////////////////////////////////////////

var alignLeft = "left";
var alignCenter = "center";
var alignRight = "right";
var baselineTop = "top";
var baselineMiddle = "middle";
var baselineBase = "base";
var baselineBottom = "bottom";

// The constructor for the font
var tbBitmapFont = function(name) {
    "use strict";
    this.name = name;
    this.align = alignLeft;
    this.baseline = baselineBase;
    this.spacing = 0;
    this.tracking = 0;
};

// Return whether correctly loaded
tbBitmapFont.prototype.complete = function() {
    "use strict";
    return this.image.texture.complete();
};

// Split the string in lines with maximal width w
tbBitmapFont.prototype._split = function(str, w) {
    "use strict";
    // Split in lines
    var lines = [],
        ind, wl, ln, st;
    if (w === undefined) {
        lines = str.split('\n');
        return lines;
    }
    if (w < 0) { w = 0; }
    ind = 0;
    wl = 0;
    lines[0] = "";
    while (ind < str.length) {
        if (str[ind] === '\n') {
            lines.push("");
            wl = 0;
            ind += 1;
        } else {
            ln = lines.length-1;
            wl += this.width[str.charCodeAt(ind)];
            if (wl > w && lines[ln].length > 0) {
                st = lines[ln].length-1;
                while (st >= 0 && lines[ln][st] !== " ") { st -= 1; }
                if (st >= 0) {
                    ind = ind - lines[ln].length + st + 1;
                    lines[ln] = lines[ln].substr(0,st);
                }
                lines.push("");
                wl = 0;
            } else {
                lines[ln] += str[ind];
                wl += this.tracking;
                ind += 1;
            }
        }
    }
    return lines;
};

// Return the width of a line
tbBitmapFont.prototype._textWidth = function(line) {
    "use strict";
    var  wl = 0, i;
    for (i = line.length-1; i >= 0; i -= 1) {
        wl += this.width[line.charCodeAt(i)] + this.tracking;
    }
    return wl - this.tracking; // Remove the last tracking
};

// Return the width of the string
tbBitmapFont.prototype.textWidth = function(str, w) {
    "use strict";
    var lines = this._split(str, w), wmax = 0, j;
    for (j = lines.length-1; j >= 0; j -= 1) {
        wmax = Math.max(wmax, this._textWidth(lines[j]));
    }
    return wmax;
};

tbBitmapFont.prototype.textHeight = function(str, w) {
    "use strict";
    var lines = this._split(str, w);
    return lines.length * this.height + (lines.length-1) * this.spacing;
};

// Draws the string at the destination
tbBitmapFont.prototype.drawSimple = function(str, dx, dy, w) {
    "use strict";
    // Split in lines
    var lines = this._split(str, w),
        th = lines.length * this.height + (lines.length-1) * this.spacing,
        xst = dx, yst = dy,
        xx, yy, i, j, chr, ind;
    switch (this.baseline) {
        case baselineTop: yst -= this.top; break;
        case baselineMiddle: yst -= this.top + Math.round(th / 2); break;
        case baselineBase: yst -= this.base; break;
        case baselineBottom: yst -= this.top + th; break;
    }
    // Now draw the lines
    yy = yst;
    for (j = 0; j < lines.length; j += 1) {
        xx = xst;
        switch (this.align) {
            case alignLeft: xx = xst; break;
            case alignCenter: xx = xst - Math.round(this._textWidth(lines[j]) / 2); break;
            case alignRight: xx = xst - this._textWidth(lines[j]); break;
        }
        for (i = 0; i < lines[j].length; i += 1) {
            chr = lines[j].charCodeAt(i);
            ind = this.index[chr];
            if (ind >= 0) { this.image.drawSimple(ind, xx-this.left[chr], yy); }
            xx += this.width[chr] + this.tracking;
        }
        yy += this.height + this.spacing;
    }
};

// Draws the string at the destination with an alpha setting
tbBitmapFont.prototype.drawAlpha = function(str, dx, dy, alpha, w) {
    "use strict";
    var context = tbGraphics.context;
    context.save();
    context.globalAlpha = alpha;
    this.drawSimple(str, dx, dy, w);
    context.restore();
};

// Draws the string at the destination transformed and with an alpha setting
tbBitmapFont.prototype.drawExt = function(str, dx, dy, xScale, yScale, angle, alpha, w) {
    "use strict";
    var context = tbGraphics.context;
    if (Math.abs(xScale) < 0.0001 || Math.abs(yScale) < 0.0001) { return; } // Solve problem with 0 scale
    context.save();
    context.translate(dx,dy);
    context.rotate(-angle * Math.PI / 180);     // from degrees to radians and counter-clockwise
    context.scale(xScale,yScale);
    context.globalAlpha = alpha;
    this.drawSimple(str, 0, 0, w/xScale);
    context.restore();
};


//////////////////////////////////////////////////////
// VECTOR FONT FACES
//////////////////////////////////////////////////////

// Create a loader object that is responsible for loading the fontface
var tbVectorFontLoader = function(fontFace, woffPath, ttfPath, loadMoment) {
    "use strict";
    // Info
    this.fontFace = fontFace;
    this.woffPath = woffPath;
    this.ttfPath = ttfPath;
    // Measurement to check whether the font has been loaded
    this._fallbackMeasurements = [
        { text: "MiHhX!@v&Qq", width: -1, font: "sans-serif" },
        { text: "MiHhX!@v&Qq", width: -1, font: "serif" },
        { text: "AaMm#@!Xx67", width: -1, font: "sans-serif" },
        { text: "AaMm#@!Xx67", width: -1, font: "serif" }
    ];
    this.success = false;
    // Add it to the loader
    tbLoader.addResource(this, loadMoment, 1);
};

// Compute the width of a text
tbVectorFontLoader.prototype._computeWidth = function(font, fallback, text) {
    "use strict";
    if(!tbGraphics.fontContext){
        return;
    }

    var width;

    tbGraphics.fontContext.save();
    tbGraphics.fontContext.font = "250pt " + font + ", " + fallback;
    width = tbGraphics.fontContext.measureText(text).width;
    tbGraphics.fontContext.restore();
    return width;
};

// Add the fontface to the style
tbVectorFontLoader.prototype._addToCss = function(location) {
    "use strict";
    // Define css
    var cssCode =	"@font-face {" +
            "font-family: " + this.fontFace + ";" +
            "src: url('" + location + this.woffPath + "') format('woff'), " +
            "url('" + location + this.ttfPath  + "') format('truetype');" +
            "}",
        // Create CSS element
        styleElement = document.createElement("style");
    styleElement.id = this.fontFace + "_fontface";
    styleElement.type = "text/css";
    if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = cssCode;
    } else {
        styleElement.appendChild(document.createTextNode(cssCode));
    }
    // Add CSS element to head
    document.getElementsByTagName("head")[0].appendChild(styleElement);
};

// Add an element to the DOM to force loading the font
tbVectorFontLoader.prototype._addToDom = function() {
    "use strict";
    var i, measurement;
    // Create the DOM element to start the loading
    this.DOMElement = document.createElement("span");
    this.DOMElement.style.position = "absolute";
    this.DOMElement.style.left = "-9999px";
    this.DOMElement.style.top = "-9999px";
    this.DOMElement.style.visibility = "hidden";
    this.DOMElement.style.fontSize = "250pt";
    this.DOMElement.id = this.fontFace + "_loader";
    // Add the element to the DOM
    document.body.appendChild(this.DOMElement);
    // Do initial _fallbackMeasurements
    for (i = 0; i < this._fallbackMeasurements.length; i += 1)
    {
        measurement = this._fallbackMeasurements[i];
        measurement.width = this._computeWidth(measurement.font, measurement.font, measurement.text);
    }
};

// This loop checks whether the font is loaded
tbVectorFontLoader.prototype._cycle = function() {
    "use strict";
    var i, measurement, that, width;
    // Do the check
    for (i = 0; i < this._fallbackMeasurements.length; i += 1) {
        measurement = this._fallbackMeasurements[i];
        width = this._computeWidth(this.fontFace, measurement.font, measurement.text);
        // Check whether width is changed (then the font is loaded)
        if(measurement.width !== width) {
            tbLoader.loadComplete(this.loadMoment);
            document.body.removeChild(this.DOMElement);
            this.success = true;
            return;
        }
    }
    // If not loaded, loop
    that = this;
    window.setTimeout(function() { that._cycle(); }, 33);
};

// Start the loading (called by tbLoader) by adding the fontface and an element to the DOM and checking
tbVectorFontLoader.prototype.startLoading = function(moment, location) {
    "use strict";
    this._addToCss(location);
    this._addToDom();
    this.loadMoment = moment;
    this._cycle();
};

//Returns whether loading is complete (true)
tbVectorFontLoader.prototype.complete = function() {
    "use strict";
    return this.success;
};


//////////////////////////////////////////////////////
// VECTOR FONTS
//////////////////////////////////////////////////////

//
// Construction
//

// Constructor for a font with a given fontface and fallback font
var tbVectorFont = function (fontFace, fallbackFontFace) {
    "use strict";
    this.fontFace = fontFace;
    this.fallbackFontFace = fallbackFontFace;
    this.setDefault();
    this.font = new PIXI["Text"]();
    this.style = undefined;
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.anchorX = 0;
    this.anchorY = 0;
    this.text = "";
};

// Create a clone of the font with all the same property values
tbVectorFont.prototype.clone = function() {
    "use strict";
    var result = new tbVectorFont(this.fontFace, this.fallbackFontFace);
    //Font
    result.fontStyle = this.fontStyle;
    result.fontWeight = this.fontWeight;
    result.fontCase = this.fontCase;
    result.fontSize = this.fontSize;
    //Fill
    result.fill = this.fill;
    result.fillAlpha = this.fillAlpha;
    result.fillMode = this.fillMode;
    result.fillColor = this.fillColor;
    result.fillPattern = {image: this.fillPattern.image, repeatH: this.fillPattern.repeatH, repeatV: this.fillPattern.repeatV};
    result.fillGradient = {vertical: this.fillGradient.vertical, number:this.fillGradient.number, colors:this.fillGradient.colors.slice(0),
        size: this.fillGradient.size, offset: this.fillGradient.offset};
    result.fillStyle = this.fillStyle;
    //Stoke
    result.stroke = this.stroke;

    if(!result.stroke){
        result.strokeWidth = 0;
    }

    result.strokeAlpha = this.strokeAlpha;
    result.strokeMode = this.strokeMode;
    result.strokeColor = this.strokeColor;
    result.strokeStyle = this.strokeStyle;
    result.strokeWidth = this.strokeWidth;
    result.strokeBehind = this.strokeBehind;
    result.strokeJoin = this.strokeJoin;
    //Shadow
    result.shadow = { active: this.shadow.active, color:this.shadow.color, offsetX: this.shadow.offsetX, offsetY: this.shadow.offsetY, blur: this.shadow.blur, angle: this.shadow.angle };
    //Text Alignment
    result.align = this.align;
    result.baseline = this.baseline;
    result.offsetFactor = this.offsetFactor;
    result.spacing = this.spacing;
    
    result.wordWrap = this.wordWrap;
    result.wordWrapWidth = this.wordWrapWidth;
    result.breakWords = this.breakWords;
    result.padding = this.padding;

    result.style = new PIXI["TextStyle"](result.textStyle());
    result.font["setStyle"](result.style);

    result.setAnchorAlign();
    result.setAnchorBaseline();

    return result;
};

//
// Settings
//

// Set all properties to default
tbVectorFont.prototype.setDefault = function() {
    "use strict";
    //Font
    this.fontStyle = "";
    this.fontWeight = "";
    this.fontCase = "normal";
    this.fontSize = 12;
    //Fill
    this.fill = true;
    this.fillAlpha = 1;
    this.fillMode = 0;
    this.fillColor = "black";
    this.fillPattern = {image: undefined, subImage: 0, repeatH: true, repeatV: true};
    this.fillGradient = {vertical: true, number:3, colors:["red","white","blue"], size: 0.6, offset: 0};
    this.fillStyle = undefined;
    //Stroke
    this.stroke = false;
    this.strokeAlpha = 1;
    this.strokeMode = 0;
    this.strokeColor = "black";
    this.strokeStyle = undefined;
    this.strokeWidth = 0.0;
    this.strokeBehind = false;
    this.strokeJoin = "miter";
    //Shadow
    this.shadow = { active: false, color:'rgba(10, 10, 10, 0.3)', offsetX: 3, offsetY: 3, blur: 1 };
    //Text Alignment
    this.align = "left";
    this.baseline = "top";
    this.offsetFactor = 0;
    this.spacing = 0;
    this.padding = 2;
    //Wrap
    this.wordWrap = false;
    this.wordWrapWidth = 100;
    this.breakWords = false;
};

// Set a number of properties at once
tbVectorFont.prototype.setProperties = function(properties) {
    "use strict";
    // Font Face
    if (properties.fontFace !== undefined) { this.fontFace = properties.fontFace; }
    if (properties.fallbackFontFace !== undefined) { this.fallbackFontFace = properties.fallbackFontFace; }
    //Font
    if (properties.fontStyle !== undefined) { this.fontStyle = properties.fontStyle; }
    if (properties.fontWeight !== undefined) { this.fontWeight = properties.fontWeight; }
    if (properties.fontCase !== undefined) { this.fontCase = properties.fontCase; }
    if (properties.fontSize !== undefined) { this.fontSize = properties.fontSize; }
    //Fill
    if (properties.fill !== undefined) { this.fill = properties.fill; }
    if (properties.fillAlpha !== undefined) { this.fillAlpha = properties.fillAlpha; }
    if (properties.fillColor !== undefined) { this.fillMode = 0; this.fillColor = properties.fillColor; }
    if (properties.fillPattern !== undefined) { this.fillMode = 1; this.fillPattern = properties.fillPattern; }
    if (properties.fillGradient !== undefined) { this.fillMode = 2; this.fillGradient = properties.fillGradient; }
    if (properties.fillStyle !== undefined) { this.fillMode = 3; this.fillStyle = properties.fillStyle; }
    //Stroke
    if (properties.stroke !== undefined) { this.stroke = properties.stroke; }
    if (properties.strokeAlpha !== undefined) { this.strokeAlpha = properties.strokeAlpha; }
    if (properties.strokeColor !== undefined) { this.strokeMode = 0; this.strokeColor = properties.strokeColor; }
    if (properties.strokeStyle !== undefined) { this.strokeMode = 3; this.strokeStyle = properties.strokeStyle; }
    if (properties.strokeWidth !== undefined) { this.strokeWidth = properties.strokeWidth; }
    if (properties.strokeBehind !== undefined) { this.strokeBehind = properties.strokeBehind; }
    if (properties.strokeJoin !== undefined) { this.strokeJoin = properties.strokeJoin; }
    //Shadow
    if (properties.shadow !== undefined) { this.shadow = properties.shadow; }
    //Text Alignment
    if (properties.align !== undefined) { this.align = properties.align; }
    if (properties.baseline !== undefined) { this.baseline = properties.baseline; }
    if (properties.offsetFactor !== undefined) { this.offsetFactor = properties.offsetFactor; }
    if (properties.spacing !== undefined) { this.spacing = properties.spacing; }

    if (properties.wordWrap !== undefined) { this.wordWrap = properties.wordWrap; }
    if (properties.wordWrapWidth !== undefined) { this.wordWrapWidth = properties.wordWrapWidth; }
    if (properties.breakWords !== undefined) { this.breakWords = properties.breakWords; }
    if (properties.padding !== undefined) { 
        this.padding = properties.padding; 
    }
    else {
        this.padding = 2;
    }

    this.style = new PIXI["TextStyle"](this.textStyle());

    this.font["setStyle"](this.style);

    this.setAnchorAlign();
    this.setAnchorBaseline();
};

tbVectorFont.prototype.textStyle = function() {
    "use strict";

    if (this.shadow.active) {
        var x = this.shadow.offsetX;
        var y = this.shadow.offsetY;

        this.shadow.angle = Math.atan2(y, x); 
        this.shadow.distance = Math.sqrt(x * x + y * y);
    }    
    else {
        this.shadow.angle = 0; 
        this.shadow.distance = 0;
    }

    var style = {
        "fontFamily" : this.fontFace,
        "fontStyle" : this.fontStyle,
        "fontWeight" : this.fontWeight,
        "fontVariant" : this.fontCase,
        "fontSize" : this.fontSize,
        "fill" : this.fillColor,
        "stroke" : this.strokeColor,
        "strokeThickness" : this.strokeWidth,
        "lineJoin" : this.strokeJoin,
        //Shadow
        "dropShadow" : this.shadow.active,
        "dropShadowBlur" : this.shadow.blur,
        "dropShadowColor" : this.shadow.color,
        "dropShadowAngle" : this.shadow.angle,
        "dropShadowDistance" : this.shadow.distance,

        //Wrap
        "wordWrap" : this.wordWrap,
        "wordWrapWidth" : this.wordWrapWidth,
        "breakWords" : this.breakWords,

        //General
        "align" : this.align,
        //"textBaseline" : this.baseline,
        "letterSpacing" : this.spacing,
        "padding" : this.padding
    }

    return style;
};

tbVectorFont.prototype.setStyle = function(){
    "use strict";
    if(this.font) {
        this.font["setStyle"](this.textStyle());
        this.style = this.font["style"];
    }
};

tbVectorFont.prototype.setAnchorAlign = function() {
    "use strict";
    if(this.font){
        switch (this.align){
            case "left":
                this.anchorX = 0;
                break;
            case "center":
                this.anchorX = 0.5;
                break;
            case "right":
                this.anchorX = 1;
                break;
        }

        this.font["anchor"]["set"](this.anchorX, this.anchorY);
    }
};

tbVectorFont.prototype.setAnchorBaseline = function() {
    "use strict";
    if(this.font){
        switch(this.baseline){
            case "top":
                this.anchorY = 0;
                break;
            case "middle":
                this.anchorY = 0.5;
                break;
            case "bottom":
                this.anchorY = 1;
                break;
        }

        this.font["anchor"]["set"](this.anchorX, this.anchorY);
    }
};

tbVectorFont.prototype.setFontFace = function(fontFace) {
    "use strict";
    this.fontFace = fontFace;

    this.setStyle();
};

tbVectorFont.prototype.getFontFace = function() {
    "use strict";
    return this.fontFace;
};

tbVectorFont.prototype.setFallbackFontFace = function(fallbackFontFace) {
    "use strict";
    this.fallbackFontFace = fallbackFontFace;
};

tbVectorFont.prototype.getFallbackFontFace = function() {
    "use strict";
    return this.fallbackFontFace;
};

tbVectorFont.prototype.setFontStyle = function(fontStyle) {
    "use strict";
    this.fontStyle = (fontStyle === undefined) ? "" : fontStyle;

    this.setStyle();
};

tbVectorFont.prototype.getFontStyle = function() {
    "use strict";
    return this.fontStyle;
};

tbVectorFont.prototype.setFontWeight = function(fontWeight) {
    "use strict";
    this.fontWeight = (fontWeight === undefined) ? "" : fontWeight;

    this.setStyle();
};

tbVectorFont.prototype.getFontWeight = function() {
    "use strict";
    return this.fontWeight;
};

tbVectorFont.prototype.setFontCase = function(fontCase) {
    "use strict";
    this.fontCase = (fontCase === undefined) ? "normal" : fontCase;

    this.setStyle();
};

tbVectorFont.prototype.getFontCase = function() {
    "use strict";
    return this.fontCase;
};

tbVectorFont.prototype.setFontSize = function(fontSize) {
    "use strict";
    this.fontSize = (fontSize === undefined) ? 12 : fontSize;

    this.setStyle();
};

tbVectorFont.prototype.getFontSize = function() {
    "use strict";
    return this.fontSize;
};

tbVectorFont.prototype.setFill = function(fill) {
    "use strict";
    this.fill = (fill === undefined) ? true : fill;

    this.setStyle();
};

tbVectorFont.prototype.getFill = function() {
    "use strict";
    return this.fill;
};

tbVectorFont.prototype.setFillAlpha = function(alpha) {
    "use strict";
    this.fillAlpha = (alpha === undefined) ? 1 : alpha;

    this.setStyle();
};

tbVectorFont.prototype.getFillAlpha = function() {
    "use strict";
    return this.fillAlpha;
};

tbVectorFont.prototype.setFillColor = function(color) {
    "use strict";
    this.fillMode = 0;
    this.fillColor = (color === undefined) ? "black" : color;

    this.setStyle();
};

tbVectorFont.prototype.getFillColor = function() {
    "use strict";
    return this.fillColor;
};

tbVectorFont.prototype.setWordWrap = function(wordWrap, wordWrapWidth) {
    "use strict";
    this.wordWrap = (wordWrap != undefined) ? wordWrap : this.wordWrap;
    this.wordWrapWidth = wordWrapWidth ? wordWrapWidth : this.wordWrapWidth;

    this.setStyle();
};

tbVectorFont.prototype.setFillPattern = function(obj, subImage, repeatH, repeatV) {
    "use strict";
    // if (obj === undefined) { return; }
    // this.fillMode = 1;
    // if (obj instanceof tbImage) {
    //     this.fillPattern = {image: obj, subImage: subImage, repeatH: repeatH, repeatV: repeatV};
    // } else {
    //     this.fillPattern = {image: obj.image, subImage: obj.subImage, repeatH: obj.repeatH, repeatV: obj.repeatV};
    // }
};

tbVectorFont.prototype.getFillPattern = function() {
    "use strict";
    // return {image: this.fillPattern.image, subImage: this.fillPattern.subImage, repeatH: this.fillPattern.repeatH, repeatV: this.fillPattern.repeatV	};
};

tbVectorFont.prototype.setFillGradient = function(obj, number, colors, size, offset) {
    "use strict";
    // if (obj === undefined) { return; }
    // this.fillMode = 2;
    // if (obj instanceof Object)
    // {
    //     this.fillGradient.vertical = obj.vertical;
    //     this.fillGradient.number = obj.number;
    //     this.fillGradient.colors = obj.colors.slice(0);
    //     this.fillGradient.size = obj.size;
    //     this.fillGradient.offset = obj.offset;
    // } else {
    //     this.fillGradient.vertical = obj;
    //     this.fillGradient.number = number;
    //     this.fillGradient.colors = colors.slice(0);
    //     this.fillGradient.size = (size === undefined) ? 0.6 : size;
    //     this.fillGradient.offset = (offset === undefined) ? 0 : offset;
    // }
};

tbVectorFont.prototype.getFillGradient = function() {
    "use strict";
    return {
        vertical: this.fillGradient.vertical,
        number: this.fillGradient.number,
        colors: this.fillGradient.colors.slice(0),
        size: this.fillGradient.size,
        offset: this.fillGradient.offset
    };
};

tbVectorFont.prototype.setFillStyle = function(style) {
    "use strict";
    // this.fillMode = 3;
    // this.fillStyle = (style === undefined) ? "black" : style;
};

tbVectorFont.prototype.getFillStyle = function() {
    "use strict";
    return this.fillStyle;
};

tbVectorFont.prototype.setStroke = function(stroke) {
    "use strict";
    this.stroke = (stroke === undefined) ? false : stroke;

    this.setStyle();
};

tbVectorFont.prototype.getStroke = function() {
    "use strict";
    return this.stroke;
};

tbVectorFont.prototype.setStrokeAlpha = function(alpha) {
    "use strict";
    this.strokeAlpha = (alpha === undefined) ? 1 : alpha;
};

tbVectorFont.prototype.getStrokeAlpha = function() {
    "use strict";
    return this.strokeAlpha;
};

tbVectorFont.prototype.setStrokeColor = function(color) {
    "use strict";
    this.strokeMode = 0;
    this.strokeColor = (color === undefined) ? "black" : color;

    this.setStyle();
};

tbVectorFont.prototype.getStrokeColor = function() {
    "use strict";
    return this.strokeColor;
};

tbVectorFont.prototype.setStrokeStyle = function(style) {
    "use strict";
    this.strokeMode = 3;
    this.strokeStyle = (style === undefined) ? "black" : style;

    this.setStyle();
};

tbVectorFont.prototype.getStrokeStyle = function() {
    "use strict";
    return this.strokeStyle;
};

tbVectorFont.prototype.setStrokeWidth = function(width) {
    "use strict";
    this.strokeWidth = (width === undefined) ? 1 : width;
	
    this.setStyle();
};

tbVectorFont.prototype.getStrokeWidth = function() {
    "use strict";
    return this.strokeWidth;
};

tbVectorFont.prototype.setStrokeBehind = function(behind) {
    "use strict";
    this.strokeBehind = (behind === undefined) ? false : behind;
};

tbVectorFont.prototype.getStrokeBehind  = function() {
    "use strict";
    return this.strokeBehind;
};

tbVectorFont.prototype.setStrokeJoin = function(join) {
    "use strict";
    this.strokeJoin = (join === undefined) ? "miter" : join;

    this.setStyle();
};

tbVectorFont.prototype.getStrokeJoin = function() {
    "use strict";
    return this.strokeJoin;
};

tbVectorFont.prototype.setShadow = function(obj, color, offsetX, offsetY, blur) {
    "use strict";
    if (obj === undefined) {
        this.shadow = { active: false, color: 'rgba(10, 10, 10, 0.3)', offsetX: 3, offsetY: 3, blur: 1, angle: Math.PI/6};
    } else if (obj instanceof Object)
    {
        this.shadow = { active: obj.active, color: obj.color, offsetX: obj.offsetX, offsetY: obj.offsetY, blur: obj.blur, angle: obj.angle};
    } else if (color === undefined) {
        this.shadow.active = obj;
    } else {
        this.shadow = { active: obj, color: color, offsetX: offsetX, offsetY: offsetY, blur: blur , angle: Math.PI/6};
    }

    this.setStyle();
};

tbVectorFont.prototype.getShadow = function() {
    "use strict";
    return { active: this.shadow.active, color: this.shadow.color, offsetX: this.shadow.offsetX, offsetY: this.shadow.offsetY, blur: this.shadow.blur , angle: this.shadow.angle};
};

tbVectorFont.prototype.setAlign = function(align) {
    "use strict";
    this.align = (align === undefined) ? "left" : align;

    this.setAnchorAlign();
};

tbVectorFont.prototype.getAlign = function() {
    "use strict";
    return this.align;
};

tbVectorFont.prototype.setBaseline = function(baseline) {
    "use strict";
    this.baseline = (baseline === undefined) ? "top" : baseline;

    this.setAnchorBaseline();
};

tbVectorFont.prototype.getBaseline = function() {
    "use strict";
    return this.baseline;
};

tbVectorFont.prototype.setOffsetFactor = function(offsetFactor) {
    "use strict";
    this.offsetFactor = (offsetFactor === undefined) ? 0 : offsetFactor;

    this.setStyle();
};

tbVectorFont.prototype.getOffsetFactor = function() {
    "use strict";
    return this.offsetFactor;
};

tbVectorFont.prototype.setLineSpacing = function(spacing) {
    "use strict";
    this.spacing = (spacing === undefined) ? 0 : spacing;

    this.setStyle();
};

tbVectorFont.prototype.getLineSpacing = function() {
    "use strict";
    return this.spacing;
};

tbVectorFont.prototype.addChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.animation) {
            _obj = obj.animation;
        } else if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.font){
            this.font["addChild"](_obj);
        } else {
            console.log("No font attached");
        }
    }
};

tbVectorFont.prototype.removeChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.animation) {
            _obj = obj.animation;
        } else if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.font){
            this.font["removeChild"](_obj);
        } else {
            console.log("No font attached");
        }
    }
};

tbVectorFont.prototype.add = function(container){
    "use strict";
    var obj;

    if(this.font){
        obj = this.font;
    } else {
        console.log("No font attached");
    }

    if(obj){
        if(container && container["addChild"]){
            container["addChild"](obj);
        } else {
            tgfGraphics.addChild(obj);
        }
    }
};

tbVectorFont.prototype.remove = function(container){
    "use strict";
    var obj;

    if(this.font){
        obj = this.font;
    } else {
        console.log("No font attached");
    }

    if(obj){
        if(container && container["removeChild"]){
            container["removeChild"](obj);
        } else {
            tgfGraphics.removeChild(obj);
        }
    }
};

tbVectorFont.prototype.free = function(alsoChildren){
    "use strict";

    if (typeof alsoChildren === "undefined") {
        alsoChildren = true;
    }

    if(this.font){
        
        if (this.font && this.font.destroy)
        this.font["destroy"](alsoChildren);
        this.font = null;
    }
};

tbVectorFont.prototype.setText = function (text) {
    "use strict";
    if(this.font && text){
        this.text = text;
        this.font["setText"](text);
    }
};

tbVectorFont.prototype.setPosition = function(x, y) {
    "use strict";

    this.x = x;
    this.y = y;

    if(this.font){
        this.font["position"]["set"](this.x, this.y);
    }
};

tbVectorFont.prototype.setRotation = function(r) {
    "use strict";
    this.rotation = r;
    if(this.font){
        this.font["rotation"] = this.rotation;
    }
};

tbVectorFont.prototype.setAlpha = function(a) {
    "use strict";
    if(this.font){
        this.font["alpha"] = a;
    }
};

tbVectorFont.prototype.setScale = function(w, y) {
    "use strict";
    if (this.font) {
        if (y === undefined)
        {
            y = w;
        }
        this.font["scale"]["set"](w, y);
    }
}

tbVectorFont.prototype.setWidth = function(w) {
    "use strict";
    if(this.font){
        this.font["width"] = w;
    }
};

tbVectorFont.prototype.setHeight = function(h) {
    "use strict";
    if(this.font){
        this.font["height"] = h;
    }
};


tbVectorFont.prototype.show = function() {
    "use strict";
    if (this.font){
        this.font["visible"] = true;
    }
};

tbVectorFont.prototype.hide = function() {
    "use strict";
    if (this.font){
        this.font["visible"] = false;
    }
};

//
// Size
//

// Create the font string for the font
tbVectorFont.prototype._getFontString = function() {
    "use strict";
    return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px " + this.fontFace + ", " + this.fallbackFontFace;
};

// Compute the text width for the collection of lines
tbVectorFont.prototype._textWidth = function(lines) {
    "use strict";
    var largestWidth = 0, li;
    for (li = 0; li < lines.length; li += 1) {
        largestWidth = Math.max(largestWidth, lines[li].width);
    }
    return largestWidth;
};

// Compute the text height for the collection of lines
tbVectorFont.prototype._textHeight = function(lines) {
    "use strict";
    return this.fontSize * lines.length + this.spacing * (lines.length - 1);
};

// Compute the text box for the collection of lines placed at (x,y)
tbVectorFont.prototype._textBox = function(lines, x, y) {
    "use strict";
    // var bx = x, by = y,
    //     bw = this._textWidth(lines),
    //     bh = this._textHeight(lines);
    // switch (this.align){
    //     case 'right': bx += -bw; break;
    //     case 'center': bx += -bw/2; break;
    // }
    // switch (this.baseline){
    //     case 'base':
    //     case 'bottom': by += -bh + Math.round(this.offsetFactor * this.fontSize); break;
    //     case 'middle': by += -bh/2 + Math.round(this.offsetFactor * this.fontSize / 2); break;
    // }
    // return {x: bx, y: by, width: bw, height: bh};
};

// Split the text in lines at \n and using the optional width
tbVectorFont.prototype._splitText = function(text, width) {
    "use strict";
    var li, wi, currentLine, words, spaceWidth, wordWidth, currentWidth, lines, output = [],
        context = tbGraphics.fontContext;
    context.font = this._getFontString();
    // Adapt case if required
    switch (this.fontCase) {
        case "upper" : text = text.toUpperCase(); break;
        case "lower" : text = text.toLowerCase(); break;
    }
    // Simple case
    if (width === undefined) {
        lines = text.split('\n');
        for (li = 0; li < lines.length; li += 1) {
            output.push({ text: lines[li], width: context.measureText(lines[li]).width });
        }
        return output;
    }
    // split on \n
    lines = text.split('\n');
    //split on width
    spaceWidth = context.measureText(' ').width;
    for (li = 0; li < lines.length; li += 1) {
        words = lines[li].split(' ');
        currentLine = words[0];
        currentWidth = context.measureText(words[0]).width;
        for (wi = 1; wi < words.length; wi += 1) {
            wordWidth = context.measureText(words[wi]).width;
            if (currentWidth + spaceWidth + wordWidth < width) {
                currentLine += ' ' + words[wi];
                currentWidth += spaceWidth + wordWidth;
            } else {
                output.push({ text: currentLine, width: currentWidth });
                currentLine = words[wi];
                currentWidth = wordWidth;
            }
        }
        output.push({ text: currentLine, width: currentWidth });
    }
    return output;
};

// Return the width of the textbox for the current font
tbVectorFont.prototype.textWidth = function(text, width) {
    "use strict";
    var w,
        text = text ? text : this.text;

    w = PIXI["TextMetrics"]["measureText"](text, this.style, this.wordWrap);

    return w["width"];
};

// Return the height of the textbox for the current font
tbVectorFont.prototype.textHeight = function(text, width) {
    "use strict";
    var h,
        text = text ? text : this.text; 

    // make sure this.style is correct
    h = PIXI["TextMetrics"]["measureText"](text, this.style, this.wordWrap);

    return h["height"];
};

tbVectorFont.prototype.lineInfo = function() {
    "use strict";
    var li;
    var text = text ? text : this.text; 

    // make sure this.style is correct
    li = PIXI["TextMetrics"]["measureText"](text, this.style, this.wordWrap);

    return li;
};

// Return the textbox for the current font when the text is place at x,y
tbVectorFont.prototype.textBox = function(text, x, y, width) {
    "use strict";
    // var h;
    // tbGraphics.fontContext.save();
    // h = this._textBox(this._splitText(text, width), x, y);
    // tbGraphics.fontContext.restore();
    // return h;
};

// Return the largest font size for the text to fit the box. split indicated whether to split lines
tbVectorFont.prototype._textFitSize = function(size, text, width, height, split) {
    "use strict";
    var oldSize = this.fontSize, lines, result;
    this.fontSize = size;
    if (split) {
        lines = this._splitText(text, width);
    } else {
        lines = this._splitText(text);
    }
    result = this._textWidth(lines) <= width && this._textHeight(lines) <= height;
    this.fontSize = oldSize;
    return result;
};

// Return the largest font size for the text to fit the box. split indicated whether to split lines
tbVectorFont.prototype.textFitSize = function(text, width, height, split) {
    "use strict";
    // console.warn('BROKEN :: tbVectorFont.textFitSize returns no value');
    var size = 0, increment = 32;
    if (split === undefined) { split = false; }
    tbGraphics.fontContext.save();
    while (this._textFitSize(size+increment, text, width, height, split)) { size += increment; }
    while (increment >= 2) {
        increment /= 2;
        if (this._textFitSize(size+increment, text, width, height, split)) { size += increment; }
    }
    tbGraphics.fontContext.restore();
    return Math.max(4, size);
};

//
// Drawing
//

// Create the pattern for drawing the text
tbVectorFont.prototype._createPattern = function() {
    "use strict";
    // var img = this.fillPattern.image,
    //     surface = new tbSurface(img.width, img.height),
    //     h = this.fillPattern.repeatH,
    //     v = this.fillPattern.repeatV,
    //     repeat;
    // if (h && v) {
    //     repeat = "repeat";
    // } else if (h && !v) {
    //     repeat = "repeat-x";
    // } else if (!h && v) {
    //     repeat = "repeat-y";
    // } else if (!h && !v) {
    //     repeat = "no-repeat";
    // }
    // surface.setTarget();
    // img.drawSimple(this.fillPattern.subImage, 0, 0);
    // surface.resetTarget();
    // return tbGraphics.fontContext.createPattern(surface.canvas, repeat);
};

// Create the gradient for drawing
tbVectorFont.prototype._createGradient = function(bx, by, bw, bh) {
    "use strict";
    // var size = Math.max(0.01, this.fillGradient.size),
    //     offset = this.fillGradient.offset,
    //     gradient, step, i;
    // // Direction
    // if (this.fillGradient.vertical) {
    //     offset = bh/2 + offset*bh;
    //     size *= 0.5*bh;
    //     gradient = tbGraphics.fontContext.createLinearGradient(bx, by + offset-size, bx, by + offset+size);
    // } else {
    //     offset = bw/2 + offset*bw;
    //     size *= 0.5*bw;
    //     gradient = tbGraphics.fontContext.createLinearGradient(bx + offset-size, by, bx  + offset+size, by);
    // }
    // // Colors
    // step = 1 / (this.fillGradient.number-1);
    // for (i = 0; i < this.fillGradient.number; i += 1) {
    //     gradient.addColorStop(i*step, this.fillGradient.colors[i]);
    // }
    // return gradient;
};

// Draw the fill
tbVectorFont.prototype._drawFill = function(context, lines, bx, by, bw, bh, alpha) {
    "use strict";
    // var li, xOffset, yOffset;
    // //Setting the shadow
    // if (this.shadow.active) {
    //     context.shadowColor = this.shadow.color;
    //     context.shadowOffsetX = this.shadow.offsetX;
    //     context.shadowOffsetY = this.shadow.offsetY;
    //     context.shadowBlur = this.shadow.blur;
    // } else {
    //     context.shadowColor = undefined;
    //     context.shadowOffsetX = 0;
    //     context.shadowOffsetY = 0;
    //     context.shadowBlur = 0;
    // }
    // // Set alpha and fill mode
    // context.globalAlpha = alpha * this.fillAlpha;
    // switch (this.fillMode) {
    //     case 0:  context.fillStyle = this.fillColor; break;
    //     case 1:  context.fillStyle = this._createPattern(); break;
    //     case 2:  context.fillStyle = this._createGradient(bx, by, bw, bh); break;
    //     case 3:  context.fillStyle = this.fillStyle; break;
    //     default: context.fillStyle = this.fillColor; break;
    // }
    // // Draw the lines
    // for (li = 0; li < lines.length; li += 1) {
    //     xOffset = 0;
    //     switch (this.align) {
    //         case 'right': xOffset = (bw - lines[li].width); break;
    //         case 'center': xOffset = (bw - lines[li].width)/2; break;
    //     }
    //     yOffset = this.fontSize * (li + 1) + this.spacing * li;
    //     if (this.fillMode === 2 && this.fillGradient.vertical) {
    //         context.fillStyle = this._createGradient(bx, by + yOffset - this.fontSize, bw, this.fontSize);
    //     }
    //     context.fillText(lines[li].text, bx + xOffset, by + yOffset);
    // }
};

// Draw the stroke
tbVectorFont.prototype._drawStroke = function(context, lines, bx, by, bw, bh, alpha) {
    "use strict";
    // var li, xOffset, yOffset;
    // //Setting the shadow
    // if (!this.fill && this.shadow.active) {
    //     context.shadowColor = this.shadow.color;
    //     context.shadowOffsetX = this.shadow.offsetX;
    //     context.shadowOffsetY = this.shadow.offsetY;
    //     context.shadowBlur = this.shadow.blur;
    // } else {
    //     context.shadowColor = undefined;
    //     context.shadowOffsetX = 0;
    //     context.shadowOffsetY = 0;
    //     context.shadowBlur = 0;
    // }
    // // Set alpha and stroke mode
    // context.globalAlpha = alpha * this.strokeAlpha;
    // switch (this.strokeMode) {
    //     case 0: context.strokeStyle = this.strokeColor; break;
    //     case 3: context.strokeStyle = this.strokeStyle; break;
    // }
    // context.lineWidth = this.strokeWidth;
    // context.lineJoin = this.strokeJoin;
    // // Draw the lines
    // for (li = 0; li < lines.length; li += 1) {
    //     xOffset = 0;
    //     switch (this.align) {
    //         case 'right': xOffset = (bw - lines[li].width); break;
    //         case 'center': xOffset = (bw - lines[li].width)/2; break;
    //     }
    //     yOffset = this.fontSize * (li + 1) + this.spacing * li;
    //     context.strokeText(lines[li].text, bx + xOffset, by + yOffset);
    // }
};

// Do the actual drawing of the font
tbVectorFont.prototype._draw = function(context, text, x, y, alpha, width) {
    "use strict";
    // var lines = this._splitText(text, width),
    //     bx = x, by = y,
    //     bw = this._textWidth(lines),
    //     bh = this._textHeight(lines);
    // // Compute the correct position
    // context.textAlign = 'left';
    // context.textBaseline = 'bottom';
    // switch (this.align){
    //     case 'right': bx += -bw; break;
    //     case 'center': bx += -bw/2; break;
    // }
    // switch (this.baseline){
    //     case 'base':
    //     case 'bottom': by += -bh + Math.round(this.offsetFactor * this.fontSize); break;
    //     case 'middle': by += -bh/2 + Math.round(this.offsetFactor * this.fontSize/2); break;
    // }
    // // Setting the font
    // context.font = this._getFontString();
    // // Now do the drawing
    // if (this.stroke && this.strokeBehind) { this._drawStroke(context, lines, bx, by, bw, bh, alpha); }
    // if (this.fill) { this._drawFill(context, lines, bx, by, bw, bh, alpha); }
    // if (this.stroke && !this.strokeBehind) { this._drawStroke(context, lines, bx, by, bw, bh, alpha); }
};

// Draw simple
tbVectorFont.prototype.drawSimple = function(text, x, y, width) {
    "use strict";
    // var context = tbGraphics.context;
    // if(tbGraphics.webGLAvailable){
    //     context = tbGraphics.fontContext;
    // }
    // if (this.fill && this.fillMode === 1) {		// For patterns we must always use transformations
    //     this.drawExt(text, x, y, 1, 1, 0, 1, width);
    // } else {
    //     context.save();
    //     this._draw(context, text, x, y, 1, width);
    //     context.restore();
    // }
};

// Draw with alpha
tbVectorFont.prototype.drawAlpha = function(text, x, y, alpha, width) {
    "use strict";
    // var context = tbGraphics.context;
    // if(tbGraphics.webGLAvailable){
    //     context = tbGraphics.fontContext;
    // }
    // if (this.fill && this.fillMode === 1) {		// For patterns we must always use transformations
    //     this.drawExt(text, x, y, 1, 1, 0, alpha, width);
    // } else {
    //     context.save();
    //     this._draw(context, text, x, y, alpha, width);
    //     context.restore();
    // }
};

// Draw with transformation
tbVectorFont.prototype.drawExt = function(text, x, y, xScale, yScale, angle, alpha, width) {
    "use strict";
    // var context = tbGraphics.context;
    // if(tbGraphics.webGLAvailable){
    //     context = tbGraphics.fontContext;
    // }
    // context.save();
    // context.translate(x, y);
    // context.rotate(-angle * Math.PI/180);
    // context.scale(xScale, yScale);
    // try {
    //     this._draw(context, text, 0, 0, alpha, width);
    // } catch (e) {
    // }
    // context.restore();
};
/////////////////////////////////////////////////////////////
// tbAudio: The engine part dealing with audio and sounds
//
// Copyright 2013-2015 CoolGames
// Last Changed: 26-11-2015
/////////////////////////////////////////////////////////////

var TBAudio = function() {
	"use strict";
    //settings
    this.maxNoOfChannels = 10;
    this._maxConSnds = -1;
	this._maxConSndsPolicy = "stop_lowest_prio";
    //determine audio support
    this.usingWebAudio = false;
    this.usingHTMLAudio = false;
    this.audioSupported = false;
	
    //check webAudio
    var audioObj, self = this,
        ContextClass = (typeof AudioContext !== 'undefined')? AudioContext : ((typeof webkitAudioContext !== 'undefined')? webkitAudioContext : undefined);
    if(ContextClass){
        this.usingWebAudio = true;
    }//check html5 audio
    else if(typeof Audio !== 'undefined'){
        try{
            if(typeof (new Audio()).canPlayType !== 'undefined'){
                this.usingHTMLAudio = true;
            }
        }catch(ignore){}
    }
	this.audioSupported = this.usingWebAudio || this.usingHTMLAudio;
	if(this.usingHTMLAudio && tbBrowser.browser.stockandroid){
		this.maxConcurrentSounds(1);
	}
	
    //check browser codec support
    if(this.audioSupported){
        try{
			audioObj = new Audio();
			this._codecs = {
				'ogg': !!audioObj.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
				'mp3': !!audioObj.canPlayType('audio/mpeg;').replace(/^no$/, ''),
				'opus': !!audioObj.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
				'wav': !!audioObj.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
				'm4a': !!(audioObj.canPlayType('audio/x-m4a;') || audioObj.canPlayType('audio/aac;')).replace(/^no$/, ''),
				'mp4': !!(audioObj.canPlayType('audio/x-mp4;') || audioObj.canPlayType('audio/aac;')).replace(/^no$/, ''),
				'weba': !!audioObj.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')
			};
        }catch(ignore){
			// To solve an issue with the Edge browser on which Audio does not seem to be supported
			this._codecs = {
				'ogg': false,
				'mp3': true,
				'opus': false,
				'wav': false,
				'm4a': false,
				'mp4': false,
				'weba': false
			};
			if (testMode) { console.log("Cannot create Audio object to determine codec support. Only supporting MP3."); }
		}
   }

    //initialise context
    this._activeInstances = [];
    this._inactiveSources = {};
    this._tagVolumeMap = {};
    this._tagVolumeMapBackup = {};
    this._fadingTags = [];
    this._noPlayingInstances = 0;
	if(this.usingWebAudio){
	   //set-up AudioContext
		this._context = new ContextClass();
		this._createGain = (typeof this._context.createGain === "function")? function(){return self._context.createGain();} : ((typeof this._context.createGainNode === "function")? function(){return self._context.createGainNode();} : function(){});
		this._gainNodes = {};
		//create master gain to which all other nodes connect
		this._masterGain = this._createGain();
		if(this._masterGain === undefined){
			this.usingHTMLAudio = true;
			this._loadAudioFile = TBAudio.prototype._loadHTMLAudio;
			return;
		}
		this._masterGain.connect(this._context.destination);
		this._gainNodes["master"] = this._masterGain;

		//set-up loading function
		this._loadAudioFile = TBAudio.prototype._loadWebAudio;
    }else if(this.usingHTMLAudio){
        this._loadAudioFile = TBAudio.prototype._loadHTMLAudio;
    }
    else{
        this._loadAudioFile = function(){};
    }
};

TBAudio.prototype.maxConcurrentSounds = function(max){
    "use strict";
    if(max !== undefined){
        this._maxConSnds = max;
	}
    return this._maxConSnds;
};

TBAudio.prototype.maxConcurrentSoundsPolicy = function(policy){
    "use strict";
    if(policy !== undefined){
        this._maxConSndsPolicy = policy;
    }
    return this._maxConSndsPolicy;
};

TBAudio.prototype._handleStep = function(timePassed){
    "use strict";
    var i, instance, handler, tag, value;
    for(i=0; i<this._activeInstances.length; i+=1){
        instance = this._activeInstances[i];
        if(instance && instance.enginePaused === 0){
            if(!instance.paused){
                instance._timer += timePassed;
                //if instance playback is delayed, check if delay has passed
                if(instance._delayed && instance._timer >= instance.startDelay){
                    instance._delayed = false;
                    this._startPlaying(instance, instance._startOffset);
                }//if instance has reached end sound loop or deactivate
                //not required for web audio because of "onended" event
                else if(instance.playing && this.usingHTMLAudio){
                    if(this.getPosition(instance.id) >= instance.duration ){
                        if(!instance.looping){
                        	instance._source.pause();
                        	tbAudio._handleEndSound(instance);
                    	}else {
                            //web audio is looped automatically, for HTML audio playing pointer has to be reset to start of sound
                        	//check and when necessary wait till audio is in "canPlayThrough" state before updating position
                        	try{
                            	instance._source.pause();
                            	instance._source.currentTime = instance._startOffset/1000;
								if(instance._source.readyState === 4){
									instance._source.play();
								}else{
									handler = (function(){
										var inst = instance;
										return {
											ready: function(){
												inst._source.play();
												inst._source.removeEventListener("canplaythrough", handler.ready, false);
											}
										};
									}());
									instance._source.addEventListener("canplaythrough", handler.ready, false);
								}
							}catch(e){
								if(testMode){
									console.log("error in step when position > duration: " + e.name + ", " + e.message);
								}
							}
                        }
                    }
                }
            }//if instance paused for specific duration, check if duration has passed
            else if(instance._pauseDuration) {
                instance._pauseTimer += timePassed;
                if(instance._pauseTimer >= instance._pauseDuration){
                    this.resume(instance.id);
                }
            }
        }
    }

    //update gain on sounds that are fading
    for(i=this._fadingTags.length-1; i>=0; i-=1){
        tag = this._fadingTags[i];
		if(!this.isPaused(tag.id) && tag.enginePaused === 0){
			tag.timer += timePassed;
			if(tag.timer >= tag.duration){
				tbAudio.setGain(tag.id, tag.targetValue);
				if(this._tagVolumeMapBackup[tag.id] !== undefined){
					this._tagVolumeMapBackup[tag.id] = tag.targetValue;
				}
				if(tag.callback){
					tag.callback();
				}
				this._fadingTags.splice(i, 1);
			}else{
				value = tag.ease(tag.timer, tag.start, tag.targetValue - tag.start, tag.duration);
				tbAudio.setGain(tag.id, value);
				if(this._tagVolumeMapBackup[tag.id] !== undefined){
					this._tagVolumeMapBackup[tag.id] = value;
				}
			}
		}
    }
};

TBAudio.prototype._deactivateInstance = function(instance){
    "use strict";
    //add audio object to inactive sound queue for reuse (without loading)
    if(!this._inactiveSources[instance.sound.sprite.name]){
        this._inactiveSources[instance.sound.sprite.name] = [instance._source];
    }else if(this._inactiveSources[instance.sound.sprite.name].length < this.maxNoOfChannels){
        this._inactiveSources[instance.sound.sprite.name].push(instance._source);
    }
};

TBAudio.prototype._findActiveInstances = function(tag){
    "use strict";
    var i, instance,retVal;
    retVal = [];
    for(i=0; i<this._activeInstances.length; i+=1){
        instance = this._activeInstances[i];
        if(instance){
            if(instance.tags.indexOf(tag) >= 0){
                retVal.push(instance);
            }
        }
    }
    return retVal;
};

TBAudio.prototype._checkPlayPrio = function(sound){
    "use strict";
    if(this._maxConSnds > 0 && this._noPlayingInstances >= this._maxConSnds){
    	switch(this._maxConSndsPolicy){
            case "cancel_new":
                return false;
            case "stop_lowest_prio":
                var i, inst, lowest;
                //find currently playing
                for(i=0; i<this._activeInstances.length; i+=1){
                    inst = this._activeInstances[i];
                    if(inst && inst.playing && !inst.paused){
                        if(lowest === undefined || lowest.priority < inst.priority){
                            lowest = inst;
                        }
                    }
                }
                if(lowest.priority > sound._priority){
                    this.stop(lowest.id);
                    return true;
                }
                return false;
            break;
        }
    }
    return true;
};

TBAudio.prototype._connectWebAudioNode = function(instance){
    "use strict";
	var t, node, totGain = 1;
	for(t=0; t<instance.tags.length; t+=1){
		if(tbAudio._tagVolumeMap[instance.tags[t]] !== undefined){
			totGain *= tbAudio._tagVolumeMap[instance.tags[t]];
		}
	}
	node = this._createGain();
	node.gain.value = totGain;
    node.connect(this._masterGain);
    this._gainNodes[instance.id] = node;
    instance._source.connect(node);
 };

TBAudio.prototype._disconnectWebAudioNode = function(instance){
    "use strict";
    instance._source.disconnect(0);
    if(this._gainNodes[instance.id]){
        this._gainNodes[instance.id].disconnect(0);
        delete this._gainNodes[instance.id];
    }
};

TBAudio.prototype._createSoundSourceInstance = function(sound){
	"use strict";
	var source;
	if(!sound.sprite || !sound.sprite.audio){
		return;
	}
	if(this.usingWebAudio){
		 //create a new source node and add the node to the graph
		source = this._context.createBufferSource();
		source.buffer = sound.sprite.audio;
		source.loopStart = sound.startOffset/1000;
		source.loopEnd = (sound.startOffset + sound.duration)/1000;
		return source;
	}
	if(this.usingHTMLAudio){
		//clone audio node
		source = sound.sprite.audio.cloneNode(true);
		source.volume = 0;
		return source;
		
	}
};

TBAudio.prototype._createSoundInstance = function(sound){
    "use strict";
    var i, instance, sources, s;
    if(this.usingWebAudio){
        s = this._createSoundSourceInstance(sound);
        if(s){
        	instance = new tbSoundInstance(sound,s);
        }
    }else if(this.usingHTMLAudio){
        //check if any audio sources are currently unused,
        //otherwise create new audio source
    	sources = this._inactiveSources[sound.sprite.name];
    	if(!sources){
    		return;
    	}
    	if(sources.length > 0 ){
    		instance = new tbSoundInstance(sound, sources.pop());            
		}else{
			s = this._createSoundSourceInstance(sound);
			if(s){
				instance = new tbSoundInstance(sound, s);
			}
        }         
    }

    //add sound instance to activeInstance array
    if(instance){
        if(this.usingWebAudio){
        	this._connectWebAudioNode(instance);
        }
    	for(i=0; i<this._activeInstances.length; i+=1){
            if(this._activeInstances[i] === undefined){
                this._activeInstances[i] = instance;
                return instance;
            }
        }
        this._activeInstances.push(instance);
    }
	return instance;
};

TBAudio.prototype._selectFormat = function(filenames){
    "use strict";
    var i, ext;
    for(i=0; i<filenames.length; i+=1){
        ext = filenames[i].split('.').pop();
        if(this._codecs[ext]){
            return filenames[i];
        }
    }
    return false;
};

TBAudio.prototype._loadHTMLAudio = function(sprite, urls, moment){
    "use strict";
    var url = tbAudio._selectFormat(urls),
        onerror = function(){
    		tbLoader.loadFailed(moment);
        },
        onload = function(){
        	var audioObjClone;
        	sprite.loaded = true;
        	tbLoader.loadComplete(moment);
        	//round up the duration when using HTML5 Audio to account for the lower precision
        	sprite.duration = Math.ceil(sprite.audio.duration * 1000);
            //remove event handlers
            sprite.audio.removeEventListener("canplaythrough", onload, false);
            sprite.audio.removeEventListener("error", onerror, false);
            //already create one copy of source so it will be pre loaded
            audioObjClone = sprite.audio.cloneNode(true);
            tbAudio._inactiveSources[sprite.name].push(audioObjClone);
        };
    if(url){
    	sprite.audio = new Audio();
    	sprite.audio.src = url;
    	sprite.audio.autoplay = false;
    	sprite.audio.preload = "auto";
    	sprite.audio.addEventListener("canplaythrough", onload, false);
    	sprite.audio.addEventListener("error", onerror, false);
    	sprite.audio.load();
    }else{
        onerror();
    }
};

TBAudio.prototype._loadWebAudio = function(sprite, urls, moment){
    "use strict";
    var url = tbAudio._selectFormat(urls),
        onerror = function(){
            tbLoader.loadFailed(moment);
        },
        onload = function(buffer){
        	sprite.audio = buffer;
            sprite.duration = buffer.duration*1000;
            sprite.loaded = true;
            tbLoader.loadComplete(moment);
        },
        request = new XMLHttpRequest();
     // load the buffer from the URL
    request.open("GET", url, true);
    request.responseType = "arraybuffer";
    request.onload = function() {
        // decode the buffer into an audio source
        tbAudio._context.decodeAudioData(
            request.response,
            function(buffer) {
                if(buffer) {
                    onload(buffer);
                }
            },
            function() {
              onerror();
            }
        );
    };
    request.onerror = function() {
      // if there is an error, switch the sound to HTML Audio
        if(typeof Audio !== "undefined") {
            tbAudio.usingWebAudio = false;
            tbAudio.usingHTMLAudio = true;
            tbAudio._loadAudioFile = TBAudio.prototype._loadHTMLAudio;
            //TODO RELOAD ALL EARLIER SOUNDS AGAIN??
            tbAudio._loadAudioFile(sprite, urls, moment);
        }
    };
    try {
        request.send();
    } catch (e) {}
};

//create and play a new soundInstance
TBAudio.prototype.play = function(item, delay, fadeDuration, fadeEase){
    "use strict";
    if(item instanceof tbSound){
    	if(this._checkPlayPrio(item)){
    		var instance = this._createSoundInstance(item);
    		if(!instance){
    			return -1;
    		}
            instance.startDelay = delay || 0;
            instance._delayed = (delay > 0);
            instance.fadeDuration = fadeDuration || 0;
            instance.fadeEase = fadeEase || function(t,b,c,d){return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;};
            if(!instance._delayed){
            	this._startPlaying(instance, instance._startOffset);
            }
            return instance.id;
    	}
    	return -1;
    }
};

TBAudio.prototype._startPlaying = function(instance, offset){
    "use strict";
    var position;
    if(typeof offset !== "number"){
		offset = 0;
	}
    this._updateGain(instance.id);
    
	if(instance.fadeDuration > 0){
        var gain = this.getTagGain(instance.id);
        this.setGain(instance.id, 0);
        this.fade(instance.id, gain, instance.fadeDuration, instance.fadeEase);
        instance.fadeDuration = 0;
        instance.fadeEase = undefined;
    }
    if(this.usingWebAudio){
        position = offset - instance._startOffset;
    	instance._startTime = this._context.currentTime*1000 - position;
        //instance._source.loop = instance.looping;
        instance._source.onended = function(){tbAudio._handleEndSound(instance);};
        try{
			//check for old function calls as well as new ones
        	if(instance._source.start){
				instance._source.start(0, offset/1000, (instance.duration - position)/1000);
			}else if(instance._source.noteGrainOn){
				instance._source.noteGrainOn(0, offset/1000, (instance.duration - position)/1000);
			}
			instance._started = true;
			instance.playing = true;
			this._noPlayingInstances += 1;
			//must be called after starting sound for Chrome 42
			instance._source.loop = instance.looping;
		}catch(e){
			if(testMode){
				console.log("error in starting sound: " + e.name + ", " + e.message);
			}
		}
    }else if(this.usingHTMLAudio){
    	if(instance._source.readyState !== 4){
			//if not yet ready to play, wait till can play through then play
    		var handler = (function(){
				var inst = instance;
				return {
					ready: function(){
						inst._source.currentTime = offset/1000;
						inst._source.play();
						inst._started = true;
						inst._source.removeEventListener("canplaythrough", handler.ready, false);
					}
				};
			}());
			instance._source.addEventListener("canplaythrough", handler.ready, false);
		}else{
			//already ready so play immediately
			instance._source.currentTime = offset/1000;
			instance._source.play();
			instance._started = true;
		}
		instance.playing = true;
		this._noPlayingInstances += 1;
    }
};

//resume (or start) active instances that match tag
TBAudio.prototype.resume = function(tag, fadeDuration, fadeEase, enginePause){
    "use strict";
    var i, instance, gain, tag, fadingTag, source,
        items = this._findActiveInstances(tag);
    for(i=0; i<items.length; i+=1){
        instance = items[i];
        if(((instance.paused || !instance.playing) && !enginePause) || (!instance.paused && enginePause)){
            if(!enginePause){
				
                //check to see if instance was already fading before pause
            	for(i=this._fadingTags.length-1; i>=0; i-=1){
                    tag = this._fadingTags[i];
            		if(tag.id === instance.id){
            			fadingTag = tag;
            			fadeDuration = 0;
            			fadeEase = undefined;
            			break;
            		}
            	}
            	instance.paused = false;
				instance.fadeDuration = fadeDuration || 0;
				instance.fadeEase = fadeEase || function(t,b,c,d){return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;};
				if(instance._fadedOnPause){
					if(fadeDuration === undefined){
						instance.fadeDuration = instance._fadedOnPause.duration;
					}
					if(fadeEase === undefined){
						instance.fadeEase = instance._fadedOnPause.ease;
					}
					gain = instance._fadedOnPause.gain;
					instance._fadedOnPause = undefined;
				}
			}
            if(this.usingWebAudio){
            	//audio node must be recreated, after sound being stopped on pause it cannot be restarted
            	source = this._createSoundSourceInstance(instance.sound);
            	if(source){
                	instance._source = source;
                    this._connectWebAudioNode(instance);
            	}
            }
            if(gain !== undefined){
            	tbAudio.setGain(instance.id, gain);
            }
            
            //the progress in the sound already made before pausing must be given as a parameter
        	this._startPlaying(instance, instance._startOffset + (instance._pausedPosition || 0));
            
            if(fadingTag !== undefined){
            	tbAudio.setGain(instance.id, fadingTag.ease(fadingTag.timer, fadingTag.start, fadingTag.targetValue - fadingTag.start, fadingTag.duration));
            	tbAudio.fade(instance.id, fadingTag.targetValue, fadingTag.duration - fadingTag.timer, fadingTag.ease, fadingTag.callback);
            }
        }
    }
};

//pause playing active instances that match tag
TBAudio.prototype.pause = function(tag, duration, fadeDuration, fadeEase, enginePause){
    "use strict";
    var i, instance, position,
        items = this._findActiveInstances(tag);
    for(i=0; i<items.length; i+=1){
        instance = items[i];
        if(!instance.paused){
			instance.fadeDuration = fadeDuration || 0;
            if(instance.fadeDuration > 0){
				instance.fadeEase = fadeEase || function(t,b,c,d){return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;};
				//remember gain previous to fading so it can be reset on resume
				instance._fadedOnPause = {gain : tbAudio.getGain(instance.id), duration : instance.fadeDuration, ease: instance.fadeEase};
				tbAudio.fade(instance.id, 0, instance.fadeDuration, instance.fadeEase, function(){tbAudio.pause(instance.id, duration);});
            }else{
            	position = this.getPosition(instance.id);
            	instance._pausedPosition = position;
            	if(!enginePause){
					instance.paused = true;
					instance._pauseTimer = 0;
					instance._pauseDuration = duration;
					this._noPlayingInstances -= 1;
				}
				if(this.usingWebAudio){
					instance._source.onended = function(){};
					if(instance.playing){
						if(instance._started){
							try{
								if(instance._source.stop){
									instance._source.stop(0);
								}else if(instance._source.noteOff){
									instance._source.noteOff(0);
								}
							}catch(e){
								if(testMode){
									console.log("error in stopping sound for pause: "+ e.name + ", " + e.message);								
								}
							}
							instance._started = false;
						}
					}
					this._disconnectWebAudioNode(instance);
				}
				else if(this.usingHTMLAudio){
					instance._source.pause();
				}
			}
        }
    }
};

TBAudio.prototype._handleEndSound = function(instance){
    "use strict";
	if(this._tagVolumeMap[instance.id]){
		delete this._tagVolumeMap[instance.id];
	}
	if(!instance.paused){
		this._noPlayingInstances -= 1;
	}
	if(this.usingWebAudio){
		instance._started = false;
		instance.playing = false;
		this._disconnectWebAudioNode(instance);
	}
	else if(this.usingHTMLAudio){
		//store source for future use
		this._deactivateInstance(instance);
	}
	//remove instance from active instances list
	this._activeInstances[this._activeInstances.indexOf(instance)] = undefined;
};

TBAudio.prototype.stop = function(tag, fadeDuration, fadeEase){
    "use strict";
    var i, instance,
        items = this._findActiveInstances(tag);
    for(i=0; i<items.length; i+=1){
        instance = items[i];
        instance.fadeDuration = fadeDuration || 0;
		if(instance.fadeDuration > 0){
			instance.fadeEase = fadeEase || function(t,b,c,d){return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;};
			tbAudio.fade(instance.id, 0, instance.fadeDuration, instance.fadeEase, function(){tbAudio.stop(instance.id);});
		}else{
			//remove instances from volume map
			if(this._tagVolumeMap[instance.id]){
				delete this._tagVolumeMap[instance.id];
			}
			//update number of sounds playing
			if(instance.playing && !instance.paused){
				this._noPlayingInstances -= 1;
			}
			if(this.usingWebAudio){
				if(instance.playing && !instance.paused && !instance._delayed){
					//make sure sound has already started otherwise an error may occur
					if(instance._started){
						try{
							if(instance._source.stop){
								instance._source.stop(0);
							} else if(instance._source.noteOff){
								instance._source.noteOff(0);
							}
						}catch(e){
							if(testMode){
								console.log("error in stopping sound: " + e.name +", " + e.message);
							}
						}
						instance._started = false;
					}
					this._disconnectWebAudioNode(instance);
				}
			}
			else if(this.usingHTMLAudio){
			    if(!instance._delayed){
			    	instance._source.pause();
			    }
				//reset instance and store for future use
				this._deactivateInstance(instance);
			}
			//remove instance from active instances list
			this._activeInstances[this._activeInstances.indexOf(instance)] = undefined;
			instance.playing = false;
		}
    }
};

TBAudio.prototype.enginePause = function(tag){
    "use strict";
    var i, instance,
        items = this._findActiveInstances(tag);
    for(i=0; i<items.length; i+=1){
        instance = items[i];
		if(instance.enginePaused === 0){
			tbAudio.pause(instance.id, 0, 0, null, true);
		}
		instance.enginePaused += 1;
    }
	for(i=0; i<this._fadingTags.length; i+=1){
        if(tag === 'master' || this._fadingTags[i].id === tag){
            this._fadingTags[i].enginePaused += 1;
		}
    }
};

TBAudio.prototype.engineResume = function(tag){
    "use strict";
    var i, instance,
        items = this._findActiveInstances(tag);
    for(i=0; i<items.length; i+=1){
        instance = items[i];
		instance.enginePaused = Math.max(instance.enginePaused - 1, 0);
		if(instance.enginePaused === 0){
			tbAudio.resume(instance.id, 0, null, true);
		}
	}
	for(i=0; i<this._fadingTags.length; i+=1){
        if(tag === 'master' || this._fadingTags[i].id === tag){
            this._fadingTags[i].enginePaused = Math.max(this._fadingTags[i].enginePaused - 1, 0);
		}
    }
};

TBAudio.prototype.engineResumeForced = function(tag){
    "use strict";
    var i,
        items = this._findActiveInstances(tag);
    for(i=0; i<items.length; i+=1){
        items[i].enginePaused = 0;
		tbAudio.resume(items[i].id, 0, null, true);
    }
	for(i=0; i<this._fadingTags.length; i+=1){
        if(tag === 'master' || this._fadingTags[i].id === tag){
            this._fadingTags[i].enginePaused = 0;
		}
    }
};


TBAudio.prototype.fade = function(tag, targetValue, duration, easeFunction, callback){
    "use strict";
    var i;
    for(i=0; i<this._fadingTags.length; i+=1){
        if(this._fadingTags[i].id === tag){
            this._fadingTags.splice(i, 1);
            break;
        }
    }
    this._fadingTags.push({id:tag, targetValue:targetValue, ease:easeFunction || function(t,b,c,d){return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;},
            duration:duration, timer:0, start:this.getTagGain(tag), callback: callback, enginePaused: 0});
};

TBAudio.prototype.mute = function(tag){
    "use strict";
    var oldVolume;
    if(this._tagVolumeMapBackup[tag] === undefined){
    	oldVolume = (this._tagVolumeMap[tag] !== undefined)?  this._tagVolumeMap[tag] : 1;
    	//set tag gain value to 0
        this.setGain(tag, 0);
    	//store previous gain value of tag
    	this._tagVolumeMapBackup[tag] = oldVolume;
    }
};

TBAudio.prototype.unmute = function(tag){
    "use strict";
    //if a previous gain value was stored, reset tag gain to this value
    if(this._tagVolumeMapBackup[tag] !== undefined){
        this.setGain(tag, this._tagVolumeMapBackup[tag]);
        delete this._tagVolumeMapBackup[tag];
    }
};

TBAudio.prototype.position = function(tag, position){
    "use strict";
    var i, instance, source,
        setPos,
        items = this._findActiveInstances(tag);
    if(!isNaN(position) && position >= 0){
    	for(i=0; i<items.length; i++){
    		instance = items[i];
    		position = position % instance.duration;
            if(this.usingWebAudio){
            	 //cannot go back in buffer so stop current buffer and create new one that starts at given position
            	if(!instance.paused){
            		instance._source.onended = function(){};
            		//make sure sound is already started before trying to stop it
                	if(instance._started){
						try{
							if(instance._source.stop){
								instance._source.stop(0);
							} else if(instance._source.noteOff){
								instance._source.noteOff(0);
							}
						}
						catch(e){
							if(testMode){
								console.log("error in stopping sound for position: " + e.name + ", " +e.message);  
							}
						}
						instance._started = false;
					}
                    this._disconnectWebAudioNode(instance);
                    this._noPlayingInstances -= 1;
                    //create new buffer and start playing from requested position
                    source = this._createSoundSourceInstance(instance.sound);
                    if(source){
                        instance._source = source;
                        this._connectWebAudioNode(instance);
                        this._startPlaying(instance, instance._startOffset + position);
                    }
                }else{
                    instance._pausedPosition = position;
                }
            }else if(this.usingHTMLAudio){
                //check and when necessary wait for sound to be "canPlayThrough" then jump to requested position
            	if(instance._source.readyState === 4){
                    instance._source.currentTime = (instance._startOffset + position)/1000;
                }else{
                    (setPos = function(){
                        var inst = instance,
                            pos = position;
                        return{
                            handler: function(){
                                inst._source.currentTime = (inst._startOffset + pos)/1000;
                                inst._source.removeEventListener("canplaythrough", setPos.handler, false);
                            }
                        };
                    }());
                    instance._source.addEventListener("canplaythrough", setPos.handler, false);
                }
            }
        }
    }
};

TBAudio.prototype.rewind = function(tag){
    "use strict";
    tbAudio.position(tag, 0);
};

TBAudio.prototype.setLooping = function(tag, looping){
    "use strict";
    var i,
        items = this._findActiveInstances(tag);
    for(i=0; i<items.length; i+=1){
        items[i].looping = looping;
		if(this.usingWebAudio){
			//set property on buffer so webaudio api will automatically take care of the looping
			items[i]._source.loop = looping;
		}
    }
};

TBAudio.prototype.setPriority = function(tag, priority){
    "use strict";
    var i,
        items = this._findActiveInstances(tag);
    for(i=0; i<items.length; i+=1){
        items[i].priority = priority;
    }
};

TBAudio.prototype.getInstances = function(tag){
    "use strict";
     var i, instance,
        retVal = [];
    for(i=0; i<this._activeInstances.length; i+=1){
        instance = this._activeInstances[i];
        if(instance){
            if(instance.tags.indexOf(tag) >= 0){
                retVal.push(instance.id);
            }
        }
    }
    return retVal;
};

TBAudio.prototype.getTagGain = function(tag){
    "use strict";
    if(this._tagVolumeMap[tag] !== undefined){
        return this._tagVolumeMap[tag];
    }
    return 1;
};

TBAudio.prototype.getGain = function(id){
    "use strict";
    var t,
        totGain = 1,
        instance = this._findActiveInstances(id)[0];
    if(instance){
        for(t=0; t<instance.tags.length; t+=1){
            if(this._tagVolumeMap[instance.tags[t]] !== undefined){
				totGain *= this._tagVolumeMap[instance.tags[t]];
			}
        }
    }
    return Math.round(100*totGain)/100;
};

TBAudio.prototype.setGain = function(tag, volume){
    "use strict";
    var i, instance, t,
		totGain = 1,
        items = this._findActiveInstances(tag);
    //update tagVolumeMap
    this._tagVolumeMap[tag] = volume;
    //unmute sound if was muted
    if(this._tagVolumeMapBackup[tag]){
    	delete this._tagVolumeMapBackup[tag];
    }
    //update volume of all instances that have tag
    for(i=0; i<items.length; i+=1){
    	instance = items[i];
    	if(instance.tags.indexOf(tag) >= 0){
    		for(t=0; t<instance.tags.length; t+=1){
                if(this._tagVolumeMap[instance.tags[t]] !== undefined){
    				totGain *= this._tagVolumeMap[instance.tags[t]];
    			}
            }
            totGain = Math.round(100*totGain)/100;
            if(this.usingWebAudio){
                this._gainNodes[instance.id].gain.value = totGain;
            }else if(this.usingHTMLAudio){
                instance._source.volume = totGain;
            }
    	}
    }
};

TBAudio.prototype._updateGain = function(tag){
	"use strict";
    var i, instance, t,
	totGain = 1,
    items = this._findActiveInstances(tag);
    
    //update volume of all instances that have tag
    for(i=0; i<items.length; i+=1){
    	instance = items[i];
		for(t=0; t<instance.tags.length; t+=1){
            if(this._tagVolumeMap[instance.tags[t]] !== undefined){
				totGain *= this._tagVolumeMap[instance.tags[t]];
			}
        }
        totGain = Math.round(100*totGain)/100;
        if(this.usingWebAudio){
            this._gainNodes[instance.id].gain.value = totGain;
        }else if(this.usingHTMLAudio){
            instance._source.volume = totGain;
        }
	}
};

TBAudio.prototype.getTags = function(id){
    "use strict";
    var i, instance, t, tag,
        items = this._findActiveInstances(id),
        retVal = [];
    for(i=0; i<items.length; i+=1){
        instance = items[i];
        for(t=0; t<instance.tags.length; t+=1){
            tag = instance.tags[t];
            if(retVal.indexOf(tag) < 0){
                retVal.push(tag);
            }
        }
    }
    return retVal;
};

TBAudio.prototype.addTags = function(id, tags){
    "use strict";
    var i, instance, t,
        items = this._findActiveInstances(id);
    for(i=0; i<items.length; i+=1){
        instance = items[i];
        tags = [].concat(tags);
        for(t=0; t<tags.length; t+=1){
            if(instance.tags.indexOf(tags[t]) < 0){
                instance.tags.push(tags[t]);
            }
        }
    }
    this._updateGain(id);
};

TBAudio.prototype.removeTags = function(id, tags){
    "use strict";
    var i, instance, t, tag, idx,
        items = this._findActiveInstances(id);
    for(i=0; i<items.length; i+=1){
        instance = items[i];
        tags = [].concat(tags);
        for(t=0; t<tags.length; t+=1){
            tag = tags[t];
            if(tag !== instance.id && tag !== 'master'){
                idx = instance.tags.indexOf(tag);
                if(idx >= 0){
                    instance.tags.splice(idx, 1);
                }
            }
        }
    }
    return instance.tags;
};


TBAudio.prototype.isPaused = function(id){
    "use strict";
    var instance = this._findActiveInstances(id)[0];
    if(instance){
        return instance.paused;
    }
};

TBAudio.prototype.isPlaying = function(id){
    "use strict";
    var instance = this._findActiveInstances(id)[0];
    if(instance){
        return instance.playing;
    }
};

TBAudio.prototype.isActive = function(id){
    "use strict";
    var instance = this._findActiveInstances(id)[0];
    if(instance){
        return true;
    }
    return false;
};

TBAudio.prototype.isLooping = function(id){
    "use strict";
    var instance = this._findActiveInstances(id)[0];
    if(instance){
        return instance.looping;
    }
};

TBAudio.prototype.getFading = function(id){
    "use strict";
    var i;
    for(i=0; i<this._fadingTags.length; i+=1){
        if(this._fadingTags[i].id === id){
            return this._fadingTags[i].targetValue;
        }
    }
    return -1;
};

TBAudio.prototype.getPriority = function(id){
    "use strict";
    var instance = this._findActiveInstances(id)[0];
    if(instance){
        return instance.priority;
    }
};

TBAudio.prototype.getDuration = function(id){
    "use strict";
    var instance = this._findActiveInstances(id)[0];
    if(instance){
        return instance.sound.duration;
    }
};

TBAudio.prototype.getPosition = function(id){
    "use strict";
    var instance = this._findActiveInstances(id)[0];
    if(instance){
        if(this.usingWebAudio){
            if(instance.paused){
                return instance._pausedPosition;
            }
            return (tbAudio._context.currentTime*1000 - instance._startTime)%instance.duration;
        }
        if(tbAudio.usingHTMLAudio){
            return Math.ceil(instance._source.currentTime*1000 - instance._startOffset);
        }   
    }
};

//create the tbAudio object
var tbAudio = new TBAudio();

//
// AudioSprites
//

//The constructor for a tbAudioSprite object
var tbAudioSprite = function(name, mp3Name, oggName, loading){
	"use strict";
	this.name = name;
	this.mp3Name = mp3Name;
	this.oggName = oggName;
	this.loadingMoment = loading;
    this.loaded = false;
    this.audio = null;
    tbLoader.addResource(this, this.loadingMoment, 1);
};

tbAudioSprite.prototype.startLoading = function(moment, location){
	"use strict";
	var fnameMp3, fnameOgg;
	fnameMp3 = this.mp3Name;
	if (fnameMp3.toLowerCase().indexOf("http:") !== 0 && fnameMp3.toLowerCase().indexOf("https:") !== 0) {
		fnameMp3 = location + fnameMp3;
	}
	fnameOgg = this.oggName;
	if (fnameOgg.toLowerCase().indexOf("http:") !== 0 && fnameOgg.toLowerCase().indexOf("https:") !== 0) {
		fnameOgg = location + fnameOgg;
	}
	tbAudio._inactiveSources[this.name] = [];
    tbAudio._loadAudioFile(this, [fnameOgg, fnameMp3], moment);
};

tbAudioSprite.prototype.complete = function(){
	"use strict";
	return this.loaded;
};

//
// Sounds
//

// The constructor for a tbSound object
var tbSound = function(name, sprite, offset, duration, gain, priority, tags) {
	"use strict";
	// Copy the arguments
	this.name = name;
	this.sprite = sprite;
	this.startOffset = offset;
	this.duration = duration;

    tbAudio.setGain(this.name, ((gain !== undefined)? gain: 1));
    this._priority = (priority !== undefined)? priority : 10;
    this.tags = [];
    if(tags){
        this.tags = this.tags.concat(tags);
    }
    if(this.tags.indexOf(this.name) < 0){
        this.tags.push(this.name);
    }
};

tbSound.prototype.complete = function(){
	"use strict";
	return this.sprite.complete();
};

// Gets or Sets the priority of the sound object
tbSound.prototype.priority = function(priority) {
	"use strict";
	if(priority !== undefined){
		this._priority = priority;
	}
	return this._priority;
};

// Gets the tags of the sound object
tbSound.prototype.getTags = function() {
	"use strict";
	//return shallow copy of array
	return this.tags.slice(0);
};

// Adds tags to the sound object
tbSound.prototype.addTags = function(tags) {
	"use strict";
	var t;
	tags = [].concat(tags);
	for(t=0; t<tags.length; t+=1){
		if(this.tags.indexOf(tags[t]) < 0){
			this.tags.push(tags[t]);
		}
	}
};

// Removes tags from the sound object
tbSound.prototype.removeTags = function(tags) {
	"use strict";
	var t, tag, idx;
	tags = [].concat(tags);
	for(t=0; t<tags.length; t+=1){
		tag = tags[t];
		if(tag !== this.name){
			idx = this.tags.indexOf(tag);
			if(idx >= 0){
				this.tags.splice(idx, 1);
			}
		}
	}
};

//
// SoundInstances
//

// The constructor for a soundInstance
var tbSoundInstance = function(sound, source) {
	"use strict";
	this.sound = sound;
    this._startOffset = this.sound.startOffset;
    this._endTime = this._startOffset + this.sound.duration;
    this._source = source;
    this.duration = this.sound.duration;
    this._init();
};

tbSoundInstance.prototype._init = function(){
    "use strict";
    this.id =  Math.round(Date.now() * Math.random()) + "";
    this.tags = ["master", this.id].concat(this.sound.tags);
    this.priority = (this.sound._priority !== undefined)? this.sound._priority : 10;
    this.looping = false;
    this.playing = false;
    this.paused = false;
	this.enginePaused = 0;
    this._timer = 0;
    this._delayed = false;
	this._started = false;
	this._pausedPosition = 0;
    this.startDelay = 0;

	//set initial gain
	var t, totGain = 1;
	for(t=0; t<this.tags.length; t+=1){
		if(tbAudio._tagVolumeMap[this.tags[t]] !== undefined){
			totGain *= tbAudio._tagVolumeMap[this.tags[t]];
		}
	}
	if(tbAudio.usingWebAudio){
		//tbAudio._gainNodes[this.id].gain.value = totGain;
	}else if(tbAudio.usingHTMLAudio){
		this._source.volume = totGain;
	}
};/////////////////////////////////////////////////////////////
// tbData: The engine part dealing with data files
//
// Copyright 2013 CoolGames
// Last Changed: 9-9-2013
/////////////////////////////////////////////////////////////

// The constructor for the data file object
var tbDataFile = function(name, fileName, info) {
	"use strict";
	this.name = name;
	this.fileName = fileName;
	this.info = info;
};


// The constructor for the text object
var tbText = function(name) {
	"use strict";
	this.name = name;
	this.text = "";						// The text
	this.complete = false;
	this.failed = false;
};

// Loading state changed
tbText.prototype._loaded = function(request) {
	"use strict";
	if (request.readyState === 4) {
		this.complete = true;
		this.failed = (request.status !== 200);
		if (this.failed) {
			tbGame.addSpecial("Get Failed", {name: this.name} );
		} else {
			this.text = request.responseText;
			tbGame.addSpecial("Get Complete", {name: this.name} );
		}
	}
};

// Posting state changed
tbText.prototype._posted = function(request) {
	"use strict";
	if (request.readyState === 4) {
		this.complete = true;
		this.failed = (request.status !== 200);
		if (this.failed) {
			tbGame.addSpecial("Post Failed", {name: this.name} );
		} else {
			tbGame.addSpecial("Post Complete", {name: this.name} );
		}
	}
};

// Get the text from an url
tbText.prototype.get = function(url) {
	"use strict";
	var self = this,
		request = new XMLHttpRequest(),
		ready = function() { self._loaded(request); };
	this.complete = false;
	request.open("GET", url);
	request.onreadystatechange = ready;
	request.send(null);
};

// Post the text to an url
tbText.prototype.post = function(url) {
	"use strict";
	var self = this,
		request = new XMLHttpRequest(),
		ready = function() { self._posted(request); };
	this.complete = false;
	request.open("POST", url);
	request.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
	request.onreadystatechange = ready;
	request.send(this.text);
};

// Get the text from an url synchronous
tbText.prototype.getSynchronous = function(url) {
	"use strict";
	var request = new XMLHttpRequest();
	request.open("GET", url, false);
	try {
		request.send();
	} catch (e) {
		return false;
	}
	this.complete = true;
	this.failed = (request.status !== 200);
	if (this.failed) {
		return false;
	}
	this.text = request.responseText;
	return true;
};

// Post the text to an url synchronous
tbText.prototype.postSynchronous = function(url) {
	"use strict";
	var request = new XMLHttpRequest();
	request.open("POST", url);
	request.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
	try {
		request.send(this.text);
	} catch(e) {
		return false;
	}
	this.complete = true;
	this.failed = (request.status !== 200);
	return (!this.failed);
};

// Parse the text as a JSON object
tbText.prototype.parseJSON = function() {
	"use strict";
	if (JSON === undefined) {
		return ({ });
	} else {
		return JSON.parse(this.text);
	}
};

// Stringify an object into a JSON text
tbText.prototype.stringifyJSON = function(obj) {
	"use strict";
	if (JSON === undefined) {
		this.text = "";
	} else {
		this.text = JSON.stringify(obj);
	}
};

tbText.prototype._browserSupportsLocalStorage = function() {
	try {
		return 'localStorage' in window && window['localStorage'] !== null;
	} catch (e) {
		return false;
	}
};

tbText.prototype.localStorageStore = function(key) {
	"use strict";

	if (this._browserSupportsLocalStorage()) {
		var localStorage = window.localStorage;
		localStorage.setItem(key || this.name, this.text);
	}
};

tbText.prototype.localStorageRetrieve = function(key) {
	"use strict";

	if (this._browserSupportsLocalStorage()) {
		var localStorage = window.localStorage;
		this.text = localStorage.getItem(key || this.name);
	}
	else {
		this.text = null;
	}
};

/////////////////////////////////////////////////////////////
// tbGame: The game object that handles the main loop and
// all the event processing
//
// Copyright 2013-2015 CoolGames
// Last Changed: 3-9-2015
/////////////////////////////////////////////////////////////

var TBGame = function(mainCanvas) {
	"use strict";
	if (mainCanvas) { this.mainCanvas = mainCanvas; }
	// Initialize the tokens
	this.clear();
	// Initialize the event handlers
	var self = this;
	this._initEventCounters();
	this._initClick(self);
	this._initTouch(self);
	this._initKeyboard(self);
	this._initAlarm(self);
	this._initSpecial(self);
	this._initPause(self);
	this._initLoop(self);

	this.renderCallback = null;
};

// Clears the game state, removing all tokens and elements
TBGame.prototype.clear = function() {
	"use strict";
	this._tokens = [];
	this._tokenOrderChanged = false;
	this._elements = [];
	this._elementOrderChanged = false;
	this._isPreventDefaultEnabled = true;
};

// Clears all events
TBGame.prototype.clearAllEvents = function() {
	"use strict";
	this.clearClickEvents();
	this.clearTouchEvents();
	this.clearKeyboardEvents();
	this.clearAlarmEvents();
	this.clearSpecialEvents();
};

// Sets the main canvas (required for finding touch event positions)
TBGame.prototype.setMainCanvas = function(mainCanvas) {
	"use strict";
	this.mainCanvas = mainCanvas;
};

// ********************************************
// ** Event counters
// ** For each class of events we maintain the number of tokens that
// ** use it. We only run through the array when this number is positive
// ********************************************

// Initialize the event counters
TBGame.prototype._initEventCounters = function() {
	"use strict";
	this._numberBeginStepEvents = 0;
	this._numberClickEvents = 0;
	this._numberTouchEvents = 0;
	this._numberKeyEvents = 0;
	this._numberAlarmEvents = 0;
	this._numberSpecialEvents = 0;
	this._numberEndStepEvents = 0;
	this._numberImmediateClickEvents = 0;
	this._numberImmediateTouchEvents = 0;
	this._numberImmediateKeyEvents = 0;
	this._numberImmediateSpecialEvents = 0;
};

// Add to the event counters
TBGame.prototype._addEventCounters = function(token) {
	"use strict";
	if (token.handleBeginStep) { this._numberBeginStepEvents += 1; }
	if (token.handleClick) { this._numberClickEvents += 1; }
	if (token.handleTouchDown || token.handleTouchUp) { this._numberTouchEvents += 1; }
	if (token.handleMouseWheel) { this._numberTouchEvents += 1; }
	if (token.handleKeyDown || token.handleKeyUp) { this._numberKeyEvents += 1; }
	if (token.handleAlarm) { this._numberAlarmEvents += 1; }
	if (token.handleSpecial) { this._numberSpecialEvents += 1; }
	if (token.handleEndStep) { this._numberEndStepEvents += 1; }
	if (token.handleImmediateClick) { this._numberImmediateClickEvents += 1; }
	if (token.handleImmediateTouchDown || token.handleImmediateTouchUp) { this._numberImmediateTouchEvents += 1; }
	if (token.handleImmediateMouseWheel) { this._numberImmediateTouchEvents += 1; }
	if (token.handleImmediateKeyDown || token.handleImmediateKeyUp) { this._numberImmediateKeyEvents += 1; }
	if (token.handleImmediateSpecial) { this._numberImmediateSpecialEvents += 1; }
};

// Subtract from the event counters
TBGame.prototype._subtractEventCounters = function(token) {
	"use strict";
	if (token.handleBeginStep) { this._numberBeginStepEvents -= 1; }
	if (token.handleClick) { this._numberClickEvents -= 1; }
	if (token.handleTouchDown || token.handleTouchUp) { this._numberTouchEvents -= 1; }
	if (token.handleMouseWheel) { this._numberTouchEvents -= 1; }
	if (token.handleKeyDown || token.handleKeyUp) { this._numberKeyEvents -= 1; }
	if (token.handleAlarm) { this._numberAlarmEvents -= 1; }
	if (token.handleSpecial) { this._numberSpecialEvents -= 1; }
	if (token.handleEndStep) { this._numberEndStepEvents -= 1; }
	if (token.handleImmediateClick) { this._numberImmediateClickEvents -= 1; }
	if (token.handleImmediateTouchDown || token.handleImmediateTouchUp) { this._numberImmediateTouchEvents -= 1; }
	if (token.handleImmediateMouseWheel) { this._numberImmediateTouchEvents -= 1; }
	if (token.handleImmediateKeyDown || token.handleImmediateKeyUp) { this._numberImmediateKeyEvents -= 1; }
	if (token.handleImmediateSpecial) { this._numberImmediateSpecialEvents -= 1; }
};

// ********************************************
// ** Dealing with the click
// ********************************************

// Initialize the click handling
TBGame.prototype._initClick = function(self) {
	"use strict";
	window.addEventListener('click', function(e) {self._doClick(e); } , false);
	this.clearClickEvents();
};

// Clears the click events
TBGame.prototype.clearClickEvents = function() {
	"use strict";
	this._clickInfo = {x:0, y:0};
	this._clickAction = [];				// The clicks since the last step
};

// Add a click event
TBGame.prototype.addClickEvent = function(x, y) {
	"use strict";
	var i, tok, handled;
	this._clickInfo.x = x;
	this._clickInfo.y = y;
	this._clickAction.push( { x: this._clickInfo.x, y: this._clickInfo.y } );
	// Handle the immediate events
	if (this._numberImmediateClickEvents > 0) {
		for (i = this._tokens.length-1; i >= 0; i -= 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && tok.handleImmediateClick) {
				handled = tok.handleImmediateClick(this._clickInfo.x, this._clickInfo.y);
				if (handled === true) { break; }
			}
		}
	}
};

// Handle a click event
TBGame.prototype._doClick = function(e) {
	"use strict";
	var canvas, bbox, x, y;
	if (this.mainCanvas === undefined) { return; }
	if (this._paused > 0) { return; }
	canvas = this.mainCanvas;
	bbox = canvas.getBoundingClientRect();
	x = (e.clientX - bbox.left) * (canvas.width / bbox.width);
	y = (e.clientY - bbox.top) * (canvas.height / bbox.height);
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	this.addClickEvent(x, y);
};

// Send the correct click events to the tokens
TBGame.prototype._handleClickEvents = function() {
	"use strict";
	var c, i, tok, act;
	if (this._clickAction.length === 0) { return; }
	// Send the events to the tokens
	if (this._numberClickEvents > 0) {
		for (i = this._tokens.length-1; i >= 0; i -= 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && tok.handleClick) {
				for (c = 0; c < this._clickAction.length; c += 1) {
					act = this._clickAction[c];
					if (act.handled !== true) {
						act.handled = tok.handleClick(act.x, act.y);
					}
				}
			}
		}
	}
	// Clear the click events
	this._clickAction = [];
};

// Return the click x position
TBGame.prototype.clickX = function() {
	"use strict";
	return this._clickInfo.x;
};

// Return the click y position
TBGame.prototype.clickY = function() {
	"use strict";
	return this._clickInfo.y;
};


// ********************************************
// ** Dealing with the touch
// ********************************************

// Initialize the touch handling
TBGame.prototype._initTouch = function(self) {
	"use strict";
	window.addEventListener('mousedown', function(e) {self._doMouseDown(e); } , false);
	window.addEventListener('mouseup', function(e) {self._doMouseUp(e); } , false);
	window.addEventListener('mousemove', function(e) {self._doMouseMove(e); } , false);
	window.addEventListener('touchstart', function(e) {self._doTouchStart(e); } , false);
	window.addEventListener('touchend', function(e) {self._doTouchEnd(e); } , false);
	window.addEventListener('touchmove', function(e) {self._doTouchMove(e); } , false);
	window.addEventListener('touchleave', function(e) {self._doTouchLeave(e); } , false);
	window.addEventListener('touchcancel', function(e) {self._doTouchCancel(e); } , false);
	window.addEventListener("mousewheel", function(e) {self._doMouseWheel(e); } , false);     // mouse wheel IE9, Chrome, Safari, Opera
	window.addEventListener("DOMMouseScroll", function(e) {self._doMouseWheel(e); } , false); // Firefox

	this.clearTouchEvents();
	// Hack to avoid touch event also firing mouse events
	this._lastTouchDown = 0;
	this._lastTouchUp = 0;
};

// Clears the touch events
TBGame.prototype.clearTouchEvents = function() {
	"use strict";
	var i;
	this._touchInfo = [];				// The information about the touch event
	for (i=0; i < 16; i += 1) {
		this._touchInfo[i] = {id: -1, down: false, x: 0, y: 0};
	}
	this._touchAction = [];				// The finger that were pressed or released since the last step
};

// We have to determine the finger ourselves as it turns out
// devices like iPad do not follow the numbering standards
// for touch identifiers.
TBGame.prototype._findFinger = function(id) {
	"use strict";
	var finger = -1,
		i;
	// Check whether it exists
	for (i=0; i<16; i += 1) {
		if (this._touchInfo[i].id === id) {
			finger = i;
			break;
		}
	}
	// If not, find first one that is not down
	if (finger === -1) {
		for (i=0; i<16; i += 1) {
			if (!this._touchInfo[i].down) {
				finger = i;
				this._touchInfo[i].id = id;
				break;
			}
		}
	}
	return finger;
};

// Add a touch move event
TBGame.prototype._addTouchMove = function(id, x, y) {
	"use strict";
	var finger, canvas, bbox;
	if (this.mainCanvas === undefined) { return; }
	finger = this._findFinger(id);
	if (finger === -1) { return; }
	canvas = this.mainCanvas;
	bbox = canvas.getBoundingClientRect();
	this._touchInfo[finger].x = (x - bbox.left) * (canvas.width / bbox.width);
	this._touchInfo[finger].y = (y - bbox.top) * (canvas.height / bbox.height);
};

// Add a touch down event
TBGame.prototype._addTouchDownEvent = function(id) {
	"use strict";
	var finger = this._findFinger(id),
		i, tok, handled;
	if (finger === -1) { return; }
	if (this._touchInfo[finger].down) { return; }
	this._touchAction.push( { finger: finger, x: this._touchInfo[finger].x, y: this._touchInfo[finger].y, down: true } );
	this._touchInfo[finger].down = true;
	// Handle the immediate events
	if (this._numberImmediateTouchEvents > 0) {
		for (i = this._tokens.length-1; i >= 0; i -= 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && tok.handleImmediateTouchDown) {
				handled = tok.handleImmediateTouchDown(finger, this._touchInfo[finger].x, this._touchInfo[finger].y);
				if (handled === true) { break; }
			}
		}
	}
};

// Add a touch up event
TBGame.prototype._addTouchUpEvent = function(id) {
	"use strict";
	var finger = this._findFinger(id),
		i, tok, handled;
	if (finger === -1) { return; }
	if (!this._touchInfo[finger].down) { return; }
	this._touchAction.push( { finger: finger, x: this._touchInfo[finger].x, y: this._touchInfo[finger].y, down: false } );
	this._touchInfo[finger].down = false;
	// Handle the immediate events
	if (this._numberImmediateTouchEvents > 0) {
		for (i = this._tokens.length-1; i >= 0; i -= 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && tok.handleImmediateTouchUp) {
				handled = tok.handleImmediateTouchUp(finger, this._touchInfo[finger].x, this._touchInfo[finger].y);
				if (handled === true) { break; }
			}
		}
	}
};

// Add a touch down event for a finger (rather than an id)
TBGame.prototype.addTouchDownEvent = function(finger) {
	"use strict";
	this._addTouchDownEvent(this._touchInfo[finger].id);
};

// Add a touch up event for a finger (rather than an id)
TBGame.prototype.addTouchUpEvent = function(finger) {
	"use strict";
	this._addTouchUpEvent(this._touchInfo[finger].id);
};

//Add a mouse wheel event
TBGame.prototype.addMouseWheelEvent = function(delta) {
	"use strict";
	var finger = 0,
		i, tok, handled;
	this._touchAction.push( { finger: finger, x: this._touchInfo[finger].x, y: this._touchInfo[finger].y, wheelDelta: delta < 0 ? -1 : 1, realDelta: delta } );
	// Handle the immediate events
	if (this._numberImmediateTouchEvents > 0) {
		for (i = this._tokens.length-1; i >= 0; i -= 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && tok.handleImmediateMouseWheel) {
				handled = tok.handleImmediateMouseWheel(delta < 0 ? -1 : 1, this._touchInfo[finger].x, this._touchInfo[finger].y, delta);
				if (handled === true) { break; }
			}
		}
	}
};

// Handle a mouse button down event
TBGame.prototype._doMouseDown = function(e) {
	"use strict";
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	window.focus();					// Because we cancel this with the previous command
	if (this._lastTouchDown >= Date.now()-1000) { return; }	// Hack to avoid a mouse down soon after a touch down event
	this._addTouchMove(0,e.clientX,e.clientY);
	this._addTouchDownEvent(0);
};

// Handle a mouse up event
TBGame.prototype._doMouseUp = function(e) {
	"use strict";
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	if (this._lastTouchUp >= Date.now()-1000) { return; }	// Hack to avoid a mouse down soon after a touch up event
	this._addTouchMove(0,e.clientX,e.clientY);
	this._addTouchUpEvent(0);
};

// Handle a mouse move event
TBGame.prototype._doMouseMove = function(e) {
	"use strict";
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	this._addTouchMove(0,e.clientX,e.clientY);
};

// Handle a mouse wheel event
TBGame.prototype._doMouseWheel = function(e) {
	"use strict";
	var delta;
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	window.focus();					// Becaused we cancel this with the previous command
	delta = e.wheelDelta || -e.detail;
	this.addMouseWheelEvent(delta);
};

// Handle a touch start event
TBGame.prototype._doTouchStart = function(e) {
	"use strict";
	var touches = e.changedTouches,
		i;
	this._lastTouchDown = Date.now();
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	window.focus();					// Because we cancel this with the previous command
	for (i=0; i<touches.length; i += 1) {
		this._addTouchMove(touches[i].identifier,touches[i].clientX,touches[i].clientY);
		this._addTouchDownEvent(touches[i].identifier);
	}
};

// Handle a touch end event
TBGame.prototype._doTouchEnd = function(e) {
	"use strict";
	var touches = e.changedTouches,
		i;
	this._lastTouchUp = Date.now();
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	for (i=0; i<touches.length; i += 1)	{
		this._addTouchMove(touches[i].identifier,touches[i].clientX,touches[i].clientY);
		this._addTouchUpEvent(touches[i].identifier);
	}
};

// Handle a touch leave event
TBGame.prototype._doTouchLeave = function(e) {
	"use strict";
	var touches = e.changedTouches,
		i;
	this._lastTouchUp = Date.now();
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	for (i=0; i<touches.length; i += 1)	{
		this._addTouchMove(touches[i].identifier,touches[i].clientX,touches[i].clientY);
		this._addTouchUpEvent(touches[i].identifier);
	}
};

// Handle a touch cancel event
TBGame.prototype._doTouchCancel = function(e) {
	"use strict";
	var touches = e.changedTouches,
		i;
	this._lastTouchUp = Date.now();
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	for (i=0; i<touches.length; i += 1)	{
		this._addTouchMove(touches[i].identifier,touches[i].clientX,touches[i].clientY);
		this._addTouchUpEvent(touches[i].identifier);
	}
};

// Handle a touch move event
TBGame.prototype._doTouchMove = function(e) {
	"use strict";
	var touches = e.changedTouches,
		i;
	if (this._paused > 0) { return; }
	if(this._isPreventDefaultEnabled){
		e.preventDefault();
	}
	for (i=0; i<touches.length; i += 1)	{
		this._addTouchMove(touches[i].identifier,touches[i].clientX,touches[i].clientY);
	}
};

// Send the correct touch events to the tokens
TBGame.prototype._handleTouchEvents = function() {
	"use strict";
	var c, i, tok, act;
	if (this._touchAction.length === 0) { return; }
	// Send the events to the tokens
	if (this._numberTouchEvents > 0) {
		for (i = this._tokens.length-1; i >= 0; i -= 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && (tok.handleTouchDown || tok.handleTouchUp || tok.handleMouseWheel)) {
				for (c = 0; c < this._touchAction.length; c += 1) {
					act = this._touchAction[c];
					if (act.handled !== true) {
						if (act.wheelDelta !== undefined && tok.handleMouseWheel) {
							act.handled = tok.handleMouseWheel(act.wheelDelta, act.x, act.y, act.realDelta);
						} else if (act.down && tok.handleTouchDown) {
							act.handled = tok.handleTouchDown(act.finger, act.x, act.y);
						} else if (act.down !== undefined && !act.down && tok.handleTouchUp) {
							act.handled = tok.handleTouchUp(act.finger, act.x, act.y);
						}
					}
				}
			}
		}
	}
	// Clear the touch events
	this._touchAction = [];
};

// Check whether a touch finger is down
TBGame.prototype.touchDown = function(finger) {
	"use strict";
	return this._touchInfo[finger].down;
};

// Returns the touch id
TBGame.prototype.touchId = function(finger) {
	"use strict";
	return this._touchInfo[finger].id;
};

// Return the touch x position
TBGame.prototype.touchX = function(finger) {
	"use strict";
	return this._touchInfo[finger].x;
};

// Return the touch y position
TBGame.prototype.touchY = function(finger) {
	"use strict";
	return this._touchInfo[finger].y;
};


// ********************************************
// ** Dealing with the keyboard
// ********************************************

// Initialize the keyboard handling
TBGame.prototype._initKeyboard = function(self) {
	"use strict";
	window.addEventListener('keydown', function(e) {self._doKeyDown(e); } , false);
	window.addEventListener('keyup', function(e) {self._doKeyUp(e); } , false);
	this.clearKeyboardEvents();
};

// Clears the keyboard handling
TBGame.prototype.clearKeyboardEvents = function() {
	"use strict";
	var i;
	this._keyDown = [];							// Whether the key is currently down
	for (i=0; i< 256; i += 1) {
		this._keyDown[i] = false;
	}
	this._keyAction = [];						// The keys that were pressed or released since the last step
};

// Add a key down event
TBGame.prototype.addKeyDownEvent = function(keyCode) {
	"use strict";
	var i, tok, handled;
	if (this._keyDown[keyCode]) { return; }
	this._keyAction.push( { key: keyCode, down: true } );
	this._keyDown[keyCode] = true;
	// Handle the immediate events
	if (this._numberImmediateKeyEvents > 0) {
		for (i = 0; i < this._tokens.length; i += 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && tok.handleImmediateKeyDown) {
				handled = tok.handleImmediateKeyDown(keyCode);
				if (handled === true) { break; }
			}
		}
	}
};

// Add a key up event
TBGame.prototype.addKeyUpEvent = function(keyCode) {
	"use strict";
	var i, tok, handled;
	if (!this._keyDown[keyCode]) { return; }
	this._keyAction.push( { key: keyCode, down: false } );
	this._keyDown[keyCode] = false;
	// Handle the immediate events
	if (this._numberImmediateKeyEvents > 0) {
		for (i = 0; i < this._tokens.length; i += 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && tok.handleImmediateKeyUp) {
				handled = tok.handleImmediateKeyUp(keyCode);
				if (handled === true) { break; }
			}
		}
	}
};

// Handle a key down event
TBGame.prototype._doKeyDown = function(e) {
	"use strict";
	if (this._paused > 0) { return; }
	if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
		e.preventDefault();
	}
	this.addKeyDownEvent(e.keyCode);
};

// Handle a key up event
TBGame.prototype._doKeyUp = function(e) {
	"use strict";
	if (this._paused > 0) { return; }
	if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
		e.preventDefault();
	}
	this.addKeyUpEvent(e.keyCode);
};

// Send the correct key events to the tokens
TBGame.prototype._handleKeyEvents = function() {
	"use strict";
	var c, i, tok, act;
	if (this._keyAction.length === 0) { return; }
	// Send the events to the tokens
	if (this._numberKeyEvents > 0) {
		for (i=0; i<this._tokens.length; i += 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && (tok.handleKeyDown || tok.handleKeyUp)) {
				for (c=0; c<this._keyAction.length; c += 1) {
					act = this._keyAction[c];
					if (act.handled !== true) {
						if (act.down && tok.handleKeyDown) {
							act.handled = tok.handleKeyDown(act.key);
						} else if (!act.down && tok.handleKeyUp) {
							act.handled = tok.handleKeyUp(act.key);
						}
					}
				}
			}
		}
	}
	// Clear the keyboard events
	this._keyAction = [];
};

// Check whether a key is down
TBGame.prototype.keyboardKeyDown = function(keyCode) {
	"use strict";
	return this._keyDown[keyCode];
};


// ********************************************
// ** Dealing with step events
// ********************************************

// Send a begin step event to the tokens
TBGame.prototype._handleBeginStepEvents = function() {
	"use strict";
	var i, tok;
	if (this._numberBeginStepEvents > 0) {
		for (i=0; i<this._tokens.length; i += 1) {
			tok = this._tokens[i];
			if (tok && tok.handleBeginStep && tok.active && tok._paused <= 0) {
				if (tok.handleBeginStep(this.stepTime) === true) { return; }
			}
		}
	}
};

// Send an end step event to the tokens
TBGame.prototype._handleEndStepEvents = function() {
	"use strict";
	var i, tok;
	if (this._numberEndStepEvents > 0) {
		for (i=0; i<this._tokens.length; i += 1) {
			tok = this._tokens[i];
			if (tok && tok.handleEndStep && tok.active && tok._paused <= 0) {
				if (tok.handleEndStep(this.stepTime) === true) { return; }
			}
		}
	}
};

// ********************************************
// ** Dealing with alarm events
// ********************************************

// Initialize the alarm events
TBGame.prototype._initAlarm = function(self) {
	"use strict";
	this._alarmId = 0;
	this.clearAlarmEvents();
};

// Clears the alarm events
TBGame.prototype.clearAlarmEvents = function() {
	"use strict";
	this._alarmInfo = [];
	this._alarmAction = [];
};

// Find an alarm index
TBGame.prototype._findAlarmIndex = function(id, token) {
	"use strict";
	var i;
	if (token === undefined) { token = null; }
	for (i = 0; i < this._alarmInfo.length; i += 1) {
		if (this._alarmInfo[i].id === id && this._alarmInfo[i].token === token) { return i; }
	}
	return -1;
};

// Add a new alarm
TBGame.prototype.addAlarm = function(time, repeats, token) {
	"use strict";
	if (repeats === undefined) { repeats = 1; }
	if (token === undefined) { token = null; }
	while (this.existsAlarm(this._alarmId, token)) { this._alarmId += 1; }
	this._alarmInfo.push( { id: this._alarmId, time: time, repeats: repeats,
							token: token, timeLeft: time, repeatsLeft: repeats-1, paused: 0 } );
	this._alarmId += 1;
	return this._alarmId-1;
};

// Remove an existing alarm
TBGame.prototype.removeAlarm = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	if (ind >= 0) { this._alarmInfo[ind].id = undefined; }
};

// Checks whether an alarm with the id exists
TBGame.prototype.existsAlarm = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	return ind >= 0;
};

// Set a new or existing alarm
TBGame.prototype.setAlarm = function(id, time, repeats, token) {
	"use strict";
	var n = this._alarmInfo.length,
		i;
	if (repeats === undefined) { repeats = 1; }
	if (token === undefined) { token = null; }
	// Check whether it exists
	for (i = 0; i < this._alarmInfo.length; i += 1) {
		if (this._alarmInfo[i].id === id && this._alarmInfo[i].token === token) { n = i; }
	}
	// Find an unused spot
	if (n === this._alarmInfo.length) {
		for (i = 0; i < this._alarmInfo.length; i += 1) {
			if (this._alarmInfo[i].id === undefined) { n = i; }
		}
	}
	this._alarmInfo[n] = { id: id, time: time, repeats: repeats,
							token: token, timeLeft: time, repeatsLeft: repeats-1, paused: 0 };
};

// Clear an existing alarm
TBGame.prototype.clearAlarm = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	if (ind >= 0) {
		this._alarmInfo[ind].timeLeft = 0;
		this._alarmInfo[ind].repeatsLeft = 0;
	}
};

// Clear all alarms
TBGame.prototype.clearAllAlarms = function() {
	"use strict";
	var i;
	for (i = 0; i < this._alarmInfo.length; i += 1) {
		this._alarmInfo[i].timeLeft = 0;
		this._alarmInfo[i].repeatsLeft = 0;
	}
};

// Get an existing alarm
TBGame.prototype.getAlarm = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	if (ind >= 0) { return this._alarmInfo[ind].timeLeft; } else { return undefined; }
};

// Get an existing alarm percentage
TBGame.prototype.getAlarmPercentage = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	if (ind >= 0) { return 100*this._alarmInfo[ind].timeLeft/this._alarmInfo[ind].time; } else { return undefined; }
};

// Pauses an alarm
TBGame.prototype.pauseAlarm = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	if (ind >= 0) { this._alarmInfo[ind].paused += 1; }
};

// Resumes an alarm
TBGame.prototype.resumeAlarm = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	if (ind >= 0) { this._alarmInfo[ind].paused = Math.max(0, this._alarmInfo[ind].paused-1); }
};

// Resumes an alarm forced
TBGame.prototype.resumeForcedAlarm = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	if (ind >= 0) { this._alarmInfo[ind].paused = 0; }
};

// Returns whether the alarm is paused
TBGame.prototype.isPausedAlarm = function(id, token) {
	"use strict";
	var ind = this._findAlarmIndex(id, token);
	if (ind >= 0) { return this._alarmInfo[ind].paused > 0; } else { return false; }
};

// Pause all alarms
TBGame.prototype.pauseAllAlarms = function() {
	"use strict";
	var i;
	for (i = 0; i < this._alarmInfo.length; i += 1) {
		this._alarmInfo[i].paused += 1;
	}
};

// Resume all alarms
TBGame.prototype.resumeAllAlarms = function() {
	"use strict";
	var i;
	for (i = 0; i < this._alarmInfo.length; i += 1) {
		this._alarmInfo[i].paused = Math.max(0, this._alarmInfo[i].paused-1);
	}
};

// Resume all alarms forced
TBGame.prototype.resumeForcedAllAlarms = function() {
	"use strict";
	var i;
	for (i = 0; i < this._alarmInfo.length; i += 1) {
		this._alarmInfo[i].paused = 0;
	}
};

// Update the alarms
TBGame.prototype._updateAlarms = function(timePassed) {
	"use strict";
	var i, alarm;
	this._alarmAction.length = 0;
	for (i=0; i< this._alarmInfo.length; i += 1) {
		alarm = this._alarmInfo[i];
		if (alarm.id !== undefined && alarm.paused === 0 && (alarm.timeLeft > 0 || alarm.repeatsLeft > 0)) {
			alarm.timeLeft -= timePassed;
			if (alarm.timeLeft <= 0) {
				this._alarmAction.push({id: alarm.id, token: alarm.token});
				if (alarm.repeatsLeft > 0) {
					alarm.repeatsLeft -= 1;
					alarm.timeLeft += alarm.time;
				} else {
					alarm.timeLeft = 0;
				}
			}
		}
	}
};

// Send alarm events to the tokens
TBGame.prototype._handleAlarmEvents = function() {
	"use strict";
	var i, tok, j, act;
	this._updateAlarms(this.stepTime);
	if (this._numberAlarmEvents > 0 && this._alarmAction.length > 0) {
		for (i = 0; i < this._tokens.length; i += 1) {
			tok = this._tokens[i];
			if (tok && tok.handleAlarm && tok.active) {
				for (j = 0; j < this._alarmAction.length; j += 1) {
					act = this._alarmAction[j];
					if (act.handled !== true && (act.token === null || act.token === tok)) {
						act.handled = tok.handleAlarm(act.id);
					}
				}
			}
		}
	}
};


// ********************************************
// ** Dealing with special events
// ********************************************

// Initialize the special events
TBGame.prototype._initSpecial = function(self) {
	"use strict";
	this.clearSpecialEvents();
};

// Clear the special events
TBGame.prototype.clearSpecialEvents = function() {
	"use strict";
	this._specialAction = [];
};

// Add a special event
TBGame.prototype.addSpecial = function(id, args, token) {
	"use strict";
	var i, tok, handled;
	if (token === undefined) { token = null; }
	this._specialAction.push( {id: id, args: args, token: token } );
	// Handle the immediate events
	if (this._numberImmediateSpecialEvents > 0) {
		for (i = 0; i < this._tokens.length; i += 1) {
			tok = this._tokens[i];
			if (tok && tok.active && tok._paused <= 0 && tok.handleImmediateSpecial && (token === null || token === tok)) {
				handled = tok.handleImmediateSpecial(id, args);
				if (handled === true) { break; }
			}
		}
	}
};

// Send special events to the tokens
TBGame.prototype._handleSpecialEvents = function() {
	// console.log(this._tokens, this._specialAction)
	"use strict";
	var i, j, tok, act;
	if (this._numberSpecialEvents > 0 && this._specialAction.length > 0) {
		for (i = 0; i < this._tokens.length; i += 1) {
			tok = this._tokens[i];
			if (tok && tok.handleSpecial && tok.active && tok._paused <= 0) {
				for (j = 0; j < this._specialAction.length; j += 1) {
					act = this._specialAction[j];
					if (act.handled !== true && (act.token === null || act.token === tok)) {
						act.handled = tok.handleSpecial(act.id, act.args);
					}
				}
			}
		}
	}
	this._specialAction.length = 0;
};


// ********************************************
// ** Dealing with drawing events
// ********************************************

// Draws an element
TBGame.prototype._drawElement = function(ind) {
	"use strict";
	var element = this._elements[ind];
	if (!element.visible) { return; }
	// Set the correct canvas
	if (element.canvas !== undefined && element.canvas !== tbGraphics.canvas) {
		tbGraphics.setCanvas(element.canvas);
	}
	// Now draw it if required
	if (tbGraphics.canvas.drawTokens === false && element.forceDraw !== true) { return; }
	if (element._kind === 0) {	// Image
		if (element._paused <= 0) { element.subImage += element.animSpeed*this.stepTime/1000; }
		if (element.xscale === 1 && element.yscale === 1 && element.angle === 0) {
			if (element.alpha === 1) {
				element.image.drawSimple(element.subImage, element.x, element.y);
			} else {
				element.image.drawAlpha(element.subImage, element.x, element.y, element.alpha);
			}
		} else {
			element.image.drawExt(element.subImage, element.x, element.y, element.xscale, element.yscale, element.angle, element.alpha);
		}
	}
	if (element._kind === 1) {	// Text
		if (element.xscale === 1 && element.yscale === 1 && element.angle === 0) {
			if (element.alpha === 1) {
				element.font.drawSimple(element.text, element.x, element.y);
			} else {
				element.font.drawAlpha(element.text, element.x, element.y, element.alpha);
			}
		} else {
			element.font.drawExt(element.text, element.x, element.y, element.xscale, element.yscale, element.angle, element.alpha);
		}
	}
};

// Draws a token
TBGame.prototype._drawToken = function(ind) {
	"use strict";
	var tok = this._tokens[ind];
	if (!tok.visible) { return; }
	// Set the correct canvas
	if (tok.canvas !== undefined && tok.canvas !== tbGraphics.canvas) {
		tbGraphics.setCanvas(tok.canvas);
	}
	// Now draw it if required
	if (tbGraphics.canvas.drawTokens === false && tok.forceDraw !== true) { return; }
	if (tok.handleDraw) { return tok.handleDraw(); }
};

// Handle the drawing and send draw events to the tokens
TBGame.prototype._handleDrawEvents = function() {
	"use strict";
	var nt = 0, ne = 0;
	while (nt < this._tokens.length || ne < this._elements.length) {
		if (ne === this._elements.length) {
			if (this._drawToken(nt) === true) { return; }
			nt += 1;
		} else if (nt === this._tokens.length) {
			this._drawElement(ne);
			ne += 1;
		} else if (this._elements[ne].layer > this._tokens[nt].layer ||
					(this._elements[ne].layer === this._tokens[nt].layer &&
						this._elements[ne].depth > this._tokens[nt].depth)) {
			this._drawElement(ne);
			ne += 1;
		} else {
			if (this._drawToken(nt) === true) { return; }
			nt += 1;
		}
	}
};


// ********************************************
// ** Dealing with pausing
// ********************************************

// Initialize the pausing
TBGame.prototype._initPause = function(self) {
	"use strict";
	this._paused = 0;
	this._pausedDraw = false;
};

// Pause the loop
TBGame.prototype.pause = function(pausedDraw) {
	"use strict";
	this._paused += 1;
	if (pausedDraw === undefined) { pausedDraw = false; }
	this._pausedDraw = pausedDraw;
};

// Resume the loop
TBGame.prototype.resume = function() {
	"use strict";
	if (this._paused === 0) { return; }
	this.lastTime = Date.now(); // To avoid jumps in game time and big step time
	this._paused -= 1;
};

// Resume the loop
TBGame.prototype.resumeForced = function() {
	"use strict";
	if (this._paused === 0) { return; }
	this.lastTime = Date.now(); // To avoid jumps in game time and big step time
	this._paused = 0;
};

// Returns whether the loop is paused
TBGame.prototype.isPaused = function() {
	"use strict";
	return this._paused > 0;
};


// ********************************************
// ** Dealing with the global game loop
// ********************************************

window.__timingStartTime = 0;			// The time just before the step is started
window.__timingFinishTime = 0;			// The time just after the step is finished
window.__timingStepTime = 0;			// The time the step took
window.__timingBetweenTime = 0;			// The time between the start of the current step and the finish of the previous
window.__timingWaitTime = 0;			// The wait time when using setTimeout
window.__timingFrames = 60;				// The desired number of frames per second when using setTimeout
window.__timingInterval = 0;			// The minimal interval used in setTimeout (to give the system some time for processing)
window.__timingForceTimeout = false;	// Whether to force using setTimeout (and not requestAnimationFrame)

// Define the callback function to be called in each step
window.__timingDoAStep = function () {
	"use strict";
	// Remember the current time
	window.__timingStartTime = Date.now();
	window.__timingBetweenTime = window.__timingStartTime - window.__timingFinishTime;
	// Perform a step in the loop
	tbGame._stepLoop();
	// Remember the time when it is finished
	window.__timingFinishTime = Date.now();
	window.__timingStepTime = window.__timingFinishTime - window.__timingStartTime;
	// Set the correct wait time and requestthe next frame
	window.__timingWaitTime = Math.max(window.__timingInterval, 1000/window.__timingFrames - window.__timingStepTime);
	window.__timingRequestNextAnimationFrame(window.__timingDoAStep);
} ;

// Define our own request animation frame function
(function() {
	"use strict";
	// Default use the timeout function
	window.__timingRequestNextAnimationFrame =
		function(callback) {
			window.setTimeout(callback, window.__timingWaitTime);
		};
	// If request animation frame is supported, use that instead
	if (!window.__timingForceTimeout) {
		window.__timingRequestNextAnimationFrame = window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.__timingRequestNextAnimationFrame;
	}
}());

TBGame.prototype.supportsRequestAnimationFrame = function () {
// Returns whether the system supports the use of request animation frame (in some form)
	"use strict";
	return window.requestAnimationFrame !== undefined ||
		window.webkitRequestAnimationFrame !== undefined ||
		window.mozRequestAnimationFrame !== undefined ||
		window.msRequestAnimationFrame !== undefined ||
		window.oRequestAnimationFrame !== undefined;
};

TBGame.prototype.forceUseTimeout = function (force) {
// forces the use of the timeout function instead of request animation frame (or not)
	"use strict";
	window.__timingForceTimeout = force;
	window.__timingDefineFunction();
};

TBGame.prototype.setLoopSpeed = function (framesPerSecond) {
// Sets the number of frames per second (when requestAnimationFrame does not exist)
	"use strict";
	window.__timingFrames = framesPerSecond;
};

TBGame.prototype.setLoopInterval = function (interval) {
// Sets the minimal interval for setTimeout (when requestAnimationFrame does not exist)
	"use strict";
	window.__timingInterval = interval;
};

// Initialize the loop
TBGame.prototype._initLoop = function(self) {
	"use strict";
	// Initialize time (all in milliseconds)
	this.startTime = Date.now();				// The time the game started
	this.lastTime = this.startTime;				// The time for the last step
	this.gameTime = 0;							// The time the game has run so far (sum of step times)
	this.stepTime = 0;							// The time of the last step
	this.maxStepTime = 200;						// The maximal step time passed back in the step events
	this.totalSteps = 0;						// The total number of steps since the start
	// Start the start loading
	this.loadingMoment = "";
	// Set the first loop call using out own version of window.requestNext AnimationFram
	window.__timingRequestNextAnimationFrame(window.__timingDoAStep);
};

// Function to order the tokens and elements and clean them up
TBGame.prototype._order = function() {
	"use strict";

	function sortfunction(a, b){
		return (a.layer === b.layer) ? b.depth-a.depth :((a.layer > b.layer) ? -1 : 1);
	}

	var i, n;
	// Handle the tokens
	n = 0;
	for (i=0; i<this._tokens.length; i += 1) {
		if (this._tokens[i]) {
			// activate when new
			if (this._tokens[i]._activateNew) {
				this._tokens[i]._activateNew = false;
				this._tokens[i].active = true;
			}
			//shift it in the array
			this._tokens[n] = this._tokens[i];
			n += 1;
		}
	}
	this._tokens.length = n;
	if (this._tokenOrderChanged) {
		this._tokens.sort(sortfunction);
	}
	this._tokenOrderChanged = false;
	// Handle the elements
	n = 0;
	for (i=0; i<this._elements.length; i += 1) {
		if (this._elements[i]) {
			this._elements[n] = this._elements[i];
			n += 1;
		}
	}
	this._elements.length = n;
	if (this._elementOrderChanged) {
		this._elements.sort(sortfunction);
	}
	this._elementOrderChanged = false;
};

// Handle a time step in the loop
TBGame.prototype._stepLoop = function() {
	"use strict";
	var newTime;
	// Handle paused mode
	if (this._paused > 0) {
		if (this._pausedDraw) {
			this._order();
			this._handleDrawEvents();
		}
		return;
	}
	// Calculate the time passed
	newTime = Date.now();
	// Solve a strange bugin which the time passed becomes NaN
	if(typeof newTime !== "number"){
		newTime = this.lastTime;
	}
	this.stepTime = Math.min(this.maxStepTime, newTime - this.lastTime);
	this.gameTime += this.stepTime;
	this.totalSteps += 1;
	// Deal with loading
	if (this.loadingMoment === "") {
		this.loadingMoment = "start";
		tbLoader.startLoading(this.loadingMoment);
	}
	if (this.loadingMoment === "start" && tbLoader.complete(this.loadingMoment)) {
		this.loadingMoment = "load";
		tbLoader.startLoading(this.loadingMoment);
	}
	if (this.loadingMoment === "load" && tbLoader.complete(this.loadingMoment)) {
		if(tbLoader.exist("images")){
			this.loadingMoment = "images";
            tbLoader.startLoading(this.loadingMoment);
		} else {
            this.loadingMoment = "game";
            tbLoader.startLoading(this.loadingMoment);

            this.preLoadImages();
		}
	}
	if (this.loadingMoment === "images" && tbLoader.complete(this.loadingMoment)) {
		this.loadingMoment = "game";
		tbLoader.startLoading(this.loadingMoment);

        this.preLoadImages();
	}
	// Handle the sounds
	if (typeof tbAudio !== "undefined") {
		tbAudio._handleStep(this.stepTime);
	}
	// Handle the events
	this._handleBeginStepEvents();
	this._handleClickEvents();
	this._handleTouchEvents();
	this._handleKeyEvents();
	this._handleAlarmEvents();
	this._handleSpecialEvents();
	this._handleEndStepEvents();
	// Order and clean up
	this._order();
	// Finally draw
	this._handleDrawEvents();

    if (this.renderCallback) {
    	this.renderCallback();
    }

	// Update the time
	this.lastTime = newTime;
};


TBGame.prototype.preLoadImages = function(){
    "use strict";

    var images = tbLoaderManager.images;
    for (var i = 0; i < images.length; i++) {
        images[i].add();
    }

    if (this.renderCallback) {
    	this.renderCallback();
	}

    for (var i = 0; i < images.length; i++) {
        images[i].remove();
    }
};

// ********************************************
// ** Adding and removing tokens
// ********************************************

// Add a token to the game; the optional activate argument indicates whether to activate it immediately
TBGame.prototype.addToken = function(token, activate) {
	"use strict";
	// Fill in properties if they are missing
	if (token.group === undefined) { token.group = 0; }
	if (token.visible === undefined) { token.visible = true; }
	if (token.active === undefined) { token.active = true; }
	if (token.depth === undefined) { token.depth = 0; }
	if (token.layer === undefined) { token.layer = 0; }
	if (token._paused === undefined) { token._paused = 0; }
	if (token._tags === undefined) { token._tags = []; }
	// Set activation
	token._activateNew = false;
	if (activate !== undefined && activate === false) {
		token._activateNew = true;
		token.active = false;
	}
	this._tokens.push(token);
	this._tokenOrderChanged = true;
	this._addEventCounters(token);
	// Add it to the array
	if (token.handleAdd) {
		token.handleAdd();
	}
};

// Change the depth of a token (also when it is not in the game!)
TBGame.prototype.setTokenDepth = function(token, depth) {
	"use strict";
	if (token.depth !== depth) { this._tokenOrderChanged = true; }
	token.depth = depth;
};

// Change the layer of a token (also when it is not in the game!)
TBGame.prototype.setTokenLayer = function(token, layer) {
	"use strict";
	if (token.layer !== layer) { this._tokenOrderChanged = true; }
	token.layer = layer;
};

// Clears the tags of a token
TBGame.prototype.clearTokenTags = function(token) {
	"use strict";
	token._tags = [];
};

// Returns (a copy of) the tags of a token
TBGame.prototype.getTokenTags = function(token) {
	"use strict";
	var t, tags = [];
	if (token._tags === undefined) { token._tags = []; }
	for (t = token._tags.length-1; t >= 0; t -= 1) { tags.push(token._tags[t]); }
	return tags;
};

// Add tags to a token
TBGame.prototype.addTokenTags = function(token, tags) {
	"use strict";
	var t;
	tags = [].concat(tags);				// Such that it also works for a single value
	if (token._tags === undefined) { token._tags = []; }
	for (t = tags.length-1; t >= 0; t -= 1) {
		if (token._tags.indexOf(tags[t]) < 0) {
			token._tags.push(tags[t]);
		}
	}
};

// Remove tags from a token
TBGame.prototype.removeTokenTags = function(token, tags) {
	"use strict";
	var t, ind;
	tags = [].concat(tags);				// Such that it also works for a single value
	if (token._tags === undefined) { token._tags = []; }
	for (t = tags.length-1; t >= 0; t -= 1) {
		ind = token._tags.indexOf(tags[t]);
		if (ind >= 0) { token._tags.splice(ind, 1); }
	}
};

// Returns all tokens that contain the tag or satisfy the select function
TBGame.prototype.findTokens = function (arg) {
	"use strict";
	var tokens = [],
		i, token;
	if (arg === undefined || arg === "all" || arg === "master") {
		for (i = 0; i < this._tokens.length; i += 1) {
			token = this._tokens[i];
			if (token !== undefined) { tokens.push(token); }
		}
	} else if (typeof arg === "function" ) {
		for (i = 0; i < this._tokens.length; i += 1) {
			token = this._tokens[i];
			if (token !== undefined && arg(token)) { tokens.push(token); }
		}
	} else {
		for (i = 0; i < this._tokens.length; i += 1) {
			token = this._tokens[i];
			if (token !== undefined && token._tags.indexOf(arg) >= 0) { tokens.push(token); }
		}
	}
	return tokens;
};

// Find all tokens (for compatibility)
TBGame.prototype.findAllTokens = function () {
	"use strict";
	return this.findTokens();
};

// Pause a single token
TBGame.prototype.pauseToken = function(token) {
	"use strict";
	token._paused += 1;
};

// Pause a number of tokens
TBGame.prototype.pauseTokens = function(arg) {
	"use strict";
	var i, tokens = this.findTokens(arg);
	for (i = 0; i < tokens.length; i += 1) { this.pauseToken(tokens[i]); }
};

// Resume a single token
TBGame.prototype.resumeToken = function(token) {
	"use strict";
	token._paused = Math.max(0, token._paused-1);
};

// Resume a number of tokens
TBGame.prototype.resumeTokens = function(arg) {
	"use strict";
	var i, tokens = this.findTokens(arg);
	for (i = 0; i < tokens.length; i += 1) { this.resumeToken(tokens[i]); }
};

// Force resume a single token
TBGame.prototype.resumeForcedToken = function(token) {
	"use strict";
	token._paused = 0;
};

// Force resume a number of tokens
TBGame.prototype.resumeForcedTokens = function(arg) {
	"use strict";
	var i, tokens = this.findTokens(arg);
	for (i = 0; i < tokens.length; i += 1) { this.resumeForcedToken(tokens[i]); }
};

// Remove a token from the game
TBGame.prototype.removeToken = function(token) {
	"use strict";
	var ind = this._tokens.indexOf(token);
	if (ind < 0) { return; }
	if (this._tokens[ind].handleRemove) {
		this._tokens[ind].handleRemove();
	}
	this._subtractEventCounters(this._tokens[ind]);
	this._tokens[ind] = undefined;
};

// Removes all tokens that satisfy the argument (tag or function or nothing)
TBGame.prototype.removeTokens = function (arg) {
	"use strict";
	var i, tokens = this.findTokens(arg);
	for (i = 0; i < tokens.length; i += 1) { this.removeToken(tokens[i]); }
};

// Remove all tokens (for compatibility)
TBGame.prototype.removeAllTokens = function () {
	"use strict";
	this.removeTokens();
};

// Counting all tokens that satisfy the argument (tag or function or nothing)
TBGame.prototype.countTokens = function (arg) {
	"use strict";
	var tokens = this.findTokens(arg);
	return tokens.length;
};

// Count all tokens (for compatibility)
TBGame.prototype.countAllTokens = function () {
	"use strict";
	this.countTokens();
};


// ********************************************
// ** Adding and removing images
// ********************************************

// Add an image to the game
TBGame.prototype.addImage = function(image, subImage, animSpeed, x, y, depth, layer) {
	"use strict";
	return this.addImageExt(image, subImage, animSpeed, x, y, 1, 1, 0, 1, depth, layer);
};

// Add a simple image to the game
TBGame.prototype.addImageSimple = function(image, x, y, depth, layer) {
	"use strict";
	return this.addImageExt(image, 0, 0, x, y, 1, 1, 0, 1, depth, layer);
};

// Add an image with alpha value to the game
TBGame.prototype.addImageAlpha = function(image, subImage, animSpeed, x, y, alpha, depth, layer) {
	"use strict";
	return this.addImageExt(image, subImage, animSpeed, x, y, 1, 1, 0, alpha, depth, layer);
};

// Add an image with alpha and transformation to the game
TBGame.prototype.addImageExt = function(image, subImage, animSpeed, x, y, xscale, yscale, angle, alpha, depth, layer) {
	"use strict";
	if (layer === undefined) { layer = 0; }
	this._elements.push({ _kind: 0, image: image, subImage: subImage, animSpeed: animSpeed, visible: true,
						x: x, y: y, xscale: xscale, yscale: yscale, angle: angle, alpha: alpha, depth: depth, layer: layer,
						_paused: 0, _tags: [] });
	this._elementOrderChanged = true;
	return this._elements[this._elements.length-1];
};

// Add an existing image token to the game
TBGame.prototype.addImageToken = function(imageToken) {
	"use strict";
	this._elements.push(imageToken);
	this._elementOrderChanged = true;
};

// Change the depth of an image token
TBGame.prototype.setImageDepth = function(imageToken, depth) {
	"use strict";
	this._elementOrderChanged = (imageToken.depth !== depth);
	imageToken.depth = depth;
};

// Change the layer of an image token
TBGame.prototype.setImageLayer = function(imageToken, layer) {
	"use strict";
	this._elementOrderChanged = (imageToken.layer !== layer);
	imageToken.layer = layer;
};

// Clears the tags of an image token
TBGame.prototype.clearImageTags = function(imageToken) {
	"use strict";
	imageToken._tags = [];
};

// Returns (a copy of) the tags of an image token
TBGame.prototype.getImageTags = function(imageToken) {
	"use strict";
	var t, tags = [];
	if (imageToken._tags === undefined) { imageToken._tags = []; }
	for (t = imageToken._tags.length-1; t >= 0; t -= 1) { tags.push(imageToken._tags[t]); }
	return tags;
};

// Add tags to an image token
TBGame.prototype.addImageTags = function(imageToken, tags) {
	"use strict";
	var t;
	tags = [].concat(tags);				// Such that it also works for a single value
	if (imageToken._tags === undefined) { imageToken._tags = []; }
	for (t = tags.length-1; t >= 0; t -= 1) {
		if (imageToken._tags.indexOf(tags[t]) < 0) {
			imageToken._tags.push(tags[t]);
		}
	}
};

// Remove tags from an image token
TBGame.prototype.removeImageTags = function(imageToken, tags) {
	"use strict";
	var t, ind;
	tags = [].concat(tags);				// Such that it also works for a single value
	if (imageToken._tags === undefined) { imageToken._tags = []; }
	for (t = tags.length-1; t >= 0; t -= 1) {
		ind = imageToken._tags.indexOf(tags[t]);
		if (ind >= 0) { imageToken._tags.splice(ind, 1); }
	}
};

// Returns all images that contain the tag or satisfy the select function
TBGame.prototype.findImages = function (arg) {
	"use strict";
	var imageTokens = [],
		i, imageToken;
	if (arg === undefined || arg === "all" || arg === "master") {
		for (i = 0; i < this._elements.length; i += 1) {
			imageToken = this._elements[i];
			if (imageToken !== undefined && imageToken._kind === 0) { imageTokens.push(imageToken); }
		}
	} else if (typeof arg === "function" ) {
		for (i = 0; i < this._elements.length; i += 1) {
			imageToken = this._elements[i];
			if (imageToken !== undefined && imageToken._kind === 0 && arg(imageToken)) { imageTokens.push(imageToken); }
		}
	} else {
		for (i = 0; i < this._elements.length; i += 1) {
			imageToken = this._elements[i];
			if (imageToken !== undefined && imageToken._kind === 0 && imageToken._tags.indexOf(arg) >= 0) { imageTokens.push(imageToken); }
		}
	}
	return imageTokens;
};

// Find all image tokens (for compatibility)
TBGame.prototype.findAllImages = function () {
	"use strict";
	return this.findImages();
};

// Pause a single image token
TBGame.prototype.pauseImage = function(imageToken) {
	"use strict";
	imageToken._paused += 1;
};

// Pause a number of image tokens
TBGame.prototype.pauseImages = function(arg) {
	"use strict";
	var i, imageTokens = this.findImages(arg);
	for (i = 0; i < imageTokens.length; i += 1) { this.pauseImage(imageTokens[i]); }
};

// Resume a single image token
TBGame.prototype.resumeImage = function(imageToken) {
	"use strict";
	imageToken._paused = Math.max(0, imageToken._paused-1);
};

// Resume a number of image tokens
TBGame.prototype.resumeImages = function(arg) {
	"use strict";
	var i, imageTokens = this.findImages(arg);
	for (i = 0; i < imageTokens.length; i += 1) { this.resumeImage(imageTokens[i]); }
};

// Force resume a single image token
TBGame.prototype.resumeForcedImage= function(imageToken) {
	"use strict";
	imageToken._paused = 0;
};

// Force resume a number of images token
TBGame.prototype.resumeForcedImages = function(arg) {
	"use strict";
	var i, imageTokens = this.findImages(arg);
	for (i = 0; i < imageTokens.length; i += 1) { this.resumeForcedImage(imageTokens[i]); }
};

// Remove an image token from the game
TBGame.prototype.removeImage = function(imageToken) {
	"use strict";
	var ind = this._elements.indexOf(imageToken);
	if (ind < 0) { return; }
	this._elements[ind] = undefined;
};

// Removes all image tokens that satisfy the argument (tag or function or nothing)
TBGame.prototype.removeImages = function (arg) {
	"use strict";
	var i, imageTokens = this.findImages(arg);
	for (i = 0; i < imageTokens.length; i += 1) { this.removeImage(imageTokens[i]); }
};

// Remove all image tokens (for compatibility)
TBGame.prototype.removeAllImages = function () {
	"use strict";
	this.removeImages();
};

// Counting all image tokens that satisfy the argument (tag or function or nothing)
TBGame.prototype.countImages = function (arg) {
	"use strict";
	var imageTokens = this.findImages(arg);
	return imageTokens.length;
};

// Count all image tokens (for compatibility)
TBGame.prototype.countAllImages = function () {
	"use strict";
	this.countImages();
};

// ********************************************
// ** Adding and removing texts
// ********************************************

// Add a simple text to the game
TBGame.prototype.addTextSimple = function(text, font, x, y, depth, layer) {
	"use strict";
	return this.addTextExt(text, font, x, y, 1, 1, 0, 1, depth, layer);
};

// Add a text with alpha value to the game
TBGame.prototype.addTextAlpha = function(text, font, x, y, alpha, depth, layer) {
	"use strict";
	return this.addTextExt(text, font, x, y, 1, 1, 0, alpha, depth, layer);
};

// Add a text with alpha and transformation to the game
TBGame.prototype.addTextExt = function(text, font, x, y, xscale, yscale, angle, alpha, depth, layer) {
	"use strict";
	if (layer === undefined) { layer = 0; }
	this._elements.push({ _kind: 1, text: text, font: font, visible: true,
						x: x, y: y, xscale: xscale, yscale: yscale, angle: angle, alpha: alpha, depth: depth, layer: layer,
						_tags: [] });
	this._elementOrderChanged = true;
	return this._elements[this._elements.length-1];
};

// Add an existing text token to the game
TBGame.prototype.addTextToken = function(textToken) {
	"use strict";
	this._elements.push(textToken);
	this._elementOrderChanged = true;
};

// Change the depth of a text token
TBGame.prototype.setTextDepth = function(textToken, depth) {
	"use strict";
	this._elementOrderChanged = (textToken.depth !== depth);
	textToken.depth = depth;
};

// Change the layer of a text token
TBGame.prototype.setTextLayer = function(textToken, layer) {
	"use strict";
	this._elementOrderChanged = (textToken.layer !== layer);
	textToken.layer = layer;
};

// Clears the tags of a text token
TBGame.prototype.clearTextTags = function(textToken) {
	"use strict";
	textToken._tags = [];
};

// Returns (a copy of) the tags of a text token
TBGame.prototype.getTextTags = function(textToken) {
	"use strict";
	var t, tags = [];
	if (textToken._tags === undefined) { textToken._tags = []; }
	for (t = textToken._tags.length-1; t >= 0; t -= 1) { tags.push(textToken._tags[t]); }
	return tags;
};

// Add tags to a text token
TBGame.prototype.addTextTags = function(textToken, tags) {
	"use strict";
	var t;
	tags = [].concat(tags);				// Such that it also works for a single value
	if (textToken._tags === undefined) { textToken._tags = []; }
	for (t = tags.length-1; t >= 0; t -= 1) {
		if (textToken._tags.indexOf(tags[t]) < 0) {
			textToken._tags.push(tags[t]);
		}
	}
};

// Remove tags from a text token
TBGame.prototype.removeTextTags = function(textToken, tags) {
	"use strict";
	var t, ind;
	tags = [].concat(tags);				// Such that it also works for a single value
	if (textToken._tags === undefined) { textToken._tags = []; }
	for (t = tags.length-1; t >= 0; t -= 1) {
		ind = textToken._tags.indexOf(tags[t]);
		if (ind >= 0) { textToken._tags.splice(ind, 1); }
	}
};

// Returns all texts that contain the tag or satisfy the select function
TBGame.prototype.findTexts = function (arg) {
	"use strict";
	var textTokens = [],
		i, textToken;
	if (arg === undefined || arg === "all" || arg === "master") {
		for (i = 0; i < this._elements.length; i += 1) {
			textToken = this._elements[i];
			if (textToken !== undefined && textToken._kind === 1) { textTokens.push(textToken); }
		}
	} else if (typeof arg === "function" ) {
		for (i = 0; i < this._elements.length; i += 1) {
			textToken = this._elements[i];
			if (textToken !== undefined && textToken._kind === 1 && arg(textToken)) { textTokens.push(textToken); }
		}
	} else {
		for (i = 0; i < this._elements.length; i += 1) {
			textToken = this._elements[i];
			if (textToken !== undefined && textToken._kind === 1 && textToken._tags.indexOf(arg) >= 0) { textTokens.push(textToken); }
		}
	}
	return textTokens;
};

// Find all text tokens (for compatibility)
TBGame.prototype.findAllTexts = function () {
	"use strict";
	return this.findTexts();
};

// Remove a text token from the game
TBGame.prototype.removeText = function(textToken) {
	"use strict";
	var ind = this._elements.indexOf(textToken);
	if (ind < 0) { return; }
	this._elements[ind] = undefined;
};

// Removes all text tokens that satisfy the argument (tag or function or nothing)
TBGame.prototype.removeTexts = function (arg) {
	"use strict";
	var i, textTokens = this.findTexts(arg);
	for (i = 0; i < textTokens.length; i += 1) { this.removeText(textTokens[i]); }
};

// Remove all text tokens (for compatibility)
TBGame.prototype.removeAllTexts = function () {
	"use strict";
	this.removeTexts();
};

// Counting all text tokens that satisfy the argument (tag or function or nothing)
TBGame.prototype.countTexts = function (arg) {
	"use strict";
	var textTokens = this.findTexts(arg);
	return textTokens.length;
};

// Count all text tokens (for compatibility)
TBGame.prototype.countAllTexts = function () {
	"use strict";
	this.countTexts();
};

TBGame.prototype.disablePreventDefault = function(){
	this._isPreventDefaultEnabled = false;
};

// Now generate the tbGame object
var tbGame = new TBGame(mainCanvas);
/////////////////////////////////////////////////////////////
// tbConstants: The engine part dealing constants and basic functions
//
// Copyright 2013 CoolGames
// Last Changed: 14-5-2013
/////////////////////////////////////////////////////////////


var tbKeyCodes = {
	vkCancel: 3,
	vkHelp: 6,
	vkBackspace: 8,
	vkTab: 9,
	vkClear: 12,
	vkReturn: 13,
	vkEnter: 14,
	vkShift: 16,
	vkControl: 17,
	vkAlt: 18,
	vkPause: 19,
	vkCapslock: 20,
	vkEscape: 27,
	vkSpace: 32,
	vkPageup: 33,
	vkPagedown: 34,
	vkEnd: 35,
	vkHome: 36,
	vkLeft: 37,
	vkUp: 38,
	vkRight: 39,
	vkDown: 40,
	vkPrintscreen: 44,
	vkInsert: 45,
	vkDelete: 46,
	vk0: 48,
	vk1: 49,
	vk2: 50,
	vk3: 51,
	vk4: 52,
	vk5: 53,
	vk6: 54,
	vk7: 55,
	vk8: 56,
	vk9: 57,
	vkSemicolon: 59,
	vkEquals: 61,
	vkA: 65,
	vkB: 66,
	vkC: 67,
	vkD: 68,
	vkE: 69,
	vkF: 70,
	vkG: 71,
	vkH: 72,
	vkI: 73,
	vkJ: 74,
	vkK: 75,
	vkL: 76,
	vkM: 77,
	vkN: 78,
	vkO: 79,
	vkP: 80,
	vkQ: 81,
	vkR: 82,
	vkS: 83,
	vkT: 84,
	vkU: 85,
	vkV: 86,
	vkW: 87,
	vkX: 88,
	vkY: 89,
	vkZ: 90,
	vkContextmenu: 93,
	vkNumpad0: 96,
	vkNumpad1: 97,
	vkNumpad2: 98,
	vkNumpad3: 99,
	vkNumpad4: 100,
	vkNumpad5: 101,
	vkNumpad6: 102,
	vkNumpad7: 103,
	vkNumpad8: 104,
	vkNumpad9: 105,
	vkMultiply: 106,
	vkAdd: 107,
	vkSeparator: 108,
	vkSubtract: 109,
	vkDecimal: 110,
	vkDivide: 111,
	vkF1: 112,
	vkF2: 113,
	vkF3: 114,
	vkF4: 115,
	vkF5: 116,
	vkF6: 117,
	vkF7: 118,
	vkF8: 119,
	vkF9: 120,
	vkF10: 121,
	vkF11: 122,
	vkF12: 123,
	vkF13: 124,
	vkF14: 125,
	vkF15: 126,
	vkF16: 127,
	vkF17: 128,
	vkF18: 129,
	vkF19: 130,
	vkF20: 131,
	vkF21: 132,
	vkF22: 133,
	vkF23: 134,
	vkF24: 135,
	vkNumlock: 144,
	vkScrolllock: 145,
	vkComma: 188,
	vkPeriod: 190,
	vkSlash: 191,
	vkBackquote: 192,
	vkOpenbracket: 219,
	vkBackslash: 220,
	vkClosebracket: 221,
	vkQuote: 222,
	vkMeta: 224
};
/////////////////////////////////////////////////////////////
// tbMasks: The engine part dealing collision masks
//
// Copyright 2013 CoolGames
// Last Changed: 9-9-2013
/////////////////////////////////////////////////////////////

// The mask constants
var maskUndefined = -1;
var maskPoint = 0;
var maskLine = 1;
var maskRectangle = 2;
var maskDisk = 3;
var maskPolygon = 4;

// The constructor for the mask
var tbMask = function(kind, args) {
	"use strict";
	var i;
	this.kind = kind;									// The kind of mask
	this.polygon = null;								// The mask area object (depending on the kind)
	switch (this.kind) {
		case maskPoint:
			this.polygon = {x: [args.x], y: [args.y]};
			this.bBoxLeft = args.x;
			this.bBoxTop = args.y;
			this.bBoxRight = args.x;
			this.bBoxBottom = args.y;
			break;
		case maskRectangle:
			this.polygon = {x: [args.x, args.x+args.w-1, args.x+args.w-1, args.x, args.x],
								y: [args.y, args.y, args.y+args.h-1, args.y+args.h-1, args.y]};
			this.bBoxLeft = args.x;
			this.bBoxTop = args.y;
			this.bBoxRight = args.x+args.w-1;
			this.bBoxBottom = args.y+args.h-1;
			break;
		case maskDisk:
			this.polygon = {x: [], y: []};
			this.bBoxLeft = args.x-args.r;
			this.bBoxTop = args.y-args.r;
			this.bBoxRight = args.x+args.r;
			this.bBoxBottom = args.y+args.r;
			break;
		case maskLine:
			this.polygon = {x: [args.x1, args.x2], y: [args.y1, args.y2]};
			this.bBoxLeft = Math.min(args.x1, args.x2);
			this.bBoxTop = Math.min(args.y1, args.y2);
			this.bBoxRight = Math.max(args.x1, args.x2);
			this.bBoxBottom = Math.max(args.y1, args.y2);
			break;
		case maskPolygon:
			this.polygon = {x: [], y: []};
			this.bBoxLeft = args.x[0]; this.bBoxTop = args.y[0]; this.bBoxRight = args.x[0]; this.bBoxBottom = args.y[0];
			for (i=0; i< args.x.length; i += 1) {
				this.polygon.x.push(args.x[i]);
				this.polygon.y.push(args.y[i]);
				this.bBoxLeft = Math.min(this.bBoxLeft,args.x[i]);
				this.bBoxTop = Math.min(this.bBoxTop,args.y[i]);
				this.bBoxRight = Math.max(this.bBoxRight,args.x[i]);
				this.bBoxBottom = Math.max(this.bBoxBottom,args.y[i]);
			}
			this.polygon.x.push(args.x[0]);
			this.polygon.y.push(args.y[0]);
			break;
		default:
			this.bBoxLeft = 0;
			this.bBoxTop = 0;
			this.bBoxRight = -1;
			this.bBoxBottom = -1;
	}
};

// Create a point mask
var tbMaskPoint = function(x, y) {
	"use strict";
	return new tbMask(maskPoint, {x: x, y: y});
};

// Create a rectangle mask
var tbMaskRectangle = function(x, y, w, h) {
	"use strict";
	return new tbMask(maskRectangle, {x: x, y: y, w: w, h: h});
};

// Create an disk mask
var tbMaskDisk = function(x, y, r) {
	"use strict";
	return new tbMask(maskDisk, {x: x, y: y, r: r});
};

// Create a line segment mask
var tbMaskLine = function(x1, y1, x2, y2) {
	"use strict";
	return new tbMask(maskLine, {x1: x1, y1: y1, x2: x2, y2: y2});
};

// Create a triangular mask
var tbMaskTriangle = function(x1, y1, x2, y2, x3, y3) {
	"use strict";
	return new tbMask(maskPolygon, {x: [x1, x2, x3], y: [y1, y2, y3] });
};

// Create a polygonal mask
var tbMaskPolygon = function(x, y) {
	"use strict";
	return new tbMask(maskPolygon, {x: x, y: y});
};

// Create a rectangle mask for a sub-image
var tbMaskSubImage = function(image, number) {
	"use strict";
	// Get the number in range
	number = (Math.round(number) % image.number + image.number) % image.number;
	// Compute the mask
	return new tbMask(maskRectangle, {x: image.subXOff[number]-image.xOrigin,
										y: image.subYOff[number]-image.yOrigin,
										w: image.subW[number],
										h: image.subH[number]});
};

// Create a rectangle mask for an image
var tbMaskImage = function(image) {
	"use strict";
	var x1 = 1000000, x2 = -1000000, y1 = 1000000, y2 = -1000000,
		number, nx1, nx2, ny1, ny2;
	for (number=0; number<image.number; number += 1) {
		nx1 = image.subXOff[number]-image.xOrigin;
		nx2 = nx1 + image.subW[number] - 1;
		ny1 = image.subYOff[number]-image.yOrigin;
		ny2 = ny1 + image.subH[number] - 1;
		if (nx1 < x1) { x1 = nx1; }
		if (nx2 > x2) { x2 = nx2; }
		if (ny1 < y1) { y1 = ny1; }
		if (ny2 > y2) { y2 = ny2; }
	}
	return new tbMask(maskRectangle, {x: x1, y: y1, w: x2-x1+1, h:y2-y1+1});
};


//
// Transformations. All these methods return a new mask. They do not change the current mask
//

tbMask.prototype.clone = function() {
	"use strict";
	var mask = new tbMask(maskUndefined,{ }),
		i;
	mask.kind = this.kind;
	mask.bBoxLeft = this.bBoxLeft;
	mask.bBoxRight = this.bBoxRight;
	mask.bBoxTop = this.bBoxTop;
	mask.bBoxBottom = this.bBoxBottom;
	mask.polygon = {x: [], y: []};
	for (i=0; i<this.polygon.x.length; i += 1) { mask.polygon.x[i] = this.polygon.x[i]; }
	for (i=0; i<this.polygon.y.length; i += 1) { mask.polygon.y[i] = this.polygon.y[i]; }
	return mask;
};

tbMask.prototype.translate = function(tx, ty) {
	"use strict";
	var mask = this.clone(),
		i;
	mask.bBoxLeft += tx;
	mask.bBoxRight += tx;
	mask.bBoxTop += ty;
	mask.bBoxBottom += ty;
	for (i=0; i<mask.polygon.x.length; i += 1) { mask.polygon.x[i] += tx; }
	for (i=0; i<mask.polygon.y.length; i += 1) { mask.polygon.y[i] += ty; }
	return mask;
};

tbMask.prototype.scale = function(sc) {
	"use strict";
	var mask = this.clone(),
		i;
	mask.bBoxLeft *= sc;
	mask.bBoxRight *= sc;
	mask.bBoxTop *= sc;
	mask.bBoxBottom *= sc;
	for (i=0; i<mask.polygon.x.length; i += 1) { mask.polygon.x[i] *= sc; }
	for (i=0; i<mask.polygon.y.length; i += 1) { mask.polygon.y[i] *= sc; }
	return mask;
};

tbMask.prototype.rotate = function(angle) {
	"use strict";
	var point0, point1, r, center, pointx, pointy, i;
	switch (this.kind) {
		case maskPoint:
			point0 = new tbVector(this.polygon.x[0],this.polygon.y[0]);
			point0 = point0.rotate(angle);
			return tbMaskPoint(point0.x,point0.y);
			break;
		case maskLine:
			point0 = new tbVector(this.polygon.x[0],this.polygon.y[0]);
			point0 = point0.rotate(angle);
			point1 = new tbVector(this.polygon.x[1],this.polygon.y[1]);
			point1 = point1.rotate(angle);
			return tbMaskLine(point0.x,point0.y,point1.x,point1.y);
			break;
		case maskDisk:
			r = (this.bBoxRight-this.bBoxLeft)/2;
			center = new tbVector(this.bBoxLeft+r,this.bBoxTop+r);
			center = center.rotate(angle);
			return tbMaskDisk(center.x,center.y,r);
			break;
		default:
			pointx = [];
			pointy = [];
			for (i=0; i<this.polygon.x.length-1; i += 1) {
				point0 = new tbVector(this.polygon.x[i],this.polygon.y[i]);
				point0 = point0.rotate(angle);
				pointx.push(point0.x);
				pointy.push(point0.y);
			}
			return tbMaskPolygon(pointx,pointy);
			break;
	}
};


//
// Collision checking, using SAT method
//

// Project a polygonal mask placed at x,y on the vector
tbMask.prototype._project = function(x,y,axis) {
	"use strict";
	var v = new tbVector(0,0),
		scalar,
		minVal = 1000000000,
		maxVal = -10000000000,
		i;
	for (i=0; i < this.polygon.x.length; i += 1) {
		v.x = x + this.polygon.x[i];
		v.y = y + this.polygon.y[i];
		scalar = v.dot(axis);
		minVal = Math.min(minVal,scalar);
		maxVal = Math.max(maxVal,scalar);
	}
	return {min: minVal, max:maxVal};
};

// Return the axis for the polygon mask
tbMask.prototype._getAxes = function() {
	"use strict";
	var v1 = new tbVector(0,0),
		v2 = new tbVector(0,0),
		axes = [],
		i;
	for (i=0; i < this.polygon.x.length-1; i += 1) {
		v1.x = this.polygon.x[i];
		v1.y = this.polygon.y[i];
		v2.x = this.polygon.x[i+1];
		v2.y = this.polygon.y[i+1];
		axes.push(v1.subtract(v2).normal());
	}
	return axes;
};

// Determines whether this mask at position x,y collides with mask at position mX, mY
tbMask.prototype.collisionMask = function(x, y, mask, mX, mY) {
	"use strict";
	var r, axes, pr1, pr2, i;
	// First check the bounding box
	if (mX + mask.bBoxRight < x+this.bBoxLeft || mX + mask.bBoxLeft > x+this.bBoxRight) { return false; }
	if (mY + mask.bBoxBottom < y+this.bBoxTop || mY + mask.bBoxTop > y+this.bBoxBottom) { return false; }
	// Now do the easy cases
	if (this.kind === maskRectangle && mask.kind === maskRectangle) {
		return true;
	}
	if (mask.kind === maskDisk) {
		r = (mask.bBoxRight-mask.bBoxLeft)/2;
		return this.collisionDisk(x,y,mX+mask.bBoxLeft+r,mY+mask.bBoxTop+r,r);
	}
	if (this.kind === maskDisk) {
		r = (this.bBoxRight-this.bBoxLeft)/2;
		return mask.collisionDisk(mX,mY,x+this.bBoxLeft+r,y+this.bBoxTop+r,r);
	}
	if (mask.kind === maskPoint) {
		return this.collisionPoint(x,y,mX+mask.bBoxLeft,mY+mask.bBoxTop);
	}
	if (this.kind === maskPoint) {
		return mask.collisionPoint(mX,mY,x+this.bBoxLeft,y+this.bBoxTop);
	}
	// General case
	axes = this._getAxes().concat(mask._getAxes());
	for (i=0; i<axes.length; i += 1) {
		pr1 = this._project(x,y,axes[i]);
		pr2 = mask._project(mX,mY,axes[i]);
		if (pr1.max < pr2.min || pr2.max < pr1.min) { return false; }
	}
	return true;
};

// Determine whether the mask at position x,y collides with a disk
tbMask.prototype.collisionDisk = function(x, y, colX, colY, colR) {
	"use strict";
	var dx, dy, r, axes, nx, ny, nd, i, dist, v1, v2, scalar, pr1, pr2;
	// First check the bounding box
	if (colX+colR < x+this.bBoxLeft || colX-colR > x+this.bBoxRight) { return false; }
	if (colY+colR < y+this.bBoxTop || colY-colR > y+this.bBoxBottom) { return false; }
	// Now do precise checking
	switch (this.kind) {
		case maskPoint:
			dx = colX-(x+this.bBoxLeft);
			dy = colY-(y+this.bBoxTop);
			return dx*dx+dy*dy <= colR*colR;
			break;
		case maskDisk:
			r = (this.bBoxRight-this.bBoxLeft)/2;
			dx = colX-(x+this.bBoxLeft+r);
			dy = colY-(y+this.bBoxTop+r);
			return dx*dx+dy*dy <= (r+colR)*(r+colR);
			break;
		default:
			axes = this._getAxes();
			// Find nearest point on polygon
			nx = 0; ny = 0; nd = 1000000000;
			for (i=0; i< this.polygon.x.length; i += 1)
			{
				dx = x+this.polygon.x[i] - colX;
				dy = y+this.polygon.y[i] - colY;
				dist = dx*dx+dy*dy;
				if (dist<=nd) { nx = x+this.polygon.x[i]; ny = y+this.polygon.y[i]; nd = dist; }
			}
			v1 = new tbVector(colX,colY);
			v2 = new tbVector(nx,ny);
			axes.push(v1.subtract(v2).normalize());
			// Now do the projections
			for (i=0; i<axes.length; i += 1) {
				scalar = v1.dot(axes[i]);
				pr1 = {min: scalar-colR, max:scalar+colR};
				pr2 = this._project(x,y,axes[i]);
				if (pr1.max < pr2.min || pr2.max < pr1.min) { return false; }
			}
			return true;
			break;
	}
};

// Determine whether the mask at position x,y collides with a point
tbMask.prototype.collisionPoint = function(x, y, colX, colY) {
	"use strict";
	var r, dx, dy, x1, y1, x2, y2, yy, axes, v, pr1, pr2, i;
	// First check the bounding box
	if (colX < x+this.bBoxLeft || colX > x+this.bBoxRight) { return false; }
	if (colY < y+this.bBoxTop || colY > y+this.bBoxBottom) { return false; }
 	// Now do precise checking
	switch (this.kind) {
		case maskPoint:
		case maskRectangle:
			return true;
			break;
		case maskDisk:
			r = (this.bBoxRight-this.bBoxLeft)/2;
			dx = colX-(x+this.bBoxLeft+r);
			dy = colY-(y+this.bBoxTop+r);
			return dx*dx+dy*dy <= r*r;
			break;
		case maskLine:
			x1 = x + this.polygon.x[0];
			y1 = y + this.polygon.y[0];
			x2 = x + this.polygon.x[1];
			y2 = y + this.polygon.y[1];
			if (colX === x1) { return (colY === y1); }
			if (colX === x2) { return (colY === y2); }
			yy = y1 + (colX-x1)*(y2-y1)/(x2-x1);
			return (Math.abs(yy-colY) < 1);
			break;
		case maskPolygon:
			axes = this._getAxes();
			for (i=0; i<axes.length; i += 1) {
				v = new tbVector(colX,colY);
				pr1 = v.dot(axes[i]);
				pr2 = this._project(x,y,axes[i]);
				if (pr1 < pr2.min || pr2.max < pr1) { return false; }
			}
			return true;
			break;
		default:
			return false;
	}
};

// Draw the mask (for testing)
tbMask.prototype.draw = function(x, y, color) {
	"use strict";
	var context = tbGraphics.context,
		r, i;
	context.fillStyle = color;
	context.strokeStyle = color;
	switch (this.kind) {
		case maskPoint:
			context.fillRect(x+this.bBoxLeft-1, y+this.bBoxTop-1, 3, 3);
			break;
		case maskRectangle:
			context.fillRect(x+this.bBoxLeft, y+this.bBoxTop, this.bBoxRight-this.bBoxLeft+1, this.bBoxBottom-this.bBoxTop+1);
			break;
		case maskDisk:
			r = (this.bBoxRight-this.bBoxLeft)/2;
			context.beginPath();
			context.arc(x+this.bBoxLeft+r,y+this.bBoxTop+r,r,0,2 * Math.PI, false);
			context.closePath();
			context.fill();
			break;
		case maskLine:
			context.beginPath();
			context.moveTo(x + this.polygon.x[0],y + this.polygon.y[0]);
			context.lineTo(x + this.polygon.x[1],y + this.polygon.y[1]);
			context.stroke();
			break;
		case maskPolygon:
			context.beginPath();
			context.moveTo(x + this.polygon.x[0],y + this.polygon.y[0]);
			for (i=1; i<this.polygon.x.length-1; i += 1) {
				context.lineTo(x + this.polygon.x[i],y + this.polygon.y[i]);
			}
			context.closePath();
			context.fill();
			break;
	}
};

// Draw the bounding box of the mask (for testing)
tbMask.prototype.drawBox = function(x, y, color) {
	"use strict";
	var context = tbGraphics.context;
	context.strokeStyle = color;
	context.strokeRect(x+this.bBoxLeft, y+this.bBoxTop, this.bBoxRight-this.bBoxLeft+1, this.bBoxBottom-this.bBoxTop+1);
};


/////////////////////////////////////////////////////////////
// tbTimeLine: The engine part dealing with time lines that
// can perform actions at certain moments in time.
//
// Copyright 2013 CoolGames
// Last Changed: 9-9-2013
/////////////////////////////////////////////////////////////


var tbTimeLine = function() {
// The constructor for the time line object
	// A time line is a token so we nee some properties used by the engine
	"use strict";
	this.depth = 10000000;				// Handle as early as possible
	this.visible = false;
	this.active = true;
	this.group = "Engine";
	// Own properties
	this._moments = [];					// The moments at which actions must be performed
	this._running = false;				// Whether the time line is running
	this._paused = false;				// Whether the time line is paused
	this._loop = false;					// Whether to loop
	this._speed = 1;					// Speed with which to run
	this._lastTime = -1;				// The previously handled time
	this._nextMoment = -1000000;		// The next moment to handle
};


//
// Help methods
//

tbTimeLine.prototype._sort = function() {
// Function to sort the moments
	"use strict";

	var sortfunction = function (a, b) {
		return (a.moment - b.moment);
	};
	
	this._moments.sort(sortfunction);
};


//
// Maintaining the time line
//

tbTimeLine.prototype.clone = function() {
// Returns a clone of the time line
	"use strict";
	var res = new tbTimeLine(),
		i;
	for (i = 0; i < this._moments.length; i += 1) {
		res._moments.push( { moment: this._moments[i].moment, action: this._moments[i].action } );
	}
	res._loop = this._loop;
	return res;
};

tbTimeLine.prototype.merge = function(timeLine) {
// Merges the moments of the time line into the current one
	"use strict";
	var i;
	for (i = 0; i < timeLine._moments.length; i += 1) {
		this._moments.push( { moment: timeLine._moments[i].moment, action: timeLine._moments[i].action } );
	}
	this._sort();
	this._nextMoment = -1000000;  // invalidate next moment
};

tbTimeLine.prototype.addMoment = function(moment, action) {
// Adds a moment to the time line
	"use strict";
	var ind, i;
	if (this._moments.length === 0 || this._moments[this._moments.length-1].moment <= moment) {
		this._moments.push({ moment: moment, action: action });
	} else {
		ind = 0;
		while (this._moments[ind].moment <= moment) { ind += 1; }
		for (i = this._moments.length; i > ind; i -= 1) { 
			this._moments[i] = this._moments[i-1];
		}
		this._moments[ind] = { moment: moment, action: action };
	}
	this._nextMoment = -1000000;  // invalidate next moment
};

tbTimeLine.prototype.changeMoment = function(moment, action) {
// Changes the action at a moment in the time line
	"use strict";
	this.deleteMoment(moment);
	this.addMoment(moment, action);
};

tbTimeLine.prototype.deleteMoment = function(moment) {
// Removes all moments at the given moment
	"use strict";
	this.deleteRange(moment, moment);
};

tbTimeLine.prototype.shiftMoment = function(moment, amount) {
// Shift all moments at the given moment
	"use strict";
	this.shiftRange(moment, moment, amount);
};

tbTimeLine.prototype.duplicateMoment = function(moment, newMoment) {
// Duplicates all moments at the given moment
	"use strict";
	this.duplicateRange(moment, moment, newMoment);
};

tbTimeLine.prototype.deleteRange = function(moment0, moment1) {
// Removes all moments in the range
	"use strict";
	var ind = 0,
		i;
	for (i = 0; i < this._moments.length; i += 1) {
		if (this._moments[i].moment < moment0) {
			ind += 1;
		} else if (this._moments[i].moment > moment1) {
			this._moments[ind] = this._moments[i];
			ind += 1;
		}
	}
	this._moments.length = ind;
	this._nextMoment = -1000000;  // invalidate next moment
};

tbTimeLine.prototype.shiftRange = function(moment0, moment1, amount) {
// Shifts all moments in the range
	"use strict";
	var i;
	for (i = 0; i < this._moments.length; i += 1) {
		if (this._moments[i].moment >= moment0 && this._moments[i].moment <= moment1) {
			this._moments[i].moment += amount;
		}
	}
	this._sort();
	this._nextMoment = -1000000;  // invalidate next moment
};

tbTimeLine.prototype.duplicateRange = function(moment0, moment1, newMoment) {
// Duplicates all moments in the range starting at the new moment
	"use strict";
	var shift = newMoment - moment0,
		i;
	for (i = 0; i < this._moments.length; i += 1) {
		if (this._moments[i].moment >= moment0 && this._moments[i].moment <= moment1) {
			this._moments.push( { moment: this._moments[i].moment + shift, action: this._moments[i].action } );
		}
	}
	this._sort();
	this._nextMoment = -1000000;  // invalidate next moment
};

tbTimeLine.prototype.stretchRange = function(moment0, moment1, factor) {
// Stretches all moments in the range
	"use strict";
	var shift = (moment1-moment0) * (factor-1),   // Amount to shift moments after the range
		i;
	for (i = 0; i < this._moments.length; i += 1) {
		if (this._moments[i].moment >= moment0 && this._moments[i].moment <= moment1) {
			this._moments[i].moment = moment0 + (this._moments[i].moment-moment0) * factor;
		} else if (this._moments[i].moment > moment1) {
			this._moments[i].moment += shift;
		}
	}
	this._sort();
	this._nextMoment = -1000000;  // invalidate next moment
};

tbTimeLine.prototype.reverseRange = function(moment0, moment1) {
// Reverses all moments in the range
	"use strict";
	var i;
	for (i = 0; i < this._moments.length; i += 1) {
		if (this._moments[i].moment >= moment0 && this._moments[i].moment <= moment1) {
			this._moments[i].moment = moment1 - (this._moments[i].moment-moment0);
		}
	}
	this._sort();
	this._nextMoment = -1000000;  // invalidate next moment
};

tbTimeLine.prototype.deleteAll = function() {
// Removes all moments
	"use strict";
	if (this._moments.length > 0) {
		this.deleteRange(0, this._moments[this._moments.length-1].moment);
	}
};

tbTimeLine.prototype.shiftAll = function(amount) {
// Shifts all moments
	"use strict";
	if (this._moments.length > 0) {
		this.shiftRange(0, this._moments[this._moments.length-1].moment, amount);
	}
};

tbTimeLine.prototype.duplicateAll = function(newMoment) {
// Duplicates all moments starting at the new moment
	"use strict";
	if (this._moments.length > 0) {
		this.duplicateRange(0, this._moments[this._moments.length-1].moment, newMoment);
	}
};

tbTimeLine.prototype.stretchAll = function(factor) {
// Stretches all moments
	"use strict";
	if (this._moments.length > 0) {
		this.stretchRange(0, this._moments[this._moments.length-1].moment, factor);
	}
};

tbTimeLine.prototype.reverseAll = function() {
// Reverses all moments
	"use strict";
	if (this._moments.length > 0) {
		this.stretchRange(0, this._moments[this._moments.length-1].moment);
	}
};


//
// Running the time line
//

tbTimeLine.prototype.start = function() {
// Start the time line to run at the start
	"use strict";
	this._running = true;
	this._paused = false;
	if (this._speed < 0 && this._moments.length > 0) {
		this._lastTime = this._moments[this._moments.length-1].moment + 1;
	} else {
		this._lastTime = -1;
	}
	this._nextMoment = -1000000;
	// Add it to the game (removing it first when it already exists)
	tbGame.removeToken(this);
	tbGame.addToken(this);
};
	
tbTimeLine.prototype.startMoment = function(moment) {
// Start the time line to run at the indicated moment
	"use strict";
	this.start();
	this.setMoment(moment);
};
	
tbTimeLine.prototype.setMoment = function(moment) {
// 	Set the moment from where to run
	"use strict";
	if (this._speed < 0) {
		this._lastTime = moment + 1;
	} else {
		this._lastTime = moment - 1;
	}
	this._nextMoment = -1000000;
};

tbTimeLine.prototype.getMoment = function() {
// 	Returns the current time moment
	"use strict";
	return this._lastTime;
};
	
tbTimeLine.prototype.rewind = function() {
// 	Set the moment from where to run to the start
	"use strict";
	if (this._speed < 0 && this._moments.length > 0) {
		this.setMoment(this._moments[this._moments.length-1].moment);
	} else {
		this.setMoment(0);
	}
};
	
tbTimeLine.prototype.stop = function() {
// Stop the time line
	"use strict";
	this._running = false;
	tbGame.removeToken(this);
};
	
tbTimeLine.prototype.running = function() {
// Returns whether the time line is running
	"use strict";
	return this._running;
};
	
tbTimeLine.prototype.pause = function() {
// Pause the time line
	"use strict";
	this._paused = true;
	tbGame.removeToken(this);
};
	
tbTimeLine.prototype.resume = function() {
// Resumes the time line
	"use strict";
	this._paused = false;
	// Add it to the game (removing it first when it already exists)
	tbGame.removeToken(this);
	tbGame.addToken(this);
};
	
tbTimeLine.prototype.paused = function() {
// Returns whether the time line is paused
	"use strict";
	return (this._running && this._paused);
};
	
tbTimeLine.prototype.setLooping = function(loop) {
// Set whether to loop
	"use strict";
	this._loop = loop;
};
	
tbTimeLine.prototype.getLooping = function() {
// Return whether to loop
	"use strict";
	return this._loop ;
};
	
tbTimeLine.prototype.setSpeed = function(speed) {
// 	Set the speed with which to run
	"use strict";
	this._speed = speed;
};

tbTimeLine.prototype.getSpeed = function() {
// 	Returns the speed with which to run
	"use strict";
	return this._speed;
};
	
//
// Callback method to handle all
//

tbTimeLine.prototype.handleMoments = function(timePassed) { 
// This is where the time line does its work
	"use strict";
	if (!this._running || this._paused) { return; }
	if (this._speed === 0) { return; }
	if (this._speed > 0) {
		// Skip moment that did lie in the past
		if (this._nextMoment < 0) { this._nextMoment = 0; }
		while (this._nextMoment < this._moments.length && this._moments[this._nextMoment].moment <= this._lastTime) {
			this._nextMoment += 1;
		}
		// Handle moments that where passed
		this._lastTime += this._speed * timePassed;
		while (this._nextMoment >= 0 && this._nextMoment < this._moments.length && this._moments[this._nextMoment].moment <= this._lastTime) {
			this._moments[this._nextMoment].action(this._moments[this._nextMoment].moment, this);
			this._nextMoment += 1;
		}
		// See whether we are done
		if (this._nextMoment >= this._moments.length) {
			if (this._loop) {
				this.rewind();
			} else {
				this.stop();
			}
		}
	} else {
		// Skip moment that did lie in the past
		if (this._nextMoment < 0) { this._nextMoment = this._moments.length-1; }
		while (this._nextMoment >= 0 && this._moments[this._nextMoment].moment >= this._lastTime) { 
			this._nextMoment -= 1;
		}
		// Handle moments that where passed
		this._lastTime += this._speed * timePassed;
		while (this._nextMoment >= 0 && this._moments[this._nextMoment].moment >= this._lastTime) {
			this._moments[this._nextMoment].action(this._moments[this._nextMoment].moment, this);
			this._nextMoment -= 1;
		}
		// See whether we are done
		if (this._nextMoment < 0 && this._lastTime <= 0) {
			if (this._loop) {
				this.rewind();
			} else {
				this.stop();
			}
		}
	}
};

tbTimeLine.prototype.handleBeginStep = function(timePassed) { 
// You can override this but make sure you at least include this call
	"use strict";
	this.handleMoments(timePassed);
};
/////////////////////////////////////////////////////////////
// tbKeyAreas: The engine part dealing with virtual key
// code areas that can be used to simulate key presses
//
// Copyright 2013 CoolGames
// Last Changed: 9-9-2013
/////////////////////////////////////////////////////////////

// The constructor for the key area object
var tbKeyArea = function () {
	"use strict";
	// Properties used by the engine
	this.depth = 10000000;				// Handle as early as possible
	this.visible = false;
	this.active = true;
	this.group = "Engine";
	// Own properties
	this._areas = [];
	this._fingerIndex = [];
	this.clear();
	this.sliding = false;
	// Add it to the game engine
	tbGame.addToken(this);
};

//
// help methods
//

// Check whether the area contains a point
tbKeyArea.prototype._containsPoint = function(area,x,y) { 
	"use strict";
	if (!area) { return false; }
	return area.mask.collisionPoint(0, 0, x, y);
};

//
// The event handlers
//

// handleBeginStep is called each step before processing other events.
tbKeyArea.prototype.handleBeginStep = function(timePassed) { 
	"use strict";
	var finger, x, y, ind, area;
	if (!this.sliding) { return; }
	for (finger = 0; finger < 16; finger += 1) {
		if (tbGame.touchDown(finger)) {
			x = tbGame.touchX(finger);
			y = tbGame.touchY(finger);
			ind = this._fingerIndex[finger];
			area = this._areas[ind];
			// Check whether a finger moved out of a region
			if (ind >= 0 && area && area.selected && !this._containsPoint(area,x,y)) {
				tbGame.addKeyUpEvent(area.keyCode);
				area.selected = false;
				this._fingerIndex[finger] = -1;
			}		
			// Check whether the finger moved into a region
			this.handleTouchDown(finger,x,y);
		}
	}	
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
tbKeyArea.prototype.handleTouchDown = function(finger, x, y) { 
	"use strict";
	var i;
	if (this._fingerIndex[finger] >= 0) { return; }
	for (i=0; i<this._areas.length; i += 1) {
		if (this._areas[i] && this._containsPoint(this._areas[i],x,y) && !this._areas[i].selected) {
			tbGame.addKeyDownEvent(this._areas[i].keyCode);
			this._areas[i].selected = true;
			this._fingerIndex[finger] = i;
			return;
		}
	}
}
;
// handleTouchUp is called when a touch is ended or if a mouse button is released.
tbKeyArea.prototype.handleTouchUp = function(finger, x, y) { 
	"use strict";
	var ind = this._fingerIndex[finger];
	if (ind >= 0 && this._areas[ind] && this._areas[ind].selected) {
		tbGame.addKeyUpEvent(this._areas[ind].keyCode);
		this._areas[ind].selected = false;
	}		
	this._fingerIndex[finger] = -1;
};

//
// The user methods
//

// Add a rectangle with the given id
tbKeyArea.prototype.addRectangle = function(id, x, y, w, h, keyCode) {
	"use strict";
	var mask = tbMaskRectangle(x, y, w, h);
	this._areas.push( { keyCode: keyCode, mask: mask, id:id, selected: false } );
};

// Add a disk with the given id
tbKeyArea.prototype.addDisk = function(id, x, y, r, keyCode) {
	"use strict";
	var mask = tbMaskDisk(x, y, r);
	this._areas.push( { keyCode: keyCode, mask: mask, id:id, selected: false } );
};

// Add a triangle with the given id
tbKeyArea.prototype.addTriangle = function(id, x1, y1, x2, y2, x3, y3, keyCode) {
	"use strict";
	var mask = tbMaskTriangle(x1, y1, x2, y2, x3, y3);
	this._areas.push( { keyCode: keyCode, mask: mask, id:id, selected: false } );
};

// Add a polygon with the given id
tbKeyArea.prototype.addPolygon = function(id, x, y, keyCode) {
	"use strict";
	var mask = tbMaskPolygon(x, y);
	this._areas.push( { keyCode: keyCode, mask: mask, id:id, selected: false } );
};

// Add a mask at a location with the given id
tbKeyArea.prototype.addMask = function(id, x, y, mask, keyCode) {
	"use strict";
	this._areas.push( { keyCode: keyCode, mask: mask.translate(x,y), id:id, selected: false } );
};

// Remove an area
tbKeyArea.prototype.removeArea = function(areaId) {
	"use strict";
	var i;
	for (i=0; i<this._areas.length; i += 1) {
		if (this._areas[i].id === areaId) {
			this._areas[i] = null;
		}
	}
};

// Remove a key code
tbKeyArea.prototype.removeKeyCode = function(keyCode) {
	"use strict";
	var i;
	for (i=0; i<this._areas.length; i += 1) {
		if (this._areas[i].keyCode === keyCode) { 
			this._areas[i] = null;
		}
	}
};

// Remove all (only moment we actually delete entries in the array!)
tbKeyArea.prototype.clear = function() {
	"use strict";
	var i;
	this._areas.length = 0;
	for (i=0; i<16; i += 1) {
		this._fingerIndex[i] = -1;
	}
};

tbKeyArea.prototype.draw = function(colUp, colDown, colText) {
	"use strict";
	var i, area, xx, yy;
	for (i=0; i<this._areas.length; i += 1) {
		area = this._areas[i];
		if (area) { 
			if (area.selected) {
				area.mask.draw(0,0,colDown); 
			} else {
				area.mask.draw(0,0,colUp);
			}
			xx = (area.mask.bBoxLeft+area.mask.bBoxRight)/2;
			yy = (area.mask.bBoxTop+area.mask.bBoxBottom)/2;
			tbGraphics.drawText("id: " + area.id, xx - 20, yy - 10, colText, "16px Arial");
			tbGraphics.drawText("key: " + area.keyCode, xx - 20, yy + 10, colText, "16px Arial");
		}
	}
};


/////////////////////////////////////////////////////////////
// tbParticles: This engine component deals with particle systems
//
// This is a complete rewrite, replacing the old particle engine
//
// Copyright 2014 CoolGames
// Last Changed: 16-07-2014
/////////////////////////////////////////////////////////////
//
//
// var tbParticle = {};
//
// tbParticle.generator = new tbRandom();			// The random number generator we use
// tbParticle.particlePool = [];					// The pool of particles that can be reused
//
//
// // ********************************************
// // ** Distribution functions
// // ********************************************
//
// tbParticle.distributionRandom = function(min, max) {
// 	"use strict";
// 	return tbParticle.generator.randomRange(min, max);
// };
//
// tbParticle.distributionIRandom = function(min, max) {
// 	"use strict";
// 	return tbParticle.generator.iRandomRange(min, max);
// };
//
// tbParticle.distributionRounded = function(min, max, step) {
// 	"use strict";
// 	return step * tbParticle.generator.iRandomRange(min/step, max/step);
// };
//
//
// // ********************************************
// // ** Support functions
// // ********************************************
//
// // Clone a distribution value
// tbParticle.cloneDistributionValue = function(value) {
// 	"use strict";
// 	if (typeof value !== "object" || value === null || value.min === undefined) {
// 		if (Array.isArray(value)) {
// 			return value.slice();
// 		}
// 		return value;
// 	}
// 	return { min: value.min, max: value.max, distribution: value.distribution, parameter: value.parameter };
// };
//
// // Compute a value from a distribution object
// tbParticle.computeDistributionValue = function(value) {
// 	"use strict";
// 	if (typeof value !== "object" || value === null || value.min === undefined) {
// 		if (Array.isArray(value)) {
// 			return value[tbParticle.generator.iRandomRange(0, value.length-1)];
// 		}
// 		return value;
// 	}
// 	if (value.max === undefined) {
// 		if (Array.isArray(value.min)) {
// 			return value.min[tbParticle.generator.iRandomRange(0, value.min.length-1)];
// 		}
// 		return value.min;
// 	}
// 	if (value.distribution === undefined) {
// 		return tbParticle.generator.randomRange(value.min, value.max);
// 	}
// 	return value.distribution(value.min, value.max, value.parameter);
// };
//
// // Creates a value for a particle type
// tbParticle.createInterpolationValue = function(begin, change, interpolation, cycle, absolute, parameter) {
// 	"use strict";
// 	if (change === undefined) { return begin; }
// 	if (interpolation === undefined) { return { begin: begin, change: change }; }
// 	if (cycle === undefined) { cycle = 1; }
// 	if (absolute === undefined) { absolute = false; }
// 	return { begin: begin, change: change, interpolation: interpolation, cycle: cycle, absolute: absolute, parameter: parameter };
// };
//
// // Clone a value for a particle type
// tbParticle.cloneInterpolationValue = function(value) {
// 	"use strict";
// 	if (typeof value !== "object" || value === null || value.begin === undefined) {
// 		return tbParticle.cloneDistributionValue(value);
// 	}
// 	return {
// 		begin: value.begin === undefined ? undefined : tbParticle.cloneDistributionValue(value.begin),
// 		change: value.change === undefined ? undefined : tbParticle.cloneDistributionValue(value.change),
// 		interpolation: value.interpolation,
// 		cycle: value.cycle === undefined ? undefined : tbParticle.cloneDistributionValue(value.cycle),
// 		absolute: value.absolute,
// 		parameter: value.parameter === undefined ? undefined : tbParticle.cloneDistributionValue(value.parameter)
// 	};
// };
//
// // Initializes a value for a particle, based on the value in the particle type
// tbParticle.initInterpolationValue = function(value) {
// 	"use strict";
// 	var val;
// 	if (typeof value !== "object" || value === null || value.begin === undefined) {
// 		return { value: tbParticle.computeDistributionValue(value) };
// 	}
// 	val = tbParticle.computeDistributionValue(value.begin);
// 	if (value.change === undefined) {
// 		return { value: val };
// 	}
// 	return {
// 		value: val,
// 		begin: val,
// 		change: tbParticle.computeDistributionValue(value.change),
// 		interpolation: value.interpolation,
// 		cycle: value.cycle === undefined ? 1 : tbParticle.computeDistributionValue(value.cycle),
// 		absolute: value.absolute === undefined ? false : value.absolute,
// 		parameter: tbParticle.computeDistributionValue(value.parameter)
// 	};
// };
//
// // Updates a value for a particle, based on the current time and duration
// tbParticle.updateInterpolationValue = function(value, time, duration) {
// 	"use strict";
// 	if (value.begin === undefined) { return; }			// value is constant
// 	if (value.interpolation === undefined) {			// simple linear interpolation
// 		value.value = value.begin + time*value.change/duration;
// 	} else {
// 		if (!value.absolute) { time /= duration; }
// 		time = time % value.cycle;
// 		value.value = value.interpolation(time, value.begin, value.change, value.cycle, value.parameter);
// 	}
// };
//
//
// // ********************************************
// // ** Defining particles
// // ********************************************
//
// // The constructor for a particle
// tbParticle.Particle = function() {
// 	"use strict";
// };
//
// // The constructor for a particle
// tbParticle.Particle.prototype.init = function(token, pType, x, y) {
// 	"use strict";
// 	this.token = token;
// 	this.pType = pType;
// 	// Settings related to the image
// 	this.shape = tbParticle.initInterpolationValue(pType.shape).value;
// 	this.image = tbParticle.initInterpolationValue(pType.image).value;
// 	this.subImage = tbParticle.initInterpolationValue(pType.subImage);
// 	this.autoSubImage = pType.autoSubImage;
// 	this.absoluteSubImage = pType.absoluteSubImage;
// 	this.alpha = tbParticle.initInterpolationValue(pType.alpha);
// 	this.imageColorMode = pType.imageColorMode;
// 	this.colorMode = pType.colorMode;
// 	this.colorRed = tbParticle.initInterpolationValue(pType.colorRed);
// 	this.colorGreen = tbParticle.initInterpolationValue(pType.colorGreen);
// 	this.colorBlue = tbParticle.initInterpolationValue(pType.colorBlue);
// 	this.colorHue = tbParticle.initInterpolationValue(pType.colorHue);
// 	this.colorSaturation = tbParticle.initInterpolationValue(pType.colorSaturation);
// 	this.colorLight = tbParticle.initInterpolationValue(pType.colorLight);
// 	this.additive = pType.additive;
// 	this.drawFunction = pType.drawFunction;
// 	if (this.shape === "image" && (this.image !== undefined || this.image !== null) && this.imageColorMode !== "none") {
// 		this.surf = new tbSurface(this.image.width, this.image.height);
// 	}
// 	// Settings related to the lifeTime
// 	this.delay = tbParticle.initInterpolationValue(pType.delay).value;
// 	this.lifeTime = tbParticle.initInterpolationValue(pType.lifeTime).value;
// 	this.stepBeginFunction = pType.stepBeginFunction;
// 	this.stepEndFunction = pType.stepEndFunction;
// 	this.time = 0;
// 	this.alive = true;
// 	// Settings related to secondary particles
// 	this.emitType = pType.emitType;
// 	if (this.emitType !== null) {
// 		this.emitAmount = tbParticle.initInterpolationValue(pType.emitAmount);
// 		this.emitAtEnd = pType.emitAtEnd;
// 		this.emitNumber = tbParticle.computeDistributionValue(pType.emitNumber);
// 		this.emitDelay = tbParticle.computeDistributionValue(pType.emitDelay);
// 		this.emitInterval = tbParticle.initInterpolationValue(pType.emitInterval);
// 		this.emitCreated = 0;
// 		this.emitNext = 0;
// 	}
// 	this.effectType = pType.effectType;
// 	if (this.effectType !== null) {
// 		this.effectAmount = tbParticle.initInterpolationValue(pType.effectAmount);
// 		this.effectAtEnd = pType.effectAtEnd;
// 		this.effectNumber = tbParticle.computeDistributionValue(pType.effectNumber);
// 		this.effectDelay = tbParticle.computeDistributionValue(pType.effectDelay);
// 		this.effectInterval = tbParticle.initInterpolationValue(pType.effectInterval);
// 		this.effectCreated = 0;
// 		this.effectNext = 0;
// 	}
// 	// Settings related to the motion
// 	this.x = x;
// 	this.y = y;
// 	this.followEffect = pType.followEffect;
// 	this.positionX = tbParticle.initInterpolationValue(pType.positionX);
// 	this.positionY = tbParticle.initInterpolationValue(pType.positionY);
// 	this.speed = tbParticle.initInterpolationValue(pType.speed);
// 	this.direction = tbParticle.initInterpolationValue(pType.direction);
// 	this.forceDirection = tbParticle.initInterpolationValue(pType.forceDirection);
// 	this.forceMagnitude = tbParticle.initInterpolationValue(pType.forceMagnitude);
// 	this.forceX = 0;
// 	this.forceY = 0;
// 	this.moveX = 0;
// 	this.moveY = 0;
// 	this.currentX = this.x + this.positionX.value;
// 	this.currentY = this.y + this.positionY.value;
// 	this.previousX = this.currentX;
// 	this.previousY = this.currentY;
// 	// Settings related to the appearance
// 	this.autoOrientation = pType.autoOrientation;
// 	this.orientation = tbParticle.initInterpolationValue(pType.orientation);
// 	this.size = tbParticle.initInterpolationValue(pType.size);
// 	this.scaleX = tbParticle.initInterpolationValue(pType.scaleX);
// 	this.scaleY = tbParticle.initInterpolationValue(pType.scaleY);
// };
//
// // Create secondary particles
// tbParticle.Particle.prototype.createEmit = function() {
// 	"use strict";
// 	var t, numb, j, pType, xx, yy, particle;
// 	if (this.emitType === null) { return; }
// 	// Determine the number of particles to create
// 	tbParticle.updateInterpolationValue(this.emitAmount, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.emitInterval, this.time, this.lifeTime);
// 	if (this.time >= this.lifeTime) {
// 		if (!this.emitAtEnd) { return; }
// 		numb =  this.emitAmount.value*(this.emitNumber - this.emitCreated);
// 	} else {
// 		numb = 0;
// 		t = this.time - this.emitDelay;
// 		while (t >= this.emitNext && numb < this.emitNumber - this.emitCreated) {
// 			numb +=  this.emitAmount.value;
// 			this.emitNext += this.emitInterval.value;
// 		}
// 	}
// 	// Now create the particles
// 	for (j = 0; j < numb; j += 1) {
// 		pType = tbParticle.computeDistributionValue(this.emitType);
// 		xx = this.currentX;
// 		yy = this.currentY;
// 		if (this.followEffect) {
// 			xx += this.token.x;
// 			yy += this.token.y;
// 		}
// 		particle = new tbParticle.Particle();
// 		particle.init(this.token, pType,xx, yy);
// 		this.token.particles.push(particle);
// 	}
// 	this.emitCreated += numb;
// 	// Remove when finished
// 	if (this.emitCreated >= this.emitNumber) { this.emitType = null; }
// };
//
// tbParticle.Particle.prototype.createEffect = function() {
// 	"use strict";
// 	var t, numb, j, eType, xx, yy;
// 	if (this.effectType === null) { return; }
// 	// Determine the number of effects to create
// 	tbParticle.updateInterpolationValue(this.effectAmount, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.effectInterval, this.time, this.lifeTime);
// 	if (this.time >= this.lifeTime) {
// 		if (!this.effectAtEnd) { return; }
// 		numb = this.effectAmount.value*(this.effectNumber - this.effectCreated);
// 	} else {
// 		numb = 0;
// 		t = this.time - this.effectDelay;
// 		while (t >= this.effectNext && numb < this.effectNumber - this.effectCreated) {
// 			numb += this.effectAmount.value;
// 			this.effectNext += this.effectInterval.value;
// 		}
// 	}
// 	// Now create the effects
// 	for (j = 0; j < numb; j += 1) {
// 		eType = tbParticle.computeDistributionValue(this.effectType);
// 		xx = this.currentX;
// 		yy = this.currentY;
// 		if (this.followEffect) {
// 			xx += this.token.x;
// 			yy += this.token.y;
// 		}
// 		tbParticle.showEffect(eType,xx, yy, this.token.layer, this.token.depth, tbGame.getTokenTags(this.token));
// 	}
// 	this.effectCreated += numb;
// 	// Remove when finished
// 	if (this.effectCreated >= this.effectNumber) { this.effectType = null; }
// };
//
//
// // Update the particle
// tbParticle.Particle.prototype.update = function(timePassed) {
// 	"use strict";
// 	var dir;
// 	// Update the life time
// 	if (this.delay > 0) {
// 		this.delay -= timePassed;
// 		if (this.delay < 0) { this.time = -this.delay; }
// 	} else {
// 		this.time += timePassed;
// 	}
// 	if (this.delay > 0) { return; }
// 	if (this.time >= this.lifeTime) {
// 		this.createEmit();
// 		this.createEffect();
// 		this.alive = false;
// 		return;
// 	}
// 	if (this.stepBeginFunction !== null) { this.stepBeginFunction(this, this.time, this.lifeTime); }
// 	// Settings related to the motion
// 	this.previousX = this.currentX;
// 	this.previousY = this.currentY;
// 	tbParticle.updateInterpolationValue(this.positionX, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.positionY, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.speed, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.direction, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.forceDirection, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.forceMagnitude, this.time, this.lifeTime);
// 	this.forceX += timePassed * tbMath.projectionX(this.forceDirection.value, this.forceMagnitude.value);
// 	this.forceY += timePassed * tbMath.projectionY(this.forceDirection.value, this.forceMagnitude.value);
// 	this.moveX += timePassed * (tbMath.projectionX(this.direction.value, this.speed.value) + this.forceX);
// 	this.moveY += timePassed * (tbMath.projectionY(this.direction.value, this.speed.value) + this.forceY);
// 	this.currentX = this.x + this.positionX.value + this.moveX;
// 	this.currentY = this.y + this.positionY.value + this.moveY;
// 	// Settings related to the appearance
// 	tbParticle.updateInterpolationValue(this.orientation, this.time, this.lifeTime);
// 	if (this.autoOrientation) {
// 		dir = tbMath.direction(this.previousX, this.previousY, this.currentX, this.currentY);
// 		this.orientation.value = dir;
// 	}
// 	tbParticle.updateInterpolationValue(this.size, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.scaleX, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.scaleY, this.time, this.lifeTime);
// 	// Settings related to the image or shape
// 	tbParticle.updateInterpolationValue(this.colorRed, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.colorGreen, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.colorBlue, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.colorHue, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.colorSaturation, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.colorLight, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.subImage, this.time, this.lifeTime);
// 	tbParticle.updateInterpolationValue(this.alpha, this.time, this.lifeTime);
// 	if (this.autoSubImage) {
// 		dir = tbMath.direction(this.previousX, this.previousY, this.currentX, this.currentY);
// 		this.subImage.value = this.image.number * this.direction / 360;
// 	}
// 	// Create secondary particles
// 	this.createEmit();
// 	this.createEffect();
// 	// Call step end function
// 	if (this.stepEndFunction !== null) { this.stepEndFunction(this, this.time, this.lifeTime, timePassed); }
// };
//
// // Draw the particle
// tbParticle.Particle.prototype.draw = function() {
// 	"use strict";
// 	var xx = this.currentX,
// 		yy = this.currentY,
// 		sub = this.subImage.value,
// 		scaleX = this.size.value * this.scaleX.value,
// 		scaleY = this.size.value * this.scaleX.value,
// 		orient = this.orientation.value,
// 		alpha = this.alpha.value,
// 		color = "white",
// 		context = tbGraphics.context,
// 		img = this.image;
// 	// See if anything must be drawn
// 	if (!this.alive) { return; }
// 	if (this.delay > 0) { return; }
// 	if (Math.abs(scaleX) < 0.0001 || Math.abs(scaleY) < 0.0001) { return; }
// 	// Follow the token, if required
// 	if (this.followEffect) {
// 		xx += this.token.x; yy += this.token.y;
// 	}
// 	// Set the color
// 	if (this.colorMode === "hsl") {
// 		color = "hsl(" + Math.round(this.colorHue.value).toString() + "," +
// 					Math.round(this.colorSaturation.value).toString() + "%,"  +
// 					Math.round(this.colorLight.value).toString() + "%)";
// 	} else {
// 		color = "rgb(" + Math.round(this.colorRed.value).toString() + "," +
// 					Math.round(this.colorGreen.value).toString() + ","  +
// 					Math.round(this.colorBlue.value).toString() + ")";
// 	}
// 	// Set the transformation and alpha
// 	context.save();
// 	context.translate(xx, yy);
// 	context.rotate(-orient * Math.PI/180);
// 	context.scale(scaleX, scaleY);
// 	if (this.additive) { context.globalCompositeOperation = "lighter"; }
// 	// Now draw it
// 	switch (this.shape) {
// 		case "function":
// 			if (this.drawFunction !== undefined && this.drawFunction !== null) {
// 				this.drawFunction(this, color, alpha);
// 			}
// 			break;
// 		case "rectangle":
// 			context.globalAlpha = alpha;
// 			tbGraphics.drawRectangle(-0.5, -0.5, 1, 1, color);
// 			break;
// 		case "disk":
// 			context.globalAlpha = alpha;
// 			tbGraphics.drawDisk(0, 0, 0.5, color);
// 			break;
// 		default:
// 			context.globalAlpha = alpha;
// 			if (this.image !== undefined && this.image !== null) {
// 				if (this.imageColorMode === "color" || this.imageColorMode === "merge") {
// 					this.surf.clearColor(color);
// 					this.surf.setTarget();
// 					this.surf.context.globalCompositeOperation = "destination-in";
// 					if (this.image instanceof tbImage) {
// 						this.image.drawSimple(0, this.image.xOrigin, this.image.yOrigin);
// 					} else {
// 						this.image.drawSimple(0, 0);
// 					}
// 					if (this.imageColorMode === "merge") {
// 						this.surf.context.globalCompositeOperation = "lighter";
// 						if (this.image instanceof tbImage) {
// 							this.image.drawSimple(0, this.image.xOrigin, this.image.yOrigin);
// 						} else {
// 							this.image.drawSimple(0, 0);
// 						}
// 					}
// 					this.surf.resetTarget();
// 					img = this.surf;
// 				}
// 				if (img instanceof tbImage) {
// 					if (!this.absoluteSubImage) { sub *= img.number-0.0001; }
// 					sub = Math.floor(sub);
// 					if (this.autoSubImage) { orient = 0; }
// 					img.drawAlpha(sub, 0,0);
// 				} else {
// 					img.drawAlpha(-img.width/2, -img.height/2);
// 				}
// 			}
// 			break;
// 	}
// 	// Restore the transformation
// 	context.restore();
// };
//
//
// // ********************************************
// // ** Defining particle types
// // ********************************************
//
// // The default particle type
// tbParticle.defaultParticleType = {
// 	// Settings related to the image
// 	shape : "image",
// 	image : null,
// 	subImage : 0,
// 	autoSubImage : false,
// 	absoluteSubImage : true,
// 	alpha : 1,
// 	imageColorMode : "none",
// 	colorMode : "rgb",
// 	colorRed : 255,
// 	colorGreen : 255,
// 	colorBlue: 255,
// 	colorHue : 0,
// 	colorSaturation : 100,
// 	colorLight : 50,
// 	additive : false,
// 	drawFunction : null,
// 	// Settings related to the life time
// 	delay : 0,
// 	lifeTime : 10000000,
// 	stepBeginFunction : null,
// 	stepEndFunction : null,
// 	//Settings related to secondary particles
// 	emitType : null,
// 	emitAtEnd : true,
// 	emitAmount : 1,
// 	emitNumber : 1,
// 	emitDelay : 10000000,
// 	emitInterval : 0,
// 	effectType : null,
// 	effectAtEnd : true,
// 	effectAmount : 1,
// 	effectNumber : 1,
// 	effectDelay : 10000000,
// 	effectInterval : 0,
// 	// Settings related to the position
// 	positionX : 0,
// 	positionY : 0,
// 	speed : 0,
// 	direction : 0,
// 	forceDirection : 0,
// 	forceMagnitude : 0,
// 	followEffect : false,
// 	// Settings related to the transformation
// 	autoOrientation : false,
// 	orientation : 0,
// 	size : 1,
// 	scaleX : 1,
// 	scaleY : 1
// };
//
// // Return a clone of a particle type; if properties is defined these are put in the particle type
// tbParticle.cloneParticleType = function (pType, properties) {
// 	"use strict";
// 	var attr, newType = {};
// 	for (attr in pType) {
// 		if (pType.hasOwnProperty(attr)) {
// 			newType[attr] = tbParticle.cloneInterpolationValue(pType[attr]);
// 		}
// 	}
// 	if (properties !== undefined) {
// 		tbParticle.changeParticleType(newType, properties);
// 	}
// 	return newType;
// };
//
// // Set a number of properties in the particle type
// tbParticle.changeParticleType = function (pType, properties) {
// 	"use strict";
// 	var attr;
// 	for (attr in properties) {
// 		if (properties.hasOwnProperty(attr)) {
// 			pType[attr] = tbParticle.cloneInterpolationValue(properties[attr]);
// 		}
// 	}
// 	return pType;
// };
//
// // Return a default particle type; if properties is defined these are put in the particle type
// tbParticle.createParticleType = function (properties) {
// 	"use strict";
// 	return tbParticle.cloneParticleType(tbParticle.defaultParticleType, properties);
// };
//
//
// // ********************************************
// // ** Defining particle effects
// // ********************************************
//
// tbParticle.createParticleEffect = function() {
// 	"use strict";
// 	return { emitters: [] };
// };
//
// // Add a particle emitter for a particular type during a particular time, after a delay
// tbParticle.addEmitter = function(effect, pType, x, y, number, delay, interval, properties ) {
// 	"use strict";
// 	var newType = tbParticle.cloneParticleType(pType);
// 	if (properties !== undefined) { tbParticle.changeParticleType(newType, properties); }
// 	effect.emitters.push({ pType: newType, x: x, y: y, number: number, delay: delay, interval: interval });
// };
//
// // Add a single particle a particular type, after a delay
// tbParticle.addSingle = function(effect, pType, x, y, delay, properties ) {
// 	"use strict";
// 	var newType = tbParticle.cloneParticleType(pType);
// 	if (properties !== undefined) { tbParticle.changeParticleType(newType, properties); }
// 	effect.emitters.push({ pType: newType, x: x, y: y, number: 1, delay: delay, interval: 0 });
// };
//
// // Add multiple particles of a particular type, after a delay
// tbParticle.addMultiple = function(effect, pType, x, y, number, delay, properties ) {
// 	"use strict";
// 	var newType = tbParticle.cloneParticleType(pType);
// 	if (properties !== undefined) { tbParticle.changeParticleType(newType, properties); }
// 	effect.emitters.push({ pType: newType, x: x, y: y, number: number, delay: delay, interval: 0 });
// };
//
// // Show a particle effect. Returns the corresponding token.
// tbParticle.showEffect = function(effect, x, y, layer, depth, tags) {
// 	"use strict";
// 	return new tbParticle.ParticleToken(effect, x, y, layer, depth, tags);
// };
//
//
// // ********************************************
// // ** Defining particle tokens (used internally)
// // ********************************************
//
// // Constructor for a particle token
// tbParticle.ParticleToken = function(pEffect, x, y, layer, depth, tags) {
// 	"use strict";
// 	var i, emitter;
// 	// Token properties used by the engine
// 	if (layer === undefined) { layer = 0; }
// 	if (depth === undefined) { depth = 0; }
// 	this.layer = layer;
// 	this.depth = depth;
// 	this.visible = true;
// 	this.active = true;
// 	this.group = 0;
// 	// Own properties
// 	this.x = x;
// 	this.y = y;
// 	this.effect = pEffect;
// 	this.lifeTime = 0;
// 	// Create the emitters
// 	this.emitters = [];
// 	for (i = 0; i < this.effect.emitters.length; i += 1) {
// 		emitter = this.effect.emitters[i];
// 		this.emitters.push({
// 			pType: emitter.pType,
// 			x: emitter.x, y: emitter.y,
// 			number: tbParticle.computeDistributionValue(emitter.number),
// 			delay: tbParticle.computeDistributionValue(emitter.delay),
// 			interval: emitter.interval, created: 0, next: 0
// 		});
// 	}
// 	// Create the particles
// 	this.particles = [];
// 	// Add it to the game engine
// 	tbGame.addToken(this);
// 	if (tags !== undefined) { tbGame.addTokenTags(this, tags); }
// };
//
// tbParticle.ParticleToken.prototype.removeParticles = function() {
// // Remove all particles from the system
// 	"use strict";
// 	var i;
// 	for (i = 0; i < this.particles.length; i += 1) {
// 		tbParticle.particlePool.push(this.particles[i]);
// 	}
// 	this.particles.length = 0;
// };
//
// tbParticle.ParticleToken.prototype.particleCount = function() {
// // Returns the number of particles
// 	"use strict";
// 	return this.particles.length;
// };
//
// // Handles the step event, updating all particles and creating new ones
// tbParticle.ParticleToken.prototype.handleEndStep = function(timePassed) {
// 	"use strict";
// 	var i, j, n, t, numb, particle, emitter, pType;
// 	this.lifeTime += timePassed/1000;
// 	// Update the current particles, also removing dead ones
// 	n = 0;
// 	for (i = 0; i < this.particles.length; i += 1) {
// 		particle = this.particles[i];
// 		particle.update(timePassed/1000);
// 		if (particle.alive) {
// 			this.particles[n] = particle;
// 			n += 1;
// 		} else {
// 			tbParticle.particlePool.push(particle);
// 		}
// 	}
// 	this.particles.length = n;
// 	// Create new particles based on the emitters, and remove emitters that are finished
// 	n = 0;
// 	for (i = 0; i < this.emitters.length; i += 1) {
// 		emitter = this.emitters[i];
// 		t = this.lifeTime - emitter.delay;
// 		numb = 0;
// 		// Determine the number of particles to create
// 		while (t >= emitter.next && numb < emitter.number - emitter.created) { numb += 1; emitter.next += tbParticle.computeDistributionValue(emitter.interval); }
// 		// Now create the particles
// 		for (j = 0; j < numb; j += 1) {
// 			pType = tbParticle.computeDistributionValue(emitter.pType);
// 			if (tbParticle.particlePool.length > 0) {
// 				particle = tbParticle.particlePool.pop();
// 			} else {
// 				particle = new tbParticle.Particle();
// 			}
// 			if (pType.followEffect) {
// 				particle.init(this, pType, tbParticle.computeDistributionValue(emitter.x), tbParticle.computeDistributionValue(emitter.y));
// 			} else {
// 				particle.init(this, pType, this.x + tbParticle.computeDistributionValue(emitter.x), this.y + tbParticle.computeDistributionValue(emitter.y));
// 			}
// 			this.particles.push(particle);
// 		}
// 		emitter.created += numb;
// 		// Keep it when not finished
// 		if (emitter.created < emitter.number) {
// 			this.emitters[n] = emitter;
// 			n += 1;
// 		}
// 	}
// 	this.emitters.length = n;
// 	// remove the token when done
// 	if (this.emitters.length === 0 && this.particles.length === 0) { tbGame.removeToken(this); }
// };
//
// // Handles the draw event, drawing all particles
// tbParticle.ParticleToken.prototype.handleDraw = function() {
// 	"use strict";
// 	var i;
// 	for (i = 0; i < this.particles.length; i += 1) {
// 		if (this.particles[i] !== undefined) {
// 			this.particles[i].draw();
// 		}
// 	}
// };
/////////////////////////////////////////////////////////////
// tbAnimation: Contains objects and methods useful for animations
//
// Currently it contains a collection of easy functions and 
// the tbAnimator class.
//
// Copyright 2013-2015 CoolGames
// Last Changed: 17-11-2015
/////////////////////////////////////////////////////////////


// *******************************
// Ease Functions
// *******************************

var tbEase = {

//
// Basic ease functions
//

	easeConstant: function (time, begin, change, duration) {
		"use strict";
		return begin;
	},
	
	easeLinear: function (time, begin, change, duration) {
		"use strict";
		var val = time/duration;
		return begin + change * val;
	},
	
	easeInPower: function (time, begin, change, duration, power) {
		"use strict";
		var val;
		if (power === undefined) { power = 3; }
		val = Math.pow(time/duration, power);
		return begin + change * val;
	},
	
	easeOutPower: function (time, begin, change, duration, power) {
		"use strict";
		var val = tbEase.easeInPower(duration-time, 1, -1, duration, power);
		return begin + change * val;
	},
	
	easeInOutPower: function (time, begin, change, duration, power) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInPower(time, 0, 0.5, duration/2, power);
		} else {
			val = tbEase.easeInPower(duration-time, 1, -0.5, duration/2, power);
		}
		return begin + change * val;
	},
	
	easeOutInPower: function (time, begin, change, duration, power) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInPower(duration/2-time, 0.5, -0.5, duration/2, power);
		} else {
			val = tbEase.easeInPower(time-duration/2, 0.5, 0.5, duration/2, power);
		}
		return begin + change * val;
	},
	
	easeInQuadratic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeInPower(time, begin, change, duration, 2);
	},
	
	easeOutQuadratic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutPower(time, begin, change, duration, 2);
	},
	
	easeInOutQuadratic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeInOutPower(time, begin, change, duration, 2);
	},
	
	easeOutInQuadratic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutInPower(time, begin, change, duration, 2);
	},
	
	easeInCubic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeInPower(time, begin, change, duration, 3);
	},
	
	easeOutCubic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutPower(time, begin, change, duration, 3);
	},
	
	easeInOutCubic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeInOutPower(time, begin, change, duration, 3);
	},
	
	easeOutInCubic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutInPower(time, begin, change, duration, 3);
	},
	
	easeInQuartic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeInPower(time, begin, change, duration, 4);
	},
	
	easeOutQuartic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutPower(time, begin, change, duration, 4);
	},
	
	easeInOutQuartic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeInOutPower(time, begin, change, duration, 4);
	},
	
	easeOutInQuartic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutInPower(time, begin, change, duration, 4);
	},
	
	easeInQuintic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeInPower(time, begin, change, duration, 5);
	},
	
	easeOutQuintic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutPower(time, begin, change, duration, 5);
	},
	
	easeInOutQuintic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeInOutPower(time, begin, change, duration, 5);
	},
	
	easeOutInQuintic: function (time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutInPower(time, begin, change, duration, 5);
	},
	
	easeInExponential: function (time, begin, change, duration, power) {
		"use strict";
		var val, base;
		if (power === undefined) { power = 8; }
		base = Math.pow(2, -power);			// The exponential function will not cover the whole range from 0-1 so we must correct it
		val = (Math.pow(2, power * time/duration - power) - base) / (1-base);
		return begin + change * val;
	},
	
	easeOutExponential: function (time, begin, change, duration, power) {
		"use strict";
		var val = tbEase.easeInExponential(duration-time, 1, -1, duration, power);
		return begin + change * val;
	},
	
	easeInOutExponential: function (time, begin, change, duration, power) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInExponential(time, 0, 0.5, duration/2, power);
		} else {
			val = tbEase.easeInExponential(duration-time, 1, -0.5, duration/2, power);
		}
		return begin + change * val;
	},
	
	easeOutInExponential: function (time, begin, change, duration, power) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInExponential(duration/2-time, 0.5, -0.5, duration/2, power);
		} else {
			val = tbEase.easeInExponential(time-duration/2, 0.5, 0.5, duration/2, power);
		}
		return begin + change * val;
	},
	
	easeInSine: function (time, begin, change, duration) {
		"use strict";
		var val = 1 - Math.cos(time/duration * Math.PI/2);
		return begin + change * val;
	},
	
	easeOutSine: function (time, begin, change, duration) {
		"use strict";
		var val = tbEase.easeInSine(duration-time, 1, -1, duration);
		return begin + change * val;
	},
	
	easeInOutSine: function (time, begin, change, duration) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInSine(time, 0, 0.5, duration/2);
		} else {
			val = tbEase.easeInSine(duration-time, 1, -0.5, duration/2);
		}
		return begin + change * val;
	},
	
	easeOutInSine: function (time, begin, change, duration) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInSine(duration/2-time, 0.5, -0.5, duration/2);
		} else {
			val = tbEase.easeInSine(time-duration/2, 0.5, 0.5, duration/2);
		}
		return begin + change * val;
	},
	
	easeInCircular: function (time, begin, change, duration) {
		"use strict";
		var val = 1 - Math.sqrt(1 - Math.pow(time/duration, 2));
		return begin + change * val;
	},
	
	easeOutCircular: function (time, begin, change, duration) {
		"use strict";
		var val = tbEase.easeInCircular(duration-time, 1, -1, duration);
		return begin + change * val;
	},
	
	easeInOutCircular: function (time, begin, change, duration) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInCircular(time, 0, 0.5, duration/2);
		} else {
			val = tbEase.easeInCircular(duration-time, 1, -0.5, duration/2);
		}
		return begin + change * val;
	},
	
	easeOutInCircular: function (time, begin, change, duration) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInCircular(duration/2-time, 0.5, -0.5, duration/2);
		} else {
			val = tbEase.easeInCircular(time-duration/2, 0.5, 0.5, duration/2);
		}
		return begin + change * val;
	},
	
	easeInElastic: function (time, begin, change, duration, oscillations, stiffness) {
		"use strict";
		var val;
		if (oscillations === undefined) { oscillations = 3; }
		if (stiffness === undefined) { stiffness = 8; }
		val = Math.sin((1-time/duration)*2*Math.PI*oscillations + Math.PI/2);			// Create the correct sign
		val *= tbEase.easeInExponential(time, 0, 1, duration, stiffness);				// Multiply with an exponential ease in
		return begin + change * val;
	},

	easeOutElastic: function (time, begin, change, duration, oscillations, stiffness) {
		"use strict";
		var val = tbEase.easeInElastic(duration-time, 1, -1, duration, oscillations, stiffness);
		return begin + change * val;
	},
	
	easeInOutElastic: function (time, begin, change, duration, oscillations, stiffness) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInElastic(time, 0, 0.5, duration/2, oscillations, stiffness);
		} else {
			val = tbEase.easeInElastic(duration-time, 1, -0.5, duration/2, oscillations, stiffness);
		}
		return begin + change * val;
	},
	
	easeOutInElastic: function (time, begin, change, duration, oscillations, stiffness) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInElastic(duration/2-time, 0.5, -0.5, duration/2, oscillations, stiffness);
		} else {
			val = tbEase.easeInElastic(time-duration/2, 0.5, 0.5, duration/2, oscillations, stiffness);
		}
		return begin + change * val;
	},
	
	easeInOvershoot: function (time, begin, change, duration, overshoot) {
		"use strict";
		var val;
		if (overshoot === undefined) { overshoot = 1.70158; }
		val = (1+overshoot) * Math.pow(time/duration, 3) - overshoot * Math.pow(time/duration, 2);
		return begin + change * val;

	},
	
	easeOutOvershoot: function (time, begin, change, duration, overshoot) {
		"use strict";
		var val = tbEase.easeInOvershoot(duration-time, 1, -1, duration, overshoot);
		return begin + change * val;
	},
	
	easeInOutOvershoot: function (time, begin, change, duration, overshoot) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInOvershoot(time, 0, 0.5, duration/2, overshoot);
		} else {
			val = tbEase.easeInOvershoot(duration-time, 1, -0.5, duration/2, overshoot);
		}
		return begin + change * val;
	},
	
	easeOutInOvershoot: function (time, begin, change, duration, overshoot) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInOvershoot(duration/2-time, 0.5, -0.5, duration/2, overshoot);
		} else {
			val = tbEase.easeInOvershoot(time-duration/2, 0.5, 0.5, duration/2, overshoot);
		}
		return begin + change * val;
	},

	easeInBounce: function (time, begin, change, duration, number, factor) {
		"use strict";
		var bounces, i, w, width, height, val;
		// Correct the arguments
		if (number === undefined) { number = 4; }
		if (factor === undefined) { factor = 2; } else { factor = Math.sqrt(factor); }
		// Create the list of bounces
		bounces = [1];
		width = 1;
		for (i = 1; i < number; i += 1) {
			bounces.push(bounces[i-1]*factor);
			width += bounces[i];
		}
		// Compute total size
		width -= bounces[number-1]/2;		// We don't use the last half bounce
		height = Math.pow(bounces[number-1],2);
		time = time/duration * width;
		// Find the correct bounce
		w = 0;
		for (i = 0; i < number; i += 1) {
			if (time > bounces[i]) { time -= bounces[i];} else { w = bounces[i]; break; }
		}
		// Now compute the value
		val = -4 * Math.pow(time-w/2,2) + w * w;
		return begin + change * val / height;
	},

	easeOutBounce: function (time, begin, change, duration, number, factor) {
		"use strict";
		var val = tbEase.easeInBounce(duration-time, 1, -1, duration, number, factor);
		return begin + change * val;
	},
	
	easeInOutBounce: function (time, begin, change, duration, number, factor) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInBounce(time, 0, 0.5, duration/2, number, factor);
		} else {
			val = tbEase.easeInBounce(duration-time, 1, -0.5, duration/2, number, factor);
		}
		return begin + change * val;
	},
	
	easeOutInBounce: function (time, begin, change, duration, number, factor) {
		"use strict";
		var val;
		if (time < duration/2) {
			val = tbEase.easeInBounce(duration/2-time, 0.5, -0.5, duration/2, number, factor);
		} else {
			val = tbEase.easeInBounce(time-duration/2, 0.5, 0.5, duration/2, number, factor);
		}
		return begin + change * val;
	},
	
//
// Creating repeated ease functions
//

	repeatConstant : 0,
	repeatRepeat : 1,
	repeatMirror : 2,
	repeatFlip : 3,
	repeatContinuous : 4,
	repeatContinuousMirror : 5,

	easeCreateRepeat: function (func, repeat) {
		"use strict";
		switch (repeat) {
			case tbEase.repeatConstant:
				return function (time, begin, change, duration, arg0, arg1, arg2) {
					if (time < 0) { return begin; }
					if (time > duration) { return begin + change; }
					return func(time, begin, change, duration, arg0, arg1, arg2);
				};
			case tbEase.repeatRepeat:
				return function (time, begin, change, duration, arg0, arg1, arg2) {
					return func(time - Math.floor(time/duration)*duration, begin, change, duration, arg0, arg1, arg2);
				};
			case tbEase.repeatMirror:
				return function (time, begin, change, duration, arg0, arg1, arg2) {
					var val;
					if (Math.floor(time/duration) % 2 === 0) {
						val = func(time - Math.floor(time/duration)*duration, 0, 1, duration, arg0, arg1, arg2);
					} else {
						val = func(duration - time + Math.floor(time/duration)*duration, 0, 1, duration, arg0, arg1, arg2);
					}
					return begin + change * val;
				};
			case tbEase.repeatFlip:
				return function (time, begin, change, duration, arg0, arg1, arg2) {
					var val = func(time - Math.floor(time/duration)*duration, 0, 1, duration, arg0, arg1, arg2);
					if (Math.floor(time/duration) % 2 !== 0) {val = 1-val; }
					return begin + change * val;
				};
			case tbEase.repeatContinuous:
				return function (time, begin, change, duration, arg0, arg1, arg2) {
					var offset = Math.floor(time/duration),
						val = func(time - Math.floor(time/duration)*duration, 0, 1, duration, arg0, arg1, arg2);
					return begin + change * (offset + val);
				};
			case tbEase.repeatContinuousMirror:
				return function (time, begin, change, duration, arg0, arg1, arg2) {
					var val, offset = Math.floor(time/duration);
					if (Math.floor(time/duration) % 2 === 0) {
						val = func(time - Math.floor(time/duration)*duration, 0, 1, duration, arg0, arg1, arg2);
					} else {
						val = func(duration - time + Math.floor(time/duration)*duration, 1, -1, duration, arg0, arg1, arg2);
					}
					return begin + change * (offset + val);
				};
			default:
				return function (time, begin, change, duration, arg0, arg1, arg2) {
					return func(time, begin, change, duration, arg0, arg1, arg2);
				};
		}
	},

//
// Creating ease functions
//

	_easeCreate: function (kind, coef5, coef4, coef3, coef2, coef1, normalize) {
		"use strict";
		var tot;
		if (coef1 === undefined) { coef1 = 0; }
		if (coef2 === undefined) { coef2 = 0; }
		if (coef3 === undefined) { coef3 = 0; }
		if (coef4 === undefined) { coef4 = 0; }
		if (coef5 === undefined) { coef5 = 0; }
		if (normalize === undefined) { normalize = true; }
		tot = coef1 + coef2 + coef3 + coef4 + coef5;
		if (tot === 0) { tot = 1; }
		if (!normalize) { tot = 1; }
		
		switch (kind) {
			case 0:	return function(time, begin, change, duration) {
						var t = time/duration,
							val = coef5 * Math.pow(t, 5) + coef4 * Math.pow(t, 4) + coef3 * Math.pow(t, 3) + coef2 * Math.pow(t, 2) + coef1 * t; 
						return begin + change * val/tot;
					};
			case 1:return function(time, begin, change, duration) {
						var t = (duration - time)/duration,
							val = 1 - (coef5 * Math.pow(t, 5) + coef4 * Math.pow(t, 4) + coef3 * Math.pow(t, 3) + coef2 * Math.pow(t, 2) + coef1 * t); 
						return begin + change * val/tot;
					};
			case 2:	return function(time, begin, change, duration) {
						var t, val;
						if (time < duration/2) {
							t = time/(duration/2);
							val = 0.5 * (coef5 * Math.pow(t, 5) + coef4 * Math.pow(t, 4) + coef3 * Math.pow(t, 3) + coef2 * Math.pow(t, 2) + coef1 * t); 
						} else {
							t = (duration-time)/(duration/2);
							val = 1 - 0.5 * (coef5 * Math.pow(t, 5) + coef4 * Math.pow(t, 4) + coef3 * Math.pow(t, 3) + coef2 * Math.pow(t, 2) + coef1 * t); 
						
						}
						return begin + change * val/tot;
					};
			case 3:	return function(time, begin, change, duration) {
						var t, val;
						if (time < duration/2) {
							t = 1-time/(duration/2);
							val = 0.5 - 0.5 * (coef5 * Math.pow(t, 5) + coef4 * Math.pow(t, 4) + coef3 * Math.pow(t, 3) + coef2 * Math.pow(t, 2) + coef1 * t); 
						} else {
							t = time/(duration/2) - 1;
							val = 0.5 + 0.5 * (coef5 * Math.pow(t, 5) + coef4 * Math.pow(t, 4) + coef3 * Math.pow(t, 3) + coef2 * Math.pow(t, 2) + coef1 * t); 
						
						}
						return begin + change * val/tot;
					};
		}
	},
	
	easeCreateIn: function (coef5, coef4, coef3, coef2, coef1, normalize) {
		"use strict";
		return tbEase._easeCreate(0, coef5, coef4, coef3, coef2, coef1, normalize);
	},
	
	easeCreateOut: function (coef5, coef4, coef3, coef2, coef1, normalize) {
		"use strict";
		return tbEase._easeCreate(1, coef5, coef4, coef3, coef2, coef1, normalize);
	},
	
	easeCreateInOut: function (coef5, coef4, coef3, coef2, coef1, normalize) {
		"use strict";
		return tbEase._easeCreate(2, coef5, coef4, coef3, coef2, coef1, normalize);
	},
	
	easeCreateOutIn: function (coef5, coef4, coef3, coef2, coef1, normalize) {
		"use strict";
		return tbEase._easeCreate(3, coef5, coef4, coef3, coef2, coef1, normalize);
	},

//
// Combined ease functions
//

	easeCreateCombined: function (funcs, flips, lengths) {
		"use strict";
		var j, ww = 0, hh, maxHeight = 1, startHeight = [0], startWidth = [0];
		// Make sure the flips array is correct
		if (flips === undefined) { flips = []; }
		while (flips.length < funcs.length) { flips.push(false); }
		// Make sure the lengths array is correct
		if (lengths === undefined) { lengths = []; }
		while (lengths.length < funcs.length) { lengths.push(1/funcs.length); }
		for (j = 0; j < funcs.length; j += 1) { ww += lengths[j]; }
		for (j = 0; j < funcs.length; j += 1) { lengths[j] /= ww; }
		// Compute the start width, height and maximal height
		for (j = 0; j < funcs.length; j += 1) {
			startWidth.push(startWidth[j] + lengths[j]);
			if (funcs[j] === tbEase.easeConstant) { hh = 0; }
			else if (flips[j]) { hh = -1; } 
			else { hh = 1; }
			startHeight.push(startHeight[j] + hh);
			maxHeight = Math.max(maxHeight, startHeight[j+1]);
		}
		
		return function(time, begin, change, duration, arg0, arg1, arg2) {
			var ind, i, val;
			// Compute the function index
			ind = funcs.length-1;
			for (i = 0; i < funcs.length; i += 1) {
				if (time/duration <= startWidth[i+1]) { ind = i; break; }
			}
			// Now compute the value
			val = funcs[ind](time/duration - startWidth[ind], 0, 1, lengths[ind], arg0, arg1, arg2);
			if (flips[ind]) { val = -val; }
			return begin + (startHeight[ind] + val) * change / maxHeight; 
		};
	}

};


/////////////////////////////////////////////////////////////
// tbAnimator: The engine part dealing with animating values over
// time, which can be used for e.g. creating animations.
/////////////////////////////////////////////////////////////

// The constructor for the tbAnimator object
/**
 * @constructor
 */
var tbAnimator = function(target, tracks, events) {
	"use strict";
	this.paused = 0;				// How often paused
	this.currentTime = 0;			// Current time in milliseconds (or whatever the user uses)
	this.speed = 1;					// The speed (multiplication factor)
	this.looping = false;			// Whether to loop the global animator
	this.target = target;			// The target object (often a token)
	this.duration = 0;				// The total duration of the animator
	this.tracks = [];				// The tracks
	this.events = [];				// The events
	if (tracks !== undefined) { this.addTracks(tracks); }
	if (events !== undefined) { this.addTEvents(events); }
};


// *****************************
// Dealing with tracks
// *****************************

// Add a collection of tracks
tbAnimator.prototype.addTracks = function(tracks) {
	"use strict";
	var i;
	if (tracks !== undefined) {
		tracks = [].concat(tracks);
		for (i = 0; i < tracks.length; i += 1) {
			this.addTrack(tracks[i].kind, tracks[i].target, tracks[i].func, tracks[i].arg, tracks[i].keys);
		}
	}
};

// Add a track; returns the id
tbAnimator.prototype.addTrack = function(kind, target, func, arg, keys) {
	"use strict";
	var result;
	this.tracks.push({kind: kind, target: target, func: func, arg: arg,
		keys: [], looping: false, rounding: "none", onlyChanged: true, lastValue: undefined});
	result = this.tracks[this.tracks.length-1];
	if (keys !== undefined) { this.addKeys(result, keys); }
	return result;	
};

// Remove a track
tbAnimator.prototype.removeTrack = function(track) {
	"use strict";
	var ind = this.tracks.indexOf(track);
	if (ind < 0) { return; }
	this.tracks.splice(ind);
};

// Remove all tracks from the animator
tbAnimator.prototype.removeAllTracks = function() {
	"use strict";
	this.tracks = [];
};

// Set whether a track loops
tbAnimator.prototype.setTrackLooping = function(track, looping) {
	"use strict";
	track.looping = looping;
};

// Set the rounding for a track
tbAnimator.prototype.setTrackRounding = function(track, rounding) {
	"use strict";
	track.rounding = rounding;
};

// Set whether a track loops
tbAnimator.prototype.setTrackOnlyChanged = function(track, onlyChanged) {
	"use strict";
	track.onlyChanged = onlyChanged;
};

// Returns the duration of the track
tbAnimator.prototype.getTrackDuration = function(track) {
	"use strict";
	var len;
	len = track.keys.length;
	if (len === 0) { return 0; }
	return track.keys[len-1].time;
};

// Computes the total duration of the animator
tbAnimator.prototype._computeDuration = function() {
	"use strict";
	var i;
	this.duration = 0;
	for (i = 0; i < this.tracks.length; i += 1) {
		this.duration = Math.max(this.duration, this.getTrackDuration(this.tracks[i]));
	}
	this.duration = Math.max(this.duration, this.getEventsDuration());
};

// Returns the value of the track at the given time
tbAnimator.prototype.getTrackValue = function(track, time) {
	"use strict";
	var theValue, len, ind, key1, key2;
	len = track.keys.length;
	if (len === 0) { return 0; }
	// Deal with looping
	if (track.looping) {
		time = time % track.keys[len-1].time;
		if (time < 0) { time += track.keys[len-1].time; }
	}
	// Find the value
	if (time <= track.keys[0].time) {
		theValue = track.keys[0].value;
	} else if (time >= track.keys[len-1].time) {
		theValue = track.keys[len-1].value;
	} else {
		ind = 0;
		while (track.keys[ind].time < time) { ind += 1; }
		key1 = track.keys[ind-1];
		key2 = track.keys[ind];
		theValue = key1.ease(time-key1.time, key1.value, key2.value-key1.value, key2.time-key1.time, key1.arg);
	}
	// Deal with rounding
	switch (track.rounding) {
		case "round": theValue = Math.round(theValue); break;
		case "floor": theValue = Math.floor(theValue); break;
		case "ceil": theValue = Math.ceil(theValue); break;
	}
	// Ready
	return theValue;
};

// Apply the value in the track
tbAnimator.prototype._applyValue = function(track, time) {
	"use strict";
	var theValue, target;
	if (track.keys.length === 0) { return; }
	theValue = this.getTrackValue(track, time);
	// Check whether changed
	if (theValue === track.lastValue && track.onlyChanged) {
		return;
	}		
	// Apply the value
	target = track.target === undefined ? this.target : track.target;
	if (target === undefined && track.kind !== "function") { return; }
	switch (track.kind) {
		case "image": target.image = theValue; break;
		case "subImage": target.subImage = theValue; break;
		case "alpha": target.alpha = theValue; break;
		case "xScale": target.xScale = theValue; break;
		case "yScale": target.yScale = theValue; break;
		case "scale": target.scale = theValue; break;
		case "angle": target.angle = theValue; break;
		case "x": target.x = theValue; break;
		case "y": target.y = theValue; break;
		case "speed": target.speed = theValue; break;
		case "function":
			if (target === undefined) {
				track.func(theValue, track.arg);
			} else {
				track.func.call(target, theValue, track.arg);
			}
			break;
	}
};


// *****************************
// Dealing with keys
// *****************************

// Add a collection of keys to a track, time is now an absolute property
tbAnimator.prototype.addKeys = function(track, keys) {
	"use strict";
	var i;
	if (keys !== undefined) {
		keys = [].concat(keys);
		for (i = 0; i < keys.length; i += 1) {
			this.addKey(track, keys[i].time, keys[i].value, keys[i].ease, keys[i].arg);
		}
	}
};

// Add a key to a track, time is now an absolute property
tbAnimator.prototype.addKey = function(track, time, value, ease, arg) {
	"use strict";
	var result;
	if (ease === undefined) { ease = tbEase.easeLinear; }
	track.keys.push( {time: time, value: value, ease: ease, arg: arg} );
	result = track.keys[track.keys.length-1];
	this._sortKeys(track);
	this._computeDuration();
	return result;
};

// Append a collection of keys to a track, time is now a relative property
tbAnimator.prototype.appendKeys = function(track, keys) {
	"use strict";
	var i;
	if (keys !== undefined) {
		keys = [].concat(keys);
		for (i = 0; i < keys.length; i += 1) {
			this.appendKey(track, keys[i].time, keys[i].value, keys[i].ease, keys[i].arg);
		}
	}
};

// Append a key to a track, time is now a relative property
tbAnimator.prototype.appendKey = function(track, time, value, ease, arg) {
	"use strict";
	var result, lastTime;
	lastTime = track.keys.length === 0 ? 0 : track.keys[track.keys.length-1].time;
	if (ease === undefined) { ease = tbEase.easeLinear; }
	track.keys.push( {time: lastTime + time, value: value, ease: ease, arg: arg} );
	result = track.keys[track.keys.length-1];
	this._computeDuration();
	return result;
};

// Remove a key
tbAnimator.prototype.removeKey = function(track, key) {
	"use strict";
	var ind = track.indexOf(key);
	if (ind < 0) { return; }
	track.splice(ind);
	this._computeDuration();
};

// Remove all keys (in an interval) from the track
tbAnimator.prototype.removeKeys = function(track, startTime, endTime) {
	"use strict";
	var i;
	if (startTime === undefined) { startTime = -99999999; }
	if (endTime === undefined) { endTime = 99999999; }
	for (i = track.keys.length - 1; i >= 0; i -= 1) {
		if (track.keys[i].time >= startTime && track.keys[i].time <= endTime) {
			track.keys.splice(i);
		}
	}
	this._computeDuration();
};

// Remove all keys (in an interval) from all tracks
tbAnimator.prototype.removeAllKeys = function(startTime, endTime) {
	"use strict";
	var i;
	for (i = 0; i < this.tracks.length; i += 1) {
		this.removeKeys(this.tracks[i], startTime, endTime);
	}
};

// Shift all keys (in an interval) in the track by a particular amount of time
tbAnimator.prototype.shiftKeys = function(track, amount, startTime, endTime) {
	"use strict";
	var i;
	if (startTime === undefined) { startTime = -99999999; }
	if (endTime === undefined) { endTime = 99999999; }
	for (i = 0; i < track.keys.length; i += 1) {
		if (track.keys[i].time >= startTime && track.keys[i].time <= endTime) {
			track.keys[i].time += amount;
			if (track.keys[i].time < 0) { track.keys[i].time = 0; }
		}
	}
	this._sortKeys(track);
	this._computeDuration();
};

// Shift all keys (in an interval) in all tracks
tbAnimator.prototype.shiftAllKeys = function(amount, startTime, endTime) {
	"use strict";
	var i;
	for (i = 0; i < this.tracks.length; i += 1) {
		this.shiftKeys(this.tracks[i], amount, startTime, endTime);
	}
};

// Stretch all keys (in an interval) in the track by multiplying the time with a factor
tbAnimator.prototype.stretchKeys = function(track, factor, startTime, endTime) {
	"use strict";
	var i;
	if (factor < 0) { return; }
	if (startTime === undefined) { startTime = -99999999; }
	if (endTime === undefined) { endTime = 99999999; }
	for (i = 0; i < track.keys.length; i += 1) {
		if (track.keys[i].time >= startTime && track.keys[i].time <= endTime) {
			track.keys[i].time *= factor;
		}
	}
	this._sortKeys(track);
	this._computeDuration();
};

// Stretch all keys (in an interval) in all tracks
tbAnimator.prototype.stretchAllKeys = function(factor, startTime, endTime) {
	"use strict";
	var i;
	for (i = 0; i < this.tracks.length; i += 1) {
		this.stretchKeys(this.tracks[i], factor, startTime, endTime);
	}
};

// Sort the keys in the track by time
tbAnimator.prototype._sortKeys = function(track) {
	"use strict";
	track.keys.sort( function(a, b) { return a.time - b.time; } );
};


// *****************************
// Dealing with events
//		- When an event returns true, is stops the progress of time
// *****************************

// Add a collection of events
tbAnimator.prototype.addEvents = function(events) {
	"use strict";
	var i;
	if (events !== undefined) {
		events = [].concat(events);
		for (i = 0; i < events.length; i += 1) {
			this.addEvent(events[i].target, events[i].time, events[i].callback, events[i].arg);
		}
	}
};

// Add an event; Returns the event object
tbAnimator.prototype.addEvent = function(target, time, callback, arg) {
	"use strict";
	var result;
	this.events.push( {target: target, time: time, callback: callback, arg: arg} ) ;
	result = this.events[this.events.length-1];
	this._sortEvents();
	this._computeDuration();
	return result;
};

// Append a collection of events, time is now a relative property
tbAnimator.prototype.appendEvents = function(events) {
	"use strict";
	var i;
	if (events !== undefined) {
		events = [].concat(events);
		for (i = 0; i < events.length; i += 1) {
			this.appendEvent(events[i].target, events[i].time, events[i].callback, events[i].arg);
		}
	}
};

tbAnimator.prototype.appendEvent = function(target, time, callback, arg) {
	"use strict";
	var result, lastTime;
	lastTime = this.events.length === 0 ? 0 : this.events[this.events.length-1].time;
	this.events.push( {target: target, time: lastTime + time, callback: callback, arg: arg} ) ;
	result = this.events[this.events.length-1];
	this._computeDuration();
	return result;
};

// Remove an event
tbAnimator.prototype.removeEvent = function(event) {
	"use strict";
	var ind = this.events.indexOf(event);
	if (ind >= 0) { this.events.splice(ind); }
	this._computeDuration();
};

// Remove all events (in a time interval) from the animator
tbAnimator.prototype.removeEvents = function(startTime, endTime) {
	"use strict";
	var i;
	if (startTime === undefined) { startTime = -99999999; }
	if (endTime === undefined) { endTime = 99999999; }
	for (i = this.events.length - 1; i >= 0; i -= 1) {
		if (this.events[i].time >= startTime && this.events[i].time <= endTime) {
			this.events.splice(i);
		}
	}
	this._computeDuration();
};

// Shift all events (in an interval) by a particular amount of time
tbAnimator.prototype.shiftEvents = function(time, startTime, endTime) {
	"use strict";
	var  i;
	if (startTime === undefined) { startTime = -99999999; }
	if (endTime === undefined) { endTime = 99999999; }
	for (i = 0; i < this.events.length; i += 1) {
		if (this.events[i].time >= startTime && this.events[i].time <= endTime) {
			this.events[i].time += time;
		}
	}
	this._sortEvents();
	this._computeDuration();
};

// Stretch all events (in an interval) by multiplying the time with a factor
tbAnimator.prototype.stretchEvents = function(factor, startTime, endTime) {
	"use strict";
	var i;
	if (startTime === undefined) { startTime = -99999999; }
	if (endTime === undefined) { endTime = 99999999; }
	for (i = 0; i < this.events.length; i += 1) {
		if (this.events[i].time >= startTime && this.events[i].time <=endTime) {
			this.events[i].time *= factor;
		}
	}
	this._sortEvents();
	this._computeDuration();
};

// Returns the duration of the events
tbAnimator.prototype.getEventsDuration = function() {
	"use strict";
	var len;
	len = this.events.length;
	if (len === 0) { return 0; }
	return this.events[len-1].time;
};


// Sort the events by time
tbAnimator.prototype._sortEvents = function() {
	"use strict";
	this.events.sort( function(a, b) { return a.time - b.time; } );
};

// Find all events in the time interval (taking speed sign and looping into account)
// Do not report events at the startTime to avoid double execution
tbAnimator.prototype._findEvents = function(startTime, endTime) {
	"use strict";
	var i, result = [];
	if (this.speed > 0) {
		if (endTime >= startTime) {
			for (i = 0; i < this.events.length; i += 1) {
				if (this.events[i].time > startTime && this.events[i].time <= endTime) { 
					result.push(this.events[i]); 
				}
			}
		} else {
			for (i = 0; i < this.events.length; i += 1) {
				if (this.events[i].time > startTime) { 
					result.push(this.events[i]); 
				}
			}
			for (i = 0; i < this.events.length; i += 1) {
				if (this.events[i].time <= endTime) { 
					result.push(this.events[i]); 
				}
			}
		}
	} else {
		if (endTime <= startTime) {
			for (i = this.events.length-1; i >= 0; i -= 1) {
				if (this.events[i].time < startTime && this.events[i].time >= endTime) { 
					result.push(this.events[i]); 
				}
			}
		} else {
			for (i = this.events.length-1; i >= 0; i -= 1) {
				if (this.events[i].time < startTime) { 
					result.push(this.events[i]); 
				}
			}
			for (i = this.events.length-1; i >= 0; i -= 1) {
				if (this.events[i].time >= endTime) { 
					result.push(this.events[i]); 
				}
			}
		}
	}
	return result;
};

// Executes an event; returns whether to break
tbAnimator.prototype._executeEvent = function(event) {
	"use strict";
	var target, result;
	target = event.target === undefined ? this.target : event.target;
	if (target === undefined) {
		result = event.callback(event.arg);
	} else {
		result = event.callback.call(target, event.arg);
	}
	return result;
};


// *****************************
// Pausing and resuming
// *****************************

// Pause the animator (these stack)
tbAnimator.prototype.pause = function() {
	"use strict";
	this.paused += 1;
};

// Resumes the animator
tbAnimator.prototype.resume = function() {
	"use strict";
	this.paused -= 1;
};

// Resumes the animator immediately
tbAnimator.prototype.resumeForced = function() {
	"use strict";
	this.paused = 0;
};

// Returns whether the animator is paused
tbAnimator.prototype.isPaused = function() {
	"use strict";
	return this.paused > 0;
};

// Set the speed
tbAnimator.prototype.setSpeed = function(speed) {
	"use strict";
	this.speed = speed;
};

// Returns the speed
tbAnimator.prototype.getSpeed = function() {
	"use strict";
	return this.speed;
};

// Set the looping
tbAnimator.prototype.setLooping = function(looping) {
	"use strict";
	this.looping = looping;
};

// Returns the looping
tbAnimator.prototype.getLooping = function() {
	"use strict";
	return this.looping;
};

// Returns the total duration
tbAnimator.prototype.getDuration = function() {
	"use strict";
	return this.duration;
};


// *****************************
// Changing time
// *****************************

// Correct the time, taking looping into account
tbAnimator.prototype._correctTime = function(time) {
	"use strict";
	if (this.looping) {
		time = time % this.duration;
		if (time < 0) { time += this.duration; }
	} else {
		time = Math.max(0, Math.min(this.duration, time));
	}
	return time;
};

// Sets the time, changing all values (unless not allowed) but NOT calling events
tbAnimator.prototype.setTime = function(newTime, noChange) {
	"use strict";
	var i;
	this.currentTime = this._correctTime(newTime);
	if (noChange) { return; }
	for (i = 0; i < this.tracks.length; i += 1) {
		this._applyValue(this.tracks[i], this.currentTime);
	}
};

// Update the time, changing all values and calling events and checking breakpoints
tbAnimator.prototype.updateTime = function(timePassed) {
	"use strict";
	var newTime, events, i;
	if (this.paused > 0) { return; }
	// Compute the new time
	newTime = this._correctTime(this.currentTime + this.speed * timePassed);
	// Handle events
	events = this._findEvents(this.currentTime, newTime);
	for (i = 0; i < events.length; i += 1) {
		this.setTime(events[i].time);
		if (this._executeEvent(events[i])) { 
			this.currentTime = events[i].time - 0.0000001 * Math.sign(this.speed);	// To make sure it is tested again the next step
			return;
		}
	}
	// Set the new time
	this.setTime(newTime);
};




/////////////////////////////////////////////////////////////
// tbSpine: The engine part dealing with spine animations
//
// Copyright 2016 CoolGames
// Last Changed: 22-3-2016
/////////////////////////////////////////////////////////////

// Note that we reference the various methods and properties in the spine runtime
// by string, to avoid problems with obfuscation. The spine runtime cannot be obfuscated.

var tbSpine = function(name, texture, filePath, spineParent) {//animationJson, namespace) {
// The constructor for the spine object
    "use strict";

    this.name = name;
    this.texture = texture;
    this.filePath = filePath;
    this.animation = undefined;
    this.didLoad = false;
    this.skeleton = null;
    this.skeletonData = null;
    this.state = null;
    this.stateDate = null;
    this._isPaused = 0;
    this.speed = 1;
    this._events = [];
    this.spineParent = spineParent;
    this.spineData = undefined;
    this._onComplete = null;
    this.x = 0;
    this.y = 0;
    this.scale = 1;
    this.rotation = 0;
	this.alpha = 1;

    if(spineParent === undefined){
        tbLoader.addResource(this, "spine", 1);
        tbLoaderManager.addSpine();
    }
};

// Clones the spine (such that you can use multiple at the same moment)
tbSpine.prototype.clone = function() {
    "use strict";
    var _spine = new tbSpine(undefined, undefined, undefined, this);

    _spine.animation = this._createNewSpine(_spine.spineParent.spineData);

    _spine._initEvents();

    _spine.setPosition(_spine.x, _spine.y);

    return _spine;
};

tbSpine.prototype._createNewSpine = function(data) {
    "use strict";
    var anim = new PIXI["spine"]["Spine"](data);

    return anim;
};

// Sets the namespace (such that we can change the visuals without redoing changing the animation)
tbSpine.prototype.setPosition = function(x, y) {
    "use strict";

    this.x = x;
    this.y = y;

	if(this.animation){
        this.animation["x"] = this.x;
        this.animation["y"] = this.y;
	}
};

tbSpine.prototype.setAlpha = function(alpha) {
	"use strict";
	this.alpha = alpha;

	if(this.alpha > 1){
		this.alpha = 1;
	} else if (this.alpha < 0){
		this.alpha = 0;
	}

	this.animation["alpha"] = this.alpha;
};

tbSpine.prototype.setRotation = function(r) {
    "use strict";
    if(this.animation){
        this.animation["rotation"] = r;
        this.rotation = r;
    }
};

tbSpine.prototype.setScale = function( s ) {
	"use strict";
	this.scale = s;

	if(this.animation){
        this.animation["scale"]["set"](s);
	}
};

tbSpine.prototype.flip = function( ) {
    "use strict";
    if(this.animation){
        this.animation["scale"]["x"] = (this.scale * -1);
    }
};

tbSpine.prototype.flipVertically = function( ) {
    "use strict";
    if(this.animation){
        this.animation["scale"]["y"] = (this.scale * -1);
    }
};

tbSpine.prototype.show = function(){
    "use strict";
    if(this.animation){
        this.animation["visible"] = true;
    }
};

tbSpine.prototype.hide = function(){
    "use strict";
    if(this.animation){
        this.animation["visible"] = false;
    }
};

tbSpine.prototype.addChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.animation){
            this.animation["addChild"](_obj);
        }
    }
};

tbSpine.prototype.add = function(container){
    "use strict";
    if(this.animation){
        if(container && container["addChild"]){
            container["addChild"](this.animation);
        } else {
            tgfGraphics.addChild(this.animation);
        }
    }
};

tbSpine.prototype.removeChild = function(obj){
    "use strict";
    var _obj;

    if(obj instanceof tbImage){
        if(obj.sprite){
            _obj = obj.sprite;
        }
    } else if(obj instanceof tbSpine) {
        if(obj.animation) {
            _obj = obj.animation;
        }
    } else if(obj instanceof tbVectorFont) {
        if(obj.font){
            _obj = obj.font;
        }
    } else if(obj instanceof tbSpriteAnimation) {
        if(obj.animation){
            _obj = obj.animation;
        }
    } else {
        _obj = obj;
    }

    if(_obj){
        if(this.animation){
            this.animation["removeChild"](_obj);
        } else {
            console.log("No sprites attached");
        }
    }
};

tbSpine.prototype.remove = function(container){
    "use strict";
    if(this.animation){
        if(container && container["removeChild"]){
            container["removeChild"](this.animation);
        } else {
            tgfGraphics.removeChild(this.animation);
        }
    }
};

tbSpine.prototype.free = function(alsoChildren){
    "use strict";
	
	if (typeof alsoChildren === "undefined") {
		alsoChildren = true;
	}

    var options = {"children": alsoChildren,
        "texture": false,
        "baseTexture": false};
	
    if(this.animation){
        this.animation["destroy"](options);
        this.animation = null;
    }
};

tbSpine.prototype.setTint = function(tint){
    "use strict";
    if(this.animation && tint){
        this.animation["tint"] = tint;
    }
};

tbSpine.prototype.setMask = function(mask){
    "use strict";
    if(this.animation && mask){
        this.animation["mask"] = mask;
    }
};

// *****************************
// Dealing with animations
// *****************************

// Sets the animation to play
tbSpine.prototype.setAnimation = function(animation, loop) {
    "use strict";
    if(this.animation && this.animation["state"]["hasAnimation"](animation)) {
        this.animation["state"]["setAnimation"](0, animation, loop);
        //this.animation["skeleton"]["setToSetupPose"]();
        // this.animation["skeleton"]["setSlotsToSetupPose"]();
    }
};

tbSpine.prototype.setSkin = function(skin) {
    "use strict";
    this.animation["skeleton"]["setSkinByName"](skin);
    //this.animation["skeleton"].setSlotsToSetupPose();
};

tbSpine.prototype.addAnimation = function(animation, loop) {
    "use strict";
    if(this.animation && this.animation["state"]["hasAnimation"](animation)) {
        this.animation["state"]["addAnimation"](0, animation, loop);
        this.animation["skeleton"]["setToSetupPose"]();
    }
};

// Add an animation to be played after the current animation
tbSpine.prototype.addAnimation = function(animation, loop, delay) {
    "use strict";

};

// Sets transition smoothness of two animations
tbSpine.prototype.mixAnimations = function(firstAnimation, secondAnimation, duration){
    "use strict";
    // if(duration === undefined){ duration = 0.2;}
    // if(this.animation["stateData"]){
    //     this.animation["stateData"]["setMixByName"](firstAnimation, secondAnimation, duration);
    // }
};


// *****************************
// Setting properties
// *****************************

// Sets the speed with which to play (1 is default, must be >= 0)
tbSpine.prototype.setSpeed = function(speed) {
    "use strict";
    if(this.animation && speed){
        this.animation["state"]["timeScale"] = speed;
    }
};

// Returns the speed with which to play
tbSpine.prototype.getSpeed = function() {
    "use strict";
    if(this.animation){
        this.speed = this.animation["state"]["timeScale"];
    }
    return this.speed;
};

tbSpine.prototype.getAnimation = function(){
    "use strict";
    return this.animation;
};
// *****************************
// Dealing with events
// *****************************

// Sets an event to call a particular callback
tbSpine.prototype.setEventCallback = function(event, callback, context) {
    "use strict";
    var i;
    var self = this;
    //Check whether it already exists
    for(i = self._events.length-1; i >= 0 ; i -= 1){
        if(self._events[i].event === event){
            self._events[i].callback = callback;
            self._events[i].context = context;
            return;
        }
    }
    this._events.push({event: event, callback: callback, context: context});
};

// Get the callback for a particular event
// Get the callback for a particular event
tbSpine.prototype.getEventCallback = function(event) {
    "use strict";
    var i, _callback;
    var self = this;
    for(i = self._events.length-1; i >= 0 ; i -= 1){
        if(self._events[i].event === event){
            _callback = self._events[i].callback;
        }
    }
    return _callback;
};

// Clear the event callback
tbSpine.prototype.clearEventCallback = function(event) {
    "use strict";
    var i;
    var self = this;
    for(i = self._events.length-1; i >= 0 ; i -= 1){
        if(self._events[i].event === event){
            self._events.splice(i, 1);
        }
    }
};

// Clear all event callbacks
tbSpine.prototype.clearAllEventCallbacks = function() {
    "use strict";
    this._events = [];
};

// Sets the callback to be called on complete
tbSpine.prototype.setOnComplete = function(callback) {
    "use strict";
    this._onComplete = callback;
};

// Returns the callback on complete
tbSpine.prototype.getOnComplete = function() {
    "use strict";
    return this._onComplete;
};

// Clears the callback on complete
tbSpine.prototype.clearOnComplete = function() {
    "use strict";
    this._onComplete = null;
};

//Initialize spines callback functions
tbSpine.prototype._initEvents = function(){
    "use strict";
    var self = this;
    if(this.animation["state"]){
        this.animation["state"]["onEvent"] = function(trackIndex, event){
            var i;
            for(i = 0; i < self._events.length; i += 1){
                if(self._events[i].event === event["data"]["name"]){
                    if (self._events[i].callback) {self._events[i].callback(self._events[i].context);}
                }
            }
        };
        this.animation["state"]["onComplete"] = function(trackIndex, count){
            if(self._onComplete){self._onComplete();}
        };
    }
};


// *****************************
// Pausing and resuming
// *****************************

// Pauses the animation, that is, no updates to the time are applied. This method stacks, so multiple pauses must be followed by multiple resumes
// tbSpine.prototype.pause = function() {
//     "use strict";
//     this._isPaused += 1;
// };
//
// // Resumes the animation. This method stacks, so multiple pauses must be followed by multiple resumes
// tbSpine.prototype.resume = function() {
//     "use strict";
//     this._isPaused -= 1;
// };
//
// // Resumes the animation immediately, ignoring the stacking of pauses
// tbSpine.prototype.resumeForced = function() {
//     "use strict";
//     this._isPaused = 0;
// };
//
// // Returns whether the animation is paused
// tbSpine.prototype.isPaused = function() {
//     "use strict";
//     return this._isPaused > 0;
// };


// *****************************
// Changing time
// *****************************

// Update the time, changing all values and calling events
tbSpine.prototype.updateTime = function(timePassed) {
    "use strict";
};


// *****************************
// Drawing
// *****************************

// Draw at a position
tbSpine.prototype.drawSimple = function(mX, mY) {
    "use strict";
    //this.drawExt(mX, mY, undefined, undefined, undefined , undefined);
};

// Draw at a position with an alpha value
tbSpine.prototype.drawAlpha = function(mX, mY, alpha) {
    "use strict";
    //this.drawExt(mX, mY, undefined, undefined, undefined , alpha);
};

// Draw at a position with a transformation and an alpha value
tbSpine.prototype.drawExt = function(mX, mY, xScale, yScale, angle, alpha) {
    "use strict";
};

// *****************************
// Internal Functions
// *****************************

tbSpine.prototype.startLoading = function(moment, location) {
    "use strict";
    this._loadSkeleton();
};

tbSpine.prototype.checkTexture = function() {
    "use strict";
    var didLoad = true;

    if(Array.isArray(this.texture)){
        for(var i = 0; i < this.texture.length; i++){
            if(!this.texture[i].didLoad){
                didLoad = false;
            }
        }
    } else {
        didLoad = this.texture.didLoad;
    }

    return didLoad;
};



//Loading the skeleton
tbSpine.prototype._loadSkeleton = function(){
    "use strict";
    var isArray = false;
    this._textureFilenames = [];

    if(Array.isArray(this.texture)){
        isArray = true;
        for(var i = 0; i < this.texture.length; i++){
            if(!this.texture[i].didLoad || this.didLoad){
                return;
            }
        }
    } else {
        if(!this.texture.didLoad || this.didLoad){
            return;
        }
    }

    var self = this;

    var loader = new PIXI["loaders"]["Loader"]();

    var atlas = new PIXI["spine"]["core"]["TextureAtlas"]();

    if(isArray){
        for(var i = 0; i < this.texture.length; i++){
            var tex = this.texture[i];
            var filenames = [];
            for(var j = 0; j < this.texture[i].filenames.length; j++){
                filenames.push(this.texture[i].filenames[j]);
            }
            var collection = {
                __tex: tex,
                __filenames: filenames
            }
            this._textureFilenames.push(collection);
        }
    } else {
        this._textureFilenames.push({
            __tex: this.texture,
            __filenames: this.texture.filenames
        });
    }

    for(var i = 0; i < this._textureFilenames.length; i++){
        for(var j = 0; j < this._textureFilenames[i].__filenames.length; j++){
            atlas["addTextureHash"](this._textureFilenames[i].__tex.loader["resources"][this._textureFilenames[i].__filenames[j]]["textures"], true);
        }
    }

    loader.add(this.name, this.filePath, {"metadata": {"spineAtlas": atlas}}).load(
        function(loader, resources){

            self.spineData = resources[self.name]["spineData"];

            self.animation = new PIXI["spine"]["Spine"](self.spineData);

            self._initEvents();

            tbLoaderManager.loadedSpine();
        }
    );

    this.didLoad = true;
};/////////////////////////////////////////////////////////////
// tbJSON: The engine part dealing with parsing json files
//
// Copyright 2016 CoolGames
// Last Changed: 22-3-2016
/////////////////////////////////////////////////////////////

var tbJSON = function (jFile) {
    // The constructor for the json object
    "use strict";
    
    this.json = jFile;
};

tbJSON.prototype.getFile = function () {
    "use strict";
    return this.json;
};/////////////////////////////////////////////////////////////
// tbUnity: The engine part dealing with Unity Ui editor
//
// Copyright 2016 CoolGames
// Last Changed: 22-3-2016
/////////////////////////////////////////////////////////////

// The constructor
var tbUnity = function(_json){
    "use strict";
    this.mainJSON = _json;
    this.mainObject = undefined;
    this.finalDialog = undefined;

    this.buttonCollection = [];
    this.placeholderCollection = [];
    this.allComponents = [];

    this.options = [
        "Group",
        "Image",
        "Button",
        "Label",
        "PlaceHolder",
        "Animation",
        "ImageNineSlice"
    ];
};

tbUnity.prototype.init = function(){
    "use strict";
    this._parseJSON();
};

tbUnity.prototype._parseJSON = function(){
    "use strict";
    this.mainObject = JSON.parse(this.mainJSON);
    if(testMode){
        console.log(this.mainObject);
    }

    this._createDialog();
};

tbUnity.prototype._createDialog = function() {
    "use strict";

    var dialog = new tgfDialogs.Base({
        x: tgfGraphics.areaWidth / 2, y: tgfGraphics.areaHeight / 2
    });

    this.finalDialog = dialog;

    this.chooseCategory(this.mainObject, this.finalDialog);
};

tbUnity.prototype.chooseCategory = function(obj, parent){
    "use strict";

    for(var i = 0; i < obj["children"].length; i++){
        for(var j = 0; j < this.options.length; j++){
            if(obj["children"][i]["type"] === this.options[j]){
                this._createComponent(obj["children"][i]["type"], obj["children"][i], parent);
            }
        }
    }
};

tbUnity.prototype._createComponent = function(type, properties, parent){
    "use strict";

    switch(type){
        case "Group":
            this.makeGroup(properties, parent);
            break;
        case "Image":
            this.makeImage(properties, parent);
            break;
        case "Button":
            this.makeButton(properties, parent);
            break;
        case "Label":
            this.makeLabel(properties, parent);
            break;
        case "PlaceHolder":
            this.makePlaceHolder(properties, parent);
            break;
        case "Animation":
            this.makeAnimation(properties, parent);
            break;
        case "ImageNineSlice":
            this.makeNineSlice(properties, parent);
            break;
    }
};

tbUnity.prototype.makeGroup = function(properties, parent){
    "use strict";

    var comp = new tgfComponents.Base({
        compName: properties["name"],
        x: this.getPos(properties["x"]), y: this.getPos(properties["y"])
    });

    this.allComponents.push(comp);

    if(properties["children"].length > 0){
        this.chooseCategory(properties, comp);
        parent.addComponent(comp);
    } else {
        parent.addComponent(comp);
    }
};

tbUnity.prototype.makeImage = function(properties, parent){
    "use strict";

    var comp = new tgfComponents.Picture({
        compName: properties["name"],
        x: this.getPos(properties["x"]), y: this.getPos(properties["y"]),
        width: this.returnNumber(properties["width"]), height: this.returnNumber(properties["height"]),
        image: window[properties["image"].replace(".png","").replace(".jpg", "")]
    });

    this.allComponents.push(comp);

    if(properties["children"].length > 0){
        this.chooseCategory(properties, comp);
        parent.addComponent(comp);
    } else {
        parent.addComponent(comp);
    }
};

tbUnity.prototype.makeNineSlice = function(properties, parent){
    "use strict";

    var comp = new tgfComponents.Picture({
        compName: properties["name"],
        x: this.getPos(properties["x"]), y: this.getPos(properties["y"]),
        width: this.returnNumber(properties["width"]), height: this.returnNumber(properties["height"]),
        image: window[properties["image"].replace(".png","").replace(".jpg", "")],
        createFromSlices: true
    });

    this.allComponents.push(comp);

    if(properties["children"].length > 0){
        this.chooseCategory(properties, comp);
        parent.addComponent(comp);
    } else {
        parent.addComponent(comp);
    }
};

tbUnity.prototype.makeButton = function(properties, parent){
    "use strict";

    var comp = new tgfComponents.Button({
        compName: properties["name"],
        x: this.getPos(properties["x"]), y: this.getPos(properties["y"]),
        width: this.returnNumber(properties["width"]), height: this.returnNumber(properties["height"]),
        image: window[properties["image"].replace(".png","").replace(".jpg", "")]
    });

    this.buttonCollection.push(comp);
    this.allComponents.push(comp);

    if(properties["children"].length > 0){
        this.chooseCategory(properties, comp);
        parent.addComponent(comp);
    } else {
        parent.addComponent(comp);
    }
};

tbUnity.prototype.makeLabel = function(properties, parent){
    "use strict";

    var _text = properties["text"];
    if(properties["unityUseLocalizationFile"]){
        _text = tgfDictionary.getText(_text);
    }

    var _fontSize = Number(properties["fontSize"]);
    if(isNaN(_fontSize)){
        _fontSize = 12;
    }

    var comp = new tgfComponents.Label({
        compName: properties["name"],
        x: this.getPos(properties["x"]), y: this.getPos(properties["y"]),
        width: this.returnNumber(properties["width"]), height: this.returnNumber(properties["height"]),
        font: { fontFace: properties["fontName"], fontSize: _fontSize, align: properties["hAlignment"], baseline: "middle"},
        text: _text
    });

    this.allComponents.push(comp);

    if(properties["children"].length > 0){
        this.chooseCategory(properties, comp);
        parent.addComponent(comp);
    } else {
        parent.addComponent(comp);
    }
};

tbUnity.prototype.makePlaceHolder = function(properties, parent){
    "use strict";

    var comp = new tgfComponents.Base({
        compName: properties["name"],
        x: this.getPos(properties["x"]), y: this.getPos(properties["y"])
    });

    this.placeholderCollection.push(comp);
    this.allComponents.push(comp);

    if(properties["children"].length > 0){
        this.chooseCategory(properties, comp);
        parent.addComponent(comp);
    } else {
        parent.addComponent(comp);
    }
};

tbUnity.prototype.makeAnimation = function(properties, parent){
    "use strict";

    var animation = window[properties["fileName"].replace(".json", "")];
    var delay = -1;
    if(!isNaN(Number(properties["delay"]))){
        delay = Number(properties["delay"]);
    }

    var comp = new tgfComponents.SpineComponent({
        compName: properties["name"],
        x: this.getPos(properties["x"]), y: this.getPos(properties["y"]),
        spineAnimation: animation,
        animationClip: properties["animationQueue"][0],
        repeat: properties["loop"], play: properties["autoPlay"],
        delay: delay
    });

    this.allComponents.push(comp);

    if(properties["children"].length > 0){
        this.chooseCategory(properties, comp);
        parent.addComponent(comp);
    } else {
        parent.addComponent(comp);
    }
};

tbUnity.prototype.getComponent = function (name) {
    "use strict";

    for (var i = 0; i < this.allComponents.length; i++) {
        if (this.allComponents[i].compName === name) {
            return this.allComponents[i];
        }
    }
};

tbUnity.prototype.addButtonCallback = function(name, callback){
    "use strict";

    for(var i = 0; i < this.buttonCollection.length; i++){
        if(this.buttonCollection[i].compName === name){
            this.buttonCollection[i].onClick = callback;
        }
    }
};

tbUnity.prototype.addPlaceHolder = function(name, obj){
    "use strict";

    if (obj instanceof tgfComponents.Button || obj instanceof tgfComponents.Picture || obj instanceof tgfComponents.SpineComponent || obj instanceof tgfComponents.Label || obj instanceof tgfComponents.Base) {
        for (var i = 0; i < this.placeholderCollection.length; i++) {
            if (this.placeholderCollection[i].compName === name) {
                this.placeholderCollection[i].addComponent(obj);
            }
        }
    } else {
        console.log("Not compatible placeholder object");
    }
};

tbUnity.prototype.getPos = function (pos) {
    "use strict";
    var pos = (tgfScale(Number(pos)) * -1);
    if (pos === -0) { pos = 0; }

    return pos;
};

tbUnity.prototype.returnNumber = function (str) {
    return tgfScale(Number(str));
};

tbUnity.prototype.getDialog = function(){
    "use strict";
    return this.finalDialog;
};

tbUnity.prototype.showScreen = function(){
    "use strict";
    this.finalDialog.show();
};

tbUnity.prototype.hideScreen = function(){
    "use strict";
    this.finalDialog.hide();
};
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//*****    The Before Game Scripts
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//******************************************************


//******************************************************
//*****    Script Resource: Chainable
//******************************************************



    var Chainable = function(func, context)
    {
        "use strict";
        this.func = func || null;

        this.context = context || null;

        this.previous = null;

        // Remove the first 2 elements
        this.args = Array.prototype.slice.call(arguments);

        this.args.splice(0, 2);

        this.nextFunc = null;
    };

    Chainable.prototype.then = function(next, context)
    {
        "use strict";
        // Create a new Chainable with custom arguments using Javascript magic
        this.nextFunc = Object.create(Chainable.prototype);

        Chainable.apply(this.nextFunc, arguments);

        this.nextFunc.previous = this;

        return this.nextFunc;
    };

    Chainable.prototype.execute = function()
    {
        "use strict";
        if (this.previous)
        {
            var temp = this.previous;

            this.previous = null;

            temp.execute();

            return;
        }

        if (this.func)
        {
            var args = this.args.slice();

            args.unshift(this.executeNext, this);

            this.func.apply(this.context, args);
        }
        else
        {
            this.executeNext();
        }
    };

    Chainable.prototype.executeNext = function()
    {
        "use strict";
        this.nextFunc.execute();
    };

//******************************************************
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//*****    The Resources
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//******************************************************


//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Namespaces
//******************************************************
//******************************************************
//******************************************************


//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Data Files
//******************************************************
//******************************************************
//******************************************************

    var nl_nl = new tbDataFile("nl_nl", "media/nl_nl.json");
    window["nl_nl"] = nl_nl;
    var en_us = new tbDataFile("en_us", "media/en_us.json");
    window["en_us"] = en_us;
    var fr_fr = new tbDataFile("fr_fr", "media/fr_fr.json");
    window["fr_fr"] = fr_fr;
    var it_it = new tbDataFile("it_it", "media/it_it.json");
    window["it_it"] = it_it;
    var de_de = new tbDataFile("de_de", "media/de_de.json");
    window["de_de"] = de_de;
    var es_es = new tbDataFile("es_es", "media/es_es.json");
    window["es_es"] = es_es;
    var ja_jp = new tbDataFile("ja_jp", "media/ja_jp.json");
    window["ja_jp"] = ja_jp;

//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Textures
//******************************************************
//******************************************************
//******************************************************

var imageScalePercentage = 100; 
    var FlowStartTexture = new tbTexture("FlowStartTexture", 1, "startImages");
    window["FlowStartTexture"] = FlowStartTexture;
        FlowStartTexture.addBitmap(0, "media/FlowStartTexture0.json");
    var texture_dont_optimise = new tbTexture("texture_dont_optimise", 1, "load");
    window["texture_dont_optimise"] = texture_dont_optimise;
        texture_dont_optimise.addBitmap(0, "media/texture_dont_optimise0.json");
    var texture = new tbTexture("texture", 4, "load");
    window["texture"] = texture;
        texture.addBitmap(0, "media/texture0.json");
        texture.addBitmap(1, "media/texture1.json");
        texture.addBitmap(2, "media/texture2.json");
        texture.addBitmap(3, "media/texture3.json");
    var texture_backgrounds_8x8 = new tbTexture("texture_backgrounds_8x8", 1, "backgrounds_8x8");
    window["texture_backgrounds_8x8"] = texture_backgrounds_8x8;
        texture_backgrounds_8x8.addBitmap(0, "media/texture_backgrounds_8x80.json");
    var texture_onboarding = new tbTexture("texture_onboarding", 1, "onboarding");
    window["texture_onboarding"] = texture_onboarding;
        texture_onboarding.addBitmap(0, "media/texture_onboarding0.json");
    var texture_board_missile_animation = new tbTexture("texture_board_missile_animation", 1, "load");
    window["texture_board_missile_animation"] = texture_board_missile_animation;
        texture_board_missile_animation.addBitmap(0, "media/texture_board_missile_animation0.json");
    var texture_battleship = new tbTexture("texture_battleship", 2, "load");
    window["texture_battleship"] = texture_battleship;
        texture_battleship.addBitmap(0, "media/texture_battleship0.json");
        texture_battleship.addBitmap(1, "media/texture_battleship1.json");
    var texture_logo = new tbTexture("texture_logo", 1, "load");
    window["texture_logo"] = texture_logo;
        texture_logo.addBitmap(0, "media/texture_logo0.json");
    var texture_result_win = new tbTexture("texture_result_win", 1, "result_screen");
    window["texture_result_win"] = texture_result_win;
        texture_result_win.addBitmap(0, "media/texture_result_win0.json");
    var texture_result_lose = new tbTexture("texture_result_lose", 1, "result_screen");
    window["texture_result_lose"] = texture_result_lose;
        texture_result_lose.addBitmap(0, "media/texture_result_lose0.json");
    var texture_whitespace = new tbTexture("texture_whitespace", 2, "load");
    window["texture_whitespace"] = texture_whitespace;
        texture_whitespace.addBitmap(0, "media/texture_whitespace0.json");
        texture_whitespace.addBitmap(1, "media/texture_whitespace1.json");
    var texture_rankup = new tbTexture("texture_rankup", 3, "rankup_shield");
    window["texture_rankup"] = texture_rankup;
        texture_rankup.addBitmap(0, "media/texture_rankup0.json");
        texture_rankup.addBitmap(1, "media/texture_rankup1.json");
        texture_rankup.addBitmap(2, "media/texture_rankup2.json");
    var texture_matchresult = new tbTexture("texture_matchresult", 1, "matchresult");
    window["texture_matchresult"] = texture_matchresult;
        texture_matchresult.addBitmap(0, "media/texture_matchresult0.json");
    var texture_badges = new tbTexture("texture_badges", 1, "badge_animations");
    window["texture_badges"] = texture_badges;
        texture_badges.addBitmap(0, "media/texture_badges0.json");
    var texture_doors = new tbTexture("texture_doors", 1, "load");
    window["texture_doors"] = texture_doors;
        texture_doors.addBitmap(0, "media/texture_doors0.json");
    var texture_sw_icon_add = new tbTexture("texture_sw_icon_add", 1, "load");
    window["texture_sw_icon_add"] = texture_sw_icon_add;
        texture_sw_icon_add.addBitmap(0, "media/texture_sw_icon_add0.json");
    var popup_reload_texture = new tbTexture("popup_reload_texture", 1, "popup_reload");
    window["popup_reload_texture"] = popup_reload_texture;
        popup_reload_texture.addBitmap(0, "media/popup_reload_texture0.json");
    var popup_extra_texture = new tbTexture("popup_extra_texture", 1, "popup_extra_shot");
    window["popup_extra_texture"] = popup_extra_texture;
        popup_extra_texture.addBitmap(0, "media/popup_extra_texture0.json");
    var texture_game = new tbTexture("texture_game", 1, "load");
    window["texture_game"] = texture_game;
        texture_game.addBitmap(0, "media/texture_game0.json");
    var texture_result = new tbTexture("texture_result", 1, "result_screen");
    window["texture_result"] = texture_result;
        texture_result.addBitmap(0, "media/texture_result0.json");
    var texture_shared = new tbTexture("texture_shared", 1, "load");
    window["texture_shared"] = texture_shared;
        texture_shared.addBitmap(0, "media/texture_shared0.json");
    var texture_splash = new tbTexture("texture_splash", 1, "load");
    window["texture_splash"] = texture_splash;
        texture_splash.addBitmap(0, "media/texture_splash0.json");
    var texture_weapon_unlock = new tbTexture("texture_weapon_unlock", 1, "weapon_unlock");
    window["texture_weapon_unlock"] = texture_weapon_unlock;
        texture_weapon_unlock.addBitmap(0, "media/texture_weapon_unlock0.json");
    var texture_unused = new tbTexture("texture_unused", 1, "unused");
    window["texture_unused"] = texture_unused;
        texture_unused.addBitmap(0, "media/texture_unused0.json");
    var texture_reward_badges = new tbTexture("texture_reward_badges", 1, "reward_badges");
    window["texture_reward_badges"] = texture_reward_badges;
        texture_reward_badges.addBitmap(0, "media/texture_reward_badges0.json");
    var texture_reward_progress = new tbTexture("texture_reward_progress", 1, "load");
    window["texture_reward_progress"] = texture_reward_progress;
        texture_reward_progress.addBitmap(0, "media/texture_reward_progress0.json");
    var FrameworkTexture = new tbTexture("FrameworkTexture", 1, "frameworkImages");
    window["FrameworkTexture"] = FrameworkTexture;
        FrameworkTexture.addBitmap(0, "media/FrameworkTexture0.json");

//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Images
//******************************************************
//******************************************************
//******************************************************

    var s_dest_in = new tbImage(texture, 1,undefined , {"x": 56,"y": 56 } );
s_dest_in.addImage("s_dest_in.png", 0);
    var s_lobby_boxTop = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_boxTop.addImage("s_lobby_boxTop.png", 0);
    var s_lobby_btnBig = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_btnBig.addImage("s_lobby_btnBig.png", 0);
    var s_lobby_btnBox = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_btnBox.addImage("s_lobby_btnBox.png", 0);
    var s_lobby_btnMedium = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_btnMedium.addImage("s_lobby_btnMedium.png", 0);
    var s_lobby_btnRound = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_btnRound.addImage("s_lobby_btnRound.png", 0);
    var s_lobby_playerBox = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_playerBox.addImage("s_lobby_playerBox.png", 0);
    var s_lobby_playerBoxLast = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_playerBoxLast.addImage("s_lobby_playerBoxLast.png", 0);
    var s_lobby_vs = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_vs.addImage("s_lobby_vs.png", 0);
    var s_lobby_playerPic = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_playerPic.addImage("s_lobby_playerPic.png", 0);
    var s_lobby_iconPig = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_iconPig.addImage("s_lobby_iconPig.png", 0);
    var s_lobby_countSmall = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_countSmall.addImage("s_lobby_countSmall.png", 0);
    var s_lobby_iconPlus = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_iconPlus.addImage("s_lobby_iconPlus.png", 0);
    var s_lobby_iconLeader = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_iconLeader.addImage("s_lobby_iconLeader.png", 0);
    var s_lobby_iconPower = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_iconPower.addImage("s_lobby_iconPower.png", 0);
    var s_lobby_iconTrash = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_lobby_iconTrash.addImage("s_lobby_iconTrash.png", 0);
    var s_pla_hit_fire = new tbImage(texture_unused, 8,undefined , {"x": 28,"y": 55 } );
s_pla_hit_fire.addImage("s_pla_hit_fire.png", 0);
s_pla_hit_fire.addImage("s_pla_hit_fire1.png", 1);
s_pla_hit_fire.addImage("s_pla_hit_fire2.png", 2);
s_pla_hit_fire.addImage("s_pla_hit_fire3.png", 3);
s_pla_hit_fire.addImage("s_pla_hit_fire4.png", 4);
s_pla_hit_fire.addImage("s_pla_hit_fire5.png", 5);
s_pla_hit_fire.addImage("s_pla_hit_fire6.png", 6);
s_pla_hit_fire.addImage("s_pla_hit_fire7.png", 7);
    var s_logo = new tbImage(texture_unused, 1,undefined , {"x": 0,"y": 0 } );
s_logo.addImage("s_logo.png", 0);
    var s_overlay_settings = new tbImage(texture_unused, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_settings.addImage("s_overlay_settings.png", 0);
    var s_overlay_options = new tbImage(texture_unused, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_options.addImage("s_overlay_options.png", 0);
    var s_overlay_assignment = new tbImage(texture_unused, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_assignment.addImage("s_overlay_assignment.png", 0);
    var s_star_blue = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_star_blue.addImage("s_star_blue.png", 0);
    var s_ui_header_lobby = new tbImage(texture, 1,undefined , {"x": 683,"y": 0 } );
s_ui_header_lobby.addImage("s_ui_header_lobby.png", 0);
    var s_background_profile = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_background_profile.addImage("s_background_profile.png", 0);
    var s_star_green = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_star_green.addImage("s_star_green.png", 0);
    var s_background_main = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_background_main.addImage("s_background_main.png", 0);
    var s_overlay_name_pla = new tbImage(texture_result, 1,undefined , {"x": 20,"y": 24 } );
s_overlay_name_pla.addImage("s_overlay_name_pla.png", 0);
    var s_overlay_name_opp = new tbImage(texture_result, 1,undefined , {"x": 293,"y": 24 } );
s_overlay_name_opp.addImage("s_overlay_name_opp.png", 0);
    var s_overlay_results = new tbImage(texture_unused, 1,undefined , {"x": 367,"y": 0 } );
s_overlay_results.addImage("s_overlay_results.png", 0);
    var s_overlay_results_vs = new tbImage(texture_result, 1,undefined , {"x": 44,"y": 47 } );
s_overlay_results_vs.addImage("s_overlay_results_vs.png", 0);
    var _s_result_turnindicator_player = new tbImage(texture_result, 1,undefined , {"x": 0,"y": 130 } );
_s_result_turnindicator_player.addImage("_s_result_turnindicator_player.png", 0);
    var _s_result_turnindicator_opponent = new tbImage(texture_result, 1,undefined , {"x": 1138,"y": 130 } );
_s_result_turnindicator_opponent.addImage("_s_result_turnindicator_opponent.png", 0);
    var s_opp_submarine_green_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_submarine_green_ver.addImage("s_opp_submarine_green_ver.png", 0);
    var s_opp_ship_battleship_green_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_battleship_green_hor.addImage("s_opp_ship_battleship_green_hor.png", 0);
    var s_opp_ship_battleship_green_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_battleship_green_ver.addImage("s_opp_ship_battleship_green_ver.png", 0);
    var s_opp_ship_carrier_green_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_carrier_green_hor.addImage("s_opp_ship_carrier_green_hor.png", 0);
    var s_opp_ship_carrier_green_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_carrier_green_ver.addImage("s_opp_ship_carrier_green_ver.png", 0);
    var s_opp_ship_cruiser_green_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_cruiser_green_hor.addImage("s_opp_ship_cruiser_green_hor.png", 0);
    var s_opp_ship_cruiser_green_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_cruiser_green_ver.addImage("s_opp_ship_cruiser_green_ver.png", 0);
    var s_opp_ship_destroyer_green_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_destroyer_green_hor.addImage("s_opp_ship_destroyer_green_hor.png", 0);
    var s_opp_ship_destroyer_green_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_destroyer_green_ver.addImage("s_opp_ship_destroyer_green_ver.png", 0);
    var s_opp_submarine_green_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_submarine_green_hor.addImage("s_opp_submarine_green_hor.png", 0);
    var s_button_blue__old = new tbImage(texture, 2,undefined , {"x": 0,"y": 0 } );
s_button_blue__old.addImage("s_button_blue__old.png", 0);
s_button_blue__old.addImage("s_button_blue__old1.png", 1);
    var s_button_green__old = new tbImage(texture, 2,undefined , {"x": 0,"y": 0 } );
s_button_green__old.addImage("s_button_green__old.png", 0);
s_button_green__old.addImage("s_button_green__old1.png", 1);
    var s_button_ad_gray = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_button_ad_gray.addImage("s_button_ad_gray.png", 0);
    var s_button_gray__old = new tbImage(texture, 2,undefined , {"x": 0,"y": 0 } );
s_button_gray__old.addImage("s_button_gray__old.png", 0);
s_button_gray__old.addImage("s_button_gray__old1.png", 1);
    var s_button_ad = new tbImage(texture_shared, 1,undefined , {"x": 26,"y": 25 } );
s_button_ad.addImage("s_button_ad.png", 0);
    var s_poke_icon = new tbImage(texture_whitespace, 1,undefined , {"x": 19,"y": 43 } );
s_poke_icon.addImage("s_poke_icon.png", 0);
    var s_poke_icon_check = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_poke_icon_check.addImage("s_poke_icon_check.png", 0);
    var s_shuffle_icon = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_shuffle_icon.addImage("s_shuffle_icon.png", 0);
    var s_button_blue = new tbImage(texture_dont_optimise, 2,undefined , {"x": 45,"y": 43 } );
s_button_blue.addImage("s_button_blue.png", 0);
s_button_blue.addImage("s_button_blue1.png", 1);
    var s_button_gray = new tbImage(texture_dont_optimise, 2,undefined , {"x": 45,"y": 43 } );
s_button_gray.addImage("s_button_gray.png", 0);
s_button_gray.addImage("s_button_gray1.png", 1);
    var s_button_green = new tbImage(texture_dont_optimise, 2,undefined , {"x": 45,"y": 43 } );
s_button_green.addImage("s_button_green.png", 0);
s_button_green.addImage("s_button_green1.png", 1);
    var d_buttons_yellow = new tbImage(texture, 2,undefined , {"x": 45,"y": 43 } );
d_buttons_yellow.addImage("d_buttons_yellow.png", 0);
d_buttons_yellow.addImage("d_buttons_yellow1.png", 1);
    var s_overlay = new tbImage(texture_unused, 1,undefined , {"x": 0,"y": 0 } );
s_overlay.addImage("s_overlay.png", 0);
    var s_overlay_statsbackground = new tbImage(texture_unused, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_statsbackground.addImage("s_overlay_statsbackground.png", 0);
    var s_overlay_next_battle = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_next_battle.addImage("s_overlay_next_battle.png", 0);
    var s_pla_ship_carrier_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_carrier_hor.addImage("s_pla_ship_carrier_hor.png", 0);
    var s_pla_ship_carrier_hor_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_carrier_hor_sunk.addImage("s_pla_ship_carrier_hor_sunk.png", 0);
    var s_pla_ship_carrier_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_carrier_ver.addImage("s_pla_ship_carrier_ver.png", 0);
    var s_pla_ship_carrier_ver_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_carrier_ver_sunk.addImage("s_pla_ship_carrier_ver_sunk.png", 0);
    var s_pla_ship_battleship_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_battleship_hor.addImage("s_pla_ship_battleship_hor.png", 0);
    var s_pla_ship_battleship_hor_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_battleship_hor_sunk.addImage("s_pla_ship_battleship_hor_sunk.png", 0);
    var s_pla_ship_battleship_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_battleship_ver.addImage("s_pla_ship_battleship_ver.png", 0);
    var s_pla_ship_battleship_ver_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_battleship_ver_sunk.addImage("s_pla_ship_battleship_ver_sunk.png", 0);
    var s_pla_ship_cruiser_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_cruiser_hor.addImage("s_pla_ship_cruiser_hor.png", 0);
    var s_pla_ship_cruiser_hor_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_cruiser_hor_sunk.addImage("s_pla_ship_cruiser_hor_sunk.png", 0);
    var s_pla_ship_cruiser_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_cruiser_ver.addImage("s_pla_ship_cruiser_ver.png", 0);
    var s_pla_ship_cruiser_ver_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_cruiser_ver_sunk.addImage("s_pla_ship_cruiser_ver_sunk.png", 0);
    var s_pla_ship_submarine_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_submarine_hor.addImage("s_pla_ship_submarine_hor.png", 0);
    var s_pla_ship_submarine_hor_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_submarine_hor_sunk.addImage("s_pla_ship_submarine_hor_sunk.png", 0);
    var s_pla_ship_submarine_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_submarine_ver.addImage("s_pla_ship_submarine_ver.png", 0);
    var s_pla_ship_submarine_ver_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_submarine_ver_sunk.addImage("s_pla_ship_submarine_ver_sunk.png", 0);
    var s_pla_ship_destroyer_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_destroyer_hor.addImage("s_pla_ship_destroyer_hor.png", 0);
    var s_pla_ship_destroyer_hor_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_destroyer_hor_sunk.addImage("s_pla_ship_destroyer_hor_sunk.png", 0);
    var s_pla_ship_destroyer_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_destroyer_ver.addImage("s_pla_ship_destroyer_ver.png", 0);
    var s_pla_ship_destroyer_ver_sunk = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_pla_ship_destroyer_ver_sunk.addImage("s_pla_ship_destroyer_ver_sunk.png", 0);
    var s_pla_tile_board = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_pla_tile_board.addImage("s_pla_tile_board.png", 0);
    var s_pla_miss_buoy = new tbImage(texture_whitespace, 1,undefined , {"x": 35,"y": 35 } );
s_pla_miss_buoy.addImage("s_pla_miss_buoy.png", 0);
    var s_pla_fire_cap = new tbImage(texture_whitespace, 2,undefined , {"x": 158,"y": 469 } );
s_pla_fire_cap.addImage("s_pla_fire_cap.png", 0);
s_pla_fire_cap.addImage("s_pla_fire_cap1.png", 1);
    var s_fire_led_on = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_fire_led_on.addImage("s_fire_led_on.png", 0);
    var s_pla_dialogue_fire = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_pla_dialogue_fire.addImage("s_pla_dialogue_fire.png", 0);
    var s_pla_fire_button = new tbImage(texture_whitespace, 2,undefined , {"x": 180,"y": 180 } );
s_pla_fire_button.addImage("s_pla_fire_button.png", 0);
s_pla_fire_button.addImage("s_pla_fire_button1.png", 1);
    var s_pla_fire_button_glow_red = new tbImage(texture_game, 1,undefined , {"x": 180,"y": 180 } );
s_pla_fire_button_glow_red.addImage("s_pla_fire_button_glow_red.png", 0);
    var s_pla_fire_button_glow_white = new tbImage(texture_whitespace, 1,undefined , {"x": 180,"y": 180 } );
s_pla_fire_button_glow_white.addImage("s_pla_fire_button_glow_white.png", 0);
    var s_pla_fire_overlay = new tbImage(texture_game, 1,undefined , {"x": 683,"y": 660 } );
s_pla_fire_overlay.addImage("s_pla_fire_overlay.png", 0);
    var s_pla_fire_button_icon_00 = new tbImage(texture_game, 1,undefined , {"x": 97,"y": 97 } );
s_pla_fire_button_icon_00.addImage("s_pla_fire_button_icon_00.png", 0);
    var s_pla_fire_button_icon_01 = new tbImage(texture_game, 1,undefined , {"x": 97,"y": 97 } );
s_pla_fire_button_icon_01.addImage("s_pla_fire_button_icon_01.png", 0);
    var s_pla_fire_button_icon_02 = new tbImage(texture_game, 1,undefined , {"x": 97,"y": 97 } );
s_pla_fire_button_icon_02.addImage("s_pla_fire_button_icon_02.png", 0);
    var s_pla_fire_button_icon_04 = new tbImage(texture_game, 1,undefined , {"x": 97,"y": 97 } );
s_pla_fire_button_icon_04.addImage("s_pla_fire_button_icon_04.png", 0);
    var s_pla_fire_button_icon_05 = new tbImage(texture_game, 1,undefined , {"x": 97,"y": 97 } );
s_pla_fire_button_icon_05.addImage("s_pla_fire_button_icon_05.png", 0);
    var s_pla_fire_overlay_clock = new tbImage(texture_game, 1,undefined , {"x": 98,"y": 29 } );
s_pla_fire_overlay_clock.addImage("s_pla_fire_overlay_clock.png", 0);
    var s_button_standard_down = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_standard_down.addImage("s_button_standard_down.png", 0);
    var s_button_special_weapon_down_01 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_down_01.addImage("s_button_special_weapon_down_01.png", 0);
    var s_button_special_weapon_down_02 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_down_02.addImage("s_button_special_weapon_down_02.png", 0);
    var s_button_special_weapon_down_04 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_down_04.addImage("s_button_special_weapon_down_04.png", 0);
    var s_button_special_weapon_down_05 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_down_05.addImage("s_button_special_weapon_down_05.png", 0);
    var s_button_special_weapon_inactive_01 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_inactive_01.addImage("s_button_special_weapon_inactive_01.png", 0);
    var s_button_special_weapon_inactive_02 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_inactive_02.addImage("s_button_special_weapon_inactive_02.png", 0);
    var s_button_special_weapon_inactive_04 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_inactive_04.addImage("s_button_special_weapon_inactive_04.png", 0);
    var s_button_special_weapon_inactive_05 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_inactive_05.addImage("s_button_special_weapon_inactive_05.png", 0);
    var s_button_special_weapon_lock_down_01 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_lock_down_01.addImage("s_button_special_weapon_lock_down_01.png", 0);
    var s_button_special_weapon_lock_down_02 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_lock_down_02.addImage("s_button_special_weapon_lock_down_02.png", 0);
    var s_button_special_weapon_lock_down_04 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_lock_down_04.addImage("s_button_special_weapon_lock_down_04.png", 0);
    var s_button_special_weapon_lock_down_05 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_lock_down_05.addImage("s_button_special_weapon_lock_down_05.png", 0);
    var s_button_standard_up = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_standard_up.addImage("s_button_standard_up.png", 0);
    var s_button_special_weapon_up_01 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_up_01.addImage("s_button_special_weapon_up_01.png", 0);
    var s_button_special_weapon_up_02 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_up_02.addImage("s_button_special_weapon_up_02.png", 0);
    var s_button_special_weapon_up_04 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_up_04.addImage("s_button_special_weapon_up_04.png", 0);
    var s_button_special_weapon_up_05 = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_special_weapon_up_05.addImage("s_button_special_weapon_up_05.png", 0);
    var s_button_add = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_button_add.addImage("s_button_add.png", 0);
    var s_circle = new tbImage(texture_game, 1,undefined , {"x": 230,"y": 230 } );
s_circle.addImage("s_circle.png", 0);
    var s_sp_lock = new tbImage(texture, 1,undefined , {"x": 24,"y": 38 } );
s_sp_lock.addImage("s_sp_lock.png", 0);
    var s_opp_radar_swoosh = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_opp_radar_swoosh.addImage("s_opp_radar_swoosh.png", 0);
    var s_opp_miss = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_opp_miss.addImage("s_opp_miss.png", 0);
    var s_opp_hit = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_opp_hit.addImage("s_opp_hit.png", 0);
    var s_opp_ship_cruiser_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_cruiser_hor.addImage("s_opp_ship_cruiser_hor.png", 0);
    var s_opp_ship_cruiser_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_cruiser_ver.addImage("s_opp_ship_cruiser_ver.png", 0);
    var s_opp_ship_destroyer_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_destroyer_hor.addImage("s_opp_ship_destroyer_hor.png", 0);
    var s_opp_ship_destroyer_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_destroyer_ver.addImage("s_opp_ship_destroyer_ver.png", 0);
    var s_opp_ship_carrier_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_carrier_ver.addImage("s_opp_ship_carrier_ver.png", 0);
    var s_opp_submarine_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_submarine_hor.addImage("s_opp_submarine_hor.png", 0);
    var s_opp_submarine_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_submarine_ver.addImage("s_opp_submarine_ver.png", 0);
    var s_opp_ship_battleship_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_battleship_hor.addImage("s_opp_ship_battleship_hor.png", 0);
    var s_opp_ship_battleship_ver = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_battleship_ver.addImage("s_opp_ship_battleship_ver.png", 0);
    var s_opp_ship_carrier_hor = new tbImage(texture_whitespace, 1,undefined , {"x": 74,"y": 74 } );
s_opp_ship_carrier_hor.addImage("s_opp_ship_carrier_hor.png", 0);
    var s_button_rotate = new tbImage(texture_shared, 2,undefined , {"x": 0,"y": 0 } );
s_button_rotate.addImage("s_button_rotate.png", 0);
s_button_rotate.addImage("s_button_rotate1.png", 1);
    var s_grid_tile_place_illegal = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_grid_tile_place_illegal.addImage("s_grid_tile_place_illegal.png", 0);
    var s_grid_tile_place_legal = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_grid_tile_place_legal.addImage("s_grid_tile_place_legal.png", 0);
    var s_overlay_shipyard = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_shipyard.addImage("s_overlay_shipyard.png", 0);
    var s_ship_place_battleship = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_ship_place_battleship.addImage("s_ship_place_battleship.png", 0);
    var s_ship_place_carrier = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_ship_place_carrier.addImage("s_ship_place_carrier.png", 0);
    var s_ship_place_cruiser = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_ship_place_cruiser.addImage("s_ship_place_cruiser.png", 0);
    var s_ship_place_destroyer = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_ship_place_destroyer.addImage("s_ship_place_destroyer.png", 0);
    var s_ship_place_submarine = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_ship_place_submarine.addImage("s_ship_place_submarine.png", 0);
    var s_grid_tile_place_validation = new tbImage(texture_game, 2,undefined , {"x": 0,"y": 0 } );
s_grid_tile_place_validation.addImage("s_grid_tile_place_validation.png", 0);
s_grid_tile_place_validation.addImage("s_grid_tile_place_validation1.png", 1);
    var s_overlay_ready = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_ready.addImage("s_overlay_ready.png", 0);
    var s_popup_tobattle = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_popup_tobattle.addImage("s_popup_tobattle.png", 0);
    var s_ship_place_cruiser_h = new tbImage(texture_game, 1,undefined , {"x": 143,"y": 66 } );
s_ship_place_cruiser_h.addImage("s_ship_place_cruiser_h.png", 0);
    var s_ship_place_destroyer_h = new tbImage(texture_game, 1,undefined , {"x": 100,"y": 61 } );
s_ship_place_destroyer_h.addImage("s_ship_place_destroyer_h.png", 0);
    var s_ship_place_submarine_h = new tbImage(texture_game, 1,undefined , {"x": 150,"y": 61 } );
s_ship_place_submarine_h.addImage("s_ship_place_submarine_h.png", 0);
    var s_ship_place_battleship_h = new tbImage(texture_game, 1,undefined , {"x": 189,"y": 62 } );
s_ship_place_battleship_h.addImage("s_ship_place_battleship_h.png", 0);
    var s_ship_place_carrier_h = new tbImage(texture_game, 1,undefined , {"x": 240,"y": 59 } );
s_ship_place_carrier_h.addImage("s_ship_place_carrier_h.png", 0);
    var s_overlay_turnindicator_player = new tbImage(texture_whitespace, 1,undefined , {"x": 999,"y": 140 } );
s_overlay_turnindicator_player.addImage("s_overlay_turnindicator_player.png", 0);
    var s_overlay_turnindicator_opponent = new tbImage(texture_whitespace, 1,undefined , {"x": 139,"y": 140 } );
s_overlay_turnindicator_opponent.addImage("s_overlay_turnindicator_opponent.png", 0);
    var s_overlay_waiting_for_opp_avatar = new tbImage(texture_game, 1,undefined , {"x": 33,"y": 33 } );
s_overlay_waiting_for_opp_avatar.addImage("s_overlay_waiting_for_opp_avatar.png", 0);
    var s_overlay_waiting_for_opp_gradient = new tbImage(texture_game, 1,undefined , {"x": 38,"y": 38 } );
s_overlay_waiting_for_opp_gradient.addImage("s_overlay_waiting_for_opp_gradient.png", 0);
    var s_overlay_waiting_for_opp_panel = new tbImage(texture_game, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_waiting_for_opp_panel.addImage("s_overlay_waiting_for_opp_panel.png", 0);
    var s_overlay_waiting_for_opp_greenlight = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_waiting_for_opp_greenlight.addImage("s_overlay_waiting_for_opp_greenlight.png", 0);
    var s_pla_dia_special_weapon = new tbImage(texture, 1,undefined , {"x": 479,"y": 94 } );
s_pla_dia_special_weapon.addImage("s_pla_dia_special_weapon.png", 0);
    var s_pla_dia_special_weapon_small = new tbImage(texture, 1,undefined , {"x": 479,"y": 77 } );
s_pla_dia_special_weapon_small.addImage("s_pla_dia_special_weapon_small.png", 0);
    var s_pla_dia_special_weapon_arrow = new tbImage(texture, 1,undefined , {"x": 34,"y": 0 } );
s_pla_dia_special_weapon_arrow.addImage("s_pla_dia_special_weapon_arrow.png", 0);
    var s_pla_crosshair = new tbImage(texture_game, 1,undefined , {"x": 35,"y": 35 } );
s_pla_crosshair.addImage("s_pla_crosshair.png", 0);
    var s_ingame_background = new tbImage(texture_backgrounds_8x8, 1,undefined , {"x": 0,"y": 0 } );
s_ingame_background.addImage("s_ingame_background.png", 0);
    var s_background_artic = new tbImage(texture_backgrounds_8x8, 1,undefined , {"x": 0,"y": 0 } );
s_background_artic.addImage("s_background_artic.png", 0);
    var s_background_tropicalbeach = new tbImage(texture_backgrounds_8x8, 1,undefined , {"x": 0,"y": 0 } );
s_background_tropicalbeach.addImage("s_background_tropicalbeach.png", 0);
    var explosion18 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion18.addImage("explosion18.png", 0);
    var buoy = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
buoy.addImage("buoy.png", 0);
    var buoy01 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
buoy01.addImage("buoy01.png", 0);
    var buoy02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
buoy02.addImage("buoy02.png", 0);
    var buoy03 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
buoy03.addImage("buoy03.png", 0);
    var buoy04 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
buoy04.addImage("buoy04.png", 0);
    var buoy05 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
buoy05.addImage("buoy05.png", 0);
    var JET_PLANE_0000_Jet_light = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_0000_Jet_light.addImage("JET_PLANE_0000_Jet_light.png", 0);
    var splash01 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash01.addImage("splash01.png", 0);
    var splash02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash02.addImage("splash02.png", 0);
    var splash03 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash03.addImage("splash03.png", 0);
    var splash04 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash04.addImage("splash04.png", 0);
    var splash05 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash05.addImage("splash05.png", 0);
    var splash06 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash06.addImage("splash06.png", 0);
    var splash07 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash07.addImage("splash07.png", 0);
    var splash11 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash11.addImage("splash11.png", 0);
    var splash12 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash12.addImage("splash12.png", 0);
    var explosion01 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion01.addImage("explosion01.png", 0);
    var explosion02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion02.addImage("explosion02.png", 0);
    var explosion03 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion03.addImage("explosion03.png", 0);
    var explosion04 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion04.addImage("explosion04.png", 0);
    var explosion05 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion05.addImage("explosion05.png", 0);
    var explosion09 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion09.addImage("explosion09.png", 0);
    var explosion10 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion10.addImage("explosion10.png", 0);
    var explosion11 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion11.addImage("explosion11.png", 0);
    var explosion12 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion12.addImage("explosion12.png", 0);
    var explosion13 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion13.addImage("explosion13.png", 0);
    var explosion14 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion14.addImage("explosion14.png", 0);
    var explosion15 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion15.addImage("explosion15.png", 0);
    var explosion19 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion19.addImage("explosion19.png", 0);
    var explosion20 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion20.addImage("explosion20.png", 0);
    var explosion21 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion21.addImage("explosion21.png", 0);
    var JET_PLANE_0004_jet_shadow = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_0004_jet_shadow.addImage("JET_PLANE_0004_jet_shadow.png", 0);
    var JET_PLANE_VERTICAL_0002_JET_VETICAL = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_VERTICAL_0002_JET_VETICAL.addImage("JET_PLANE_VERTICAL_0002_JET_VETICAL.png", 0);
    var JET_PLANE_VERTICAL_0001_JET_VETICAL_FIRE_GREEN = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_VERTICAL_0001_JET_VETICAL_FIRE_GREEN.addImage("JET_PLANE_VERTICAL_0001_JET_VETICAL_FIRE_GREEN.png", 0);
    var Special_weapon_02_circle_r = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_02_circle_r.addImage("Special_weapon_02_circle_r.png", 0);
    var JET_PLANE_0003_jet_bomb = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_0003_jet_bomb.addImage("JET_PLANE_0003_jet_bomb.png", 0);
    var projectile = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
projectile.addImage("projectile.png", 0);
    var ripple = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
ripple.addImage("ripple.png", 0);
    var splash08 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash08.addImage("splash08.png", 0);
    var splash09 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash09.addImage("splash09.png", 0);
    var splash10 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splash10.addImage("splash10.png", 0);
    var explosion06 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion06.addImage("explosion06.png", 0);
    var JET_PLANE_VERTICAL_0003_JET_VETICAL_FIRE = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_VERTICAL_0003_JET_VETICAL_FIRE.addImage("JET_PLANE_VERTICAL_0003_JET_VETICAL_FIRE.png", 0);
    var explosion07 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion07.addImage("explosion07.png", 0);
    var explosion08 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion08.addImage("explosion08.png", 0);
    var explosion16 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion16.addImage("explosion16.png", 0);
    var explosion17 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
explosion17.addImage("explosion17.png", 0);
    var shockwave_ripple = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
shockwave_ripple.addImage("shockwave_ripple.png", 0);
    var flash_light = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
flash_light.addImage("flash_light.png", 0);
    var globe_01 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
globe_01.addImage("globe_01.png", 0);
    var globe_02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
globe_02.addImage("globe_02.png", 0);
    var globe_03 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
globe_03.addImage("globe_03.png", 0);
    var glow = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
glow.addImage("glow.png", 0);
    var JET_PLANE_0001_Jet_plane = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_0001_Jet_plane.addImage("JET_PLANE_0001_Jet_plane.png", 0);
    var JET_PLANE_0002_Jet_fire = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_0002_Jet_fire.addImage("JET_PLANE_0002_Jet_fire.png", 0);
    var Special_weapon_2 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_2.addImage("Special_weapon_2.png", 0);
    var JET_PLANE_VERTICAL_0000_JET_VETICAL_GREEN = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_VERTICAL_0000_JET_VETICAL_GREEN.addImage("JET_PLANE_VERTICAL_0000_JET_VETICAL_GREEN.png", 0);
    var JET_PLANE_VERTICAL_0004_JET_VETICAL_SHADOW = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
JET_PLANE_VERTICAL_0004_JET_VETICAL_SHADOW.addImage("JET_PLANE_VERTICAL_0004_JET_VETICAL_SHADOW.png", 0);
    var Special_weapon_02_circle_02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_02_circle_02.addImage("Special_weapon_02_circle_02.png", 0);
    var Special_weapon_2_green = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_2_green.addImage("Special_weapon_2_green.png", 0);
    var Special_weapon_2_shadow = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_2_shadow.addImage("Special_weapon_2_shadow.png", 0);
    var flash_white = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
flash_white.addImage("flash_white.png", 0);
    var s_areaeffect_playerfield = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_areaeffect_playerfield.addImage("s_areaeffect_playerfield.png", 0);
    var s_pulse_playerfield = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_pulse_playerfield.addImage("s_pulse_playerfield.png", 0);
    var cluster_bomb_02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
cluster_bomb_02.addImage("cluster_bomb_02.png", 0);
    var cluster_bomb_02_GREEN = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
cluster_bomb_02_GREEN.addImage("cluster_bomb_02_GREEN.png", 0);
    var cluster_bomb_02_SHADOW = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
cluster_bomb_02_SHADOW.addImage("cluster_bomb_02_SHADOW.png", 0);
    var cluster_bomb_04 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 12,"y": 24 } );
cluster_bomb_04.addImage("cluster_bomb_04.png", 0);
    var cluster_bomb_06 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
cluster_bomb_06.addImage("cluster_bomb_06.png", 0);
    var cluster_bomb_fire = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
cluster_bomb_fire.addImage("cluster_bomb_fire.png", 0);
    var FR_020 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_020.addImage("FR_020.png", 0);
    var FR_021 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_021.addImage("FR_021.png", 0);
    var FR_022 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_022.addImage("FR_022.png", 0);
    var FR_023 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_023.addImage("FR_023.png", 0);
    var FR_024 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_024.addImage("FR_024.png", 0);
    var FR_025 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_025.addImage("FR_025.png", 0);
    var FR_026 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_026.addImage("FR_026.png", 0);
    var FR_027 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_027.addImage("FR_027.png", 0);
    var FR_028 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_028.addImage("FR_028.png", 0);
    var FR_029 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_029.addImage("FR_029.png", 0);
    var FR_030 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_030.addImage("FR_030.png", 0);
    var FR_031 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_031.addImage("FR_031.png", 0);
    var FR_032 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_032.addImage("FR_032.png", 0);
    var FR_033 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_033.addImage("FR_033.png", 0);
    var FR_034 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_034.addImage("FR_034.png", 0);
    var FR_035 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_035.addImage("FR_035.png", 0);
    var FR_036 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_036.addImage("FR_036.png", 0);
    var FR_037 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_037.addImage("FR_037.png", 0);
    var FR_038 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_038.addImage("FR_038.png", 0);
    var FR_039 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_039.addImage("FR_039.png", 0);
    var FR_040 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_040.addImage("FR_040.png", 0);
    var FR_041 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_041.addImage("FR_041.png", 0);
    var FR_042 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_042.addImage("FR_042.png", 0);
    var FR_043 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_043.addImage("FR_043.png", 0);
    var FR_044 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_044.addImage("FR_044.png", 0);
    var FR_045 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
FR_045.addImage("FR_045.png", 0);
    var s_drone = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_drone.addImage("s_drone.png", 0);
    var s_drone_propshine_01 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_drone_propshine_01.addImage("s_drone_propshine_01.png", 0);
    var s_drone_propshine_02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_drone_propshine_02.addImage("s_drone_propshine_02.png", 0);
    var s_drone_shadow = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_drone_shadow.addImage("s_drone_shadow.png", 0);
    var s_water01 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_water01.addImage("s_water01.png", 0);
    var s_water02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_water02.addImage("s_water02.png", 0);
    var Special_weapon_2_GREEN = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_2_GREEN.addImage("Special_weapon_2_GREEN.png", 0);
    var Special_weapon_2_SHADOW = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_2_SHADOW.addImage("Special_weapon_2_SHADOW.png", 0);
    var splashes = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
splashes.addImage("splashes.png", 0);
    var s_torpedo_special_weapon = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_torpedo_special_weapon.addImage("s_torpedo_special_weapon.png", 0);
    var torpedo_green = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
torpedo_green.addImage("torpedo_green.png", 0);
    var torpedo_shadow = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
torpedo_shadow.addImage("torpedo_shadow.png", 0);
    var torpedo_wave = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
torpedo_wave.addImage("torpedo_wave.png", 0);
    var torpedo_wave_green = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
torpedo_wave_green.addImage("torpedo_wave_green.png", 0);
    var s_opp_hit_2 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_opp_hit_2.addImage("s_opp_hit_2.png", 0);
    var s_opp_miss_2 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_opp_miss_2.addImage("s_opp_miss_2.png", 0);
    var missile = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
missile.addImage("missile.png", 0);
    var plane = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
plane.addImage("plane.png", 0);
    var weapon_02 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
weapon_02.addImage("weapon_02.png", 0);
    var clustor_bomb = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
clustor_bomb.addImage("clustor_bomb.png", 0);
    var s_drone_radar = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_drone_radar.addImage("s_drone_radar.png", 0);
    var s_pulse_radar = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_pulse_radar.addImage("s_pulse_radar.png", 0);
    var torpedo = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
torpedo.addImage("torpedo.png", 0);
    var torpedo_bubble = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
torpedo_bubble.addImage("torpedo_bubble.png", 0);
    var torpedo_bubble2 = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
torpedo_bubble2.addImage("torpedo_bubble2.png", 0);
    var torpedo_bubbleA = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
torpedo_bubbleA.addImage("torpedo_bubbleA.png", 0);
    var wave14 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave14.addImage("wave14.png", 0);
    var flames01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames01.addImage("flames01.png", 0);
    var flames02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames02.addImage("flames02.png", 0);
    var flames03 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames03.addImage("flames03.png", 0);
    var flames04 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames04.addImage("flames04.png", 0);
    var flames05 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames05.addImage("flames05.png", 0);
    var flames06 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames06.addImage("flames06.png", 0);
    var flames07 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames07.addImage("flames07.png", 0);
    var flames08 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames08.addImage("flames08.png", 0);
    var flames09 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames09.addImage("flames09.png", 0);
    var flames10 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames10.addImage("flames10.png", 0);
    var flames11 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames11.addImage("flames11.png", 0);
    var flames12 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
flames12.addImage("flames12.png", 0);
    var ripple_back_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_01.addImage("ripple_back_01.png", 0);
    var ripple_back_02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_02.addImage("ripple_back_02.png", 0);
    var ripple_back_03 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_03.addImage("ripple_back_03.png", 0);
    var ripple_back_04 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_04.addImage("ripple_back_04.png", 0);
    var ripple_back_05 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_05.addImage("ripple_back_05.png", 0);
    var ripple_front = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_front.addImage("ripple_front.png", 0);
    var s_pla_ship_battleship_hor_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_battleship_hor_skin_01.addImage("s_pla_ship_battleship_hor_skin_01.png", 0);
    var s_pla_ship_battleship_hor_skin_02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_battleship_hor_skin_02.addImage("s_pla_ship_battleship_hor_skin_02.png", 0);
    var s_pla_ship_battleship_ver_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_battleship_ver_skin_01.addImage("s_pla_ship_battleship_ver_skin_01.png", 0);
    var s_pla_ship_battleship_ver_skin_02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_battleship_ver_skin_02.addImage("s_pla_ship_battleship_ver_skin_02.png", 0);
    var s_pla_ship_carrier_hor_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_carrier_hor_skin_01.addImage("s_pla_ship_carrier_hor_skin_01.png", 0);
    var s_pla_ship_carrier_ver_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_carrier_ver_skin_01.addImage("s_pla_ship_carrier_ver_skin_01.png", 0);
    var s_pla_ship_cruiser_hor_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_cruiser_hor_skin_01.addImage("s_pla_ship_cruiser_hor_skin_01.png", 0);
    var s_pla_ship_cruiser_ver_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_cruiser_ver_skin_01.addImage("s_pla_ship_cruiser_ver_skin_01.png", 0);
    var s_pla_ship_destroyer_hor_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_destroyer_hor_skin_01.addImage("s_pla_ship_destroyer_hor_skin_01.png", 0);
    var s_pla_ship_destroyer_ver_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_destroyer_ver_skin_01.addImage("s_pla_ship_destroyer_ver_skin_01.png", 0);
    var s_pla_ship_submarine_hor_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_submarine_hor_skin_01.addImage("s_pla_ship_submarine_hor_skin_01.png", 0);
    var s_pla_ship_submarine_ver_skin_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_pla_ship_submarine_ver_skin_01.addImage("s_pla_ship_submarine_ver_skin_01.png", 0);
    var s_ripple_center = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_ripple_center.addImage("s_ripple_center.png", 0);
    var s_ripple_circle = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_ripple_circle.addImage("s_ripple_circle.png", 0);
    var SMOKE__0000 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0000.addImage("SMOKE__0000.png", 0);
    var SMOKE__0001 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0001.addImage("SMOKE__0001.png", 0);
    var SMOKE__0002 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0002.addImage("SMOKE__0002.png", 0);
    var SMOKE__0003 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0003.addImage("SMOKE__0003.png", 0);
    var SMOKE__0004 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0004.addImage("SMOKE__0004.png", 0);
    var SMOKE__0005 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0005.addImage("SMOKE__0005.png", 0);
    var SMOKE__0006 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0006.addImage("SMOKE__0006.png", 0);
    var SMOKE__0007 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0007.addImage("SMOKE__0007.png", 0);
    var SMOKE__0008 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0008.addImage("SMOKE__0008.png", 0);
    var SMOKE__0009 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0009.addImage("SMOKE__0009.png", 0);
    var SMOKE__0010 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0010.addImage("SMOKE__0010.png", 0);
    var SMOKE__0011 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0011.addImage("SMOKE__0011.png", 0);
    var SMOKE__0012 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0012.addImage("SMOKE__0012.png", 0);
    var SMOKE__0013 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0013.addImage("SMOKE__0013.png", 0);
    var SMOKE__0014 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0014.addImage("SMOKE__0014.png", 0);
    var SMOKE__0015 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0015.addImage("SMOKE__0015.png", 0);
    var SMOKE__0016 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0016.addImage("SMOKE__0016.png", 0);
    var SMOKE__0017 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
SMOKE__0017.addImage("SMOKE__0017.png", 0);
    var splash_02_05 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_05.addImage("splash_02_05.png", 0);
    var splash_02_06 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_06.addImage("splash_02_06.png", 0);
    var splash_02_07 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_07.addImage("splash_02_07.png", 0);
    var splash_02_08 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_08.addImage("splash_02_08.png", 0);
    var splash_02_09 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_09.addImage("splash_02_09.png", 0);
    var splash_02_10 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_10.addImage("splash_02_10.png", 0);
    var splash_02_11 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_11.addImage("splash_02_11.png", 0);
    var splash_02_12 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_12.addImage("splash_02_12.png", 0);
    var steam_left_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_01.addImage("steam_left_01.png", 0);
    var steam_left_02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_02.addImage("steam_left_02.png", 0);
    var steam_left_03 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_03.addImage("steam_left_03.png", 0);
    var steam_left_04 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_04.addImage("steam_left_04.png", 0);
    var steam_left_05 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_05.addImage("steam_left_05.png", 0);
    var steam_left_06 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_06.addImage("steam_left_06.png", 0);
    var steam_left_07 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_07.addImage("steam_left_07.png", 0);
    var steam_left_08 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_08.addImage("steam_left_08.png", 0);
    var steam_left_09 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_09.addImage("steam_left_09.png", 0);
    var steam_left_10 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_10.addImage("steam_left_10.png", 0);
    var steam_left_11 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_11.addImage("steam_left_11.png", 0);
    var steam_left_12 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_12.addImage("steam_left_12.png", 0);
    var steam_left_13 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_13.addImage("steam_left_13.png", 0);
    var steam_left_14 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_14.addImage("steam_left_14.png", 0);
    var steam_left_15 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_15.addImage("steam_left_15.png", 0);
    var steam_left_16 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_16.addImage("steam_left_16.png", 0);
    var steam_left_17 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_17.addImage("steam_left_17.png", 0);
    var steam_left_18 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_18.addImage("steam_left_18.png", 0);
    var steam_left_19 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_left_19.addImage("steam_left_19.png", 0);
    var steam_right_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_01.addImage("steam_right_01.png", 0);
    var steam_right_02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_02.addImage("steam_right_02.png", 0);
    var steam_right_03 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_03.addImage("steam_right_03.png", 0);
    var steam_right_04 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_04.addImage("steam_right_04.png", 0);
    var steam_right_05 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_05.addImage("steam_right_05.png", 0);
    var steam_right_06 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_06.addImage("steam_right_06.png", 0);
    var steam_right_07 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_07.addImage("steam_right_07.png", 0);
    var steam_right_08 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_08.addImage("steam_right_08.png", 0);
    var steam_right_09 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_09.addImage("steam_right_09.png", 0);
    var steam_right_10 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_10.addImage("steam_right_10.png", 0);
    var steam_right_11 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_11.addImage("steam_right_11.png", 0);
    var steam_right_12 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_12.addImage("steam_right_12.png", 0);
    var steam_right_13 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_13.addImage("steam_right_13.png", 0);
    var steam_right_14 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_14.addImage("steam_right_14.png", 0);
    var steam_right_15 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_15.addImage("steam_right_15.png", 0);
    var steam_right_16 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_16.addImage("steam_right_16.png", 0);
    var steam_right_17 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_17.addImage("steam_right_17.png", 0);
    var steam_right_18 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_18.addImage("steam_right_18.png", 0);
    var steam_right_19 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
steam_right_19.addImage("steam_right_19.png", 0);
    var wave01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave01.addImage("wave01.png", 0);
    var wave02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave02.addImage("wave02.png", 0);
    var wave03 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave03.addImage("wave03.png", 0);
    var wave04 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave04.addImage("wave04.png", 0);
    var wave05 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave05.addImage("wave05.png", 0);
    var wave06 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave06.addImage("wave06.png", 0);
    var wave07 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave07.addImage("wave07.png", 0);
    var wave08 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave08.addImage("wave08.png", 0);
    var wave09 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave09.addImage("wave09.png", 0);
    var wave10 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave10.addImage("wave10.png", 0);
    var wave11 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave11.addImage("wave11.png", 0);
    var wave12 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave12.addImage("wave12.png", 0);
    var wave13 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
wave13.addImage("wave13.png", 0);
    var ripple_back_hor_02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_hor_02.addImage("ripple_back_hor_02.png", 0);
    var splash_04_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_04_placement.addImage("splash_04_placement.png", 0);
    var splash_05_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_05_placement.addImage("splash_05_placement.png", 0);
    var splash_06_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_06_placement.addImage("splash_06_placement.png", 0);
    var splash_07_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_07_placement.addImage("splash_07_placement.png", 0);
    var splash_08_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_08_placement.addImage("splash_08_placement.png", 0);
    var splash_09_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_09_placement.addImage("splash_09_placement.png", 0);
    var splash_10_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_10_placement.addImage("splash_10_placement.png", 0);
    var splash_11_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_11_placement.addImage("splash_11_placement.png", 0);
    var splash_02_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_02_placement.addImage("splash_02_placement.png", 0);
    var splash_03_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_03_placement.addImage("splash_03_placement.png", 0);
    var s_explosion01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion01.addImage("s_explosion01.png", 0);
    var s_explosion02 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion02.addImage("s_explosion02.png", 0);
    var s_explosion03 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion03.addImage("s_explosion03.png", 0);
    var s_explosion04 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion04.addImage("s_explosion04.png", 0);
    var s_explosion05 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion05.addImage("s_explosion05.png", 0);
    var s_explosion06 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion06.addImage("s_explosion06.png", 0);
    var s_explosion07 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion07.addImage("s_explosion07.png", 0);
    var s_explosion08 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion08.addImage("s_explosion08.png", 0);
    var s_explosion09 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion09.addImage("s_explosion09.png", 0);
    var s_explosion10 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion10.addImage("s_explosion10.png", 0);
    var s_explosion11 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_explosion11.addImage("s_explosion11.png", 0);
    var ripple_back_hor_04 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_hor_04.addImage("ripple_back_hor_04.png", 0);
    var ripple_back_hor_05 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_hor_05.addImage("ripple_back_hor_05.png", 0);
    var ripple_back_hor_01 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_hor_01.addImage("ripple_back_hor_01.png", 0);
    var ripple_back_hor_03 = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
ripple_back_hor_03.addImage("ripple_back_hor_03.png", 0);
    var splash_01_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
splash_01_placement.addImage("splash_01_placement.png", 0);
    var s_ripple_placement = new tbImage(texture_battleship, 1,undefined , {"x": 0,"y": 0 } );
s_ripple_placement.addImage("s_ripple_placement.png", 0);
    var s_fire_08 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_08.addImage("s_fire_08.png", 0);
    var s_fire_09 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_09.addImage("s_fire_09.png", 0);
    var s_ripple_big = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_ripple_big.addImage("s_ripple_big.png", 0);
    var s_ship_sinking = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_ship_sinking.addImage("s_ship_sinking.png", 0);
    var s_smoke_circle = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_smoke_circle.addImage("s_smoke_circle.png", 0);
    var s_airswoosh = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_airswoosh.addImage("s_airswoosh.png", 0);
    var s_bubble = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_bubble.addImage("s_bubble.png", 0);
    var s_fire_01 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_01.addImage("s_fire_01.png", 0);
    var s_fire_02 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_02.addImage("s_fire_02.png", 0);
    var s_fire_03 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_03.addImage("s_fire_03.png", 0);
    var s_fire_04 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_04.addImage("s_fire_04.png", 0);
    var s_fire_05 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_05.addImage("s_fire_05.png", 0);
    var s_fire_06 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_06.addImage("s_fire_06.png", 0);
    var s_fire_07 = new tbImage(texture_result_lose, 1,undefined , {"x": 0,"y": 0 } );
s_fire_07.addImage("s_fire_07.png", 0);
    var s_fireworks = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_fireworks.addImage("s_fireworks.png", 0);
    var s_jet = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_jet.addImage("s_jet.png", 0);
    var s_rays = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_rays.addImage("s_rays.png", 0);
    var s_ship = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_ship.addImage("s_ship.png", 0);
    var s_smoketrail_1 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_smoketrail_1.addImage("s_smoketrail_1.png", 0);
    var s_smoketrail_2 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_smoketrail_2.addImage("s_smoketrail_2.png", 0);
    var s_smoketrail_3 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_smoketrail_3.addImage("s_smoketrail_3.png", 0);
    var s_waves_1 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_1.addImage("s_waves_1.png", 0);
    var s_waves_2 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_2.addImage("s_waves_2.png", 0);
    var s_waves_3 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_3.addImage("s_waves_3.png", 0);
    var s_waves_4 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_4.addImage("s_waves_4.png", 0);
    var s_waves_5 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_5.addImage("s_waves_5.png", 0);
    var s_waves_6 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_6.addImage("s_waves_6.png", 0);
    var s_waves_7 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_7.addImage("s_waves_7.png", 0);
    var s_waves_8 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_8.addImage("s_waves_8.png", 0);
    var s_waves_9 = new tbImage(texture_result_win, 1,undefined , {"x": 0,"y": 0 } );
s_waves_9.addImage("s_waves_9.png", 0);
    var s_bouy = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_bouy.addImage("s_bouy.png", 0);
    var s_plaque = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_plaque.addImage("s_plaque.png", 0);
    var s_sparks = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_sparks.addImage("s_sparks.png", 0);
    var s_birdbanner = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_birdbanner.addImage("s_birdbanner.png", 0);
    var s_birdbanner_shine01 = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_birdbanner_shine01.addImage("s_birdbanner_shine01.png", 0);
    var s_birdbanner_shine02 = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_birdbanner_shine02.addImage("s_birdbanner_shine02.png", 0);
    var s_birdbanner_shine03 = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_birdbanner_shine03.addImage("s_birdbanner_shine03.png", 0);
    var s_birdbanner_shine04 = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_birdbanner_shine04.addImage("s_birdbanner_shine04.png", 0);
    var s_birdbanner_shine05 = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_birdbanner_shine05.addImage("s_birdbanner_shine05.png", 0);
    var s_birdbanner_shine06 = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_birdbanner_shine06.addImage("s_birdbanner_shine06.png", 0);
    var s_birdbanner_shine07 = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_birdbanner_shine07.addImage("s_birdbanner_shine07.png", 0);
    var s_colors = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_colors.addImage("s_colors.png", 0);
    var s_win_plaque = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_win_plaque.addImage("s_win_plaque.png", 0);
    var s_matchresult_rays = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_matchresult_rays.addImage("s_matchresult_rays.png", 0);
    var s_shine = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_shine.addImage("s_shine.png", 0);
    var s_stars = new tbImage(texture_matchresult, 1,undefined , {"x": 0,"y": 0 } );
s_stars.addImage("s_stars.png", 0);
    var shipyard_splash_01_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_01_placement.addImage("shipyard_splash_01_placement.png", 0);
    var shipyard_splash_02_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_02_placement.addImage("shipyard_splash_02_placement.png", 0);
    var shipyard_splash_03_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_03_placement.addImage("shipyard_splash_03_placement.png", 0);
    var shipyard_splash_04_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_04_placement.addImage("shipyard_splash_04_placement.png", 0);
    var shipyard_splash_05_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_05_placement.addImage("shipyard_splash_05_placement.png", 0);
    var shipyard_splash_06_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_06_placement.addImage("shipyard_splash_06_placement.png", 0);
    var shipyard_splash_07_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_07_placement.addImage("shipyard_splash_07_placement.png", 0);
    var shipyard_splash_08_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_08_placement.addImage("shipyard_splash_08_placement.png", 0);
    var shipyard_splash_09_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_09_placement.addImage("shipyard_splash_09_placement.png", 0);
    var shipyard_splash_10_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_10_placement.addImage("shipyard_splash_10_placement.png", 0);
    var shipyard_splash_11_placement = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
shipyard_splash_11_placement.addImage("shipyard_splash_11_placement.png", 0);
    var Special_weapon_01_circle = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_01_circle.addImage("Special_weapon_01_circle.png", 0);
    var Special_weapon_02_circle = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
Special_weapon_02_circle.addImage("Special_weapon_02_circle.png", 0);
    var corner_miss = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
corner_miss.addImage("corner_miss.png", 0);
    var flash = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
flash.addImage("flash.png", 0);
    var flash_green = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
flash_green.addImage("flash_green.png", 0);
    var s_indication = new tbImage(texture_board_missile_animation, 1,undefined , {"x": 0,"y": 0 } );
s_indication.addImage("s_indication.png", 0);
    var bling = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
bling.addImage("bling.png", 0);
    var distroyed_shadow = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
distroyed_shadow.addImage("distroyed_shadow.png", 0);
    var distroyed = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
distroyed.addImage("distroyed.png", 0);
    var progress_circle = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
progress_circle.addImage("progress_circle.png", 0);
    var shine = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
shine.addImage("shine.png", 0);
    var special_weapon_shadow = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
special_weapon_shadow.addImage("special_weapon_shadow.png", 0);
    var special_weapon = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
special_weapon.addImage("special_weapon.png", 0);
    var survived_shadow = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
survived_shadow.addImage("survived_shadow.png", 0);
    var survived = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
survived.addImage("survived.png", 0);
    var victory_shadow = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
victory_shadow.addImage("victory_shadow.png", 0);
    var victory = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
victory.addImage("victory.png", 0);
    var lost = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
lost.addImage("lost.png", 0);
    var lost_shadow = new tbImage(texture_badges, 1,undefined , {"x": 0,"y": 0 } );
lost_shadow.addImage("lost_shadow.png", 0);
    var door_left = new tbImage(texture_doors, 1,undefined , {"x": 0,"y": 0 } );
door_left.addImage("door_left.png", 0);
    var door_right = new tbImage(texture_doors, 1,undefined , {"x": 0,"y": 0 } );
door_right.addImage("door_right.png", 0);
    var s_effect_01 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_effect_01.addImage("s_effect_01.png", 0);
    var s_effect_02 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_effect_02.addImage("s_effect_02.png", 0);
    var s_leaf_left_01 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_left_01.addImage("s_leaf_left_01.png", 0);
    var s_leaf_left_02 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_left_02.addImage("s_leaf_left_02.png", 0);
    var s_leaf_left_03 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_left_03.addImage("s_leaf_left_03.png", 0);
    var s_leaf_left_04 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_left_04.addImage("s_leaf_left_04.png", 0);
    var s_leaf_left_05 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_left_05.addImage("s_leaf_left_05.png", 0);
    var s_leaf_left_06 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_left_06.addImage("s_leaf_left_06.png", 0);
    var s_leaf_left_07 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_left_07.addImage("s_leaf_left_07.png", 0);
    var s_leaf_right_01 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_right_01.addImage("s_leaf_right_01.png", 0);
    var s_leaf_right_02 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_right_02.addImage("s_leaf_right_02.png", 0);
    var s_leaf_right_03 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_right_03.addImage("s_leaf_right_03.png", 0);
    var s_leaf_right_04 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_right_04.addImage("s_leaf_right_04.png", 0);
    var s_leaf_right_05 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_right_05.addImage("s_leaf_right_05.png", 0);
    var s_leaf_right_06 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_right_06.addImage("s_leaf_right_06.png", 0);
    var s_leaf_right_07 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_leaf_right_07.addImage("s_leaf_right_07.png", 0);
    var s_medal_placeholder_01 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_medal_placeholder_01.addImage("s_medal_placeholder_01.png", 0);
    var s_medal_placeholder_02 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_medal_placeholder_02.addImage("s_medal_placeholder_02.png", 0);
    var s_sfx_bling_fr_01 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_01.addImage("s_sfx_bling_fr_01.png", 0);
    var s_sfx_bling_fr_02 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_02.addImage("s_sfx_bling_fr_02.png", 0);
    var s_sfx_bling_fr_03 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_03.addImage("s_sfx_bling_fr_03.png", 0);
    var s_sfx_bling_fr_04 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_04.addImage("s_sfx_bling_fr_04.png", 0);
    var s_sfx_bling_fr_05 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_05.addImage("s_sfx_bling_fr_05.png", 0);
    var s_sfx_bling_fr_06 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_06.addImage("s_sfx_bling_fr_06.png", 0);
    var s_sfx_bling_fr_07 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_07.addImage("s_sfx_bling_fr_07.png", 0);
    var s_sfx_bling_fr_08 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_08.addImage("s_sfx_bling_fr_08.png", 0);
    var s_sfx_bling_fr_09 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_09.addImage("s_sfx_bling_fr_09.png", 0);
    var s_sfx_bling_fr_10 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_10.addImage("s_sfx_bling_fr_10.png", 0);
    var s_sfx_bling_fr_11 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_11.addImage("s_sfx_bling_fr_11.png", 0);
    var s_sfx_bling_fr_12 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_12.addImage("s_sfx_bling_fr_12.png", 0);
    var s_sfx_bling_fr_13 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_13.addImage("s_sfx_bling_fr_13.png", 0);
    var s_sfx_bling_fr_14 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_14.addImage("s_sfx_bling_fr_14.png", 0);
    var s_sfx_bling_fr_15 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_15.addImage("s_sfx_bling_fr_15.png", 0);
    var s_sfx_bling_fr_16 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_16.addImage("s_sfx_bling_fr_16.png", 0);
    var s_sfx_bling_fr_17 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_bling_fr_17.addImage("s_sfx_bling_fr_17.png", 0);
    var s_sfx_lightning_fr_01 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_01.addImage("s_sfx_lightning_fr_01.png", 0);
    var s_sfx_lightning_fr_02 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_02.addImage("s_sfx_lightning_fr_02.png", 0);
    var s_sfx_lightning_fr_03 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_03.addImage("s_sfx_lightning_fr_03.png", 0);
    var s_sfx_lightning_fr_04 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_04.addImage("s_sfx_lightning_fr_04.png", 0);
    var s_sfx_lightning_fr_05 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_05.addImage("s_sfx_lightning_fr_05.png", 0);
    var s_sfx_lightning_fr_06 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_06.addImage("s_sfx_lightning_fr_06.png", 0);
    var s_sfx_lightning_fr_07 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_07.addImage("s_sfx_lightning_fr_07.png", 0);
    var s_sfx_lightning_fr_08 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_08.addImage("s_sfx_lightning_fr_08.png", 0);
    var s_sfx_lightning_fr_09 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_09.addImage("s_sfx_lightning_fr_09.png", 0);
    var s_sfx_lightning_fr_10 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_10.addImage("s_sfx_lightning_fr_10.png", 0);
    var s_sfx_lightning_fr_11 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_11.addImage("s_sfx_lightning_fr_11.png", 0);
    var s_sfx_lightning_fr_12 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_12.addImage("s_sfx_lightning_fr_12.png", 0);
    var s_sfx_lightning_fr_13 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_13.addImage("s_sfx_lightning_fr_13.png", 0);
    var s_sfx_lightning_fr_14 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_14.addImage("s_sfx_lightning_fr_14.png", 0);
    var s_sfx_lightning_fr_15 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_15.addImage("s_sfx_lightning_fr_15.png", 0);
    var s_sfx_lightning_fr_16 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_16.addImage("s_sfx_lightning_fr_16.png", 0);
    var s_sfx_lightning_fr_17 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_17.addImage("s_sfx_lightning_fr_17.png", 0);
    var s_sfx_lightning_fr_18 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_18.addImage("s_sfx_lightning_fr_18.png", 0);
    var s_sfx_lightning_fr_19 = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_sfx_lightning_fr_19.addImage("s_sfx_lightning_fr_19.png", 0);
    var s_shield = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_shield.addImage("s_shield.png", 0);
    var s_shield_beams = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_shield_beams.addImage("s_shield_beams.png", 0);
    var s_shield_glow = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_shield_glow.addImage("s_shield_glow.png", 0);
    var s_banner = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_banner.addImage("s_banner.png", 0);
    var s_banner_dept = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_banner_dept.addImage("s_banner_dept.png", 0);
    var s_banner_left = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_banner_left.addImage("s_banner_left.png", 0);
    var s_banner_right = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_banner_right.addImage("s_banner_right.png", 0);
    var s_captain_head = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_captain_head.addImage("s_captain_head.png", 0);
    var s_captain_head_shadow = new tbImage(texture_rankup, 1,undefined , {"x": 0,"y": 0 } );
s_captain_head_shadow.addImage("s_captain_head_shadow.png", 0);
    var lock_close = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
lock_close.addImage("lock_close.png", 0);
    var s_chest_back = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_chest_back.addImage("s_chest_back.png", 0);
    var s_chest_front = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_chest_front.addImage("s_chest_front.png", 0);
    var s_chest_lid = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_chest_lid.addImage("s_chest_lid.png", 0);
    var s_chest_lid_open = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_chest_lid_open.addImage("s_chest_lid_open.png", 0);
    var s_fx_rays_01 = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_fx_rays_01.addImage("s_fx_rays_01.png", 0);
    var s_fx_rays_02 = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_fx_rays_02.addImage("s_fx_rays_02.png", 0);
    var s_fx_shine_01 = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_fx_shine_01.addImage("s_fx_shine_01.png", 0);
    var s_fx_shine_02 = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_fx_shine_02.addImage("s_fx_shine_02.png", 0);
    var s_particle_green = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_particle_green.addImage("s_particle_green.png", 0);
    var s_reward_airstrike_btn = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_reward_airstrike_btn.addImage("s_reward_airstrike_btn.png", 0);
    var s_reward_airstrike_image = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_reward_airstrike_image.addImage("s_reward_airstrike_image.png", 0);
    var s_reward_rocket_btn = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_reward_rocket_btn.addImage("s_reward_rocket_btn.png", 0);
    var s_reward_rocket_image = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_reward_rocket_image.addImage("s_reward_rocket_image.png", 0);
    var s_reward_scatter_btn = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_reward_scatter_btn.addImage("s_reward_scatter_btn.png", 0);
    var s_reward_scatter_image = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_reward_scatter_image.addImage("s_reward_scatter_image.png", 0);
    var s_reward_torpedo_btn = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_reward_torpedo_btn.addImage("s_reward_torpedo_btn.png", 0);
    var s_reward_torpedo_image = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
s_reward_torpedo_image.addImage("s_reward_torpedo_image.png", 0);
    var d_txt_torpedounlocked = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
d_txt_torpedounlocked.addImage("d_txt_torpedounlocked.png", 0);
    var d_txt_rocketlocked = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
d_txt_rocketlocked.addImage("d_txt_rocketlocked.png", 0);
    var d_txt_scatterlocked = new tbImage(texture_weapon_unlock, 1,undefined , {"x": 0,"y": 0 } );
d_txt_scatterlocked.addImage("d_txt_scatterlocked.png", 0);
    var backgound = new tbImage(texture_unused, 1,undefined , {"x": 0,"y": 0 } );
backgound.addImage("backgound.png", 0);
    var s_tutorial_circle = new tbImage(texture_onboarding, 1,undefined , {"x": 0,"y": 0 } );
s_tutorial_circle.addImage("s_tutorial_circle.png", 0);
    var s_tutorial_circle_blue = new tbImage(texture_onboarding, 1,undefined , {"x": 0,"y": 0 } );
s_tutorial_circle_blue.addImage("s_tutorial_circle_blue.png", 0);
    var s_tutorial_hand = new tbImage(texture_onboarding, 1,undefined , {"x": 0,"y": 0 } );
s_tutorial_hand.addImage("s_tutorial_hand.png", 0);
    var s_tutorial_hand_shadow = new tbImage(texture_onboarding, 1,undefined , {"x": 0,"y": 0 } );
s_tutorial_hand_shadow.addImage("s_tutorial_hand_shadow.png", 0);
    var s_button_music = new tbImage(texture_whitespace, 2,undefined , {"x": 29,"y": 43 } );
s_button_music.addImage("s_button_music.png", 0);
s_button_music.addImage("s_button_music1.png", 1);
    var s_button_sound = new tbImage(texture_whitespace, 2,undefined , {"x": 29,"y": 43 } );
s_button_sound.addImage("s_button_sound.png", 0);
s_button_sound.addImage("s_button_sound1.png", 1);
    var s_button_exit = new tbImage(texture, 2,undefined , {"x": 0,"y": 0 } );
s_button_exit.addImage("s_button_exit.png", 0);
s_button_exit.addImage("s_button_exit1.png", 1);
    var s_button_next_battle = new tbImage(texture_whitespace, 2,undefined , {"x": 0,"y": 0 } );
s_button_next_battle.addImage("s_button_next_battle.png", 0);
s_button_next_battle.addImage("s_button_next_battle1.png", 1);
    var s_button_next_battle_exit = new tbImage(texture_whitespace, 2,undefined , {"x": 0,"y": 0 } );
s_button_next_battle_exit.addImage("s_button_next_battle_exit.png", 0);
s_button_next_battle_exit.addImage("s_button_next_battle_exit1.png", 1);
    var s_next_battle_button_updated = new tbImage(texture_whitespace, 1,undefined , {"x": 846,"y": 0 } );
s_next_battle_button_updated.addImage("s_next_battle_button_updated.png", 0);
    var s_next_battle_header = new tbImage(texture_whitespace, 1,undefined , {"x": 768,"y": 0 } );
s_next_battle_header.addImage("s_next_battle_header.png", 0);
    var s_next_battle_button_pannel = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_next_battle_button_pannel.addImage("s_next_battle_button_pannel.png", 0);
    var s_avatar_player = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_avatar_player.addImage("s_avatar_player.png", 0);
    var s_avatar_captain_rhighstreets = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_avatar_captain_rhighstreets.addImage("s_avatar_captain_rhighstreets.png", 0);
    var s_avatar_captain_robin = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_avatar_captain_robin.addImage("s_avatar_captain_robin.png", 0);
    var s_avatar_captain_brock = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_avatar_captain_brock.addImage("s_avatar_captain_brock.png", 0);
    var s_avatar_captain_carol = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_avatar_captain_carol.addImage("s_avatar_captain_carol.png", 0);
    var s_avatar_captain_hyung = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_avatar_captain_hyung.addImage("s_avatar_captain_hyung.png", 0);
    var s_avatar_captain_maverick = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_avatar_captain_maverick.addImage("s_avatar_captain_maverick.png", 0);
    var s_connection_lost = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_connection_lost.addImage("s_connection_lost.png", 0);
    var s_exclamation_mark = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_exclamation_mark.addImage("s_exclamation_mark.png", 0);
    var s_logo_de = new tbImage(texture_logo, 1,undefined , {"x": 0,"y": 0 } );
s_logo_de.addImage("s_logo_de.png", 0);
    var s_logo_en = new tbImage(texture_logo, 1,undefined , {"x": 0,"y": 0 } );
s_logo_en.addImage("s_logo_en.png", 0);
    var s_logo_es = new tbImage(texture_logo, 1,undefined , {"x": 0,"y": 0 } );
s_logo_es.addImage("s_logo_es.png", 0);
    var s_logo_fr = new tbImage(texture_logo, 1,undefined , {"x": 0,"y": 0 } );
s_logo_fr.addImage("s_logo_fr.png", 0);
    var s_logo_it = new tbImage(texture_logo, 1,undefined , {"x": 0,"y": 0 } );
s_logo_it.addImage("s_logo_it.png", 0);
    var s_logo_nl = new tbImage(texture_logo, 1,undefined , {"x": 0,"y": 0 } );
s_logo_nl.addImage("s_logo_nl.png", 0);
    var s_logo_tr = new tbImage(texture_logo, 1,undefined , {"x": 0,"y": 0 } );
s_logo_tr.addImage("s_logo_tr.png", 0);
    var s_throbber = new tbImage(texture_whitespace, 1,undefined , {"x": 49,"y": 92 } );
s_throbber.addImage("s_throbber.png", 0);
    var s_throbber_bg = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_throbber_bg.addImage("s_throbber_bg.png", 0);
    var captain_body_ = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_body_.addImage("captain_body_.png", 0);
    var captain_arm_upper = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_arm_upper.addImage("captain_arm_upper.png", 0);
    var captain_arm_lower = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_arm_lower.addImage("captain_arm_lower.png", 0);
    var captain_eyes_closed = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_eyes_closed.addImage("captain_eyes_closed.png", 0);
    var icon_sw_03 = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
icon_sw_03.addImage("icon_sw_03.png", 0);
    var icon_sw_04 = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
icon_sw_04.addImage("icon_sw_04.png", 0);
    var icon_sw_05 = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
icon_sw_05.addImage("icon_sw_05.png", 0);
    var icon_sw_01 = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
icon_sw_01.addImage("icon_sw_01.png", 0);
    var icon_sw_02 = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
icon_sw_02.addImage("icon_sw_02.png", 0);
    var textballoon = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
textballoon.addImage("textballoon.png", 0);
    var captain_mouth_open = new tbImage(popup_reload_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_mouth_open.addImage("captain_mouth_open.png", 0);
    var s_big_popup = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_big_popup.addImage("s_big_popup.png", 0);
    var captain_arm_left = new tbImage(popup_extra_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_arm_left.addImage("captain_arm_left.png", 0);
    var captain_arm_right = new tbImage(popup_extra_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_arm_right.addImage("captain_arm_right.png", 0);
    var captain_body = new tbImage(popup_extra_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_body.addImage("captain_body.png", 0);
    var captain_cape = new tbImage(popup_extra_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_cape.addImage("captain_cape.png", 0);
    var captain_expression = new tbImage(popup_extra_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_expression.addImage("captain_expression.png", 0);
    var captain_hat = new tbImage(popup_extra_texture, 1,undefined , {"x": 0,"y": 0 } );
captain_hat.addImage("captain_hat.png", 0);
    var icon_firebutton = new tbImage(popup_extra_texture, 1,undefined , {"x": 0,"y": 0 } );
icon_firebutton.addImage("icon_firebutton.png", 0);
    var button = new tbImage(texture_sw_icon_add, 1,undefined , {"x": 0,"y": 0 } );
button.addImage("button.png", 0);
    var button_movie = new tbImage(texture_sw_icon_add, 1,undefined , {"x": 0,"y": 0 } );
button_movie.addImage("button_movie.png", 0);
    var s_icon_add = new tbImage(texture_sw_icon_add, 1,undefined , {"x": 0,"y": 0 } );
s_icon_add.addImage("s_icon_add.png", 0);
    var popup_bottom = new tbImage(texture, 1,undefined , {"x": 359,"y": 0 } );
popup_bottom.addImage("popup_bottom.png", 0);
    var s_back_icon = new tbImage(texture, 1,undefined , {"x": 18,"y": 19 } );
s_back_icon.addImage("s_back_icon.png", 0);
    var s_button_close_popup = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_button_close_popup.addImage("s_button_close_popup.png", 0);
    var s_icon_destroyed = new tbImage(texture_reward_badges, 1,undefined , {"x": 54,"y": 52 } );
s_icon_destroyed.addImage("s_icon_destroyed.png", 0);
    var s_icon_destroyed_dropshadow = new tbImage(texture_reward_badges, 1,undefined , {"x": 55,"y": 53 } );
s_icon_destroyed_dropshadow.addImage("s_icon_destroyed_dropshadow.png", 0);
    var s_icon_destroyed_shadow = new tbImage(texture_reward_badges, 1,undefined , {"x": 58,"y": 59 } );
s_icon_destroyed_shadow.addImage("s_icon_destroyed_shadow.png", 0);
    var s_icon_special_weapon = new tbImage(texture_reward_badges, 1,undefined , {"x": 57,"y": 53 } );
s_icon_special_weapon.addImage("s_icon_special_weapon.png", 0);
    var s_icon_special_weapon_dropshadow = new tbImage(texture_reward_badges, 1,undefined , {"x": 57,"y": 53 } );
s_icon_special_weapon_dropshadow.addImage("s_icon_special_weapon_dropshadow.png", 0);
    var s_icon_special_weapon_shadow = new tbImage(texture_reward_badges, 1,undefined , {"x": 60,"y": 59 } );
s_icon_special_weapon_shadow.addImage("s_icon_special_weapon_shadow.png", 0);
    var s_icon_survived = new tbImage(texture_reward_badges, 1,undefined , {"x": 56,"y": 55 } );
s_icon_survived.addImage("s_icon_survived.png", 0);
    var s_icon_survived_dropshadow = new tbImage(texture_reward_badges, 1,undefined , {"x": 56,"y": 55 } );
s_icon_survived_dropshadow.addImage("s_icon_survived_dropshadow.png", 0);
    var s_icon_survived_shadow = new tbImage(texture_reward_badges, 1,undefined , {"x": 59,"y": 61 } );
s_icon_survived_shadow.addImage("s_icon_survived_shadow.png", 0);
    var s_icon_victory = new tbImage(texture_reward_badges, 1,undefined , {"x": 64,"y": 53 } );
s_icon_victory.addImage("s_icon_victory.png", 0);
    var s_icon_victory_shadow = new tbImage(texture_reward_badges, 1,undefined , {"x": 67,"y": 59 } );
s_icon_victory_shadow.addImage("s_icon_victory_shadow.png", 0);
    var s_icon_lost = new tbImage(texture_reward_badges, 1,undefined , {"x": 66,"y": 56 } );
s_icon_lost.addImage("s_icon_lost.png", 0);
    var s_icon_lost_shadow = new tbImage(texture_reward_badges, 1,undefined , {"x": 66,"y": 56 } );
s_icon_lost_shadow.addImage("s_icon_lost_shadow.png", 0);
    var s_result_add = new tbImage(texture_reward_badges, 1,undefined , {"x": 0,"y": 0 } );
s_result_add.addImage("s_result_add.png", 0);
    var s_result_times = new tbImage(texture_reward_badges, 1,undefined , {"x": 0,"y": 0 } );
s_result_times.addImage("s_result_times.png", 0);
    var s_progress_bar = new tbImage(texture_reward_progress, 1,undefined , {"x": 326,"y": 43 } );
s_progress_bar.addImage("s_progress_bar.png", 0);
    var s_progress_border = new tbImage(texture_reward_progress, 1,undefined , {"x": 294,"y": 28 } );
s_progress_border.addImage("s_progress_border.png", 0);
    var s_progress_bubble_filling = new tbImage(texture_reward_progress, 1,undefined , {"x": 0,"y": 0 } );
s_progress_bubble_filling.addImage("s_progress_bubble_filling.png", 0);
    var s_progress_bubble_filling_glow = new tbImage(texture_reward_progress, 1,undefined , {"x": 25,"y": 24 } );
s_progress_bubble_filling_glow.addImage("s_progress_bubble_filling_glow.png", 0);
    var s_progress_circle = new tbImage(texture_reward_progress, 1,undefined , {"x": 40,"y": 40 } );
s_progress_circle.addImage("s_progress_circle.png", 0);
    var s_progress_filling = new tbImage(texture_reward_progress, 1,undefined , {"x": 0,"y": 0 } );
s_progress_filling.addImage("s_progress_filling.png", 0);
    var s_movie_icon_orange = new tbImage(texture_reward_progress, 1,undefined , {"x": 0,"y": 0 } );
s_movie_icon_orange.addImage("s_movie_icon_orange.png", 0);
    var s_ui_icon_rank01_04 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank01_04.addImage("s_ui_icon_rank01_04.png", 0);
    var s_ui_icon_rank02_59 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank02_59.addImage("s_ui_icon_rank02_59.png", 0);
    var s_ui_icon_rank03_1014 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank03_1014.addImage("s_ui_icon_rank03_1014.png", 0);
    var s_ui_icon_rank04_1519 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank04_1519.addImage("s_ui_icon_rank04_1519.png", 0);
    var s_ui_icon_rank05_2024 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank05_2024.addImage("s_ui_icon_rank05_2024.png", 0);
    var s_ui_icon_rank06_2529 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank06_2529.addImage("s_ui_icon_rank06_2529.png", 0);
    var s_ui_icon_rank07_3034 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank07_3034.addImage("s_ui_icon_rank07_3034.png", 0);
    var s_ui_icon_rank08_3539 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank08_3539.addImage("s_ui_icon_rank08_3539.png", 0);
    var s_ui_icon_rank09_4044 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank09_4044.addImage("s_ui_icon_rank09_4044.png", 0);
    var s_ui_icon_rank10_4549 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank10_4549.addImage("s_ui_icon_rank10_4549.png", 0);
    var s_ui_icon_rank11_5054 = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank11_5054.addImage("s_ui_icon_rank11_5054.png", 0);
    var s_ui_icon_rank01_04_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank01_04_grey.addImage("s_ui_icon_rank01_04_grey.png", 0);
    var s_ui_icon_rank02_59_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank02_59_grey.addImage("s_ui_icon_rank02_59_grey.png", 0);
    var s_ui_icon_rank03_1014_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank03_1014_grey.addImage("s_ui_icon_rank03_1014_grey.png", 0);
    var s_ui_icon_rank04_1519_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank04_1519_grey.addImage("s_ui_icon_rank04_1519_grey.png", 0);
    var s_ui_icon_rank05_2024_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank05_2024_grey.addImage("s_ui_icon_rank05_2024_grey.png", 0);
    var s_ui_icon_rank06_2529_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank06_2529_grey.addImage("s_ui_icon_rank06_2529_grey.png", 0);
    var s_ui_icon_rank07_3034_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank07_3034_grey.addImage("s_ui_icon_rank07_3034_grey.png", 0);
    var s_ui_icon_rank08_3539_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank08_3539_grey.addImage("s_ui_icon_rank08_3539_grey.png", 0);
    var s_ui_icon_rank09_4044_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank09_4044_grey.addImage("s_ui_icon_rank09_4044_grey.png", 0);
    var s_ui_icon_rank10_4549_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank10_4549_grey.addImage("s_ui_icon_rank10_4549_grey.png", 0);
    var s_ui_icon_rank11_5054_grey = new tbImage(texture_whitespace, 1,undefined , {"x": 90,"y": 98 } );
s_ui_icon_rank11_5054_grey.addImage("s_ui_icon_rank11_5054_grey.png", 0);
    var s_splash_loadingscreen = new tbImage(texture_splash, 1,undefined , {"x": 0,"y": 0 } );
s_splash_loadingscreen.addImage("s_splash_loadingscreen.png", 0);
    var s_ui_loadingbar_loadscreen_bg = new tbImage(texture_splash, 1,undefined , {"x": 0,"y": 0 } );
s_ui_loadingbar_loadscreen_bg.addImage("s_ui_loadingbar_loadscreen_bg.png", 0);
    var s_ui_loadingbar_loadscreen_fill = new tbImage(texture_splash, 1,undefined , {"x": 0,"y": 0 } );
s_ui_loadingbar_loadscreen_fill.addImage("s_ui_loadingbar_loadscreen_fill.png", 0);
    var s_ui_portrait = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_ui_portrait.addImage("s_ui_portrait.png", 0);
    var s_background = new tbImage(texture, 4,undefined , {"x": 0,"y": 0 } );
s_background.addImage("s_background.png", 0);
s_background.addImage("s_background1.png", 1);
s_background.addImage("s_background2.png", 2);
s_background.addImage("s_background3.png", 3);
    var s_screen_start = new tbImage(texture, 4,undefined , {"x": 0,"y": 0 } );
s_screen_start.addImage("s_screen_start.png", 0);
s_screen_start.addImage("s_screen_start1.png", 1);
s_screen_start.addImage("s_screen_start2.png", 2);
s_screen_start.addImage("s_screen_start3.png", 3);
    var s_default_profile_image = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_default_profile_image.addImage("s_default_profile_image.png", 0);
    var s_tgf_console_pause = new tbImage(FrameworkTexture, 1,undefined , {"x": 2,"y": 2 } );
s_tgf_console_pause.addImage("s_tgf_console_pause.png", 0);
    var s_tgf_console_restart = new tbImage(FrameworkTexture, 1,undefined , {"x": 2,"y": 2 } );
s_tgf_console_restart.addImage("s_tgf_console_restart.png", 0);
    var s_tgf_console_step = new tbImage(FrameworkTexture, 1,undefined , {"x": 2,"y": 2 } );
s_tgf_console_step.addImage("s_tgf_console_step.png", 0);
    var s_tgf_console_position = new tbImage(FrameworkTexture, 1,undefined , {"x": 2,"y": 2 } );
s_tgf_console_position.addImage("s_tgf_console_position.png", 0);
    var s_tgf_console_close = new tbImage(FrameworkTexture, 1,undefined , {"x": 2,"y": 2 } );
s_tgf_console_close.addImage("s_tgf_console_close.png", 0);
    var s_tgf_console_play = new tbImage(FrameworkTexture, 1,undefined , {"x": 2,"y": 2 } );
s_tgf_console_play.addImage("s_tgf_console_play.png", 0);
    var s_tgf_flag_us = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_us.addImage("s_tgf_flag_us.png", 0);
    var s_tgf_flag_gb = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_gb.addImage("s_tgf_flag_gb.png", 0);
    var s_tgf_flag_nl = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_nl.addImage("s_tgf_flag_nl.png", 0);
    var s_tgf_flag_tr = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_tr.addImage("s_tgf_flag_tr.png", 0);
    var s_tgf_flag_de = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_de.addImage("s_tgf_flag_de.png", 0);
    var s_tgf_flag_fr = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_fr.addImage("s_tgf_flag_fr.png", 0);
    var s_tgf_flag_br = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_br.addImage("s_tgf_flag_br.png", 0);
    var s_tgf_flag_es = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_es.addImage("s_tgf_flag_es.png", 0);
    var s_tgf_flag_ru = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_ru.addImage("s_tgf_flag_ru.png", 0);
    var s_tgf_flag_ar = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_ar.addImage("s_tgf_flag_ar.png", 0);
    var s_tgf_flag_kr = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_kr.addImage("s_tgf_flag_kr.png", 0);
    var s_tgf_flag_unknown = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_unknown.addImage("s_tgf_flag_unknown.png", 0);
    var s_tgf_flag_jp = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_flag_jp.addImage("s_tgf_flag_jp.png", 0);
    var s_tgf_button = new tbImage(FrameworkTexture, 2,undefined , {"x": 0,"y": 0 } );
s_tgf_button.addImage("s_tgf_button.png", 0);
s_tgf_button.addImage("s_tgf_button1.png", 1);
    var s_tgf_frame = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_frame.addImage("s_tgf_frame.png", 0);
    var s_tgf_icon_difficulty_easy = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_difficulty_easy.addImage("s_tgf_icon_difficulty_easy.png", 0);
    var s_tgf_icon_difficulty_hard = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_difficulty_hard.addImage("s_tgf_icon_difficulty_hard.png", 0);
    var s_tgf_icon_difficulty_medium = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_difficulty_medium.addImage("s_tgf_icon_difficulty_medium.png", 0);
    var s_tgf_icon_exit = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_exit.addImage("s_tgf_icon_exit.png", 0);
    var s_tgf_icon_music_off = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_music_off.addImage("s_tgf_icon_music_off.png", 0);
    var s_tgf_icon_music_on = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_music_on.addImage("s_tgf_icon_music_on.png", 0);
    var s_tgf_icon_options = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_options.addImage("s_tgf_icon_options.png", 0);
    var s_tgf_icon_pause = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_pause.addImage("s_tgf_icon_pause.png", 0);
    var s_tgf_icon_play = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_play.addImage("s_tgf_icon_play.png", 0);
    var s_tgf_icon_play_large = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_play_large.addImage("s_tgf_icon_play_large.png", 0);
    var s_tgf_icon_quit = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_quit.addImage("s_tgf_icon_quit.png", 0);
    var s_tgf_icon_retry = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_retry.addImage("s_tgf_icon_retry.png", 0);
    var s_tgf_icon_retry_large = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_retry_large.addImage("s_tgf_icon_retry_large.png", 0);
    var s_tgf_icon_sound_off = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_sound_off.addImage("s_tgf_icon_sound_off.png", 0);
    var s_tgf_icon_sound_on = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_sound_on.addImage("s_tgf_icon_sound_on.png", 0);
    var s_tgf_icon_undo = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_icon_undo.addImage("s_tgf_icon_undo.png", 0);
    var s_tgf_notification_error = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_notification_error.addImage("s_tgf_notification_error.png", 0);
    var s_tgf_notification_message = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_notification_message.addImage("s_tgf_notification_message.png", 0);
    var s_tgf_notification_warning = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_notification_warning.addImage("s_tgf_notification_warning.png", 0);
    var s_tgf_progressbar_back = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_progressbar_back.addImage("s_tgf_progressbar_back.png", 0);
    var s_tgf_progressbar_fill = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_progressbar_fill.addImage("s_tgf_progressbar_fill.png", 0);
    var s_tgf_slider_back = new tbImage(FrameworkTexture, 2,undefined , {"x": 0,"y": 0 } );
s_tgf_slider_back.addImage("s_tgf_slider_back.png", 0);
s_tgf_slider_back.addImage("s_tgf_slider_back1.png", 1);
    var s_tgf_slider_slider = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_slider_slider.addImage("s_tgf_slider_slider.png", 0);
    var s_tgf_throbber = new tbImage(FrameworkTexture, 12,undefined , {"x": 0,"y": 0 } );
s_tgf_throbber.addImage("s_tgf_throbber.png", 0);
s_tgf_throbber.addImage("s_tgf_throbber1.png", 1);
s_tgf_throbber.addImage("s_tgf_throbber2.png", 2);
s_tgf_throbber.addImage("s_tgf_throbber3.png", 3);
s_tgf_throbber.addImage("s_tgf_throbber4.png", 4);
s_tgf_throbber.addImage("s_tgf_throbber5.png", 5);
s_tgf_throbber.addImage("s_tgf_throbber6.png", 6);
s_tgf_throbber.addImage("s_tgf_throbber7.png", 7);
s_tgf_throbber.addImage("s_tgf_throbber8.png", 8);
s_tgf_throbber.addImage("s_tgf_throbber9.png", 9);
s_tgf_throbber.addImage("s_tgf_throbber10.png", 10);
s_tgf_throbber.addImage("s_tgf_throbber11.png", 11);
    var s_tgf_transparent = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_transparent.addImage("s_tgf_transparent.png", 0);
    var s_tgf_tutorial_close = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_tutorial_close.addImage("s_tgf_tutorial_close.png", 0);
    var s_tgf_tutorial_next = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_tutorial_next.addImage("s_tgf_tutorial_next.png", 0);
    var s_tgf_tutorial_previous = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_tgf_tutorial_previous.addImage("s_tgf_tutorial_previous.png", 0);
    var s_logo_tinglygames_background = new tbImage(FlowStartTexture, 1,undefined , {"x": 0,"y": 0 } );
s_logo_tinglygames_background.addImage("s_logo_tinglygames_background.png", 0);
    var s_logo_tinglygames_large = new tbImage(FlowStartTexture, 1,undefined , {"x": 0,"y": 0 } );
s_logo_tinglygames_large.addImage("s_logo_tinglygames_large.png", 0);
    var s_logo_tinglygames_small = new tbImage(FlowStartTexture, 1,undefined , {"x": 2,"y": 2 } );
s_logo_tinglygames_small.addImage("s_logo_tinglygames_small.png", 0);
    var s_dialog_load_bar_back = new tbImage(FlowStartTexture, 1,undefined , {"x": 0,"y": 0 } );
s_dialog_load_bar_back.addImage("s_dialog_load_bar_back.png", 0);
    var s_dialog_load_bar_fill = new tbImage(FlowStartTexture, 1,undefined , {"x": 0,"y": 0 } );
s_dialog_load_bar_fill.addImage("s_dialog_load_bar_fill.png", 0);
    var s_dialog_load_btn_load = new tbImage(FlowStartTexture, 2,undefined , {"x": 0,"y": 0 } );
s_dialog_load_btn_load.addImage("s_dialog_load_btn_load.png", 0);
s_dialog_load_btn_load.addImage("s_dialog_load_btn_load1.png", 1);
    var s_dialog_load_frame = new tbImage(FlowStartTexture, 1,undefined , {"x": 0,"y": 0 } );
s_dialog_load_frame.addImage("s_dialog_load_frame.png", 0);
    var s_sfx_star = new tbImage(texture, 8,undefined , {"x": 0,"y": 0 } );
s_sfx_star.addImage("s_sfx_star.png", 0);
s_sfx_star.addImage("s_sfx_star1.png", 1);
s_sfx_star.addImage("s_sfx_star2.png", 2);
s_sfx_star.addImage("s_sfx_star3.png", 3);
s_sfx_star.addImage("s_sfx_star4.png", 4);
s_sfx_star.addImage("s_sfx_star5.png", 5);
s_sfx_star.addImage("s_sfx_star6.png", 6);
s_sfx_star.addImage("s_sfx_star7.png", 7);
    var s_star01_empty = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_star01_empty.addImage("s_star01_empty.png", 0);
    var s_star01_fill = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_star01_fill.addImage("s_star01_fill.png", 0);
    var s_star02_empty = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_star02_empty.addImage("s_star02_empty.png", 0);
    var s_star02_fill = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_star02_fill.addImage("s_star02_fill.png", 0);
    var s_star03_empty = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_star03_empty.addImage("s_star03_empty.png", 0);
    var s_star03_fill = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_star03_fill.addImage("s_star03_fill.png", 0);
    var blackAdFrame = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
blackAdFrame.addImage("blackAdFrame.png", 0);
    var s_level2_0 = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_level2_0.addImage("s_level2_0.png", 0);
    var s_level2_1 = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_level2_1.addImage("s_level2_1.png", 0);
    var s_level2_2 = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_level2_2.addImage("s_level2_2.png", 0);
    var s_level2_3 = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_level2_3.addImage("s_level2_3.png", 0);
    var s_level2_lock = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_level2_lock.addImage("s_level2_lock.png", 0);
    var s_logo_tinglygames = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_logo_tinglygames.addImage("s_logo_tinglygames.png", 0);
    var s_tgf_buttonSelect = new tbImage(texture, 2,undefined , {"x": 0,"y": 0 } );
s_tgf_buttonSelect.addImage("s_tgf_buttonSelect.png", 0);
s_tgf_buttonSelect.addImage("s_tgf_buttonSelect1.png", 1);
    var s_about = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_about.addImage("s_about.png", 0);
    var s_button_drop_icon_coin = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_button_drop_icon_coin.addImage("s_button_drop_icon_coin.png", 0);
    var s_overlay_worldmap_levelselect = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_overlay_worldmap_levelselect.addImage("s_overlay_worldmap_levelselect.png", 0);
    var s_profilepicture_default = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_profilepicture_default.addImage("s_profilepicture_default.png", 0);
    var s_tutorial = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_tutorial.addImage("s_tutorial.png", 0);
    var s_tutorialButton_exit = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_tutorialButton_exit.addImage("s_tutorialButton_exit.png", 0);
    var s_tutorialButton_next = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_tutorialButton_next.addImage("s_tutorialButton_next.png", 0);
    var s_tutorialButton_previous = new tbImage(texture, 1,undefined , {"x": 0,"y": 0 } );
s_tutorialButton_previous.addImage("s_tutorialButton_previous.png", 0);
    var s_btn_big_restart = new tbImage(texture, 2,undefined , {"x": 2,"y": 2 } );
s_btn_big_restart.addImage("s_btn_big_restart.png", 0);
s_btn_big_restart.addImage("s_btn_big_restart1.png", 1);
    var s_btn_big_start = new tbImage(texture, 2,undefined , {"x": 2,"y": 2 } );
s_btn_big_start.addImage("s_btn_big_start.png", 0);
s_btn_big_start.addImage("s_btn_big_start1.png", 1);
    var s_btn_bigtext = new tbImage(texture, 2,undefined , {"x": 1,"y": 2 } );
s_btn_bigtext.addImage("s_btn_bigtext.png", 0);
s_btn_bigtext.addImage("s_btn_bigtext1.png", 1);
    var s_btn_small_exit = new tbImage(texture, 2,undefined , {"x": 2,"y": 2 } );
s_btn_small_exit.addImage("s_btn_small_exit.png", 0);
s_btn_small_exit.addImage("s_btn_small_exit1.png", 1);
    var s_btn_small_options = new tbImage(texture, 2,undefined , {"x": 2,"y": 2 } );
s_btn_small_options.addImage("s_btn_small_options.png", 0);
s_btn_small_options.addImage("s_btn_small_options1.png", 1);
    var s_btn_small_pause = new tbImage(texture, 2,undefined , {"x": 2,"y": 2 } );
s_btn_small_pause.addImage("s_btn_small_pause.png", 0);
s_btn_small_pause.addImage("s_btn_small_pause1.png", 1);
    var s_btn_small_retry = new tbImage(texture, 2,undefined , {"x": 2,"y": 2 } );
s_btn_small_retry.addImage("s_btn_small_retry.png", 0);
s_btn_small_retry.addImage("s_btn_small_retry1.png", 1);
    var s_btn_small_undo = new tbImage(texture, 2,undefined , {"x": 2,"y": 2 } );
s_btn_small_undo.addImage("s_btn_small_undo.png", 0);
s_btn_small_undo.addImage("s_btn_small_undo1.png", 1);
    var s_btn_standard = new tbImage(texture, 2,undefined , {"x": 0,"y": 0 } );
s_btn_standard.addImage("s_btn_standard.png", 0);
s_btn_standard.addImage("s_btn_standard1.png", 1);
    var s_btn_toggle = new tbImage(texture, 2,undefined , {"x": 2,"y": 2 } );
s_btn_toggle.addImage("s_btn_toggle.png", 0);
s_btn_toggle.addImage("s_btn_toggle1.png", 1);
    var s_buttons_bigtext = new tbImage(texture, 2,undefined , {"x": 0,"y": 2 } );
s_buttons_bigtext.addImage("s_buttons_bigtext.png", 0);
s_buttons_bigtext.addImage("s_buttons_bigtext1.png", 1);
    var s_buttons_bigtext_play = new tbImage(texture, 1,undefined , {"x": 2,"y": 2 } );
s_buttons_bigtext_play.addImage("s_buttons_bigtext_play.png", 0);
    var s_icon_toggle_fxoff = new tbImage(texture, 2,undefined , {"x": 1,"y": 2 } );
s_icon_toggle_fxoff.addImage("s_icon_toggle_fxoff.png", 0);
s_icon_toggle_fxoff.addImage("s_icon_toggle_fxoff1.png", 1);
    var s_icon_toggle_fxon = new tbImage(texture, 2,undefined , {"x": 1,"y": 2 } );
s_icon_toggle_fxon.addImage("s_icon_toggle_fxon.png", 0);
s_icon_toggle_fxon.addImage("s_icon_toggle_fxon1.png", 1);
    var s_icon_toggle_music_off = new tbImage(texture, 1,undefined , {"x": 1,"y": 1 } );
s_icon_toggle_music_off.addImage("s_icon_toggle_music_off.png", 0);
    var s_icon_toggle_music_on = new tbImage(texture, 1,undefined , {"x": 1,"y": 1 } );
s_icon_toggle_music_on.addImage("s_icon_toggle_music_on.png", 0);
    var s_icon_toggle_musicoff = new tbImage(texture, 2,undefined , {"x": 1,"y": 2 } );
s_icon_toggle_musicoff.addImage("s_icon_toggle_musicoff.png", 0);
s_icon_toggle_musicoff.addImage("s_icon_toggle_musicoff1.png", 1);
    var s_icon_toggle_musicon = new tbImage(texture, 2,undefined , {"x": 0,"y": 0 } );
s_icon_toggle_musicon.addImage("s_icon_toggle_musicon.png", 0);
s_icon_toggle_musicon.addImage("s_icon_toggle_musicon1.png", 1);
    var s_icon_toggle_sfx_off = new tbImage(texture, 1,undefined , {"x": 1,"y": 1 } );
s_icon_toggle_sfx_off.addImage("s_icon_toggle_sfx_off.png", 0);
    var s_icon_toggle_sfx_on = new tbImage(texture, 1,undefined , {"x": 1,"y": 1 } );
s_icon_toggle_sfx_on.addImage("s_icon_toggle_sfx_on.png", 0);
    var s_ui_background = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_ui_background.addImage("s_ui_background.png", 0);
    var s_ui_progress_round_background = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_ui_progress_round_background.addImage("s_ui_progress_round_background.png", 0);
    var s_ui_progress_round_foreground = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_ui_progress_round_foreground.addImage("s_ui_progress_round_foreground.png", 0);
    var s_ui_star_empty = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_ui_star_empty.addImage("s_ui_star_empty.png", 0);
    var s_ui_star_filled = new tbImage(FrameworkTexture, 1,undefined , {"x": 0,"y": 0 } );
s_ui_star_filled.addImage("s_ui_star_filled.png", 0);

//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Fonts
//******************************************************
//******************************************************
//******************************************************


//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Vector Fonts
//******************************************************
//******************************************************
//******************************************************

    var ff_tgf_normalLoader = new tbVectorFontLoader("ff_tgf_normal", "fonts/ff_tgf_normal.woff", "fonts/ff_tgf_normal.ttf", "frameworkFonts");
    window["ff_tgf_normalLoader"] = ff_tgf_normalLoader;
    var ff_tgf_boldLoader = new tbVectorFontLoader("ff_tgf_bold", "fonts/ff_tgf_bold.woff", "fonts/ff_tgf_bold.ttf", "frameworkFonts");
    window["ff_tgf_boldLoader"] = ff_tgf_boldLoader;
    var f_tgf_title = new tbVectorFont("ff_tgf_bold", "Arial");
    window["f_tgf_title"] = f_tgf_title;
       f_tgf_title.setFontSize(48);
       f_tgf_title.setFill(true);
       f_tgf_title.setFillColor("Black");
       f_tgf_title.setFillAlpha(100/100);
       f_tgf_title.setStroke(false);
       f_tgf_title.setStrokeColor("Black");
       f_tgf_title.setStrokeWidth(1);
       f_tgf_title.setStrokeJoin("miter");
       f_tgf_title.setStrokeAlpha(100/100);
       f_tgf_title.setStrokeBehind(false);
       f_tgf_title.setAlign("center");
       f_tgf_title.setBaseline("middle");
       f_tgf_title.setOffsetFactor(0/100);
       f_tgf_title.setLineSpacing(0);
    var f_tgf_text = new tbVectorFont("ff_tgf_normal", "Arial");
    window["f_tgf_text"] = f_tgf_text;
       f_tgf_text.setFontSize(32);
       f_tgf_text.setFill(true);
       f_tgf_text.setFillColor("Black");
       f_tgf_text.setFillAlpha(100/100);
       f_tgf_text.setStroke(false);
       f_tgf_text.setStrokeColor("Black");
       f_tgf_text.setStrokeWidth(1);
       f_tgf_text.setStrokeJoin("miter");
       f_tgf_text.setStrokeAlpha(100/100);
       f_tgf_text.setStrokeBehind(false);
       f_tgf_text.setAlign("center");
       f_tgf_text.setBaseline("middle");
       f_tgf_text.setOffsetFactor(0/100);
       f_tgf_text.setLineSpacing(0);
    var f_tgf_button = new tbVectorFont("ff_tgf_normal", "Arial");
    window["f_tgf_button"] = f_tgf_button;
       f_tgf_button.setFontSize(40);
       f_tgf_button.setFill(true);
       f_tgf_button.setFillColor("#01198A");
       f_tgf_button.setFillAlpha(100/100);
       f_tgf_button.setStroke(false);
       f_tgf_button.setStrokeColor("Black");
       f_tgf_button.setStrokeWidth(1);
       f_tgf_button.setStrokeJoin("miter");
       f_tgf_button.setStrokeAlpha(100/100);
       f_tgf_button.setStrokeBehind(false);
       f_tgf_button.setShadow(true, "rgba(120,253,255,1.00)", 0, 2, 0);
       f_tgf_button.setAlign("center");
       f_tgf_button.setBaseline("middle");
       f_tgf_button.setOffsetFactor(14/100);
       f_tgf_button.setLineSpacing(0);
    var f_defaultLoader = new tbVectorFontLoader("f_default", "fonts/f_default.woff", "fonts/f_default.ttf", "fonts");
    window["f_defaultLoader"] = f_defaultLoader;
    var f_default = new tbVectorFont("f_default", "Arial");
    window["f_default"] = f_default;
       f_default.setFontSize(24);
       f_default.setFill(true);
       f_default.setFillColor("Black");
       f_default.setFillAlpha(100/100);
       f_default.setStroke(false);
       f_default.setStrokeColor("Black");
       f_default.setStrokeWidth(1);
       f_default.setStrokeJoin("miter");
       f_default.setStrokeAlpha(100/100);
       f_default.setStrokeBehind(false);
       f_default.setAlign("left");
       f_default.setBaseline("top");
       f_default.setOffsetFactor(0/100);
       f_default.setLineSpacing(0);
    var f_babas_regularLoader = new tbVectorFontLoader("f_babas_regular", "fonts/f_babas_regular.woff", "fonts/f_babas_regular.ttf", "fonts");
    window["f_babas_regularLoader"] = f_babas_regularLoader;
    var f_babas_regular = new tbVectorFont("f_babas_regular", "Arial");
    window["f_babas_regular"] = f_babas_regular;
       f_babas_regular.setFontSize(12);
       f_babas_regular.setFill(true);
       f_babas_regular.setFillColor("Black");
       f_babas_regular.setFillAlpha(100/100);
       f_babas_regular.setStroke(false);
       f_babas_regular.setStrokeColor("Black");
       f_babas_regular.setStrokeWidth(1);
       f_babas_regular.setStrokeJoin("miter");
       f_babas_regular.setStrokeAlpha(100/100);
       f_babas_regular.setStrokeBehind(false);
       f_babas_regular.setAlign("left");
       f_babas_regular.setBaseline("top");
       f_babas_regular.setOffsetFactor(0/100);
       f_babas_regular.setLineSpacing(0);
    var f_babas_boldLoader = new tbVectorFontLoader("f_babas_bold", "fonts/f_babas_bold.woff", "fonts/f_babas_bold.ttf", "fonts");
    window["f_babas_boldLoader"] = f_babas_boldLoader;
    var f_babas_bold = new tbVectorFont("f_babas_bold", "Arial");
    window["f_babas_bold"] = f_babas_bold;
       f_babas_bold.setFontSize(12);
       f_babas_bold.setFill(true);
       f_babas_bold.setFillColor("Black");
       f_babas_bold.setFillAlpha(100/100);
       f_babas_bold.setStroke(false);
       f_babas_bold.setStrokeColor("Black");
       f_babas_bold.setStrokeWidth(1);
       f_babas_bold.setStrokeJoin("miter");
       f_babas_bold.setStrokeAlpha(100/100);
       f_babas_bold.setStrokeBehind(false);
       f_babas_bold.setAlign("left");
       f_babas_bold.setBaseline("top");
       f_babas_bold.setOffsetFactor(0/100);
       f_babas_bold.setLineSpacing(0);
    var bitdustLoader = new tbVectorFontLoader("bitdust", "fonts/bitdust.woff", "fonts/bitdust.ttf", "fonts");
    window["bitdustLoader"] = bitdustLoader;
    var bitdust = new tbVectorFont("bitdust", "Arial");
    window["bitdust"] = bitdust;
       bitdust.setFontSize(12);
       bitdust.setFill(true);
       bitdust.setFillColor("Black");
       bitdust.setFillAlpha(100/100);
       bitdust.setStroke(false);
       bitdust.setStrokeColor("Black");
       bitdust.setStrokeWidth(1);
       bitdust.setStrokeJoin("miter");
       bitdust.setStrokeAlpha(100/100);
       bitdust.setStrokeBehind(false);
       bitdust.setAlign("left");
       bitdust.setBaseline("top");
       bitdust.setOffsetFactor(0/100);
       bitdust.setLineSpacing(0);
    var f_wurmics_bravoLoader = new tbVectorFontLoader("f_wurmics_bravo", "fonts/f_wurmics_bravo.woff", "fonts/f_wurmics_bravo.ttf", "fonts");
    window["f_wurmics_bravoLoader"] = f_wurmics_bravoLoader;
    var f_wurmics_bravo = new tbVectorFont("f_wurmics_bravo", "Arial");
    window["f_wurmics_bravo"] = f_wurmics_bravo;
       f_wurmics_bravo.setFontSize(12);
       f_wurmics_bravo.setFill(true);
       f_wurmics_bravo.setFillColor("Black");
       f_wurmics_bravo.setFillAlpha(100/100);
       f_wurmics_bravo.setStroke(false);
       f_wurmics_bravo.setStrokeColor("Black");
       f_wurmics_bravo.setStrokeWidth(1);
       f_wurmics_bravo.setStrokeJoin("miter");
       f_wurmics_bravo.setStrokeAlpha(100/100);
       f_wurmics_bravo.setStrokeBehind(false);
       f_wurmics_bravo.setAlign("left");
       f_wurmics_bravo.setBaseline("top");
       f_wurmics_bravo.setOffsetFactor(0/100);
       f_wurmics_bravo.setLineSpacing(0);
    var f_impactLoader = new tbVectorFontLoader("f_impact", "fonts/f_impact.woff", "fonts/f_impact.ttf", "fonts");
    window["f_impactLoader"] = f_impactLoader;
    var f_impact = new tbVectorFont("f_impact", "Arial");
    window["f_impact"] = f_impact;
       f_impact.setFontSize(12);
       f_impact.setFill(true);
       f_impact.setFillColor("Black");
       f_impact.setFillAlpha(100/100);
       f_impact.setStroke(false);
       f_impact.setStrokeColor("Black");
       f_impact.setStrokeWidth(1);
       f_impact.setStrokeJoin("miter");
       f_impact.setStrokeAlpha(100/100);
       f_impact.setStrokeBehind(false);
       f_impact.setAlign("left");
       f_impact.setBaseline("top");
       f_impact.setOffsetFactor(0/100);
       f_impact.setLineSpacing(0);
    var f_autoradiographic_italicLoader = new tbVectorFontLoader("f_autoradiographic_italic", "fonts/f_autoradiographic_italic.woff", "fonts/f_autoradiographic_italic.ttf", "fonts");
    window["f_autoradiographic_italicLoader"] = f_autoradiographic_italicLoader;
    var f_autoradiographic_italic = new tbVectorFont("f_autoradiographic_italic", "Arial");
    window["f_autoradiographic_italic"] = f_autoradiographic_italic;
       f_autoradiographic_italic.setFontSize(12);
       f_autoradiographic_italic.setFill(true);
       f_autoradiographic_italic.setFillColor("Black");
       f_autoradiographic_italic.setFillAlpha(100/100);
       f_autoradiographic_italic.setStroke(false);
       f_autoradiographic_italic.setStrokeColor("Black");
       f_autoradiographic_italic.setStrokeWidth(1);
       f_autoradiographic_italic.setStrokeJoin("miter");
       f_autoradiographic_italic.setStrokeAlpha(100/100);
       f_autoradiographic_italic.setStrokeBehind(false);
       f_autoradiographic_italic.setAlign("left");
       f_autoradiographic_italic.setBaseline("top");
       f_autoradiographic_italic.setOffsetFactor(0/100);
       f_autoradiographic_italic.setLineSpacing(0);

//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Spine Resources
//******************************************************
//******************************************************
//******************************************************

   var carrier = new tbSpine(
          "carrier",           texture_battleship,           "media/carrier.json"
    );
    window["carrier"] = carrier;
   var shipyard = new tbSpine(
          "shipyard",           texture_game,           "media/shipyard.json"
    );
    window["shipyard"] = shipyard;
   var matchresult_win = new tbSpine(
          "matchresult_win",           texture_matchresult,           "media/matchresult_win.json"
    );
    window["matchresult_win"] = matchresult_win;
   var matchresult_lose = new tbSpine(
          "matchresult_lose",           texture_matchresult,           "media/matchresult_lose.json"
    );
    window["matchresult_lose"] = matchresult_lose;
   var rank_up_shield = new tbSpine(
          "rank_up_shield",           texture_rankup,           "media/rank_up_shield.json"
    );
    window["rank_up_shield"] = rank_up_shield;
   var submarine = new tbSpine(
          "submarine",           texture_battleship,           "media/submarine.json"
    );
    window["submarine"] = submarine;
   var destroyer = new tbSpine(
          "destroyer",           texture_battleship,           "media/destroyer.json"
    );
    window["destroyer"] = destroyer;
   var cruiser = new tbSpine(
          "cruiser",           texture_battleship,           "media/cruiser.json"
    );
    window["cruiser"] = cruiser;
   var battleship = new tbSpine(
          "battleship",           texture_battleship,           "media/battleship.json"
    );
    window["battleship"] = battleship;
   var player_explosion = new tbSpine(
          "player_explosion",           texture_board_missile_animation,           "media/player_explosion.json"
    );
    window["player_explosion"] = player_explosion;
   var player_missile = new tbSpine(
          "player_missile",           texture_board_missile_animation,           "media/player_missile.json"
    );
    window["player_missile"] = player_missile;
   var miss_animation = new tbSpine(
          "miss_animation",           texture_board_missile_animation,           "media/miss_animation.json"
    );
    window["miss_animation"] = miss_animation;
   var hit_animation = new tbSpine(
          "hit_animation",           texture_board_missile_animation,           "media/hit_animation.json"
    );
    window["hit_animation"] = hit_animation;
   var sw_reward_unlock = new tbSpine(
          "sw_reward_unlock",           texture_weapon_unlock,           "media/sw_reward_unlock.json"
    );
    window["sw_reward_unlock"] = sw_reward_unlock;
   var Onboarding = new tbSpine(
          "Onboarding",           texture_onboarding,           "media/Onboarding.json"
    );
    window["Onboarding"] = Onboarding;
   var opponent_special_weapons = new tbSpine(
          "opponent_special_weapons",           texture_board_missile_animation,           "media/opponent_special_weapons.json"
    );
    window["opponent_special_weapons"] = opponent_special_weapons;
   var result_lose = new tbSpine(
          "result_lose",           texture_result_lose,           "media/result_lose.json"
    );
    window["result_lose"] = result_lose;
   var result_win = new tbSpine(
          "result_win",           texture_result_win,           "media/result_win.json"
    );
    window["result_win"] = result_win;
   var badge_destroyed = new tbSpine(
          "badge_destroyed",           texture_badges,           "media/badge_destroyed.json"
    );
    window["badge_destroyed"] = badge_destroyed;
   var badge_special_weapon = new tbSpine(
          "badge_special_weapon",           texture_badges,           "media/badge_special_weapon.json"
    );
    window["badge_special_weapon"] = badge_special_weapon;
   var badge_victory = new tbSpine(
          "badge_victory",           texture_badges,           "media/badge_victory.json"
    );
    window["badge_victory"] = badge_victory;
   var badge_survived = new tbSpine(
          "badge_survived",           texture_badges,           "media/badge_survived.json"
    );
    window["badge_survived"] = badge_survived;
   var badge_lost = new tbSpine(
          "badge_lost",           texture_badges,           "media/badge_lost.json"
    );
    window["badge_lost"] = badge_lost;
   var doors = new tbSpine(
          "doors",           texture_doors,           "media/doors.json"
    );
    window["doors"] = doors;
   var popup_extra = new tbSpine(
          "popup_extra",           popup_extra_texture,           "media/popup_extra.json"
    );
    window["popup_extra"] = popup_extra;
   var popup_reload = new tbSpine(
          "popup_reload",           popup_reload_texture,           "media/popup_reload.json"
    );
    window["popup_reload"] = popup_reload;
   var specialweapons_confirmation = new tbSpine(
          "specialweapons_confirmation",           popup_reload_texture,           "media/specialweapons_confirmation.json"
    );
    window["specialweapons_confirmation"] = specialweapons_confirmation;
   var specialweapons_add_icon = new tbSpine(
          "specialweapons_add_icon",           texture_sw_icon_add,           "media/specialweapons_add_icon.json"
    );
    window["specialweapons_add_icon"] = specialweapons_add_icon;

//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Audio Sprites
//******************************************************
//******************************************************
//******************************************************

    var FrameworkAudio = new tbAudioSprite("FrameworkAudio", "audio/FrameworkAudio.mp3", "audio/FrameworkAudio.ogg", "frameworkAudio");
    window["FrameworkAudio"] = FrameworkAudio;
    var audioSprite = new tbAudioSprite("audioSprite", "audio/audioSprite.mp3", "audio/audioSprite.ogg", "audio");
    window["audioSprite"] = audioSprite;
    var audioSpriteBoard = new tbAudioSprite("audioSpriteBoard", "audio/audioSpriteBoard.mp3", "audio/audioSpriteBoard.ogg", "audio");
    window["audioSpriteBoard"] = audioSpriteBoard;
    var audioSpriteRadar = new tbAudioSprite("audioSpriteRadar", "audio/audioSpriteRadar.mp3", "audio/audioSpriteRadar.ogg", "audio");
    window["audioSpriteRadar"] = audioSpriteRadar;
    var audioSpriteResult = new tbAudioSprite("audioSpriteResult", "audio/audioSpriteResult.mp3", "audio/audioSpriteResult.ogg", "audio");
    window["audioSpriteResult"] = audioSpriteResult;
    var audioSpriteMisc = new tbAudioSprite("audioSpriteMisc", "audio/audioSpriteMisc.mp3", "audio/audioSpriteMisc.ogg", "audio");
    window["audioSpriteMisc"] = audioSpriteMisc;
    var audioSpritePlacement = new tbAudioSprite("audioSpritePlacement", "audio/audioSpritePlacement.mp3", "audio/audioSpritePlacement.ogg", "audio");
    window["audioSpritePlacement"] = audioSpritePlacement;
    var audioSpriteIngame = new tbAudioSprite("audioSpriteIngame", "audio/audioSpriteIngame.mp3", "audio/audioSpriteIngame.ogg", "audio");
    window["audioSpriteIngame"] = audioSpriteIngame;
    var audioSpriteLobby = new tbAudioSprite("audioSpriteLobby", "audio/audioSpriteLobby.mp3", "audio/audioSpriteLobby.ogg", "audio");
    window["audioSpriteLobby"] = audioSpriteLobby;

//******************************************************
//******************************************************
//******************************************************
//*****    Definition of the Sound Resources
//******************************************************
//******************************************************
//******************************************************

    var a_tgf_silence = new tbSound("a_tgf_silence", FrameworkAudio, 0, 471, 0/100, 10, ["sfx"]);
    window["a_tgf_silence"] = a_tgf_silence;
    var a_tgf_button_down = new tbSound("a_tgf_button_down", FrameworkAudio, 2000, 471, 100/100, 10, ["sfx"]);
    window["a_tgf_button_down"] = a_tgf_button_down;
    var a_levelend_star_01 = new tbSound("a_levelend_star_01", audioSprite, 0, 1161, 100/100, 10, ["game"]);
    window["a_levelend_star_01"] = a_levelend_star_01;
    var a_levelend_star_02 = new tbSound("a_levelend_star_02", audioSprite, 3000, 1070, 100/100, 10, ["game"]);
    window["a_levelend_star_02"] = a_levelend_star_02;
    var a_levelend_star_03 = new tbSound("a_levelend_star_03", audioSprite, 6000, 1039, 100/100, 10, ["game"]);
    window["a_levelend_star_03"] = a_levelend_star_03;
    var a_rank_up = new tbSound("a_rank_up", audioSprite, 9000, 3569, 100/100, 10, ["game"]);
    window["a_rank_up"] = a_rank_up;
    var a_experience_gain = new tbSound("a_experience_gain", audioSprite, 14000, 116, 100/100, 10, ["game"]);
    window["a_experience_gain"] = a_experience_gain;
    var a_badge_reward = new tbSound("a_badge_reward", audioSprite, 16000, 1000, 100/100, 10, ["game"]);
    window["a_badge_reward"] = a_badge_reward;
    var a_close_gate = new tbSound("a_close_gate", audioSprite, 19000, 1057, 100/100, 10, ["game"]);
    window["a_close_gate"] = a_close_gate;
    var a_open_gate = new tbSound("a_open_gate", audioSprite, 22000, 901, 100/100, 10, ["game"]);
    window["a_open_gate"] = a_open_gate;
    var a_reward_torpedo_chest_open = new tbSound("a_reward_torpedo_chest_open", audioSprite, 24000, 5913, 100/100, 10, ["game"]);
    window["a_reward_torpedo_chest_open"] = a_reward_torpedo_chest_open;
    var a_reward_torpedo_chest_glow_loop = new tbSound("a_reward_torpedo_chest_glow_loop", audioSprite, 31000, 1995, 100/100, 10, ["game"]);
    window["a_reward_torpedo_chest_glow_loop"] = a_reward_torpedo_chest_glow_loop;
    var a_reward_torpedo_appear = new tbSound("a_reward_torpedo_appear", audioSprite, 34000, 1699, 100/100, 10, ["game"]);
    window["a_reward_torpedo_appear"] = a_reward_torpedo_appear;
    var a_board_strike_land_4 = new tbSound("a_board_strike_land_4", audioSpriteBoard, 0, 1351, 100/100, 10, ["game"]);
    window["a_board_strike_land_4"] = a_board_strike_land_4;
    var a_board_strike_land_3 = new tbSound("a_board_strike_land_3", audioSpriteBoard, 3000, 1540, 100/100, 10, ["game"]);
    window["a_board_strike_land_3"] = a_board_strike_land_3;
    var a_board_strike_land_2 = new tbSound("a_board_strike_land_2", audioSpriteBoard, 6000, 1164, 100/100, 10, ["game"]);
    window["a_board_strike_land_2"] = a_board_strike_land_2;
    var a_board_strike_land_1 = new tbSound("a_board_strike_land_1", audioSpriteBoard, 9000, 999, 100/100, 10, ["game"]);
    window["a_board_strike_land_1"] = a_board_strike_land_1;
    var a_board_strike_land_0 = new tbSound("a_board_strike_land_0", audioSpriteBoard, 11000, 893, 100/100, 10, ["game"]);
    window["a_board_strike_land_0"] = a_board_strike_land_0;
    var a_board_strike = new tbSound("a_board_strike", audioSpriteBoard, 13000, 1113, 100/100, 10, ["game"]);
    window["a_board_strike"] = a_board_strike;
    var a_board_miss = new tbSound("a_board_miss", audioSpriteBoard, 16000, 1006, 100/100, 10, ["game"]);
    window["a_board_miss"] = a_board_miss;
    var a_radar_reveal = new tbSound("a_radar_reveal", audioSpriteRadar, 0, 733, 100/100, 10, ["game"]);
    window["a_radar_reveal"] = a_radar_reveal;
    var a_radar_hit_4 = new tbSound("a_radar_hit_4", audioSpriteRadar, 2000, 1499, 100/100, 10, ["game"]);
    window["a_radar_hit_4"] = a_radar_hit_4;
    var a_radar_tap = new tbSound("a_radar_tap", audioSpriteRadar, 5000, 67, 100/100, 10, ["game"]);
    window["a_radar_tap"] = a_radar_tap;
    var a_radar_strike = new tbSound("a_radar_strike", audioSpriteRadar, 7000, 1271, 100/100, 10, ["game"]);
    window["a_radar_strike"] = a_radar_strike;
    var a_radar_strike_flight = new tbSound("a_radar_strike_flight", audioSpriteRadar, 10000, 79, 100/100, 10, ["game"]);
    window["a_radar_strike_flight"] = a_radar_strike_flight;
    var a_radar_ambience = new tbSound("a_radar_ambience", audioSpriteRadar, 12000, 3000, 100/100, 10, ["game"]);
    window["a_radar_ambience"] = a_radar_ambience;
    var a_radar_miss = new tbSound("a_radar_miss", audioSpriteRadar, 17000, 750, 100/100, 10, ["game"]);
    window["a_radar_miss"] = a_radar_miss;
    var a_radar_hit_2 = new tbSound("a_radar_hit_2", audioSpriteRadar, 19000, 1451, 100/100, 10, ["game"]);
    window["a_radar_hit_2"] = a_radar_hit_2;
    var a_radar_hit_0 = new tbSound("a_radar_hit_0", audioSpriteRadar, 22000, 1289, 100/100, 10, ["game"]);
    window["a_radar_hit_0"] = a_radar_hit_0;
    var a_radar_hit_1 = new tbSound("a_radar_hit_1", audioSpriteRadar, 25000, 1402, 100/100, 10, ["game"]);
    window["a_radar_hit_1"] = a_radar_hit_1;
    var a_radar_hit_3 = new tbSound("a_radar_hit_3", audioSpriteRadar, 28000, 1438, 100/100, 10, ["game"]);
    window["a_radar_hit_3"] = a_radar_hit_3;
    var a_loseanimation_board_out = new tbSound("a_loseanimation_board_out", audioSpriteResult, 0, 840, 100/100, 10, ["game"]);
    window["a_loseanimation_board_out"] = a_loseanimation_board_out;
    var a_loseanimation_board_in = new tbSound("a_loseanimation_board_in", audioSpriteResult, 2000, 1404, 100/100, 10, ["game"]);
    window["a_loseanimation_board_in"] = a_loseanimation_board_in;
    var a_winanimation_shimmer = new tbSound("a_winanimation_shimmer", audioSpriteResult, 5000, 1390, 100/100, 10, ["game"]);
    window["a_winanimation_shimmer"] = a_winanimation_shimmer;
    var a_winanimation_stars = new tbSound("a_winanimation_stars", audioSpriteResult, 8000, 1803, 100/100, 10, ["game"]);
    window["a_winanimation_stars"] = a_winanimation_stars;
    var a_result_win = new tbSound("a_result_win", audioSpriteResult, 11000, 1867, 100/100, 10, ["game"]);
    window["a_result_win"] = a_result_win;
    var a_result_lose = new tbSound("a_result_lose", audioSpriteResult, 14000, 2647, 100/100, 10, ["game"]);
    window["a_result_lose"] = a_result_lose;
    var a_result_lose_left = new tbSound("a_result_lose_left", audioSpriteResult, 18000, 3700, 100/100, 10, ["game"]);
    window["a_result_lose_left"] = a_result_lose_left;
    var a_result_win_left = new tbSound("a_result_win_left", audioSpriteResult, 23000, 7095, 100/100, 10, ["game"]);
    window["a_result_win_left"] = a_result_win_left;
    var a_result_lose_right = new tbSound("a_result_lose_right", audioSpriteResult, 32000, 3700, 100/100, 10, ["game"]);
    window["a_result_lose_right"] = a_result_lose_right;
    var a_result_win_right = new tbSound("a_result_win_right", audioSpriteResult, 37000, 7095, 100/100, 10, ["game"]);
    window["a_result_win_right"] = a_result_win_right;
    var a_win_stinger = new tbSound("a_win_stinger", audioSpriteResult, 46000, 8235, 100/100, 10, ["game"]);
    window["a_win_stinger"] = a_win_stinger;
    var a_lose_stinger = new tbSound("a_lose_stinger", audioSpriteResult, 56000, 7573, 100/100, 10, ["game"]);
    window["a_lose_stinger"] = a_lose_stinger;
    var a_result_music = new tbSound("a_result_music", audioSpriteResult, 65000, 4000, 100/100, 10, ["music"]);
    window["a_result_music"] = a_result_music;
    var a_shoot_airstrike = new tbSound("a_shoot_airstrike", audioSpriteMisc, 0, 2310, 100/100, 10, ["game"]);
    window["a_shoot_airstrike"] = a_shoot_airstrike;
    var a_shoot_bomb = new tbSound("a_shoot_bomb", audioSpriteMisc, 4000, 1237, 100/100, 10, ["game"]);
    window["a_shoot_bomb"] = a_shoot_bomb;
    var a_shoot_scattershot = new tbSound("a_shoot_scattershot", audioSpriteMisc, 7000, 1178, 100/100, 10, ["game"]);
    window["a_shoot_scattershot"] = a_shoot_scattershot;
    var a_shoot_torpedo = new tbSound("a_shoot_torpedo", audioSpriteMisc, 10000, 2235, 100/100, 10, ["game"]);
    window["a_shoot_torpedo"] = a_shoot_torpedo;
    var a_ship_explodes = new tbSound("a_ship_explodes", audioSpriteMisc, 14000, 2818, 100/100, 10, ["game"]);
    window["a_ship_explodes"] = a_ship_explodes;
    var a_ship_sink = new tbSound("a_ship_sink", audioSpriteMisc, 18000, 2500, 100/100, 10, ["game"]);
    window["a_ship_sink"] = a_ship_sink;
    var a_select_special = new tbSound("a_select_special", audioSpriteMisc, 22000, 368, 100/100, 10, ["game"]);
    window["a_select_special"] = a_select_special;
    var a_fireunit_moveout = new tbSound("a_fireunit_moveout", audioSpriteMisc, 24000, 750, 100/100, 10, ["game"]);
    window["a_fireunit_moveout"] = a_fireunit_moveout;
    var a_opponent_target = new tbSound("a_opponent_target", audioSpriteMisc, 26000, 131, 100/100, 10, ["game"]);
    window["a_opponent_target"] = a_opponent_target;
    var a_on_opp_turn = new tbSound("a_on_opp_turn", audioSpriteMisc, 28000, 1518, 100/100, 10, ["game"]);
    window["a_on_opp_turn"] = a_on_opp_turn;
    var a_battle_start = new tbSound("a_battle_start", audioSpriteMisc, 31000, 4800, 100/100, 10, ["game"]);
    window["a_battle_start"] = a_battle_start;
    var a_popup_show = new tbSound("a_popup_show", audioSpriteMisc, 37000, 206, 51/100, 10, ["game"]);
    window["a_popup_show"] = a_popup_show;
    var a_button_click = new tbSound("a_button_click", audioSpriteMisc, 39000, 61, 100/100, 10, ["game"]);
    window["a_button_click"] = a_button_click;
    var a_lock_sound = new tbSound("a_lock_sound", audioSpriteMisc, 41000, 196, 100/100, 10, ["game"]);
    window["a_lock_sound"] = a_lock_sound;
    var a_shipyard_animation = new tbSound("a_shipyard_animation", audioSpritePlacement, 0, 1699, 100/100, 10, ["game"]);
    window["a_shipyard_animation"] = a_shipyard_animation;
    var a_water_ambience = new tbSound("a_water_ambience", audioSpritePlacement, 3000, 15902, 100/100, 10, ["game"]);
    window["a_water_ambience"] = a_water_ambience;
    var a_water_tap = new tbSound("a_water_tap", audioSpritePlacement, 20000, 310, 100/100, 10, ["game"]);
    window["a_water_tap"] = a_water_tap;
    var a_ship_rotation = new tbSound("a_ship_rotation", audioSpritePlacement, 22000, 643, 100/100, 10, ["game"]);
    window["a_ship_rotation"] = a_ship_rotation;
    var a_ship_placement = new tbSound("a_ship_placement", audioSpritePlacement, 24000, 1722, 100/100, 10, ["game"]);
    window["a_ship_placement"] = a_ship_placement;
    var a_illegal_placement = new tbSound("a_illegal_placement", audioSpritePlacement, 27000, 208, 100/100, 10, ["game"]);
    window["a_illegal_placement"] = a_illegal_placement;
    var a_ship_tap = new tbSound("a_ship_tap", audioSpritePlacement, 29000, 1326, 100/100, 10, ["game"]);
    window["a_ship_tap"] = a_ship_tap;
    var a_ingame_music = new tbSound("a_ingame_music", audioSpriteIngame, 0, 36000, 100/100, 10, ["music"]);
    window["a_ingame_music"] = a_ingame_music;
    var a_lobby_music = new tbSound("a_lobby_music", audioSpriteLobby, 0, 14397, 100/100, 10, ["music"]);
    window["a_lobby_music"] = a_lobby_music;

//******************************************************
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//*****    The Game Scripts
//******************************************************
//******************************************************
//******************************************************
//******************************************************
//******************************************************


//******************************************************
//*****    Script Resource: RewardAds
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

'use strict';

var _REWARD = function(pause, resume){
	
	function AdTech(pause, resume)
	{
		//this._pause = pause;
		//this._resume = resume;

		window.addEventListener("message", function(event){ this.receiveAdTechMessage(event) }.bind(this), false);
	}

	AdTech.prototype._getAdDescriptor = function()
	{
		if (tbBrowser.features.mobile || tbBrowser.features.tablet || tbBrowser.features.touchpad)
		{
			return {
				frameClass: "adFrameMobile",
				adClass: "adtechMobile",
				width: 320,
				height: 250,
				zoneId: publisher['mobileRewardId']
			}
		}
		else
		{
			return {
				frameClass: "adFrame",
				adClass: "adtech",
				width: 640,
				height: 480,
				zoneId: publisher['desktopRewardId']
			}
		}
	};

	AdTech.prototype.playAdTechVideo = function(callback, context)
	{
		this._videoCallback = callback;

		this._videoContext = context;

		var descriptor = this._getAdDescriptor();

		var random = Math.floor(Math.random() * 1000000000);

		this._overlay = document.createElement('div');
		this._overlay.className = "adOverlay";

		var bg = document.createElement('div');
		bg.className = "adBg";

		var frame = document.createElement('div');
		frame.className = descriptor.frameClass;

		this._iframe = document.createElement('iframe');
		this._iframe.src = 'http://media.oadts.com/www/delivery/afv.php?zoneid=' + descriptor.zoneId + '&cb=' + random;
		this._iframe.frameborder = '0';
		this._iframe.scrolling = 'no';
		this._iframe.width = descriptor.width;
		this._iframe.height = descriptor.height;
		this._iframe.className = descriptor.adClass;

		this._overlay.appendChild(bg);

		this._overlay.appendChild(frame);

		this._overlay.appendChild(this._iframe);

		document.body.appendChild(this._overlay);
	};

	AdTech.prototype.completeAdTechVideo = function(success)
	{
		if (this._overlay)
		{
			document.body.removeChild(this._overlay);

			this._overlay = null;
		}

		this._videoCallback.call(this._videoContext, success);
	};

	AdTech.prototype.receiveAdTechMessage = function(event)
	{
		if (event.origin !== 'http://media.oadts.com' || !this._overlay)
		{
			return;
		}

		console.log(event);

		switch (event.data)
		{
			case 'videoStart':
				break;
			case 'noVideo':
			case 'NoVideo':

				document.body.removeChild(this._overlay);

				this._overlay = null;
				
				this.completeAdTechVideo(true);
			   
				break;
			case 'videoEnds':
			case 'videoComplete':
				this.completeAdTechVideo(true);
				break;

		}
	};

	return AdTech;
}();

var _rewardVideo = new _REWARD();
//******************************************************
//*****    Script Resource: tgfSettings
//******************************************************

// ***************************************
// tgfSettings
//
// This objects contains all settings and a number of
// methods to deal with them. All the settings must be
// in sub-groups of groups of tgfSettings.
//
// Actually, you can create multiple instances of the TGFSettings
// object if you want. tgfSettings is simply the default one.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 8-7-2015
// ***************************************

// Directives for jslint
/*global imageScalePercentage */


// The constructor
var TGFSettings = function () {
	"use strict";
	// The different groups of settings
	this.framework = { };
	this.errors = { };
	this.console = { };
	this.analytics = { };
	this.graphics = { };
	this.audio = { };
	this.dictionary = { };
	this.profile = { };
	this.statusStorage = { };
	this.status = { };
	this.inventoryStorage = { };
	this.inventory = { };
	this.flow = { };
	this.game = { };
	this.theme = { };
	this.client = { };
	this.play = { };
};


// ***************************************
// Global functions related to settings
// ***************************************

// Scale the value according to the scaling variable
var tgfScale = function(value, method) {
	"use strict";
	var result, i;
	// Case of a number
	if (typeof value === "number") {
		result = imageScalePercentage * value / 100;
		if (method === "round") { result = Math.round(result); }
		if (method === "floor") { result = Math.floor(result); }
		if (method === "ceil") { result = Math.ceil(result); }
		return result;
	}
	// In case of an array scale all its elements
	if (Object.prototype.toString.call(value) === "[object Array]") {
		for (i = 0; i < value.length; i += 1) {
			value[i] = tgfScale(value[i], method);
		}
		return value;
	}
	// In case of an object, scale all its properties
	if (typeof value === "object") {
		for (i in value) {
			if (value.hasOwnProperty(i)) {
			    value[i] = tgfScale(value[i], method);
			}
		}
		return value;
	}
	// Otherwise return the value itself
	return value;
};

// For backwards compatibility with old settings files
var tgScale = function(value, method) {
	"use strict";
	return tgfScale(value, method);
};

// For backwards compatibility with old settings files
var tgSelect = function(obj) {
	"use strict";
	return (obj.big !== undefined)? tgfScale(obj.big) : obj;
};


// ***************************************
// Merging settings and groups of settings
// ***************************************

// Merge the settings into the current ones
TGFSettings.prototype.mergeSettings = function(settings) {
	"use strict";
	var setting;
	if (typeof settings !== "object") { return; }
	// Run through all the settings in the object
	for (setting in settings) {
		if (settings.hasOwnProperty(setting)) {
			if (settings[setting] === undefined || settings[setting] === null) {
				this[setting] = settings[setting];
			} else if (Object.prototype.toString.call(settings[setting]) === "[object Array]") {
				this[setting] = settings[setting];				
			} else if (typeof settings[setting] === "object" && settings[setting].constructor === Object) {
				// When it is an object without its own constructor, recursively merge
				if (typeof this[setting] !== "object") { this[setting] = { } ; }
				this.mergeGroup(this[setting], settings[setting]);
			} else {
				this[setting] = settings[setting];
			}
		}
	}
};

// Merge a group of settings (group is e.g. tgfSettings.XXX)
TGFSettings.prototype.mergeGroup = function(group, settings) {
	"use strict";
	var setting;
	if (typeof settings !== "object") { return; }
	// Run through all the settings in the object
	for (setting in settings) {
		if (settings.hasOwnProperty(setting)) {
			if (settings[setting] === undefined || settings[setting] === null) {
				group[setting] = settings[setting];
			} else if (Object.prototype.toString.call(settings[setting]) === "[object Array]") {
				group[setting] = settings[setting];
			} else if (typeof settings[setting] === "object" && settings[setting].constructor === Object) {
				// When it is an object without its own constructor, recursively merge
				if (typeof group[setting] !== "object") { group[setting] = { } ; }
				this.mergeSubGroup(group[setting], settings[setting]);
			} else {
				group[setting] = settings[setting];
			}
		}
	}
};

// Merge a sub-group of settings (subGroup is e.g. tgfSettings.XXX.YYY)
TGFSettings.prototype.mergeSubGroup = function(subGroup, settings) {
	"use strict";
	var setting;
	if (typeof settings !== "object") { return; }
	// Run through all the settings in the object
	for (setting in settings) {
		if (settings.hasOwnProperty(setting)) {
			subGroup[setting] = settings[setting];
		}
	}
};


// ***************************************
// Create the default version
// ***************************************

var tgfSettings = new TGFSettings();


//******************************************************
//*****    Script Resource: tgfFunctions
//******************************************************

// ***************************************
// tgfFunctions
//
// This namespace object contains a number of useful functions used inside
// the framework and can also be used by the games
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 2-11-2015
// ***************************************

// Directives for jslint
/*global window */
/*global tbGame, tbGraphics, tbKeyCodes, tbLoader, tbAudio, defaultRandom */
/*global tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfFunctions, tgfMD5 */

var tgfFunctions = {};


// ***************************************
// Loading
// ***************************************

// Loading the resources with the given settings
tgfFunctions.loadStart = function(settings) {
	"use strict";
	var i;
	tgfFunctions._loadSettings = settings;
	tgfFunctions._loadTime = tbGame.gameTime;
	for (i = 0; i < tgfFunctions._loadSettings.moments.length; i += 1) {
		tbLoader.startLoading(tgfFunctions._loadSettings.moments[i]);
	}
};

// Check whether the loading is complete
tgfFunctions.loadComplete = function() {
	"use strict";
	var i, ready = true;
	// Check whether the minimum time has passed
	if (tbGame.gameTime < tgfFunctions._loadTime + 1000 * tgfFunctions._loadSettings.minTime) { return false; }
	// Check whether the required ones are ready
	for (i = 0; i < tgfFunctions._loadSettings.required.length; i += 1) {
		if (!tbLoader.complete(tgfFunctions._loadSettings.required[i])) {
			return false;
		}
	}
	// Check whether also the non-required are ready
	for (i = 0; i < tgfFunctions._loadSettings.moments.length; i += 1) {
		if (!tbLoader.complete(tgfFunctions._loadSettings.moments[i])) {
			ready = false;
		}
	}
	return ready || tbGame.gameTime >= tgfFunctions._loadTime + 1000 * tgfFunctions._loadSettings.maxTime;
};

// Return the percentage of loading
tgfFunctions.loadPercentage = function() {
	"use strict";
	var i, n = 1, perc = 0, mt;

	for(var j = 0; j < tgfFunctions._loadSettings.required.length; j++){
		if(tgfFunctions._loadSettings.required[j] === "spine"){
			tbLoader.checkSpineLoad();
		}
	}

	if (tgfFunctions.loadComplete()) { return 100; }

	for (i = 0; i < tgfFunctions._loadSettings.moments.length; i += 1) {
		perc += tbLoader.percentage(tgfFunctions._loadSettings.moments[i]);
		n += 1;
	}
	// Half is determined by the loading and the other half by the time passed
	perc /= n;
	mt = 1000 * Math.max(tgfFunctions._loadSettings.maxTime, tgfFunctions._loadSettings.minTime);
	return perc *  Math.min(1, (tbGame.gameTime - tgfFunctions._loadTime) / mt);
};


// ***************************************
// Pausing and resuming everything
// ***************************************

// Pause everything
tgfFunctions.pauseAll = function() {
	"use strict";
	tbAudio.pause("master");
	tbGame.pause();
};

// Resume everything (also clear events unless true is passed as parameter)
tgfFunctions.resumeAll = function(keepEvents) {
	"use strict";
	tbAudio.resume("master");
	if (!keepEvents) {
		tbGame.clearClickEvents();
		tbGame.clearTouchEvents();
		tbGame.clearKeyboardEvents();
	}
	tbGame.resume();
};


// ***************************************
// Site locks and time lock
// ***************************************

// Returns whether any of the MD5 hashed sitelocks in the argument
// is correct for the current site (it must be a suffix of it; so e.g. google.com matches http://www.google.com)
tgfFunctions.checkSiteLocks = function(siteLocks) {
	"use strict";
	var ind, i, siteLock, subStrings, beginString, stringToCompare, origin, localString = "file://";
	// If no sitelock, we do not run!
	if (!siteLocks) { return false; }
	siteLocks = [].concat(siteLocks);		// To make sure it is an array
	if (siteLocks.length === 0) { return false; }
	// Get the origin where the game is running
	origin = (window.location.origin !== undefined) ? window.location.origin : window.location.protocol + "//" + window.location.hostname;
	// Now check the various site locks
	for (ind = 0; ind < siteLocks.length; ind += 1) {	
		siteLock = siteLocks[ind];
		// Check whether running local
		if(origin.indexOf(localString) === 0 && siteLock === tgfMD5.createMD5Hash(localString)) {
			return true;
		}
		// Split the origin in pieces
		subStrings = origin.split(".");
		beginString = subStrings.shift().split("://");
		beginString[0] += "://";
		subStrings = beginString.concat(subStrings);
		// Now check whether a part matches (e.g. google.com, www.google.com, http://www.google.com)
		stringToCompare = subStrings[subStrings.length - 1];
		for(i = subStrings.length-2; i >= 0; i -= 1) {
			// Add a piece to the string
			stringToCompare = subStrings[i] + (i > 0 ? "." : "") + stringToCompare;
			// Check whether it matches
			if (siteLock === tgfMD5.createMD5Hash(stringToCompare)) {
				return true;
			}
		}
	}
	return false;
};

// Returns whether the time has passed
tgfFunctions.checkTimeLock = function(timeLock) {
	"use strict";
	if (timeLock === undefined) { return true; }
	return new Date().getTime() <= timeLock;
};


// ***************************************
// Dealing with objects
// ***************************************

// Checks whether the two values are equal (also works for objects, arrays, etc.)
tgfFunctions.equalValues = function(value1, value2) {
	"use strict";
	var i, obj;
	// Check easy case
	if (value1 === undefined) { return value2 === undefined; }
	if (value1 === null) { return value2 === null; }
	if (value2 === undefined) { return false; }
	if (value2 === null) { return false; }
	// Check for arrays
	if (Object.prototype.toString.call(value1) === "[object Array]") {
		if (Object.prototype.toString.call(value2) !== "[object Array]") { return false; }
		if (value1.length !== value2.length) { return false; }
		for (i = 0; i < value1.length; i += 1) {
			if (!tgfFunctions.equalValues(value1[i], value2[i])) { return false; }
		}
		return true;
	}
	// Check for objects
	if (typeof value1 === "object" && value1.constructor === Object) {
		if (typeof value2 !== "object" || value2.constructor !== Object) { return false; }
		for (obj in value1) {
			if (value1.hasOwnProperty(obj)) {
				if (!tgfFunctions.equalValues(value1[obj], value2[obj])) { return false; }
			}
		}
		for (obj in value2) {
			if (value2.hasOwnProperty(obj)) {
				if (!tgfFunctions.equalValues(value1[obj], value2[obj])) { return false; }
			}
		}
		return true;
	}
	// Check for simple types
	return value2 === value1;
};

// Create a deep copy of a value (also works for objects, arrays, etc.)
tgfFunctions.copyValue = function(value) {
	"use strict";
	var i, obj, result;
	// Check easy case
	if (value === undefined) { return undefined; }
	if (value === null) { return null; }
	// Check for arrays
	if (Object.prototype.toString.call(value) === "[object Array]") {
		result = [];
		for (i = 0; i < value.length; i += 1) {
			result.push(tgfFunctions.copyValue(value[i]));
		}
		return result;
	}
	// Check for objects
	if (typeof value === "object" && value.constructor === Object) {
		result = {};
		for (obj in value) {
			if (value.hasOwnProperty(obj)) {
				result[obj] = tgfFunctions.copyValue(value[obj]);
			}
		}
		return result;
	}
	// Handle simple types
	return value;
};

// Return a merged version where value2 replaces elements of value1
tgfFunctions.mergeValues = function(value1, value2) {
	"use strict";
	var i, result, obj;
	// Handle easy case
	if (value1 === undefined || value1 === null) { return tgfFunctions.copyValue(value2); }
	if (value2 === undefined || value2 === null) { return tgfFunctions.copyValue(value1); }
	// Handle arrays
	if (Object.prototype.toString.call(value1) === "[object Array]") {
		if (Object.prototype.toString.call(value2) !== "[object Array]") { return tgfFunctions.copyValue(value2); }
		result = tgfFunctions.copyValue(value1);
		for (i = 0; i < value2.length; i += 1) {
			result[i] = tgfFunctions.copyValue(value2[i]);
		}
		return result;
	}
	// Handle objects
	if (typeof value1 === "object" && value1.constructor === Object) {
		if (typeof value2 !== "object" || value2.constructor !== Object) { return tgfFunctions.copyValue(value2); }
		result = tgfFunctions.copyValue(value1);
		for (obj in value2) {
			if (value2.hasOwnProperty(obj)) {
				result[obj] = tgfFunctions.copyValue(value2[obj]);
			}
		}
		return result;
	}
	// Handle simple types
	return tgfFunctions.copyValue(value2);
};


// ***************************************
// Miscellaneous
// ***************************************

// Let C inherit the prototype of P, using the Holy Grail inheritance (JavaScript Patterns, page 127)
tgfFunctions.inherit = function(C, P) {
	"use strict";
	var F = function(){};
	F.prototype = P.prototype;
	C.prototype = new F();
	C.uber = P.prototype;
	C.prototype.constructor = C;
};

// Generate a sort of unique id
tgfFunctions.generateGuid = function() {
    "use strict";
    var guid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
    return guid.replace(/[xy]/g, function(c) {
        var r = defaultRandom.iRandomRange(0, 15);
		if (c === "x") { return r.toString(16); }
		if (c === "y") { return (r % 4 + 8).toString(16); }
    } );
};



// Return the url parameters in a object of the form name: value
tgfFunctions.getUrlParameters = function() {
	"use strict";
	var queryString = window.location.search.substring(1),
		params = {}, queries, temp, i;
	if (queryString) {
		// Split into key/value pairs
		queries = queryString.split("&");
		// Convert the array of strings into an object
		for (i = 0; i < queries.length; i += 1) {
			temp = queries[i].split("=");
			params[temp[0]] = temp[1];
		}
	}
	return params;
};

//******************************************************
//*****    Script Resource: tgfMD5
//******************************************************

// ***************************************
// tgfMD5
//
// This namespace object contains methods for encoding data
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 29-6-2015
// ***************************************

// Directives for jslint
/*jslint bitwise: true, vars: true */
/*global window */

var tgfMD5 = {};

tgfMD5.utf8_encode = function(argString) {
	"use strict";
	// discuss at: http://phpjs.org/functions/utf8_encode/
	// original by: Webtoolkit.info (http://www.webtoolkit.info/)
	// improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// improved by: sowberry
	// improved by: Jack
	// improved by: Yves Sucaet
	// improved by: kirilloid
	// bugfixed by: Onno Marsman
	// bugfixed by: Onno Marsman
	// bugfixed by: Ulrich
	// bugfixed by: Rafal Kukawski
	// bugfixed by: kirilloid
	// example 1: utf8_encode('Kevin van Zonneveld');
	// returns 1: 'Kevin van Zonneveld'

	if (argString === null || typeof argString === "undefined") {
		return "";
	}

	// .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
	var string = (argString + "");
	var utftext = "", start, end, stringl = 0;

	start = end = 0;
	stringl = string.length;
	for (var n = 0; n < stringl; n++) {
		var c1 = string.charCodeAt(n);
		var enc = null;

		if (c1 < 128) {
			end++;
		}
		else if (c1 > 127 && c1 < 2048) {
			enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);
		}
		else if ((c1 & 0xF800) !== 0xD800) {
			enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);
		}
		else {
			// surrogate pairs
			if ((c1 & 0xFC00) !== 0xD800) {
				throw new RangeError("Unmatched trail surrogate at " + n);
			}
			var c2 = string.charCodeAt(++n);
			if ((c2 & 0xFC00) !== 0xDC00) {
				throw new RangeError("Unmatched lead surrogate at " + (n - 1));
			}
			c1 = ((c1 & 0x3FF) << 10) + (c2 & 0x3FF) + 0x10000;
			enc = String.fromCharCode((c1 >> 18) | 240, ((c1 >> 12) & 63) | 128, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);
		}
		if (enc !== null) {
			if (end > start) {
				utftext += string.slice(start, end);
			}
			utftext += enc;
			start = end = n + 1;
		}
	}

	if (end > start) {
		utftext += string.slice(start, stringl);
	}

	return utftext;
};

tgfMD5.createMD5Hash = function(str) {
	"use strict";
	// discuss at: http://phpjs.org/functions/md5/
	// original by: Webtoolkit.info (http://www.webtoolkit.info/)
	// improved by: Michael White (http://getsprink.com)
	// improved by: Jack
	// improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// input by: Brett Zamir (http://brett-zamir.me)
	// bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// depends on: utf8_encode
	// example 1: md5('Kevin van Zonneveld');
	// returns 1: '6e658d4bfcb59cc13f96c14450ac40b9'

	var xl;

	var rotateLeft = function(lValue, iShiftBits) {
		return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
	};

	var addUnsigned = function(lX, lY) {
		var lX4, lY4, lX8, lY8, lResult;
		lX8 = (lX & 0x80000000);
		lY8 = (lY & 0x80000000);
		lX4 = (lX & 0x40000000);
		lY4 = (lY & 0x40000000);
		lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
		if (lX4 & lY4) {
			return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
		}
		if (lX4 | lY4) {
			if (lResult & 0x40000000) {
				return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
			}
			return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
					}
		return (lResult ^ lX8 ^ lY8);
	};

	var _F = function(x, y, z) {
		return (x & y) | ((~x) & z);
	};
	var _G = function(x, y, z) {
		return (x & z) | (y & (~z));
	};
	var _H = function(x, y, z) {
		return (x ^ y ^ z);
	};
	var _I = function(x, y, z) {
		return (y ^ (x | (~z)));
	};

	var _FF = function(a, b, c, d, x, s, ac) {
		a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	};

	var _GG = function(a, b, c, d, x, s, ac) {
		a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	};

	var _HH = function(a, b, c, d, x, s, ac) {
		a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	};

	var _II = function(a, b, c, d, x, s, ac) {
		a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	};

	var convertToWordArray = function(s) {
		var lWordCount;
		var lMessageLength = s.length;
		var lNumberOfWords_temp1 = lMessageLength + 8;
		var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
		var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
		var lWordArray = new Array(lNumberOfWords - 1);
		var lBytePosition = 0;
		var lByteCount = 0;
		while (lByteCount < lMessageLength) {
			lWordCount = (lByteCount - (lByteCount % 4)) / 4;
			lBytePosition = (lByteCount % 4) * 8;
			lWordArray[lWordCount] = (lWordArray[lWordCount] | (s.charCodeAt(lByteCount) << lBytePosition));
			lByteCount++;
		}
		lWordCount = (lByteCount - (lByteCount % 4)) / 4;
		lBytePosition = (lByteCount % 4) * 8;
		lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
		lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
		lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
		return lWordArray;
	};

	var wordToHex = function(lValue) {
		var wordToHexValue = "", wordToHexValue_temp = "", lByte, lCount;
		for (lCount = 0; lCount <= 3; lCount++) {
			lByte = (lValue >>> (lCount * 8)) & 255;
			wordToHexValue_temp = "0" + lByte.toString(16);
			wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
		}
		return wordToHexValue;
	};

	var x = [], k, AA, BB, CC, DD, a, b, c, d, S11 = 7, S12 = 12, S13 = 17, S14 = 22, S21 = 5, S22 = 9, S23 = 14, S24 = 20, S31 = 4, S32 = 11, S33 = 16, S34 = 23, S41 = 6, S42 = 10, S43 = 15, S44 = 21;

	str = tgfMD5.utf8_encode(str);
	x = convertToWordArray(str);
	a = 0x67452301;
	b = 0xEFCDAB89;
	c = 0x98BADCFE;
	d = 0x10325476;

	xl = x.length;
	for (k = 0; k < xl; k += 16) {
		AA = a;
		BB = b;
		CC = c;
		DD = d;
		a = _FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
		d = _FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
		c = _FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
		b = _FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
		a = _FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
		d = _FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
		c = _FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
		b = _FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
		a = _FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
		d = _FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
		c = _FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
		b = _FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
		a = _FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
		d = _FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
		c = _FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
		b = _FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
		a = _GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
		d = _GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
		c = _GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
		b = _GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
		a = _GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
		d = _GG(d, a, b, c, x[k + 10], S22, 0x2441453);
		c = _GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
		b = _GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
		a = _GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
		d = _GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
		c = _GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
		b = _GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
		a = _GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
		d = _GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
		c = _GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
		b = _GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
		a = _HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
		d = _HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
		c = _HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
		b = _HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
		a = _HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
		d = _HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
		c = _HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
		b = _HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
		a = _HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
		d = _HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
		c = _HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
		b = _HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
		a = _HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
		d = _HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
		c = _HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
		b = _HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
		a = _II(a, b, c, d, x[k + 0], S41, 0xF4292244);
		d = _II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
		c = _II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
		b = _II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
		a = _II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
		d = _II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
		c = _II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
		b = _II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
		a = _II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
		d = _II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
		c = _II(c, d, a, b, x[k + 6], S43, 0xA3014314);
		b = _II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
		a = _II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
		d = _II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
		c = _II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
		b = _II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
		a = addUnsigned(a, AA);
		b = addUnsigned(b, BB);
		c = addUnsigned(c, CC);
		d = addUnsigned(d, DD);
	}

	var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);

	return temp.toLowerCase();
};

//******************************************************
//*****    Script Resource: tgfGraphics
//******************************************************

// ***************************************
// tgfGraphics
//
// This object contains properties and methods related to the
// graphics, like dealing with canvasses and some useful generic
// drawing methods
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 26-6-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbPlatforms, tbBrowser */
/*global tgfSettings, tgfScale, tgfFunctions, testMode */
/*global window, document, console, setTimeout */


tgfSettings.graphicDefaults = {
		mainCanvasId: "canvas",					// id of main canvas (if that is already in the index file)
		containerId: "game_container",			// id of game container element (if that is already in the index file)
		areaWidth: tgfScale(1152),				// Total width of the area that contains the canvasses
		areaHeight: tgfScale(640),				// Total height of the area that contains the canvasses
		createBackgroundCanvas: true,			// whether to create a static background canvas
		safeZoneWidth: tgfScale(850),			// width of safe zone on the total area
		safeZoneHeight: tgfScale(640),			// height of safe zone on the total area
		safeZoneTop: tgfScale(0),				// top of safe zone on the total area
		safeZoneLeft: tgfScale(151),			// left of safe zone on the total area
		safeZoneHorizontalAnchor: "center",		// anchor for horizontal position of the safe zone
		safeZoneVerticalAnchor: "middle",		// anchor for vertical position of the safe zone
		allowScalingUp: true,					// whether or not to scale up to the encompassing window
		allowScalingDown: true,					// whether or not to scale down to the encompassing window
		backgroundImage: undefined,				// background image location
		// backgroundColor: "white",				// background color
		autoUpdateInterval: 1,					// Interval (in seconds for automatically updating the sizes when the window size changed)
		autoUpdateForce: false,					// Whether to force updating at automatic interval

		view : null,
		transparent : true,
		autoResize : false,
		antialias : false,
		forceFXAA : false,
		resolution : 1,
		backgroundColor	: 0x000000,
		clearBeforeRender : true,
		preserveDrawingBuffer : false,
		roundPixels : false
	};

	
// ***************************************
// Constructor
// ***************************************

var TGFGraphics = function() {
	"use strict";
	this._initialized = false;							// boolean to indicate if the object has been initialized
	this.canvasses = [];								// Array of all canvasses in order of depth (lowest one first)
	this.renderers = [];
	this.pixiContainer = tbGraphics.mainContainer;
};


// ***************************************
// Initialization
// ***************************************

// Initialize the graphics, creating the default canvasses
TGFGraphics.prototype.initialize = function(settings) {
	"use strict";
	var self = this;
	// Set the properties from the settings
	this._initialized = true;
	this.canvasses = [];

	this._setProperties(tgfSettings.graphicDefaults);
	this._setProperties(settings);
	// get or create DIV element to contain canvasses
	this.container = document.getElementById(this.containerId);
	if (!this.container) {
		this.container = document.createElement("DIV");
		this.container.id = this.containerId;
		document.body.appendChild(this.container);
	}

	var fontCanvas = this.addCanvas();
	tbGraphics.fontCanvas = fontCanvas;


	var options = {
		view : this.view,
        transparent : this.transparent,
        autoResize : this.autoResize,
        antialias : this.antialias,
        forceFXAA : this.forceFXAA,
        resolution : this.resolution,
        backgroundColor	: this.backgroundColor,
        clearBeforeRender : this.clearBeforeRender,
        preserveDrawingBuffer : this.preserveDrawingBuffer,
        roundPixels : this.roundPixels
	};

    // PIXI.glCore.VertexArrayObject.FORCE_NATIVE = true;
    // PIXI.settings.SPRITE_MAX_TEXTURES = 1;
	// get or create main canvas and set the properties
	this.renderer = new PIXI["autoDetectRenderer"](tgfGraphics.areaWidth, tgfGraphics.areaHeight, options);
	tbGame.renderCallback = function () { self.render(); }

	//disable the pixi ticker to avoid an extra requestAnimationFrame
    var ticker = PIXI["ticker"]["shared"];
	ticker["autoStart"] = false;
    ticker["stop"]();

	//this.renderers.push(this.renderer);
	this.mainCanvas = this.renderer.view;//document.getElementById(this.mainCanvasId);
	if (!this.mainCanvas){
		this.mainCanvas = document.createElement("canvas");
		this.container.appendChild(this.mainCanvas);
	} else {
		this.addCustomCanvas(this.mainCanvas);
	}

	this._initializeCanvas(this.mainCanvas, {canvasTop:0, canvasLeft: 0});
	this.canvasses.push(this.mainCanvas);
	// create background canvas
	//if (this.createBackgroundCanvas) {
	//	this.backgroundCanvas = this.insertCanvas(undefined, {canvasStatic: true});
	//}
	// update the viewport and register the resize event handler to do the same
	window.addEventListener("resize", function() { TGFGraphics.prototype._updateViewport.call(self, true); }, true);
	if (this.autoUpdateInterval > 0) {
		window.setInterval( function() { TGFGraphics.prototype._updateViewport.call(self, self.autoUpdateForce); }, 1000 * this.autoUpdateInterval);
	}
	this._updateViewport(true);
	//set the background color and image
	if (this.backgroundColor !== undefined) { this.setBackgroundColor(this.backgroundColor); }
	if (this.backgroundImage !== undefined) { this.setBackgroundImage(this.backgroundImage); }
	// set current canvas properly in the engine
	//tbGraphics.checkWebGL(this.mainCanvas);
	tbGame.setMainCanvas(this.mainCanvas);
	//tbGraphics.checkWebGL(this.mainCanvas);
	//tbGraphics.setCanvas(this.mainCanvas);
	tbGraphics.webGLAvailable = true;
};


// ***************************************
// Internal methods
// ***************************************

// Set a number of properties of the graphics object
TGFGraphics.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

// Determines the size of the container div and updates the scale factor of the canvasses
TGFGraphics.prototype._updateViewport = function(force) {
	"use strict";

	if (this._canLog == undefined) this._canLog = true;
	
	var prefRatio, minRatio, windowRatio, width, height, divWidth, divHeight,
		widthOutside, widthOutsideFactor, heightOutside, heightOutsideFactor;
	if (!this._initialized) { return; }
	// Check whether anything must be done
	if (!force && this.windowWidth !== undefined && this.windowWidth === window.innerWidth && 
			this.windowHeight !== undefined && this.windowHeight === window.innerHeight) { return; } 
	// determine the size of the window
	this.windowWidth = window.innerWidth;
	this.windowHeight = window.innerHeight;
	// determine the ratios
	var safeZoneWidthDifference = this.safeZoneWidth - this.areaWidth;
	var safeZoneHeightDifference = this.safeZoneHeight - this.areaHeight;
	windowRatio = (this.windowWidth - safeZoneWidthDifference) / (this.windowHeight - safeZoneHeightDifference);
	// if (this._canLog) ScreenDebugger.debug('szw-diff', safeZoneWidthDifference);
	// if (this._canLog) ScreenDebugger.debug('szh-diff', safeZoneHeightDifference);
	
	prefRatio = this.areaWidth / (this.areaHeight);
	minRatio = this.safeZoneWidth / this.safeZoneHeight;

	// Default settings for when the area covers the whole window
	width = this.windowWidth;
	height = this.windowHeight;
	this.scaleFactor = Math.min(this.windowWidth/this.safeZoneWidth, this.windowHeight/this.safeZoneHeight);

	// if (this._canLog) ScreenDebugger.debug('ratio-win', windowRatio);
	// if (this._canLog) ScreenDebugger.debug('ratio-pref', prefRatio);
	// if (this._canLog) ScreenDebugger.debug('ratio-min', minRatio);

	
	// Screen is too high, take full width, but scale up so complete width is being used by safe zone to achieve maximum height
	if (windowRatio < prefRatio && windowRatio < minRatio) {

		var scaleHeight = this.windowWidth/this.safeZoneWidth;
		if (scaleHeight < this.scaleFactor) {

			height = Math.floor(this.windowWidth / (this.safeZoneWidth / this.areaHeight));
			this.scaleFactor = scaleHeight;
			// if (this._canLog) ScreenDebugger.debug('fit', 'too high');
		}
		else {
			
			height = Math.floor(this.windowWidth / (this.safeZoneWidth / this.areaHeight));
			// if (this._canLog) ScreenDebugger.debug('fit', 'too high - but bigger scale');
		}
	}
	else {
		
		// if (this._canLog) ScreenDebugger.debug('fit', 'dont-check-height');
	}
	// Screen is too wide, take full height but scale up so complete height is being used by safe zone to achieve maximum width
	if (windowRatio > prefRatio && windowRatio > minRatio) {

		var scaleWidth = (this.windowHeight - this.safeZoneTop) / (this.safeZoneHeight - this.safeZoneTop);
		if (scaleWidth < this.scaleFactor) {

			width = Math.floor((this.windowHeight - this.safeZoneTop) * (this.areaWidth / (this.safeZoneHeight - this.safeZoneTop)));
			this.scaleFactor = scaleWidth;
			// if (this._canLog) ScreenDebugger.debug('fit', 'too wide');
		}
		else {

			width = Math.floor((this.windowHeight - this.safeZoneTop) * (this.areaWidth / (this.safeZoneHeight - this.safeZoneTop)));
			// if (this._canLog) ScreenDebugger.debug('fit', 'too wide - but bigger scale');
		}
	}
	else {

		// if (this._canLog) ScreenDebugger.debug('fit', 'dont-check-width');
	}
	// Check if game is allowed to scale
	if (!this.allowScalingUp && this.scaleFactor > 1) {
		width = Math.min(width, this.areaWidth);
		height = Math.min(height, this.areaHeight);
		this.scaleFactor = 1;
	}
	if (!this.allowScalingDown && this.scaleFactor < 1) {
		width = Math.max(width, this.areaWidth);
		height = Math.max(height, this.areaHeight);
		this.scaleFactor = 1;
	}

	// ScreenDebugger.debug('scale-factor', this.scaleFactor);
	this._canLog = false;

	
	// determine total area offsets
	this.cssLeftOffset = 0;
	this.cssTopOffset = 0;
	widthOutside = this.areaWidth - this.windowWidth/this.scaleFactor;
	if (this.areaWidth === this.safeZoneWidth) {
		widthOutsideFactor = 1;
	} else {
		widthOutsideFactor = widthOutside / (this.areaWidth - this.safeZoneWidth);
	}
	if (widthOutside >= 1) {
		switch (this.safeZoneHorizontalAnchor) {
			case "right":
				// move total area as far as possible to the left
				this.cssLeftOffset = -Math.min(widthOutside, this.safeZoneLeft);
				break;
			case "left":
				// only move total area to left if the safe zone on the right is not enough to compensate
				this.cssLeftOffset = -Math.max(0, widthOutside - this.areaWidth + this.safeZoneWidth + this.safeZoneLeft);
				break;
			default:
				// move total area half of the difference between width and window.width to the left
				this.cssLeftOffset = -widthOutsideFactor * this.safeZoneLeft;
		}
	}
	heightOutside = this.areaHeight - this.windowHeight/this.scaleFactor;
	heightOutsideFactor = heightOutside / (this.areaHeight - this.safeZoneHeight);

	// resize and position the game container
	divHeight = Math.min(this.windowHeight, height);
	divWidth = Math.min(this.windowWidth, width);

	var verticalAlignment = "top:50%; margin-top:" + (-divHeight / 2) + "px";

	switch (this.safeZoneVerticalAnchor) {
		case "bottom":
			// move total area as far as possible to the top
			this.cssTopOffset = -Math.min(heightOutside, this.safeZoneTop);
			break;
		case "top":
			// only move total area to top if the safe zone on the bottom is not enough to compensate
			this.cssTopOffset = -Math.max(0, heightOutside - this.areaHeight + this.safeZoneHeight ) + this.safeZoneTop;
			verticalAlignment = "margin-top:" + this.cssTopOffset + "px"
			break;
		default:
			// move total area half of the difference between height and window.height to the top
			this.cssTopOffset = -heightOutsideFactor * this.safeZoneTop;
	}

	this.container.setAttribute("style", "position:fixed; overflow:hidden; z-index: 0; width:" + divWidth + "px; left:50%; margin-left:" + (-divWidth / 2) +
			"px; height: " + divHeight + "px;" +verticalAlignment);
	// set visible area properties
	this.visibleLeft = - this.cssLeftOffset;
	this.visibleTop = - this.cssTopOffset;
	this.visibleWidth = Math.ceil(divWidth / this.scaleFactor);
	this.visibleHeight = Math.ceil(divHeight / this.scaleFactor);
	
	// resize the canvasses using CSS
	this._updateCanvassesCSS();

	// apply a hack to clear browser back buffer after DOM changes
	this.performBufferClearHack();
};

// Pauses the game and then forces a DOM update to clear browser back buffers
// See Confluence Android Browser Canvas Redraw Bug Fix
TGFGraphics.prototype.performBufferClearHack = function() {
	"use strict";
	var useHack, context, i, canvas, images, image, self = this;
	// first check whether hack should be applied (only on Android stock browser version4 and higher)
	useHack = tbBrowser.browser.stockandroid && tbBrowser.browser.versionAsNumber && tbBrowser.browser.versionAsNumber >= 4;
	if(tbGraphics.webGLAvailable){ return; }
	if (!useHack) { return; }
	if (this._DOMUpdating) { return; }
	this._DOMUpdating = true;		
	// pause game
	tgfFunctions.pauseAll();
	// copy canvas image data and clear canvasses
	images = [];
	for (i = 0; i < this.canvasses.length; i += 1) {
		canvas = this.canvasses[i];
		context = canvas.getContext("2d");
		try {
			image = context.getImageData(0, 0, canvas.width, canvas.height);
			images.push(image);
		} catch(e) {
			if (testMode){
				console.log("error in getting image data: " + e.name + ", " + e.message);
			}
		}
		context.clearRect(0, 0, canvas.width, canvas.height);
		canvas.style.visibility = "hidden";
	}
	// set almost immediate timeout to force DOM refresh
	setTimeout( function() {
			var i;
			for (i = 0; i < self.canvasses.length; i += 1) {
				self.canvasses[i].style.visibility = "visible";
			}
		}, 1);

	// set slightly later timeout to redraw image data
	setTimeout( function() {
			var i, context;
			//redraw image data per canvas
			for (i = 0; i < self.canvasses.length; i += 1) {
				context = self.canvasses[i].getContext("2d");
				try {
					context.putImageData(images[i], 0, 0);
				} catch(e) {
					if (testMode) {
						console.log("error in putting image data: " + e.name + ", " + e.message);
					}
				}
			}
			//resume game
			tgfFunctions.resumeAll();			
			this._DOMUpdating = false;
		}, 100);
};

// Updates the style element of the canvas with the given depth index
TGFGraphics.prototype._updateCanvasCSS = function(canvas, depthIndex) {
	"use strict";
	var left, top;
	if (this.scaleFactor === undefined) { return; }

	left = this.cssLeftOffset + canvas.canvasLeft;
	top = this.cssTopOffset + canvas.canvasTop;

	// console.log('update::Canvas --> centerSquare' + depthIndex, this.centerSquare);

	if (this.centerSquare) { 
		
		var ratio = this.windowWidth / this.windowHeight;

	    var squared_left = 0; 
	    var squared_top = 0; 

	    if (ratio <= 1) {
	    	squared_left = -Math.round(( (this.scaleFactor * canvas.canvasWidth) - this.windowWidth) / 2);
	    	squared_top = 0;	
	    }
	    else {
	    	ratio = 1;
	    	squared_left = 0;
	    	squared_top = 0;
	    }


	    tgfGraphics.squaredLeft = squared_left * this.scaleFactor;
	    tgfGraphics.squaredTop = squared_top;// * this.scaleFactor;
	    tgfGraphics.ratio = ( (ratio < this.minRatio) ? this.minRatio : ratio);

	    if (depthIndex == 1) {
	    	
			// ScreenDebugger.debug('update::Canvas', depthIndex);
		    // ScreenDebugger.debug('dim-win', this.windowWidth + ' :: ' + this.windowHeight);
		    // ScreenDebugger.debug('ratio', ratio + ' :: ' + this.minRatio);
		    // ScreenDebugger.debug('ratio-sel', tgfGraphics.ratio);
		    // ScreenDebugger.debug('scale-factor', this.scaleFactor);
	    }

	    // console.log(tgfGraphics.ratio);
	    
	    // transform instead of left/top
	    canvas.setAttribute("style", "-webkit-transform: translate(" + squared_left + "px, " + squared_top + "px); transform: translate(" + squared_left + "px, " + squared_top + "px); position:absolute; left:" + 0 + "px; top:" + 0 + "px; width:" 
            + Math.round(this.scaleFactor * canvas.canvasWidth) + "px; height:" + Math.round(this.scaleFactor * canvas.canvasHeight) + "px; z-index: " + (depthIndex+1).toString());

	    // canvas.setAttribute("style", "position:absolute; transform: translate(0px, 0px); left:" + squared_left + "px; top:" + squared_top + "px; width:" 
	        // + Math.round(this.scaleFactor * canvas.canvasWidth) + "px; height:" + Math.round(this.scaleFactor * canvas.canvasHeight) + "px; z-index: " + (depthIndex+1).toString()); 
  	}
  	else {
  		

  		if (depthIndex == 1) {
	    	
  			var diff = this.areaWidth - this.safeZoneWidth;
  			var vis = Math.round(this.scaleFactor * canvas.canvasWidth) - Math.round(diff * this.scaleFactor);

			// ScreenDebugger.debug('update::Canvas', depthIndex);
		    // ScreenDebugger.debug('dim-win', this.windowWidth + ' :: ' + this.windowHeight);
		    // ScreenDebugger.debug('dim-factor', Math.round(this.scaleFactor * canvas.canvasWidth) + ' :: ' + Math.round(this.scaleFactor * canvas.canvasHeight) );
		    // ScreenDebugger.debug('dim-vis-width', (this.visibleWidth * this.scaleFactor));
		    // ScreenDebugger.debug('dim-vis-width', diff + '::' +  vis);
		    // ScreenDebugger.debug('scale-factor', this.scaleFactor);
	    }


		canvas.setAttribute("style", "position:absolute; left:" + Math.round(this.scaleFactor * left) + "px; width:"
			+ Math.round(this.scaleFactor * canvas.canvasWidth) + "px; height:" + Math.round(this.scaleFactor * canvas.canvasHeight) + "px; z-index: " + (depthIndex+1).toString());
  	}


	
};

// Updates the style element of all the canvasses
TGFGraphics.prototype._updateCanvassesCSS = function() {
	"use strict";
	var i;
	for (i = 0; i < this.canvasses.length; i += 1) {
		this._updateCanvasCSS(this.canvasses[i], i);
	}
};

// Applies the properties to the specified canvas
TGFGraphics.prototype._initializeCanvas = function(canvas, properties) {
	"use strict";
	var top, left, width, height, canvasStatic;
	// check properties
	if (!properties) { properties = {}; }
	top = (properties.canvasTop !== undefined) ? properties.canvasTop : 0;
	left = (properties.canvasLeft !== undefined) ? properties.canvasLeft : 0;
	width = (properties.canvasWidth !== undefined) ? properties.canvasWidth : this.areaWidth;
	height = (properties.canvasHeight !== undefined) ? properties.canvasHeight : this.areaHeight;
	canvasStatic = (properties.canvasStatic !== undefined) ? properties.canvasStatic : false;	
	//set standard canvas properties	
	canvas.style.top =  top + "px";
	canvas.style.left = left + "px";
	canvas.style.position = "absolute";
	canvas.width = width;
	canvas.height = height;
	//set own canvas properties
	canvas.canvasTop = top;
	canvas.canvasLeft = left;
	canvas.canvasWidth = width;
	canvas.canvasHeight = height;
	canvas.canvasStatic = canvasStatic;
	if (canvasStatic) { canvas.drawTokens = false; }
};

// Creates a canvas html element and adds it to page; returns the canvas
TGFGraphics.prototype._createCanvas = function(properties) {
	"use strict";
	//create canvas
	var canvas = document.createElement("canvas");
	this._initializeCanvas(canvas, properties);
	//add canvas to DOM
	if(this.container){
		this.container.appendChild(canvas);
	}else{
		document.body.appendChild(canvas);
	}

	return canvas;
};

TGFGraphics.prototype.addCustomCanvas = function(canvas, properties){
	"use strict";
	this._initializeCanvas(canvas, properties);
	if(this.container){
		this.container.appendChild(canvas);
	}else{
		document.body.appendChild(canvas);
	}

	this.canvasses.push(canvas);
	this._updateCanvasCSS(canvas, this.canvasses.length-1);
};

// Destroy the canvas
TGFGraphics.prototype._destroyCanvas = function(canvas) {
	"use strict";
	//remove element from DOM
	if (this.container) {
		this.container.removeChild(canvas);
	} else {
		document.body.removeChild(canvas);
	}
};

// Find the index of a canvas in the array. -1 if it does not exist.
TGFGraphics.prototype._findIndex = function(canvas) {
	"use strict";
	var i;
	if (!canvas) { return -1; }
    for (i = 0; i < this.canvasses.length; i += 1) {
		if (this.canvasses[i] === canvas) { return i; }
	}
	return -1;
};


// ***************************************
// Adding and removing canvasses
// ***************************************

// Adds a canvas on top of the existing ones; returns the canvas
TGFGraphics.prototype.addCanvas = function(properties) {
	"use strict";
	var newCanvas;
	newCanvas = this._createCanvas(properties);
	this.canvasses.push(newCanvas);
	this._updateCanvasCSS(newCanvas, this.canvasses.length-1);
	return newCanvas;
};

// Inserts a canvas below the given one; returns the canvas
TGFGraphics.prototype.insertCanvas = function(targetCanvas, properties) {
	"use strict";
	var index, newCanvas;
	index = this._findIndex(targetCanvas);
	if (index < 0) { index = 0; }
	newCanvas = this._createCanvas(properties);
	this.canvasses.splice(index, 0, newCanvas);
	this._updateCanvassesCSS();
	return newCanvas;
};

// Removes the given canvas; returns whether found and removed
TGFGraphics.prototype.removeCanvas = function(canvas) {
	"use strict";
	var index;
	// Cannot remove the main canvas
	if (canvas === this.mainCanvas) { return false; }
	index = this._findIndex(canvas);
	if (index < 0) { return false; }
	this.canvasses.splice(index, 1);
	//if removing backgroundCanvas update pointer
	if (canvas === this.backgroundCanvas) { this.backgroundCanvas = undefined; }
	this._destroyCanvas(canvas);
	// update css settings for the remaining canvasses
	this._updateCanvassesCSS();
	return true;
};

// Updates the position of the canvas relative to the main canvas
TGFGraphics.prototype.moveCanvas = function(canvas, top, left) {
	"use strict";
	if (!canvas) { return; }
	canvas.canvasTop = (top !== undefined && top !== null) ? top : canvas.canvasTop;
	canvas.canvasLeft = (left !== undefined && left !== null) ? left : canvas.canvasLeft;
	this._updateCanvasCSS(canvas, this._findIndex(canvas));
};

// Updates the width and height of the specified canvas, note that this might clear the canvas
TGFGraphics.prototype.resizeCanvas = function(canvas, width, height) {
	"use strict";
	if (!canvas) { return; }
	canvas.canvasWidth = (width !== undefined && width !== null) ? width : canvas.canvasWidth;
	canvas.canvasHeight = (height !== undefined && height !== null) ? height : canvas.canvasHeight;
	canvas.width = canvas.canvasWidth;
	canvas.height = canvas.canvasHeight;
	this._updateCanvasCSS(canvas, this._findIndex(canvas));
	// Make sure tbGraphics knows the correct size
	if (tbGraphics.canvas === canvas) { tbGraphics.setCanvas(canvas); }
};

// ***************************************
// Retrieving and clearing canvasses
// ***************************************

// Returns an array containing all canvasses ordered from lowest to highest
TGFGraphics.prototype.getAllCanvasses = function() {
	"use strict";
	var i, res = [];
	for (i = 0; i < this.canvasses.length; i += 1) {
		res.push(this.canvasses[i]);
	}
	return res;
};

// Returns an array containing all static canvasses ordered from lowest to highest
TGFGraphics.prototype.getStaticCanvasses = function() {
	"use strict";
	var i, res = [];
	for (i = 0; i < this.canvasses.length; i += 1) {
		if (this.canvasses[i].canvasStatic) { res.push(this.canvasses[i]); }
	}
	return res;
};

// Returns an array containing all dynamic canvasses ordered from lowest to highest
TGFGraphics.prototype.getDynamicCanvasses = function() {
	"use strict";
	var i, res = [];
	for (i = 0; i < this.canvasses.length; i += 1) {
		if (!this.canvasses[i].canvasStatic) { res.push(this.canvasses[i]); }
	}
	return res;
};

// Sets a canvas to be static
TGFGraphics.prototype.setCanvasStatic = function(canvas) {
	"use strict";
	canvas.canvasStatic = true;
	canvas.drawTokens = false;
};

// Sets a canvas to be dynamic
TGFGraphics.prototype.setCanvasDynamic = function(canvas) {
	"use strict";
	canvas.canvasStatic = false;
	canvas.drawTokens = true;
};

// Clear a given canvas. If color is defined, that color is used for clearing
TGFGraphics.prototype.clearCanvas = function(canvas, color) {
	"use strict";

	if(tbGraphics.webGLAvailable){
		return;
	}
};

TGFGraphics.prototype.render = function() {
    "use strict";

	this.renderer["render"](this.pixiContainer);
};

TGFGraphics.prototype.addChild = function(obj){
	"use strict";
    this.pixiContainer["addChild"](obj);
};

TGFGraphics.prototype.addChildAt = function(obj, index){
	"use strict";
    this.pixiContainer["addChildAt"](obj, index);
};

TGFGraphics.prototype.removeChild = function(obj){
    "use strict";
    this.pixiContainer["removeChild"](obj);
};

// Clear all canvasses. If color is defined, that color is used for clearing
TGFGraphics.prototype.clearAllCanvasses = function(color) {
	"use strict";
	var i;
	for (i = 0; i < this.canvasses.length; i += 1) {
		this.clearCanvas(this.canvasses[i], color);
	}
};

// Clear all static canvasses. If color is defined, that color is used for clearing
TGFGraphics.prototype.clearStaticCanvasses = function(color) {
	"use strict";
	var i;
	for (i = 0; i < this.canvasses.length; i += 1) {
		if (this.canvasses[i].canvasStatic) { this.clearCanvas(this.canvasses[i], color); }
	}
};

// Clear all dynamic canvasses. If color is defined, that color is used for clearing
TGFGraphics.prototype.clearDynamicCanvasses = function(color) {
	"use strict";
	var i;
	for (i = 0; i < this.canvasses.length; i += 1) {
		if (!this.canvasses[i].canvasStatic) { this.clearCanvas(this.canvasses[i], color); }
	}
};


// ***************************************
// Changing the depth order of the canvasses
// ***************************************

// Move the given canvas before the specified target canvas
TGFGraphics.prototype.moveBefore = function(canvas, targetCanvas) {
	"use strict";
	var targetIndex, canvasIndex;
	if (this.canvasses.length <= 1 || !canvas || canvas === targetCanvas) { return; }
	// find canvas and remove it from array array
	canvasIndex = this._findIndex(canvas);
	if (canvasIndex < 0) { return; }
	this.canvasses.splice(canvasIndex, 1);
    // find target canvas position in array
	targetIndex = this._findIndex(targetCanvas);
	if (targetIndex < 0) { targetIndex = this.canvasses.length-1; }
	// add canvas in front of target canvas (so behind it in the array)
	this.canvasses.splice(targetIndex + 1, 0, canvas);
	this._updateCanvassesCSS();
};

// Move the given canvas in front of all other canvasses
TGFGraphics.prototype.moveToFront = function(canvas) {
	"use strict";
	this.moveBefore(canvas);
};

//Move the given canvas right behind the specified canvas
TGFGraphics.prototype.moveBehind = function(canvas, targetCanvas) {
	"use strict";
	var targetIndex, canvasIndex;
	if (this.canvasses.length <= 1 || !canvas || canvas === targetCanvas) { return; }
	// find canvas and remove it from array array
	canvasIndex = this._findIndex(canvas);
	if (canvasIndex < 0) { return; }
	this.canvasses.splice(canvasIndex, 1);
    // find target canvas position in array
	targetIndex = this._findIndex(targetCanvas);
	if (targetIndex < 0) { targetIndex = 0; }
	
	// add canvas behind target canvas (so before the target canvas in the array)
	this.canvasses.splice(targetIndex, 0, canvas);
	this._updateCanvassesCSS();
};

// Move the given canvas behind all other canvasses
TGFGraphics.prototype.moveToBack = function(canvas) {
	"use strict";
	this.moveBehind(canvas);
};


// ***************************************
// Useful other methods
// ***************************************

// Translates the specified x coordinate based on the sourceCanvas to the x coordinate of
// the same location on the targetCanvas
TGFGraphics.prototype.translateCoordinateX = function(sourceCanvas, targetCanvas, x) {
	"use strict";
	if (!sourceCanvas || !targetCanvas) { return x; }
	return sourceCanvas.canvasLeft - targetCanvas.canvasLeft + x;
};

// Translates the specified y coordinate based on the sourceCanvas to the y coordinate of
// the same location on the targetCanvas
TGFGraphics.prototype.translateCoordinateY = function(sourceCanvas, targetCanvas, y) {
	"use strict";
	if (!sourceCanvas || !targetCanvas) { return y; }
	return sourceCanvas.canvasTop - targetCanvas.canvasTop + y;
};

// Set the url of the background image of the game page
TGFGraphics.prototype.setBackgroundImage = function(url) {
	"use strict";
	document.body["style"]["backgroundImage"] = "url(" + url + ")";
};

// Set the background color of the game page
TGFGraphics.prototype.setBackgroundColor = function(color) {
	"use strict";
	document.body["style"]["backgroundColor"] = color;
};

// Set the safe zone
TGFGraphics.prototype.setSafeZone = function(left, top, width, height) {
	"use strict";
	this.safeZoneLeft = (left === undefined) ? this.safeZoneLeft : left;
	this.safeZoneTop = (top === undefined) ? this.safeZoneTop : top;
	this.safeZoneWidth = (width === undefined) ? this.safeZoneWidth : width;
	this.safeZoneHeight = (height === undefined) ? this.safeZoneHeight : height;
	this._updateViewport(true);
};

// Set the safe zone anchors
TGFGraphics.prototype.setSafeZoneAnchors = function(horizontal, vertical) {
	"use strict";
	this.safeZoneHorizontalAnchor = (horizontal === undefined) ? this.safeZoneHorizontalAnchor : horizontal;
	this.safeZoneVerticalAnchor = (vertical === undefined) ? this.safeZoneVerticalAnchor : vertical;
	this._updateViewport(true);
};

// Set whether the canvasses must be scaled
TGFGraphics.prototype.setScaling = function(scaleUp, scaleDown) {
	"use strict";
	this.allowScalingUp = (scaleUp === undefined) ? this.allowScalingUp : scaleUp;
	this.allowScalingDown = (scaleDown === undefined) ? this.allowScalingDown : scaleDown;
	this._updateViewport(true);
};

// Set the area that the canvasses can cover
TGFGraphics.prototype.setArea = function(width, height) {
	"use strict";
	this.areaWidth = (width === undefined) ? this.areaWidth : width;
	this.areaHeight = (height === undefined) ? this.areaHeight : height;
	this._updateViewport(true);
};


// ***************************************
// Create the instance
// ***************************************

var tgfGraphics = new TGFGraphics();


//******************************************************
//*****    Script Resource: tgfDictionary
//******************************************************

// ***************************************
// tgfDictionary
//
// This object deals with the dictionary. 
//
// Actually, you can create multiple instances of the TGFDictionary
// object if you want. tgfDictionary is simply the default one.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 12-11-2015
// ***************************************

// Directives for jslint
/*global navigator */
/*global tbGame, tbBrowser */
/*global tgfFunctions, tgfStatus, tgfProfile, tgfSettings */


tgfSettings.dictionaryDefaults = {
		dictionaries: [],									// Array of dictionaries to use
		languages: [],										// Array of available languages in the shown order (if empty all ones in the dictionary)
		removeLanguages: [],								// Array of languages that must be removed, even if they are in the previous properties
		removeIncomplete: true,							// Whether to remove incomplete languages from the allowed ones
		initialLanguage: undefined,							// The initial language to be used
		useUrlLanguages: true,								// Whether to use the url parameter languages instead when provided
		urlLanguagesParameter: "lang",						// Url parameter that is used for the languages
		useBrowserLanguage: true,							// Use the browser language instead
		usePlayerLanguage: true								// Use the player language when it is set (overwriting other settings)
	};


// The constructor
var TGFDictionary = function () {
	"use strict";
	this.theDictionaries = {};								// The dictionaries for the different languages
	this.currentLanguage = "en-us";							// Current language being used
	this.availableLanguages = ["en-us"];					// Array of available languages
};

// Initialize
TGFDictionary.prototype.initialize = function(settings) {
	"use strict";
	var languages, language;
	// set the properties
	this._setProperties(tgfSettings.dictionaryDefaults);
	this._setProperties(settings);
	// set the dictionaries
	this.theDictionaries = {};
	this.addDictionaries(this.dictionaries);
	// set the languages
	this.setAllAvailableLanguages();
	if (this.languages.length > 0) {
		this.setAvailableLanguages(this.languages, true);
	}
	if(this.languages.available && this.languages.available.length > 0){
		this.setAvailableLanguages(this.languages.available, true);
	}
	if (this.useUrlLanguages) {
		languages = this.getUrlLanguages(this.urlLanguagesParameter);
		if (languages.length > 0) { this.setAvailableLanguages(languages, true); }
	}
	if (this.removeLanguages.length > 0) {
		this.removeAvailableLanguages(this.removeLanguages);
	}
	if (this.removeIncomplete) {
		this._removeIncompleteLanguages();
	}
	// set the language to use (order: status, profile, setting, browser, url, language setting)
	this.setLanguageToDefault();
	if (this.usePlayerLanguage) { 
		language = tgfStatus.getPreferencesData().language; 
		if (!this.languageAvailable(language)) { language = undefined; }
	}
	if (language === undefined && this.usePlayerLanguage) {
		language = tgfProfile.language;
		if (!this.languageAvailable(language)) { language = undefined; }
	}
	if (language === undefined && this.initialLanguage) {
		language = this.initialLanguage;
		if (!this.languageAvailable(language)) { language = undefined; }
	}
	if (language === undefined && this.useBrowserLanguage) {
		language = this.getBrowserLanguage();
		if (!this.languageAvailable(language)) { language = undefined; }
	}
	if (language !== undefined) {
		this.setLanguage(language);
	}
};

// Set a number of properties of the graphics object
TGFDictionary.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};


// ***************************************
// The dictionary
// ***************************************

// Adds a dictionary
TGFDictionary.prototype.addDictionary = function (dictionary) {
	"use strict";
	var language, key;
	if (typeof dictionary !== "object") { return; }
	for (language in dictionary) {
		if (dictionary.hasOwnProperty(language)) {
			if (!this.theDictionaries[language]) { this.theDictionaries[language] = {}; }
			for (key in dictionary[language]) {
				if (dictionary[language].hasOwnProperty(key)) {
					this.theDictionaries[language][key] = dictionary[language][key];
				}
			}
		}
	}
};

// Adds a number of dictionaries
TGFDictionary.prototype.addDictionaries = function (dictionaries) {
	"use strict";
	var i;
	dictionaries = [].concat(dictionaries);			// Such that it also works for a single value
	for (i = 0; i < dictionaries.length; i += 1) {
		this.addDictionary(dictionaries[i]);
	}
};

// Replaces the dictionary
TGFDictionary.prototype.replaceDictionary = function (dictionary) {
	"use strict";
	this.theDictionaries = {};
	this.addDictionary(dictionary);
};


// ***************************************
// The languages
// ***************************************

// Set all available languages in the dictionary
TGFDictionary.prototype.setAllAvailableLanguages = function() {
	"use strict";
	var language;
	this.availableLanguages = [];
	for (language in this.theDictionaries) {
		if (this.theDictionaries.hasOwnProperty(language)) {
			this.availableLanguages.push(language);
		}
	}
	// Make sure it always contains an entry
	if (this.availableLanguages.length === 0) {
		this.availableLanguages.push("en-us");
	}
};

// Set the array of available languages
TGFDictionary.prototype.setAvailableLanguages = function(languages, checkExist) {
	"use strict";
	this.availableLanguages = [];
	this.addAvailableLanguages(languages, checkExist);
	// Make sure it always contains an entry
	if (this.availableLanguages.length === 0) {
		this.availableLanguages.push("en-us");
	}
};

// Add the languages in the array to the available languages
TGFDictionary.prototype.addAvailableLanguages = function(languages, checkExist) {
	"use strict";
	var i, language;
	if (checkExist === undefined) { checkExist = true; }
	languages = [].concat(languages);				// Such that it also works for a single value
	for (i = 0; i < languages.length; i += 1) {
		language = languages[i].toLowerCase();
		if (this.availableLanguages.indexOf(language) >= 0) { continue; }	
		if (!checkExist || this.theDictionaries[language] !== undefined) {
			this.availableLanguages.push(language);
		}
	}
};

// Remove the languages in the array from the available languages
TGFDictionary.prototype.removeAvailableLanguages = function(languages) {
	"use strict";
	var i, ind, language;
	languages = [].concat(languages);				// Such that it also works for a single value
	for (i = 0; i < languages.length; i += 1) {
		language = languages[i].toLowerCase();
		ind = this.availableLanguages.indexOf(language);
		if (ind >= 0) {
			this.availableLanguages.splice(ind, 1);
		}
	}
	// Make sure it always contains an entry
	if (this.availableLanguages.length === 0) {
		this.availableLanguages.push("en-us");
	}
};

// Get a copy of the array of available languages
TGFDictionary.prototype.getAvailableLanguages = function() {
	"use strict";
	return this.availableLanguages.slice(0);
};

// Returns whether the language is available
TGFDictionary.prototype.languageAvailable = function(languageKey) {
	"use strict";
	if (!languageKey) { return false; } 
	languageKey = languageKey.toLowerCase();
	return this.availableLanguages.indexOf(languageKey) >= 0;
};

// Set the current language to the default one (the first)
TGFDictionary.prototype.setLanguageToDefault = function() {
	"use strict";
	if (this.availableLanguages.length === 0) { return; }
	this.setLanguage(this.availableLanguages[0]);
};

// Set the current language to use
TGFDictionary.prototype.setLanguage = function(languageKey) {
	"use strict";
	if (!languageKey) { return; } 
	languageKey = languageKey.toLowerCase();
	if (this.currentLanguage === languageKey) { return; }
	if (this.availableLanguages.indexOf(languageKey) === -1) {
		// failed to find language, try en-us
		if(this.availableLanguages.indexOf('en-us') === -1){
			// EN-US is somehow unavailable, return
			return;
		}
		this.setLanguage('en-us');
		return;
	}
	this.currentLanguage = languageKey;
	tbGame.addSpecial("languageSet", languageKey);			// Send a special event to everybody
};

// Get the current language
TGFDictionary.prototype.getLanguage = function() {
	"use strict";
	return this.currentLanguage;
};

// Get the browser language (when it is in the available languages)
TGFDictionary.prototype.getBrowserLanguage = function() {
	"use strict";
	var i, j, browserLanguages, language;
	browserLanguages = navigator["languages"] || [navigator["language"] || navigator["userLanguage"]];
	for(i = 0; i < browserLanguages.length; i += 1){
		if (typeof browserLanguages[i] !== "string") { continue; }
		language = browserLanguages[i].toLowerCase();
		for (j = 0; j < this.availableLanguages.length; j += 1) {
			if (this.availableLanguages[j].search(language) >= 0) {  // Also true when it is a sub-string, e.g. en will match en-us
				return this.availableLanguages[j];
			}
		}
	}
	return undefined;
};

// Get the url parameter languages in an array
TGFDictionary.prototype.getUrlLanguages = function(urlParameter) {
	"use strict";
	var result = [],
		urlParams = tgfFunctions.getUrlParameters();
	if (typeof urlParams[urlParameter] === "string") {
		result = urlParams[urlParameter].toLowerCase().split("+");
	}
	return result;
};


// ***************************************
// Checking whether all keys exist in all languages
// ***************************************

// Returns whether a language contains all keys
TGFDictionary.prototype._checkLanguage = function(languageKey) {
	"use strict";
	var dictionary, language, key;
	if (languageKey === undefined) { languageKey = this.currentLanguage; }
	languageKey = languageKey.toLowerCase();
	// Find the dictionary, if it exists
	dictionary = this.theDictionaries[languageKey];
	if (dictionary === undefined) { return false; }
	// Find all keys in all languages and check whether they exist in current language
	for (language in this.theDictionaries) {
		if (this.theDictionaries.hasOwnProperty(language)) {
			for (key in this.theDictionaries[language]) {
				if (this.theDictionaries[language].hasOwnProperty(key)) {
					if (dictionary[key] === undefined) { return false; }
				}
			}
		}
	}
	// Everything OK
	return true;
};

// Returns all incomplete languages (with missing keys) in an array
TGFDictionary.prototype._getIncompleteLanguages = function() {
	"use strict";
	var result = [], language;
	for (language in this.theDictionaries) {
		if (this.theDictionaries.hasOwnProperty(language)) {
			if (!this._checkLanguage(language)) { result.push(language); }
		}
	}
	return result;
};

// Remove all incomplete languages
TGFDictionary.prototype._removeIncompleteLanguages = function() {
	"use strict";
	var i, languages = this._getIncompleteLanguages();
	this.removeAvailableLanguages(languages);
	// Report this in test mode
	if (testMode) {
		for (i = 0; i < languages.length; i += 1) {
			console.log("Removed incomplete language: " + languages[i]);
		}
	}
};


// ***************************************
// The keys
// ***************************************

// Returns whether the key exists in the dictionary
TGFDictionary.prototype.keyExists = function(key, languageKey) {
	"use strict";
	var dictionary, text;
	if (languageKey === undefined) { languageKey = this.currentLanguage; }
	languageKey = languageKey.toLowerCase();
	// Find the dictionary, if it exists
	dictionary = this.theDictionaries[languageKey];
	if (dictionary === undefined) { return false; }
	// Find the key if it exists
	text = dictionary[key];
	return text !== undefined;
};

// Get a text from the dictionary
TGFDictionary.prototype.getText = function(key, defaultText, languageKey) {
	"use strict";
	var dictionary, text, subStringsToReplace, replacement, i, touch;
	if (languageKey === undefined) { languageKey = this.currentLanguage; }
	languageKey = languageKey.toLowerCase();
	if (defaultText === undefined) { defaultText = "< UNDEFINED: " + key + ">"; }
	// Find the dictionary, if it exists
	dictionary = this.theDictionaries[languageKey];
	if (dictionary === undefined) { return defaultText; }
	// Find the key if it exists
	text = dictionary[key];
	if (text === undefined) { return defaultText; }
	// Do replacements, when required
	subStringsToReplace = text.match(/#touch\{.*\}\s*\{.*\}/g);
	if (subStringsToReplace){
		touch = tbBrowser.features.tablet || tbBrowser.features.mobile;
		for (i = 0; i < subStringsToReplace.length; i += 1) {
			replacement = touch ? subStringsToReplace[i].match(/\{[^}]*\}/g)[1] : subStringsToReplace[i].match(/\{[^}]*\}/g)[0];
			replacement = replacement.substring(1, replacement.length - 1);
			text = text.replace(subStringsToReplace[i], replacement);
		}
	}
	return text;
};

// ***************************************
// Names and flags
// ***************************************

// Get the flag for a language
TGFDictionary.prototype.getLanguageFlag = function(languageKey) {
	"use strict";
	switch (languageKey) {
		case "nl-nl": return s_tgf_flag_nl;
		case "en-us": return s_tgf_flag_us;
		case "en-gb": return s_tgf_flag_gb;
		case "de-de": return s_tgf_flag_de;
		case "fr-fr": return s_tgf_flag_fr;
		case "pt-br": return s_tgf_flag_br;
		case "es-es": return s_tgf_flag_es;
		case "tr-tr": return s_tgf_flag_tr;
		case "ru-ru": return s_tgf_flag_ru;
		case "ar-eg": return s_tgf_flag_ar;
		case "ko-kr": return s_tgf_flag_kr;
		default: return s_tgf_flag_unknown;
	}
};

// Get the name for a language
TGFDictionary.prototype.getLanguageName = function(languageKey) {
	"use strict";
	switch (languageKey) {
		case "nl-nl": return "Nederlands";
		case "en-us": return "English (US)";
		case "en-gb": return "English (GB)";
		case "de-de": return "Deutsch";
		case "fr-fr": return "Franais";
		case "pt-br": return "Portugus do Brasil";
		case "es-es": return "Espaol";
		case "tr-tr": return "Trke";
		case "ru-ru": return "";
		case "ar-eg": return "";
		case "ko-kr": return "";
		default: return "<UNKNOWN>";
	}
};

// ***************************************
// Create the default version
// ***************************************

var tgfDictionary = new TGFDictionary();

//******************************************************
//*****    Script Resource: TGFStorage
//******************************************************

// ***************************************
//TGFStorage
//
// This object class deals with storing data. It uses both local
// storage and, if available, some form of remote storage. 
// Initially only local storage is supported.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 29-6-2015
// ***************************************

// Directives for jslint
/*global testMode, defaultRandom */
/*global tgfFunctions, tgfSettings, tgfProfile */
/*global window */

tgfSettings.storageDefaults = {
		remote: "none",							// Method to use for remote storage of data ("none" or ???)
		encode: "hex",							// Method for encoding the data before storing it ("none" or "hex")
		encodeInTestMode: false,				// Do also encode when in test more
		version: 1,								// Version of the storage data
		seperatePerTheme: true,					// Whether data is stored separately per theme
		seperatePerClient: true,				// Whether data is stored separately per client
		autoLoadInterval: 0,					// Interval between automatic loading of data (0 = no automatic loading)
		autoSaveInterval: 5						// Interval between automatic saving of data (0 = no automatic saving)
	};
	
	
// The constructor
var TGFStorage = function (name) {
	"use strict";
	this.name = name === undefined ? "storage" : name;
	// Initialize the data
	this.timeStamp = 0;						// Last date something changed (seconds since 1970)
	this.data = {};							// The actual data to be stored
	this.dataChanged = false;				// Whether the data was changed
};


// ***************************************
// Initialization
// ***************************************

// Initialize the storage (this can be asynchronous)
TGFStorage.prototype.initialize = function(settings, onSuccess, onFail) {
	"use strict";
	var self = this;
	// Initialize the settings
	this._setProperties(tgfSettings.storageDefaults);
	this._setProperties(settings);
	this.busyLoading = false;				// Whether busy loading data from remote
	this.busySaving = false;				// Whether busy saving data to remote
	this.localAvailable = false;			// Whether local storage is available
	this.remoteAvailable = false;			// Whether remote storage is available
	this.synchronous = true;				// Whether saving and loading is synchronous
	this.loadComplete = true;				// Whether the last load action was successfully completed
	this.loadFailed = false;				// Whether the last load action failed
	this.saveComplete = true;				// Whether the last save action was successfully completed
	this.saveFailed = false;				// Whether the last save action failed
	this.initComplete = false;				// Whether initialization was successfully completed
	this.initFailed = false;				// Whether initialization failed
	// Check whether JSON stringify is supported
	if (!JSON || !JSON.stringify) {
		this.initFailed = true;
		return;
	}
	// Initialize the local storage
	try {
		this.localAvailable = window["localStorage"] !== undefined;
	} catch (error) {
		this.localAvailable = false;
	}

	// Initialize the remote storage
	switch(this.remote) {
		case "none": this.methodRemote = undefined; break;
	}
	this.remoteAvailable = this.methodRemote !== undefined;
	if (tgfProfile.id) { this.remoteAvailable = false; }
	if (this.remoteAvailable) {
		this.synchronous = this.methodRemote.synchronous;
		this.methodRemote.initialize(
			function() { 
					if (onSuccess) { onSuccess(); }
					self.initComplete = true; 
				}, 
			function() { 
					if (onFail) { onFail(); }
					self.initFailed = true; 
					self.remoteAvailable = false;
				}
		);
	} else {
		this.initComplete = true;
	}
	// Deal with automatic loading and saving
	this.setAutoLoadInterval(this.autoLoadInterval);
	this.setAutoSaveInterval(this.autoSaveInterval);
};

// Update the system when the client id changed (e.g. due to logging in)
TGFStorage.prototype.updateId = function(newMethod) {
	"use strict";
	//TODO: Handle this, probably reinitializing the remote method
};

// Sets the automatic load interval in seconds (<=0 is don't load automatically)
TGFStorage.prototype.setAutoLoadInterval = function(interval) {
	"use strict";
	var self = this;
	// Clear the old timer, if any
	if (this.autoLoadTimer !== undefined) {
		window.clearInterval(this.autoLoadTimer);
	}
	// Set the new timer, if required
	this.autoLoadInterval = interval;
	if (this.autoLoadInterval > 0) {
		this.autoLoadTimer = window.setInterval(
			function() { TGFStorage.prototype.loadData.call(self); },		
			1000 * this.autoLoadInterval
		);
	}
};

// Sets the automatic save interval in seconds (<=0 is don't save automatically)
TGFStorage.prototype.setAutoSaveInterval = function(interval) {
	"use strict";
	var self = this;
	// Clear the old timer, if any
	if (this.autoSaveTimer !== undefined) {
		window.clearInterval(this.autoSaveTimer);
	}
	// Set the new timer, if required
	this.autoSaveInterval = interval;
	if (this.autoSaveInterval > 0) {
		this.autoSaveTimer = window.setInterval(
			function() { TGFStorage.prototype.saveData.call(self); },		
			1000 * this.autoSaveInterval
		);
	}
};


// ***************************************
// Internal methods
// ***************************************

// Set a number of properties
TGFStorage.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};


// ***************************************
// Dealing with keys and data
// ***************************************

// Encode in hex format with a simple shift (not meant to be secure but just to make it harder)
TGFStorage.prototype._hexEncode = function(key, str) {
	"use strict";
	var code, i, result;
	result = ("000" + key.toString(16)).slice(-4);
	for (i = 0; i < str.length; i += 1) {
		code = str.charCodeAt(i);
		code += i * key;
		code = code % 0xFFFF;
		result += ("000" + code.toString(16)).slice(-4);
	}
	return result;
};

// Decode from hex format
TGFStorage.prototype._hexDecode = function(str) {
	"use strict";
	var i, key, code, result = "", hexes = str.match(/.{1,4}/g) || [];
	key = parseInt(hexes[0], 16);
	for (i = 1; i < hexes.length; i += 1) {
		code = parseInt(hexes[i], 16);
		code -= (i-1) * key;
		code = ((code % 0xFFFF) + 0xFFFF) % 0xFFFF;
		result += String.fromCharCode(code);
	}
	return result;
};

// Returns the storage key string based on the name
TGFStorage.prototype._createKey = function () {
	"use strict";
	var key = "TG_";
	key += this.version + "_";
	if (tgfProfile.id) {
		key += tgfProfile.id + "_";
	} else {
		key += "anonymous_";
	}
	if (tgfSettings.game && tgfSettings.game.id) {
		key += tgfSettings.game.id + "_";
	}
	if (this.seperatePerTheme && tgfSettings.theme && tgfSettings.theme.id) {
		key += tgfSettings.theme.id + "_";
	}
	if (this.seperatePerClient && tgfSettings.client && tgfSettings.client.id) {
		key += tgfSettings.client.id + "_";
	}
	key += this.name;
	if (!testMode || this.encodeInTestMode) {
		switch (this.encode) {
			case "hex": key = this._hexEncode(12345, key); break;
		}
	}
	return key;
};

// Returns the storage data string for the data
TGFStorage.prototype._encodeData = function () {
	"use strict";
	var result = JSON.stringify( {
            "timeStamp": this.timeStamp,
            "data": JSON.stringify(this.data)
        } );
	if (!testMode || this.encodeInTestMode) {
		switch (this.encode) {
			case "hex": result = this._hexEncode(defaultRandom.iRandomRange(10000, 20000), result); break;
		}
	}
	return result;
};

// Processing data retrieved from local or remote storage
TGFStorage.prototype._processData = function (data) {
	"use strict";
	var obj;	
	if (!data) { return; }
	if (!testMode || this.encodeInTestMode) {
		switch (this.encode) {
			case "hex": data = this._hexDecode(data); break;
		}
	}
	obj = JSON.parse(data);
	if (obj["timeStamp"] >= this.timeStamp) {
		this.timeStamp = obj["timeStamp"];
		this.data = JSON.parse(obj["data"]);
		this.dataChanged = false;
	}
};


// ***************************************
// Fast methods for simple data
// ***************************************


// Setting the value for the key in a simple way
TGFStorage.prototype.setValueSimple = function (key, value) {
	"use strict";
	// Change the data when it is different
	if (this.data[key] !== value) {
		this.timeStamp = (new Date()).getTime();
		this.data[key] = value;
		this.dataChanged = true;
	}
};

// Getting the value for key in a simple way
TGFStorage.prototype.getValueSimple = function(key) {
	"use strict";
	return this.data[key];
};


// ***************************************
// Setting and retrieving data
// ***************************************

// Check whether a key exists
TGFStorage.prototype.keyExists = function (key) {
	"use strict";
	return this.data[key] !== undefined;
};

// Check whether a sub key exists
TGFStorage.prototype.subKeyExists = function (key, subkey) {
	"use strict";
	if (typeof this.data[key] !== "object") { return false; }
	return this.data[key][subkey] !== undefined;
};

// Setting all the data
TGFStorage.prototype.setData = function (value, save, onSuccess, onFail, noCopy) {
	"use strict";
	// Change the data when it is different
	if (!tgfFunctions.equalValues(this.data, value)) {
		this.timeStamp = (new Date()).getTime();
		if (noCopy) {
			this.data = value;
		} else {
			this.data = tgfFunctions.copyValue(value);
		}
		this.dataChanged = true;
	}
	// Save the data when required
	if (save && this.dataChanged) {
		this.saveData(onSuccess, onFail, false);
	}
};

// Setting the value for the key
TGFStorage.prototype.setValue = function (key, value, save, onSuccess, onFail, noCopy) {
	"use strict";
	// Change the data when it is different
	if (!tgfFunctions.equalValues(this.data[key], value)) {
		this.timeStamp = (new Date()).getTime();
		if (noCopy) {
			this.data[key] = value;
		} else {
			this.data[key] = tgfFunctions.copyValue(value);
		}
		this.dataChanged = true;
	}
	// Save the data when required
	if (save && this.dataChanged) {
		this.saveData(onSuccess, onFail, false);
	}
};

// Setting the value for a sub key
TGFStorage.prototype.setSubValue = function (key, subkey, value, save, onSuccess, onFail, noCopy) {
	"use strict";
	// Change the data when it is different
	if (typeof this.data[key] !== "object") { return; }
	if (!tgfFunctions.equalValues(this.data[key][subkey], value)) {
		this.timeStamp = (new Date()).getTime();
		if (noCopy) {
			this.data[key][subkey] = value;
		} else {
			this.data[key][subkey] = tgfFunctions.copyValue(value);
		}
		this.dataChanged = true;
	}
	// Save the data when required
	if (save && this.dataChanged) {
		this.saveData(onSuccess, onFail, false);
	}
};

// Set multiple data values
TGFStorage.prototype.setValues = function(values, save, onSuccess, onFail, noCopy) {
	"use strict";
	var key;
	if (typeof values !== "object") { return; }
	// Change the data when it is different
	for (key in values) {
		if (values.hasOwnProperty(key)) {
			if (!tgfFunctions.equalValues(this.data[key], values[key])) {
				this.timeStamp = (new Date()).getTime();
				if (noCopy) {
					this.data[key] = values[key];
				} else {
					this.data[key] = tgfFunctions.copyValue(values[key]);
				}
				this.dataChanged = true;
			}
		}
	}
	// Save the data when required
	if (save && this.dataChanged) {
		this.saveData(onSuccess, onFail, false);
	}
};

// Getting a copy of the data
TGFStorage.prototype.getData = function(noCopy) {
	"use strict";
	if (noCopy) {
		return this.data;
	} else {
		return tgfFunctions.copyValue(this.data);
	}
};

// Getting the value for key
TGFStorage.prototype.getValue = function(key, noCopy) {
	"use strict";
	if (noCopy) {
		return this.data[key];
	} else {
		return tgfFunctions.copyValue(this.data[key]);
	}
};

// Getting the value for a sub key
TGFStorage.prototype.getSubValue = function(key, subkey, noCopy) {
	"use strict";
	if (typeof this.data[key] !== "object") { return undefined; }
	if (noCopy) {
		return this.data[key][subkey];
	} else {
		return tgfFunctions.copyValue(this.data[key][subkey]);
	}
};

// Loading all the data
TGFStorage.prototype.loadData = function (onSuccess, onFail, force) {
	"use strict";
	var self = this, data, key;
	// Check whether we are loading or saving
	if (this.busyLoading || this.busySaving) {
		if (onFail) { onFail(); }
		return;
	}
	// If force, reset the current timestamp
	if (force) { this.timeStamp = 0; }
	// Create the key
	key = this._createKey();
	// Load the local data
	if (this.localAvailable) {
		try{			
			data = window.localStorage.getItem(key);
			this._processData(data);
		}
		catch(e){
			
		}
	}
	// Load the remote data
	if (this.remoteAvailable) {
		this.loadComplete = false;
		this.loadFailed = false;
		this.busyLoading = true;
		this.methodRemote.loadData(key, 
			function(data) { TGFStorage.prototype._processData.call(self, data); },
			function() { self.busyLoading = false; this.loadComplete = true; if (onSuccess) { onSuccess(); } },
			function() { self.busyLoading = false; this.loadFailed = true; if (onFail) { onFail(); } }
		);
	} else {
		this.loadComplete = true;
		if (onSuccess) { onSuccess(); }
	}	
};

// Saving all the data
TGFStorage.prototype.saveData = function(onSuccess, onFail, force) {
	"use strict";
	var self = this, data, key;
	// Check whether there is anything to save
	if (!this.dataChanged  && !force) { return; }
	// Check whether we are loading or saving
	if (this.busyLoading || this.busySaving) {
		if (onFail) { onFail(); }
		return;
	}
	// Encode the data
	key = this._createKey();
	data = this._encodeData();
	// Save local
	if (this.localAvailable) {
		try{			
			window.localStorage.setItem(key, data);
		}
		catch(e){
			
		}
	}
	// Save external
	if (this.remoteAvailable) {
		this.saveComplete = false;
		this.saveFailed = false;
		this.busySaving = true;
		this.methodRemote.saveData(key, data,
			function() { self.busySaving = false; this.saveComplete = true; if (onSuccess) { onSuccess(); } },
			function() { self.busySaving = false; this.saveFailed = true; if (onFail) { onFail(); } }
		);
	} else {
		this.saveComplete = true;
		if (onSuccess) { onSuccess(); }
	}	
	// Ready
	this.dataChanged = false;
};

/*
// ***************************************
// A template for a method for remote storage
// ***************************************

// The constructor
var TGFSaveRemoteTemplate = function(storage) {
	"use strict";
	// TODO:
	this.storage = storage;
	this.synchronous = false;
};

// Initialize the remote method
TGFSaveRemoteTemplate.prototype.initialize = function(onSuccess, onFail) {
	"use strict";
	// TODO: 
};


// Saving data (key and data are string).
TGFSaveRemoteTemplate.prototype.saveData = function(key, data, onSuccess, onFail) {
	"use strict";
	// TODO: 
	// If still initializing it should wait until that is finished and then save the data
};

// Loading data. When ready, process data is called with the data.
TGFSaveRemoteTemplate.prototype.loadData = function(key, processData, onSuccess, onFail) {
	"use strict";
	// TODO:
	// If still initializing it should wait until that is finished and then load the data
};
*/
//******************************************************
//*****    Script Resource: tgfProfile
//******************************************************

// ***************************************
// tgfProfile
//
// This object deals with the player profile. 
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 26-6-2015
// ***************************************

// Directives for jslint
/*global tgfFunctions, tgfSettings */

// TODO: call tgfStatus.updateId when the profile use id changes.

tgfSettings.profileDefaults = {
		name: "Anonymous",						// The name of the player
		id: undefined,							// id of the player in the profile (undefined if there is no unique id)
		avatarUrl: "",							// The avatar url
		avatar: undefined,						// The avatar image (or surface)
		language: undefined						// The preferred language
	};
	

// The constructor
var TGFProfile = function () {
	"use strict";
};


// ***************************************
// Initialization
// ***************************************

// Initialize the profile
TGFProfile.prototype.initialize = function (settings) {
	"use strict";
	this._setProperties(tgfSettings.profileDefaults);
	this._setProperties(settings);
};

// Set a number of properties
TGFProfile.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

// ***************************************
// Changing the profile
// ***************************************

// Set a number of profile values
TGFProfile.prototype.setValues = function(values) {
	"use strict";
	var key;
	if (typeof values !== "object") { return; }
	for (key in values) {
		if (values.hasOwnProperty(key)) { this[key] = values[key]; }
	}
};


// ***************************************
// Create the default version
// ***************************************

var tgfProfile = new TGFProfile();

//******************************************************
//*****    Script Resource: tgfStatus
//******************************************************

// ***************************************
// tgfStatus
//
// This object deals with the player status. 
// It uses and instance of TGFStorage to store and retrieve the data
//
// Copyright 2015-2016 Tingly Games B.V.
// Last Changed: 11-1-2016
// ***************************************

// Directives for jslint
/*global tgfFunctions, tgfSettings, TGFStorage */
/*global window */

tgfSettings.statusDefaults = {
		preferences: {
		},
		version: {
		},
		global: {
			totalPlayed: 0,
			totalWon: 0,
			totalLost: 0,
			lastLevelPlayed: -1,
			lastLevelWon: -1,
			lastLevelLost: -1,
			maxLevelPlayed: -1,
			maxLevelWon: -1,
			maxLevelLost: -1,
			lastModePlayed: -1,
			lastModeWon: -1,
			lastModeLost: -1,
			maxModePlayed: -1,
			maxModeWon: -1,
			maxModeLost: -1,
			sumMaxScore: 0,
			sumMaxTime: 0,
			sumMaxStars: 0,
			sumMaxMoves: 0
		},
		play: {
			unlocked: false,
			totalPlayed: 0,
			totalWon: 0,
			totalLost: 0,
			lastScore: 0,
			sumScore: 0,
			minScore: 0,
			maxScore: 0,
			lastTime: 0,
			sumTime: 0,
			minTime: 0,
			maxTime: 0,
			lastStars: 0,
			sumStars: 0,
			minStars: 0,
			maxStars: 0,
			lastMoves: 0,
			sumMoves: 0,
			minMoves: 0,
			maxMoves: 0
		},
		additional: {				// Must be string properties!!!
		}
};
	

// The constructor
var TGFStatus = function () {
	"use strict";
};


// ***************************************
// Initialization
// ***************************************

// Initialize the status (this can be asynchronous)
TGFStatus.prototype.initialize = function(settings, status, onSuccess, onFail) {
	"use strict";
	var self = this;
	// Initialize the storage object and set the default data
	this.storage = new TGFStorage("tgfStatus");
	this.storage.initialize(settings);
	// Create the default data values, also from status
	this.setPreferencesData(tgfFunctions.mergeValues(tgfSettings.statusDefaults.preferences, status.preferences));
	this.setVersionData(tgfFunctions.mergeValues(tgfSettings.statusDefaults.version, status.version));
	this.setGlobalData(tgfFunctions.mergeValues(tgfSettings.statusDefaults.global, status.global));
	this.setAdditionalData(tgfFunctions.mergeValues(tgfSettings.statusDefaults.additional, status.additional));
	this.playDefaults = tgfFunctions.mergeValues(tgfSettings.statusDefaults.play, status.play);
	// Create the timer to check whether initialization is ready
	this.initComplete = false;
	this.initFailed = false;
	this.initOnSuccess = onSuccess;
	this.initOnFail = onFail;
	this.initState = 0;
	this.initTimer = window.setInterval(
		function() { TGFStatus.prototype.checkInitState.call(self); },		
		50
	);
};

// Check the initialization state
TGFStatus.prototype.checkInitState = function() {
	"use strict";
	if (this.initState === 0) {				// Waiting for storage to be initialized
		if (this.storage.initComplete) {
			this.loadStatus(true);
			this.initState = 1;
		} else if (this.storage.initFailed) {
			this.initFailed = true;
			this.initState = 2;
		}
	}
	if (this.initState === 1) {				// Waiting for status data to load data
		if (this.loadComplete) {
			this.initComplete = true;
			this.initState = 2;
		} else if (this.loadFailed) {
			this.initFailed = true;
			this.initState = 2;
		}
	}
	if (this.initState === 2) {				// Ready
		window.clearInterval(this.initTimer);
		if (this.initComplete && this.initOnSuccess) { this.initOnSuccess(); }
		if (this.initFailed && this.initOnFail) { this.initOnFail(); }
	}
};

// Update the storage when the client id changed (e.g. due to logging in) (called by tgfProfile)
TGFStatus.prototype.updateId = function(newMethod) {
	"use strict";
	this.storage.updateId(newMethod);
};


// ***************************************
// Loading and saving the status data
// ***************************************

// Load the status data
TGFStatus.prototype.loadStatus = function(force) {
	"use strict";
	var self = this;
	this.loadComplete = false;
	this.loadFailed = false;
	this.storage.loadData(
		function() { self.loadComplete = true; }, 
		function() { self.loadFailed = true; },
		force );
};

// Save the status data
TGFStatus.prototype.saveStatus = function(force) {
	"use strict";
	var self = this;
	this.saveComplete = false;
	this.saveFailed = false;
	this.storage.saveData(
		function() { self.saveComplete = true; }, 
		function() { self.saveFailed = true; },
		force );
};


// ***************************************
// Getting and setting data
// ***************************************

// Get the preference data in an object
TGFStatus.prototype.getPreferencesData = function() {
	"use strict";
	return {
		language: this.storage.getValueSimple("Pla"),
		effectsMuted: this.storage.getValueSimple("Pem"),
		effectsGain: this.storage.getValueSimple("Peg"),
		musicMuted: this.storage.getValueSimple("Pmm"),
		musicGain: this.storage.getValueSimple("Pmg")
	};
};

// Set the preference data from an object
TGFStatus.prototype.setPreferencesData = function(data, save) {
	"use strict";
	if (data.language !== undefined) { this.storage.setValueSimple("Pla", data.language); }
	if (data.effectsMuted !== undefined) { this.storage.setValueSimple("Pem", data.effectsMuted); }
	if (data.effectsGain !== undefined) { this.storage.setValueSimple("Peg", data.effectsGain); }
	if (data.musicMuted !== undefined) { this.storage.setValueSimple("Pmm", data.musicMuted); }
	if (data.musicGain !== undefined) { this.storage.setValueSimple("Pmg", data.musicGain); }
	if (save) { this.saveStatus(false); }
};

// Get the version data in an object
TGFStatus.prototype.getVersionData = function() {
	"use strict";
	return {
		gameId: this.storage.getValueSimple("Vgi"),
		themeId: this.storage.getValueSimple("Vti"),
		clientId: this.storage.getValueSimple("Vci"),
		gameVersion: this.storage.getValueSimple("Vgv"),
		themeVersion: this.storage.getValueSimple("Vtv"),
		clientVersion: this.storage.getValueSimple("Vcv")
	};
};

// Set the version data from an object
TGFStatus.prototype.setVersionData = function(data, save) {
	"use strict";
	if (data.gameId !== undefined) { this.storage.setValueSimple("Vgi", data.gameId); }
	if (data.themeId !== undefined) { this.storage.setValueSimple("Vti", data.themeId); }
	if (data.clientId !== undefined) { this.storage.setValueSimple("Vci", data.clientId); }
	if (data.gameVersion !== undefined) { this.storage.setValueSimple("Vgv", data.gameVersion); }
	if (data.themeVersion !== undefined) { this.storage.setValueSimple("Vtv", data.themeVersion); }
	if (data.clientVersion !== undefined) { this.storage.setValueSimple("Vcv", data.clientVersion); }
	if (save) { this.saveStatus(false); }
};

// Get the global data in an object
TGFStatus.prototype.getGlobalData = function() {
	"use strict";
	return {
		totalPlayed: this.storage.getValueSimple("Gtp"),
		totalWon: this.storage.getValueSimple("Gtw"),
		totalLost: this.storage.getValueSimple("Gtl"),
		lastLevelPlayed: this.storage.getValueSimple("Gllp"),
		lastLevelWon: this.storage.getValueSimple("Gllw"),
		lastLevelLost: this.storage.getValueSimple("Glll"),
		maxLevelPlayed: this.storage.getValueSimple("Gmlp"),
		maxLevelWon: this.storage.getValueSimple("Gmlw"),
		maxLevelLost: this.storage.getValueSimple("Gmll"),
		lastModePlayed: this.storage.getValueSimple("Glmp"),
		lastModeWon: this.storage.getValueSimple("Glmw"),
		lastModeLost: this.storage.getValueSimple("Glml"),
		maxModePlayed: this.storage.getValueSimple("Gmmp"),
		maxModeWon: this.storage.getValueSimple("Gmmw"),
		maxModeLost: this.storage.getValueSimple("Gmml"),
		sumMaxScore: this.storage.getValueSimple("Gsms"),
		sumMaxTime: this.storage.getValueSimple("Gsmt"),
		sumMaxStars: this.storage.getValueSimple("Gsmr"),
		sumMaxMoves: this.storage.getValueSimple("Gsmm")
	};
};

// Set the global data from an object
TGFStatus.prototype.setGlobalData = function(data, save) {
	"use strict";
	if (data.totalPlayed !== undefined) { this.storage.setValueSimple("Gtp", data.totalPlayed); }
	if (data.totalWon !== undefined) { this.storage.setValueSimple("Gtw", data.totalWon); }
	if (data.totalLost !== undefined) { this.storage.setValueSimple("Gtl", data.totalLost); }
	if (data.lastLevelPlayed !== undefined) { this.storage.setValueSimple("Gllp", data.lastLevelPlayed); }
	if (data.lastLevelWon !== undefined) { this.storage.setValueSimple("Gllw", data.lastLevelWon); }
	if (data.lastLevelLost !== undefined) { this.storage.setValueSimple("Glll", data.lastLevelLost); }
	if (data.maxLevelPlayed !== undefined) { this.storage.setValueSimple("Gmlp", data.maxLevelPlayed); }
	if (data.maxLevelWon !== undefined) { this.storage.setValueSimple("Gmlw", data.maxLevelWon); }
	if (data.maxLevelLost !== undefined) { this.storage.setValueSimple("Gmll", data.maxLevelLost); }
	if (data.lastModePlayed !== undefined) { this.storage.setValueSimple("Glmp", data.lastModePlayed); }
	if (data.lastModeWon !== undefined) { this.storage.setValueSimple("Glmw", data.lastModeWon); }
	if (data.lastModeLost !== undefined) { this.storage.setValueSimple("Glml", data.lastModeLost); }
	if (data.maxModePlayed !== undefined) { this.storage.setValueSimple("Gmmp", data.maxModePlayed); }
	if (data.maxModeWon !== undefined) { this.storage.setValueSimple("Gmmw", data.maxModeWon); }
	if (data.maxModeLost !== undefined) { this.storage.setValueSimple("Gmml", data.maxModeLost); }
	if (data.sumMaxScore !== undefined) { this.storage.setValueSimple("Gsms", data.sumMaxScore); }
	if (data.sumMaxTime !== undefined) { this.storage.setValueSimple("Gsmt", data.sumMaxTime); }
	if (data.sumMaxStars !== undefined) { this.storage.setValueSimple("Gsmr", data.sumMaxStars); }
	if (data.sumMaxMoves !== undefined) { this.storage.setValueSimple("Gsmm", data.sumMaxMoves); }
	if (save) { this.saveStatus(false); }
};

// Get the play data in an object
TGFStatus.prototype.getPlayData = function(mode, level) {
	"use strict";
	var playStr;
	if (mode === undefined) { mode = 0; }
	if (level === undefined) { level = 0; }
	playStr = "M" + mode + "L" + level;
	if (!this.storage.keyExists(playStr + "ex")) {
		return tgfFunctions.copyValue(this.playDefaults);
	}
	return {
		unlocked: this.storage.getValueSimple(playStr + "un"),
		totalPlayed: this.storage.getValueSimple(playStr + "tp"),
		totalWon: this.storage.getValueSimple(playStr + "tw"),
		totalLost: this.storage.getValueSimple(playStr + "tl"),
		lastScore: this.storage.getValueSimple(playStr + "las"),
		sumScore: this.storage.getValueSimple(playStr + "sus"),
		minScore: this.storage.getValueSimple(playStr + "mis"),
		maxScore: this.storage.getValueSimple(playStr + "mas"),
		lastTime: this.storage.getValueSimple(playStr + "lat"),
		sumTime: this.storage.getValueSimple(playStr + "sut"),
		minTime: this.storage.getValueSimple(playStr + "mit"),
		maxTime: this.storage.getValueSimple(playStr + "mat"),
		lastStars: this.storage.getValueSimple(playStr + "lar"),
		sumStars: this.storage.getValueSimple(playStr + "sur"),
		minStars: this.storage.getValueSimple(playStr + "mir"),
		maxStars: this.storage.getValueSimple(playStr + "mar"),
		lastMoves: this.storage.getValueSimple(playStr + "lam"),
		sumMoves: this.storage.getValueSimple(playStr + "sum"),
		minMoves: this.storage.getValueSimple(playStr + "mim"),
		maxMoves: this.storage.getValueSimple(playStr + "mam")
	};
};

// Set the play data from an object
TGFStatus.prototype.setPlayData = function(mode, level, data, save) {
	"use strict";
	var playStr;
	if (mode === undefined) { mode = 0; }
	if (level === undefined) { level = 0; }
	playStr = "M" + mode + "L" + level;
	this.storage.setValueSimple(playStr + "ex", true);
	if (data.unlocked !== undefined) { this.storage.setValueSimple(playStr + "un", data.unlocked); }
	if (data.totalPlayed !== undefined) { this.storage.setValueSimple(playStr + "tp", data.totalPlayed); }
	if (data.totalWon !== undefined) { this.storage.setValueSimple(playStr + "tw", data.totalWon); }
	if (data.totalLost !== undefined) { this.storage.setValueSimple(playStr + "tl", data.totalLost); }
	if (data.lastScore !== undefined) { this.storage.setValueSimple(playStr + "las", data.lastScore); }
	if (data.sumScore !== undefined) { this.storage.setValueSimple(playStr + "sus", data.sumScore); }
	if (data.minScore !== undefined) { this.storage.setValueSimple(playStr + "mis", data.minScore); }
	if (data.maxScore !== undefined) { this.storage.setValueSimple(playStr + "mas", data.maxScore); }
	if (data.lastTime !== undefined) { this.storage.setValueSimple(playStr + "lat", data.lastTime); }
	if (data.sumTime !== undefined) { this.storage.setValueSimple(playStr + "sut", data.sumTime); }
	if (data.minTime !== undefined) { this.storage.setValueSimple(playStr + "mit", data.minTime); }
	if (data.maxTime !== undefined) { this.storage.setValueSimple(playStr + "mat", data.maxTime); }
	if (data.lastStars !== undefined) { this.storage.setValueSimple(playStr + "lar", data.lastStars); }
	if (data.sumStars !== undefined) { this.storage.setValueSimple(playStr + "sur", data.sumStars); }
	if (data.minStars !== undefined) { this.storage.setValueSimple(playStr + "mir", data.minStars); }
	if (data.maxStars !== undefined) { this.storage.setValueSimple(playStr + "mar", data.maxStars); }
	if (data.lastMoves !== undefined) { this.storage.setValueSimple(playStr + "lam", data.lastMoves); }
	if (data.sumMoves !== undefined) { this.storage.setValueSimple(playStr + "sum", data.sumMoves); }
	if (data.minMoves !== undefined) { this.storage.setValueSimple(playStr + "mim", data.minMoves); }
	if (data.maxMoves !== undefined) { this.storage.setValueSimple(playStr + "mam", data.maxMoves); }
	if (save) { this.saveStatus(false); }
};

// Get the additional data in an object
TGFStatus.prototype.getAdditionalData = function() {
	"use strict";
	return this.storage.getValue("Additional");
};

// Set the additional data from an object
TGFStatus.prototype.setAdditionalData = function(data, save) {
	"use strict";
	this.storage.setValue("Additional", data);
	if (save) { this.saveStatus(false); }
};


// ***************************************
// Changing status, saving corresponding data
// ***************************************

// Set the language
TGFStatus.prototype.setLanguage = function(language) {
	"use strict";
	var preferencesData = this.getPreferencesData();
	if (language !== undefined) { preferencesData.language = language; }
	// Now save it
	this.setPreferencesData(preferencesData);
	this.saveStatus(false);
};

// Set the audio data
TGFStatus.prototype.setAudio = function(effectsMuted, effectsGain, musicMuted, musicGain) {
	"use strict";
	var preferencesData = this.getPreferencesData();
	if (effectsMuted !== undefined) { preferencesData.effectsMuted = effectsMuted; }
	if (effectsGain !== undefined) { preferencesData.effectsGain = effectsGain; }
	if (musicMuted !== undefined) { preferencesData.musicMuted = musicMuted; }
	if (musicGain !== undefined) { preferencesData.musicGain = musicGain; }
	// Now save it
	this.setPreferencesData(preferencesData);
	this.saveStatus(false);
};

// Start a play
TGFStatus.prototype.startPlay = function(mode, level) {
	"use strict";
	var versionData = this.getVersionData(),
		globalData = this.getGlobalData(),
		playData = this.getPlayData(mode, level);
	this.theLevel = level === undefined ? 0 : level;
	this.theMode = mode === undefined ? 0 : mode;
	// Version information
	if (tgfSettings.game && tgfSettings.game.id) { versionData.gameId = tgfSettings.game.id; }
	if (tgfSettings.theme && tgfSettings.theme.id) { versionData.themeId = tgfSettings.theme.id; }
	if (tgfSettings.client && tgfSettings.client.id) { versionData.clientId = tgfSettings.client.id; }
	if (tgfSettings.game && tgfSettings.game.version) { versionData.gameVersion = tgfSettings.game.version; }
	if (tgfSettings.theme && tgfSettings.theme.version) { versionData.themeVersion = tgfSettings.theme.version; }
	if (tgfSettings.client && tgfSettings.client.version) { versionData.clientVersion = tgfSettings.client.version; }
	// Global information
	globalData.totalPlayed += 1;
	globalData.lastLevelPlayed = this.theLevel;
	globalData.maxLevelPlayed = Math.max(globalData.maxLevelPlayed, this.theLevel);
	globalData.lastModePlayed = this.theMode;
	globalData.maxModePlayed = Math.max(globalData.maxModePlayed, this.theMode);
	// Play information
	playData.totalPlayed += 1;
	// Now save it
	this.setVersionData(versionData);
	this.setGlobalData(globalData);
	this.setPlayData(mode, level, playData);
	this.saveStatus(false);
};

// End a play by winning
TGFStatus.prototype.endPlayWon = function(score, time, stars, moves) {
	"use strict";
	var globalData = this.getGlobalData(),
		playData = this.getPlayData(this.theMode, this.theLevel);
	if (score === undefined) { score = 0; }
	if (time === undefined) { time = 0; }
	if (stars === undefined) { stars = 0; }
	if (moves === undefined) { moves = 0; }
	// Global information
	globalData.totalWon += 1;
	globalData.lastLevelWon = this.theLevel;
	globalData.maxLevelWon = Math.max(globalData.maxLevelWon, this.theLevel);
	globalData.lastModeWon = this.theMode;
	globalData.maxModeWon = Math.max(globalData.maxModeWon, this.theMode);
	if (score > playData.maxScore) { globalData.sumMaxScore += score - playData.maxScore; }
	if (time > playData.maxTime) { globalData.sumMaxTime += time - playData.maxTime; }
	if (stars > playData.maxStars) { globalData.sumMaxStars += stars - playData.maxStars; }
	if (moves > playData.maxMoves) { globalData.sumMaxMoves += moves - playData.maxMoves; }	
	// Play information
	playData.totalWon += 1;
	playData.lastScore = score;
	playData.sumScore += score;
	playData.minScore = playData.totalWon === 1 ? score : Math.min(playData.minScore, score);
	playData.maxScore = playData.totalWon === 1 ? score : Math.max(playData.maxScore, score);
	playData.lastTime = time;
	playData.sumTime += time;
	playData.minTime = playData.totalWon === 1 ? time : Math.min(playData.minTime, time);
	playData.maxTime = playData.totalWon === 1 ? time : Math.max(playData.maxTime, time);
	playData.lastStars = stars;
	playData.sumStars += stars;
	playData.minStars = playData.totalWon === 1 ? stars : Math.min(playData.minStars, stars);
	playData.maxStars = playData.totalWon === 1 ? stars : Math.max(playData.maxStars, stars);
	playData.lastMoves = moves;
	playData.sumMoves += moves;
	playData.minMoves = playData.totalWon === 1 ? moves : Math.min(playData.minMoves, moves);
	playData.maxMoves = playData.totalWon === 1 ? moves : Math.max(playData.maxMoves, moves);	
	// Now save the data
	this.setGlobalData(globalData);
	this.setPlayData(this.theMode, this.theLevel, playData);
	this.saveStatus(false);
};

// End a play by losing
TGFStatus.prototype.endPlayLost = function() {
	"use strict";
	var globalData = this.getGlobalData(),
		playData = this.getPlayData(this.theMode, this.theLevel);
	// Global information
	globalData.totalLost += 1;
	globalData.lastLevelLost = this.theLevel;
	globalData.maxLevelLost = Math.max(globalData.maxLevelLost, this.theLevel);
	globalData.lastModeLost = this.theMode;
	globalData.maxModeLost = Math.max(globalData.maxModeLost, this.theMode);
	// Play information
	playData.totalLost += 1;
	// Now save the data
	this.setGlobalData(globalData);
	this.setPlayData(this.theMode, this.theLevel, playData);
	this.saveStatus(false);
};

// Unlock a level
TGFStatus.prototype.unlockPlay = function(mode, level) {
	"use strict";
	var playData = this.getPlayData(mode, level);
	playData.unlocked = true;
	// Now save the data
	this.setPlayData(mode, level, playData);
	this.saveStatus(false);
};


// ***************************************
// Create the default version
// ***************************************

var tgfStatus = new TGFStatus();

//******************************************************
//*****    Script Resource: tgfAnalytics
//******************************************************

// ***************************************
// tgfAnalytics
//
// This object deals with the gathering of analytics data.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 1-7-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbBrowser, testMode */
/*global tgfFunctions, tgfSettings, tgfConsole, tgfProfile, tgfMD5 */
/*global TGFAnalyticsGameAnalytics */
/*global console, window, document, XMLHttpRequest */

tgfSettings.analyticsDefaults = {
	// General settings
	providers: "none",						// Method to use for analytics of data ("none" or "gameAnalytics") (can be an array)
	version: "1",									// The version of the game under which to store the analytics
	localStorageKey: "analyticsUserId",				// The local storage key for storing the user id used for analytics (for all our games on the site)
	showDebug: true,								// Whether to show debug information in test mode
	externalDeviceInfo: {
		os: "ios",
		os_major: "ios 10.1",
		device: "unknown"
	},

	// Game Analytics settings
	gameAnalyticsBaseUrl: "https://api.gameanalytics.com/v2/",	// Basic url for game analytics
	gameAnalyticsGameKey: undefined,							// Game key as provided by game analytics
	gameAnalyticsSecretKey: undefined							// Secret key as provided by game analytics
};

// The constructor
var TGFAnalytics = function () {
	"use strict";
	this.active = false;
	this.initialized = false;

	//this.externalDeviceInfo = {};
};


// ***************************************
// Initialization
// ***************************************

// Initialize the analytics
TGFAnalytics.prototype.initialize = function(settings) {
	"use strict";
	var i, providers;
	// Initialize the settings
	this._setProperties(settings);
	this._setProperties(tgfSettings.analyticsDefaults);

	this.gameAnalyticsBaseUrl = "https://api.gameanalytics.com/v2/";

	this._timers = [];
	// Determine the user id (from profile, local storage, generate)
	this.userId = tgfProfile.userId;
	if (this.userId === undefined && window["localStorage"] !== undefined) {
		try{			
			this.userId = window.localStorage.getItem(this.localStorageKey);
		}
		catch(e){
			this.userId = tgfFunctions.generateGuid();
		}
	}
	if (this.userId === null || this.userId === undefined) {
		this.userId = tgfFunctions.generateGuid();
	}
	if (window["localStorage"] !== undefined) {
		try{			
			window.localStorage.setItem(this.localStorageKey, this.userId);
		}
		catch(e){
			
		}
	}
	// Determine the providers, creating an array of methods
	providers = [].concat(this.providers);
	this.methods = [];
	for (i = 0; i < providers.length; i += 1) {
		switch(providers[i]) {
			case "gameAnalytics": this.methods.push(new TGFAnalyticsGameAnalytics(this)); break;
		}
	}
	// Initialize the providers
	for (i = 0; i < this.methods.length; i += 1) {
		this.methods[i].initialize();
	}
	// Get going
	this.active = false;
	this.initialized = true;
};

// Set a number of properties
TGFAnalytics.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};


// ***************************************
// Starting and ending sessions
// ***************************************

// Start the session
TGFAnalytics.prototype.startSession = function() {
    "use strict";
	var i;
	// Check if we can start the session
	if	(this.active || !this.initialized) { return; }
    this.active = true;
	// Start the session for the methods
	for (i = 0; i < this.methods.length; i += 1) {
		this.methods[i].initSession(tgfSettings.game.id, tgfSettings.theme.id, tgfSettings.client.id, this.userId, this.version);
	}
	// Send start events through the methods
	for (i = 0; i < this.methods.length; i += 1) {
		this.methods[i].reportEventExt(undefined, undefined, undefined, "user");
	}
};

// End the session (this is probably never called as there is no way of knowing when the game ends)
TGFAnalytics.prototype.endSession = function() {
    "use strict";
	var i;
	// Check if we can end the session
	if	(!this.active || !this.initialized) { return; }
	// Send events through the methods
	for (i = 0; i < this.methods.length; i += 1) {
		this.methods[i].reportEventExt(undefined, undefined, 0, "session_end");
	}
	// End the session for the methods
	for (i = 0; i < this.methods.length; i += 1) {
		this.methods[i].endSession();
	}
	// Ready
    this.active = false;
};


// ***************************************
// Dealing with normal events
// ***************************************

// Report an extended event with the given category, subcategory, name, and value
TGFAnalytics.prototype.reportEventExt = function(category, subcategory, value, name) {
	"use strict";
	var i;
	// Check if we can send the event
	if	(!this.active || !this.initialized) { return; }
	// Send events through the methods
	for (i = 0; i < this.methods.length; i += 1) {
		this.methods[i].reportEventExt(category, subcategory, value, name);
	}
};

// Report a simple event with just a name and value
TGFAnalytics.prototype.reportEvent = function(name, value) {
	"use strict";
	var _value = value;
	if(_value === undefined || _value === null) {
		_value = 0;
	}

	this.reportEventExt(name, "", _value, "design");
};

// Report an error message with a severity
TGFAnalytics.prototype.reportErrorEvent = function(message, severity) {
    "use strict";
	var i;
	// Check if we can send the event
	if	(!this.active || !this.initialized) { return; }
	// Send events through the methods
	for (i = 0; i < this.methods.length; i += 1) {
		this.methods[i].reportErrorEvent(message, severity);
	}
};


// ***************************************
// Dealing with timed events
// ***************************************

// Start a timed events
TGFAnalytics.prototype.startTimedEventExt = function(tag, category, subcategory, name) {
	"use strict";
	var i, timer;
	// Check whether there is a slot available
	for (i = 0; i < this._timers.length; i += 1) {
		if (!this._timers[i].active) { timer = this._timers[i]; break; }
	}
	if (timer === undefined){
		this._timers.push({});
		timer = this._timers[this._timers.length-1];
	}
	timer.paused = 0;
	timer.active = true;
	timer.tag = tag;
	timer.name = name;
	timer.category = category;
	timer.subcategory = subcategory;
	timer.startTime = tbGame.gameTime;
	timer.pauseTime = 0;
};

// Start a timed events with only a name
TGFAnalytics.prototype.startTimedEvent = function(tag, name) {
	"use strict";
	this.startTimedEventExt(tag, undefined, undefined, name);
};

// End the timed events with the tag, reporting the duration
TGFAnalytics.prototype.endTimedEvent = function(tag) {
	"use strict";
	var i, timer;
	for (i = 0; i < this._timers.length; i += 1) {
		if (this._timers[i].active && (tag === undefined || this._timers[i].tag === tag)) {
			timer = this._timers[i];
			// If paused shift the start time with the time it was paused
			if (timer.paused > 0) { timer.startTime += tbGame.gameTime - timer.pauseTime; }
			this.reportEventExt(timer.category, timer.subcategory, timer.name, tbGame.gameTime - timer.startTime);
			timer.active = false;
		}
	}
};

// Cancel the timed events with the tag, without any reporting
TGFAnalytics.prototype.cancelTimedEvent = function(tag) {
	"use strict";
	var i, timer;
	for (i = 0; i < this._timers.length; i += 1) {
		if (this._timers[i].active && (tag === undefined || this._timers[i].tag === tag)) {
			timer = this._timers[i];
			timer.active = false;
		}
	}
};

// Pause a timed event, remembering when it was paused
TGFAnalytics.prototype.pauseTimedEvent = function(tag) {
    "use strict";
	var i, timer;
	for (i = 0; i < this._timers.length; i += 1) {
		if (this._timers[i].active && (tag === undefined || this._timers[i].tag === tag)) {
			timer = this._timers[i];
			if (timer.paused === 0) { timer.pauseTime = tbGame.gameTime; }
			timer.paused += 1;
		}
	}
};

// Resume a timed event
TGFAnalytics.prototype.resumeTimedEvent = function(tag, force) {
	"use strict";
	var i, timer;
	for (i = 0; i < this._timers.length; i += 1) {
		if (this._timers[i].active && (tag === undefined || this._timers[i].tag === tag)) {
			timer = this._timers[i];
			if (timer.paused === 0) { continue; }
			timer.paused -= 1;
			if (force) { timer.paused = 0; }
			// Shift the start time with the time it was paused
			if (timer.paused === 0) { timer.startTime += tbGame.gameTime - timer.pauseTime; }
		}
	}
};



// ***************************************
// Implementation for Game Analytics
// ***************************************

// The constructor
var TGFAnalyticsGameAnalytics = function(analytics) {
	"use strict";
	this.analytics = analytics;
	this.initialized = false;
	this.active = false;
};

// Initialize the analytics method
TGFAnalyticsGameAnalytics.prototype.initialize = function() {
	"use strict";
	this.gameKey = this.analytics.gameAnalyticsGameKey;
	this.secretKey = this.analytics.gameAnalyticsSecretKey;
	this.baseUrl = this.analytics.gameAnalyticsBaseUrl + this.gameKey;
	// Check whether game key and secret keys are provided
	if (this.gameKey === undefined || this.secretKey === undefined) {
		if (this.analytics.showDebug && testMode) {
			console.log("Error in gameAnalytics: no gameKey or secretKey provided.");
			tgfConsole.addMessage("Error in gameAnalytics: no gameKey or secretKey provided.", "red");
		}
		return;
	}
	// Check whether JSON stringify is supported
	if (!JSON || !JSON.stringify) {
		if (this.analytics.showDebug && testMode) {
			console.log("Error in gameAnalytics: JSON stringify not supported.");
			tgfConsole.addMessage("Error in gameAnalytics: JSON stringify not supported.", "red");
		}
		return;
	}
	this.initialized = true;
};

TGFAnalyticsGameAnalytics.prototype._createJSONObject = function(){
	"use strict";
	var timestamp = Math.floor(Date.now() / 1000);

	return {
		"user_id": this.userId,
		"session_id": this.sessionId,
		"build": this.version,
		"device": tgfAnalytics.externalDeviceInfo.device,
		"platform": tgfAnalytics.externalDeviceInfo.os,
		"os_version": tgfAnalytics.externalDeviceInfo.os_major,
		"sdk_version": "rest api v2",
		"v": 2,
		"client_ts": timestamp,
		"manufacturer": "",
		"session_num": 1
	};
};

// Start the session for the analytics method
TGFAnalyticsGameAnalytics.prototype.initSession = function(gameId, themeId, clientId, userId, version) {
    "use strict";
	var data;
	// Check if we can start the session
	if	(this.active || !this.initialized) { return; }
	this.active = true;
	// Set some properties
	this.sessionId = tgfFunctions.generateGuid();
	this.userId = userId;
	this.version = version;
	this.active = true;

	// Create user data object
	data = this._createJSONObject();

	// Send event
	this._sendEvent("init", data);
};

// End the session for the analytics method
TGFAnalyticsGameAnalytics.prototype.endSession = function(){
    "use strict";
    this.active = false;
};

// Report an event with the given category, subcategory, name, and value
TGFAnalyticsGameAnalytics.prototype.reportEventExt = function(eventName, categories, value, type) {
	"use strict";
	var arr = new Array();
	var fountData = false;
	//check if tracking should be done
	if(!this.active || !this.initialized){
		return;
	}

	if(type){
		switch(type){
			case this.TYPES.SESSION_START:
				//DO nothing
				this._startSession(type);
				fountData = true;
				break;
			case this.TYPES.SESSION_END:
				//DO nothing
				this._endSession(eventName, categories, value, type);
				fountData = true;
				break;
			case this.TYPES.BUSINESS:
				this.eventBusiness(eventName, categories, value, type);
				fountData = true;
				break;
			case this.TYPES.RESOURCE:
				this.eventResource(eventName, categories, value, type);
				fountData = true;
				break;
			case this.TYPES.PROGRESSION:
				this.eventProgression(eventName, categories, value, type);
				fountData = true;
				break;
			case this.TYPES.DESIGN:
				this.eventDesign(eventName, categories, value, type);
				fountData = true;
				break;
			case this.TYPES.ERROR:
				//DO Nothing
				break;
		}
	}

	if(fountData){
		return;
	}

	var data,
		eventId = "";
	if(categories){
		if(categories instanceof Array){
			eventId = categories.toString().replace(",",":");
		}else{
			eventId += categories;
		}
	}
	//create JSON object
	data = this._createJSONObject();
	data["event_id"] = eventId + ":" + eventName;
	data["value"] = value;

	arr.push(data);
	//send event
	this._sendEvent("design", arr);
};

// Report an error message with a severity
TGFAnalyticsGameAnalytics.prototype.reportErrorEvent = function(message, severity) {
    "use strict";
    var data;
	// Check if events can be sent
	if	(!this.active || !this.initialized) { return; }
	var timestamp = Math.floor(Date.now() / 1000);
	// Create the data object
	data = this._createJSONObject();
	// Send event
   this._sendEvent("events", data);
};

// Send an event
TGFAnalyticsGameAnalytics.prototype._sendEvent = function(kind, data) {
	"use strict";
	var request,
		msg = JSON.stringify(data),
		hash = window["Crypto"]["HmacSHA256"](msg, this.secretKey),
		md5Msg = window["Crypto"]["enc"]["Base64"]["stringify"](hash),
		url = this.baseUrl + "/" + kind;
	try { //might fail in IE9
		//create xmlhttp request
		request = new XMLHttpRequest();
		request.open("POST", url, true);
		if (this.analytics.showDebug && testMode) {
			request.onreadystatechange = function() {
				if (request.readyState === 4) {
					if (request.status === 200) {
					} else {
						console.log("ERROR ajax call error: " + request.statusText + ", url: " + url);
					}
				}
			};
		}
		request.setRequestHeader("Content-Type", "text/plain");
		request.setRequestHeader("Authorization", md5Msg);
		request.send(msg);
	} catch(e) {}
};

TGFAnalyticsGameAnalytics.prototype.TYPES = {
	SESSION_START: "user",
	SESSION_END: "session_end",
	BUSINESS: "business",
	RESOURCE: "resource",
	PROGRESSION: "progression",
	DESIGN: "design",
	ERROR: "error"
};

TGFAnalyticsGameAnalytics.prototype._startSession = function(type){
	"use strict";
	var userData = this._createJSONObject();
	var arr = new Array();
	userData["category"] = type;

	arr.push(userData);
	this._sendEvent("events", arr);
};

TGFAnalyticsGameAnalytics.prototype._endSession = function(eventName, categories, value, type){
	"use strict";
	//this.active = false;
	var arr = new Array();
	var userData = this._createJSONObject();
	userData["length"] = Math.floor(value);
	userData["category"] = type;
	arr.push(userData);
	this._sendEvent("events", arr);
};

TGFAnalyticsGameAnalytics.prototype.eventBusiness = function (eventName, categories, value, type){
	"use strict";
	//Not Needed yet
};

TGFAnalyticsGameAnalytics.prototype.eventResource = function (eventName, categories, value, type){
	"use strict";
	//Not Needed yet
};

TGFAnalyticsGameAnalytics.prototype.eventProgression = function (eventName, categories, value, type){
	"use strict";
	var arr = new Array();
	var data = this._createJSONObject();

	switch(eventName){
		case "Start:":
			data["category"] = type;
			data["event_id"] = eventName + categories;
			break;
		case "Complete:":
			data["category"] = type;
			data["event_id"] = eventName + categories;
			data["score"] = value;
			break;
		case "Fail:":
			data["category"] = type;
			data["event_id"] = eventName + categories;
			data["score"] = value;
			break;
	}
	arr.push(data);
	this._sendEvent("events", arr);
};

TGFAnalyticsGameAnalytics.prototype.eventDesign = function (eventName, categories, value, type){
	"use strict";
	var arr = new Array();
	var data = this._createJSONObject();
	data["category"] = type;
	data["event_id"] = eventName + categories;
	data["value"] = value;

	arr.push(data);
	this._sendEvent("events", arr);
};

TGFAnalyticsGameAnalytics.prototype.reportError = function(errorMessage, errorSeverity){
	"use strict";
	var arr = new Array();
	var data = this._createJSONObject();
	data["category"] = "error";
	data["message"] = errorMessage;
	data["severity"] = errorSeverity;
	arr.push(data);
	this._sendEvent("events", arr);
};


// ***************************************
// Create the object
// ***************************************

var tgfAnalytics = new TGFAnalytics();

/*
TG.analyticsProvider.showDebugDataAnalytics = false;


TG.analyticsProvider.initialise = function(args){
    "use strict";
    if(args instanceof Array){
        this.gameKey = args[0];
        this.secretKey = args[1];
        this.baseUrl = "http://api.gameanalytics.com/1/"+this.gameKey;
        this.initialized = true;
    }
};

TG.analyticsProvider._sendEvent = function(category, message){
    "use strict";
    var request,
        msg = JSON.stringify(message),
        md5Msg = tgfMD5.createMD5Hash(msg + this.secretKey),
        url = this.baseUrl+"/"+category;

    try{ //might fail in IE9
        //create xmlhttp request
        request=new XMLHttpRequest();
        request.open("POST", url, true);
        if(this.showDebugDataAnalytics){
            request.onreadystatechange = function(){
                if(request.readyState === 4){
                    if(request.status === 200){
                        console.log("GOOD! statusText: " + request.statusText);
                        console.log(message);
                    }
                    else{
                        console.log("ERROR ajax call error: " + request.statusText + ", url: " + url);
                    }
                }
            };
        }
        request.setRequestHeader("Content-Type", "text/plain");
        request.setRequestHeader("Authorization", md5Msg);
        request.send(msg);
    }catch(e){}
};

TG.analyticsProvider._createJSONObject = function(){
    "use strict";
    return {
        "user_id": this.userId,
        "session_id": this.sessionId,
        "build": this.build
    };
};

TG.analyticsProvider.startSession = function(sessionId, gameId, themeId, publisherId, version, userInfo, deviceInfo){
    "use strict";
    var userData;
    this.sessionId = sessionId;
    if(userInfo && typeof userInfo === "object"){
        this.userId = userInfo.userId;
    }
    this.build = version;
    this.active = true;

    //send user data
    if(this.initialized){
        userData = this._createJSONObject();
        userData["device"] = deviceInfo.device;
        userData["platform"] = deviceInfo.os;
        userData["os_major"] = deviceInfo.os_major;
        userData["os_minor"] = deviceInfo.os_minor;
        userData["install_publisher"] = publisherId;
        userData["install_site"] = (window["location"] !== window["parent"]["location"]) ? document["referrer"]: document["location"].href;
        this._sendEvent("user", userData);
    }
    this.reportEvent("start", "session");
};

TG.analyticsProvider.endSession = function(){
    "use strict";
    this.active = false;
    this.reportEvent("end", "session");
};

TG.analyticsProvider.reportEvent = function(eventName, categories, value){
    "use strict";
    //check if tracking should be done
    if(!this.active || !this.initialized){
        return;
    }

    var data,
        eventId = "";
    if(categories){
        if(categories instanceof Array){
            eventId = categories.toString().replace(",",":");
        }else{
            eventId += categories;
        }
    }
    //create JSON object
    data = this._createJSONObject();
    data["event_id"] = eventId + ":" + eventName;
    data["value"] = value;
    //send event
    this._sendEvent("design", data);
};

TG.analyticsProvider.reportTimedEvent = function(eventName, categories, duration){
    "use strict";
    this.reportEvent(eventName, categories, duration);
};

TG.analyticsProvider.reportError = function(errorMessage, errorSeverity){
    "use strict";
    var data = this._createJSONObject();
    data["message"] = errorMessage;
    data["severity"] = errorSeverity;
    this._sendEvent("error", data);
};

*/




/*
// ***************************************
// Definition of game token TG_Analytics
// ***************************************

// The constructor for the TG_Analytics game token.
var TG_Analytics = function() {
	"use strict";
	// Properties used by the engine
	this.depth = 0;
	this.layer = 0;
	this.visible = false;
	this.active = true;
	// Your own properties
	this.settings = TG.settings.tg.analytics;
	this.poolSize = this.settings.timerPoolSize;
	// Add it to the game engine
	tbGame.addToken(this);
	tbGame.addTokenTags(this, "system");
};

TG_Analytics.prototype._getSessionId = function(){
    "use strict";
    return this._generateUniqueId();
};

TG_Analytics.prototype._getUserId = function(){
    "use strict";
    var userId = TG.controller._getGameData("userId", "");
    if(userId === ""){
        userId = this._generateUniqueId();
        TG.controller._updateGameData("userId", userId);
    }
    return userId;
};

TG_Analytics.prototype._generateUniqueId = function(){
    "use strict";
    var guid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
    return guid.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c === "x" ? r : (r&0x3|0x8);
        return v.toString(16);
    });
};

TG_Analytics.prototype.start = function(args){
    "use strict";
    TG.analyticsProvider.initialise(args);
    TG.analyticsProvider.startSession(TG.analytics._getSessionId(), TG.settings.game.framework.gameId, TG.settings.theme.id, TG.config.publisherId, TG.controller.getShortVersion(), {userId: TG.analytics._getUserId()}, TG.deviceData);
};

TG_Analytics.prototype.reportEvent = function(eventName, parents, value){
    "use strict";
    TG.analyticsProvider.reportEvent(eventName, parents, value);
};

TG_Analytics.prototype.reportTimedEventStart = function(eventName, parents, tag, reportStart){
    "use strict";
    var i;
    for(i=0; i<this._timers.length; i++){
        if(!this._timers[i].active){
            this._timers[i].timer = 0;
            this._timers[i].paused = 0;
            this._timers[i].active = true;
            this._timers[i].eventName = eventName;
            this._timers[i].parents = parents;
            this._timers[i].tag = tag;
            break;
        }
    }
    if(i === this._timers.length){
        this._timers.push({active: true, timer: 0, paused: 0, eventName: eventName, parents: parents, tag:tag});
    }

    if(reportStart){
        this.reportEvent(eventName, parents);
    }
};

TG_Analytics.prototype.reportTimedEventStop = function(tag, eventName, parents){
    "use strict";
    var i, timer;
    for(i=0; i<this._timers.length; i++){
        if(this._timers[i] !== undefined && this._timers[i].tag === tag){
            timer = this._timers[i];
            this.reportEvent((eventName !== undefined)? eventName : timer.eventName, (parents !== undefined)? parents: timer.parents, timer.timer);
            timer.active = false;
        }
    }
};

TG_Analytics.prototype.pauseTimedEvent = function(tag){
    "use strict";
    var i;
    for(i=0; i<this._timers.length; i++){
        if(this._timers[i] !== undefined && this._timers[i].tag === tag){
            this._timers[i].paused += 1;
        }
    }
};

TG_Analytics.prototype.resumeTimedEvent = function(tag){
    "use strict";
    var i;
    for(i=0; i<this._timers.length; i++){
        if(this._timers[i] !== undefined && this._timers[i].tag === tag){
            this._timers[i].paused -= 1;
            this._timers[i].paused = Math.max(this._timers[i].paused, 0);
        }
    }
};

TG_Analytics.prototype.pauseAllTimedEvents = function(){
    "use strict";
    var i;
    for(i=0; i<this._timers.length; i++){
        if(this._timers[i].active){
            this._timers[i].paused += 1;
        }
    }
};

TG_Analytics.prototype.resumeAllTimedEvents = function(){
    "use strict";
    var i;
    for(i=0; i<this._timers.length; i++){
        if(this._timers[i].active){
            this._timers[i].paused -= 1;
            this._timers[i].paused = Math.max(this._timers[i].paused, 0);
        }
    }
};

TG_Analytics.prototype.reportError = function(message, severity){
    "use strict";
    TG.analyticsProvider.reportError(message, severity);
};

// handleAdd is called when the token is (re-) added to the game.
TG_Analytics.prototype.handleAdd = function() {
	"use strict";
	this._timers = [];
};

// handleBeginStep is called each step before processing other events.
TG_Analytics.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	var i, toRemove, lastActiveTimerIdx = 0;
	for(i=0; i<this._timers.length; i++){
	    if(this._timers[i].active){
	        if(this._timers[i].paused === 0){
	            this._timers[i].timer += timePassed;
	        }
	        lastActiveTimerIdx = i;
	    }
	}
	if(lastActiveTimerIdx < this._timers.length - 1){
	    toRemove = this._timers.length - Math.max(this.poolSize, lastActiveTimerIdx + 1);
	    if(toRemove > 0){
	        this._timers.splice(this._timers.length - toRemove, toRemove);
	    }
	}
};
*/

//******************************************************
//*****    Script Resource: tgfConsole
//******************************************************

// ***************************************
// tgfConsole
//
// This object shows a console besides the game area in 
// which messages can be displayed
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 28-6-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbKeyCodes, testMode */
/*global tgfFunctions, tgfSettings, tgfScale, tgfGraphics, tgfDictionary */
/*global s_tgf_console_play, s_tgf_console_pause, s_tgf_console_step, s_tgf_console_restart, s_tgf_console_position, s_tgf_console_close */
/*global window, location */

tgfSettings.consoleDefaults = {
	showOnInit: false,								// Whether to show the console on initialization
	showOnlyInTestMode: true,						// Whether to show the console only in test mode
	toggleKey: tbKeyCodes.vkF9,						// Key for toggling visibility
	tabSequence: "ABBCCDDA",						// Tab sequence to show the console (A = top-left, B = top-right, C = bottom-left, D = bottom-right)
	tabDuration: 5,									// Maximal duration before resetting the tab sequence after it starts
	updateInterval: 0.2,							// Interval in seconds for updating watches and information
	
	showFps: true,									// Whether to show the frames-per-second in the console
	fpsUpdateInterval: 1,							// Interval for updating the fps (in seconds)
	
	width: tgfScale(320),							// The width of the console canvas in pixels (undefined = area width)
	height: undefined,								// The height of the console canvas in pixels( undefined = area height)
	left: undefined,								// Left of the console canvas, w.r.t. the game area (undefined = next to it)
	top: tgfScale(0),								// Top of the console canvas, w.r.t. the game area (undefined = below it)

	width2: undefined,								// Alternative width
	height2: tgfScale(320),							// Alternative height
	left2: tgfScale(0),								// Alternative left
	top2: undefined,								// Alternative top

	watchFunctions: false,							// Whether to show functions in the watches
	watchNull: false,								// Whether to show properties that are null
	watchUndefined: false,							// Whether to show properties that are undefined (is that at all possible?)
	watchOnlyOwn: false,							// Whether to watch only own properties
	sortExpandedWatches: true,						// Whether to sort the expanded watches
	
	forceReload: true,								// Whether a reload should force to load it from the server
	resumeOnHide: true,								// Whether on hiding the console, the game must be resumed when paused

	buttonAreaHeight: tgfScale(48),					// Height of the button area
	buttonColor: "#CCE6FF",							// Color of the buttons
	buttonBackColor: "#EEEEEE",						// Background color
	
	margin: tgfScale(6),							// Margin around the area with the information

	headerAreaHeight: tgfScale(48),					// Height of the header area
	headerColorLight: "#CCCCCC",					// Light header background color
	headerColorDark: "#999999",						// Dark header background color
	headerColorText: "#000000",						// Header text color
	headerFontName: "Arial",						// Name of the HTML5 header font
	headerFontSize: tgfScale(16, "round"),			// Size of the header font
	
	textFontName: "Courier New",					// Name of the HTML5 font to be used
	textFontSize: tgfScale(16, "round"),			// Size of the font to use
	textColor: "#000000",							// Color of the normal texts
	textBackColor: "#CCE6FF",						// Color used for the backgrounds of the lines of text
	textHeight: tgfScale(24),						// Height of a line of text in pixels
	textIndent: tgfScale(24),						// Indent for each line of text
	textMarkerColor: "#2E8AE6",						// Color used marker in front of the text
	
	sliderWidth: tgfScale(32),						// Width of the slider
	sliderColorLight: "#DDDDDD",					// Light slider color
	sliderColorDark: "#AAAAAA"						// Dark slider color
};

// The constructor for the TGFConsole game token. 
var TGFConsole = function() {
	"use strict";
	// Properties used by the engine
	this.depth = 0;	
	this.layer = -99999999;
	this.visible = false;
	this.active = true;
	this.initialized = false;
	this.tabString = "";					// The tabbed sequence so far
	this.tabTime = 0;						// The time since the first tab
	// Add it to the game engine
	tbGame.addToken(this);
};


// ***************************************
// Initialization
// ***************************************

// Initialize the console
TGFConsole.prototype.initialize = function(settings) {
	"use strict";
	if (this.initialized) { return; }
	// Set the settings
	this._setProperties(tgfSettings.consoleDefaults);
	this._setProperties(settings);
	if (this.showOnlyInTestMode && !testMode) { return; }
	this.initialized = true;
	// Initialize the information
	this.info = [];						// The info fields in the info tab
	this.messages = [];					// The messages in the message tab
	this.watches = [];					// The watches in the watches tab
	this.mode = 0;						// Current mode (0 = info, 1 = watch, 2 = console)
	this.clear();
	// Deal with the status
	this.gamePaused = false;
	this.pauseNextStep = false;
	// Create the console canvas, when required
	this.consoleCanvas = null;
	if (this.showOnInit) { this.show(); }
	// Deal with showing the fps
	if (this.showFps) {
		this.lastGameTime = tbGame.gameTime;
		this.lastTotalSteps = tbGame.totalSteps;
		this.fpsString = "";
		this.fpsTime = 0;
	}		
	// Deal with updating information
	if (this.updateInterval > 0) {
		this.updateTime = 0;
	}
};

// Clear all data
TGFConsole.prototype.clear = function() {
	"use strict";
	if (!this.initialized) { return; }
	this.clearMessages();
	this.clearInfo();
	this.clearWatches();
};

// Clear all data
TGFConsole.prototype.isActive = function(checkCanvas) {
	"use strict";
	if (!this.initialized) { return false; }
	if (this.showOnlyInTestMode && !testMode) { return false; }
	if (!this.consoleCanvas && checkCanvas !== false) { return false; }
	return true;
};

// Set a number of properties
TGFConsole.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

// Update the fps information
TGFConsole.prototype._updateFps = function() {
	"use strict";
	var time = (tbGame.gameTime - this.lastGameTime)/1000,
		steps = tbGame.totalSteps - this.lastTotalSteps,
		fps = Math.round(steps/time),
		newString;
	if (!this.initialized) { return; }
	this.lastGameTime = tbGame.gameTime;
	this.lastTotalSteps = tbGame.totalSteps;
	newString = "fps: " + fps;
	if (newString !== this.fpsString) {
		this.fpsString = newString;
		if (!this.consoleCanvas) { return; }
	}
	this._drawFps();
};


// ***************************************
// Showing and hiding
// ***************************************

// Show the console canvas
TGFConsole.prototype.show = function(alternative) {
	"use strict";
	var l, t, w, h;
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	if (this.consoleCanvas) { return; }
	if (alternative === undefined) { alternative = false; }
	// Save the old graphics settings
	this._oldAreaWidth = tgfGraphics.areaWidth;
	this._oldAreaHeight = tgfGraphics.areaHeight;
	this._oldSafeZoneWidth = tgfGraphics.safeZoneWidth;
	this._oldSafeZoneHeight = tgfGraphics.safeZoneHeight;
	this._oldSafeZoneTop = tgfGraphics.safeZoneTop;
	this._oldSafeZoneLeft = tgfGraphics.safeZoneLeft;
	// Determine position and size
	this._alternative = alternative;
	if (alternative) {
		l = this.left2 === undefined ? tgfGraphics.areaWidth : this.left2;
		t = this.top2 === undefined ? tgfGraphics.areaHeight : this.top2;
		w = this.width2 === undefined ? tgfGraphics.areaWidth : this.width2;
		h = this.height2 === undefined ? tgfGraphics.areaHeight : this.height2;
	} else {
		l = this.left === undefined ? tgfGraphics.areaWidth : this.left;
		t = this.top === undefined ? tgfGraphics.areaHeight : this.top;
		w = this.width === undefined ? tgfGraphics.areaWidth : this.width;
		h = this.height === undefined ? tgfGraphics.areaHeight : this.height;
	}
	if (l < 0) { l = 0; }
	if (t < 0) { t = 0; }
	// Create the new canvas
	this.consoleCanvas = tgfGraphics.addCanvas( {
		canvasLeft: l, canvasTop: t,
		canvasWidth: w, canvasHeight: h,
		canvasStatic: true
	} );
	// Set the correct area
	tgfGraphics.setArea(Math.max(tgfGraphics.areaWidth, l+w), Math.max(tgfGraphics.areaHeight, t+h));
	tgfGraphics.setSafeZone(0, 0, tgfGraphics.areaWidth, tgfGraphics.areaHeight);
	// Set the initial tab
	this.mode = -1;
	this._setMessagesTab();
};

// Hide the console canvas
TGFConsole.prototype.hide = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	tgfGraphics.setArea(this._oldAreaWidth, this._oldAreaHeight);
	tgfGraphics.setSafeZone(this._oldSafeZoneLeft, this._oldSafeZoneTop, this._oldSafeZoneWidth, this._oldSafeZoneHeight);
	tgfGraphics.removeCanvas(this.consoleCanvas);
	this.consoleCanvas = null;
	// Resume the game when required
	if (this.gamePaused && this.resumeOnHide) {
		tbGame.pauseToken(this);
		tbGame.resumeTokens();
		this.gamePaused = false;
	}
};

// Toggle the visibility of the console canvas
TGFConsole.prototype.toggle = function() {
	"use strict";
	if (!this.initialized) { return; }
	// Check whether things are ok
	if (!this.isActive(false)) { return; }
	if (this.consoleCanvas) { 
		this.hide();
	} else {
		this.show();
	}
};

// Returns whether the console is shown
TGFConsole.prototype.shown = function() {
	"use strict";
	return this.consoleCanvas !== undefined && this.consoleCanvas !== null;
};


// ***************************************
// Deal with messages
// ***************************************

// Show the messages tab
TGFConsole.prototype._setMessagesTab = function() {
	"use strict";
	var visibleLines;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mode === 2) { return; }
	this.mode = 2;
	// Set the slider
	this._computeArea();
	visibleLines = Math.floor(this.areaHeight/this.textHeight);
	this.sliderSize = Math.min(1, visibleLines / this.messages.length);
	this.sliderPosition = 1 - this.sliderSize;
	// Now draw everything for the first time
	this._drawTabs();
	this._drawMessages();
};

// Draw the messages
TGFConsole.prototype._drawMessages = function() {
	"use strict";
	var lines = [], mes, i,
		fnt = this.textFontSize + "px " + this.textFontName;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mode !== 2) { return; }
	// Convert the messages into lines
	for (i = 0; i < this.messages.length; i += 1) {
		mes = this.messages[i];
		if (mes !== undefined) {
			lines.push( {text: mes.text, color: mes.color, indent: 0, icon: i === this.messages.length-1 ? "disk" : "", font: fnt } );
		} else {
			lines.push( {text: "", color: "black", indent: 0, icon: "", font: fnt } );
		}	
	}
	// Now draw the lines
	this._drawLines(lines);
};

// Add a message to the console
TGFConsole.prototype.addMessage = function(text, color) {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	if (color === undefined) { color = this.textColor; }
	this.messages.push( {text: text, color: color} );
	// Now draw it
	this._drawMessages();
};

// Clears the messages information
TGFConsole.prototype.clearMessages = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	this.messages = [];
	this._drawMessages();
};

// Update the console information
TGFConsole.prototype._updateMessages = function() {
	"use strict";
	// Nothing needs to be done
};


// ***************************************
// Deal with information
// ***************************************

// Show the information tab
TGFConsole.prototype._setInfoTab = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mode === 0) { return; }
	this.mode = 0;
	// Set the slider
	this.sliderPosition = 0;
	// Now draw everything for the first time
	this._drawTabs();
	this._drawInfo();
};

// Draw the information
TGFConsole.prototype._drawInfo = function() {
	"use strict";
	var lines = [], inf, str, i,
		fnt = this.textFontSize + "px " + this.textFontName;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mode !== 0) { return; }
	// Convert the info into lines
	for (i = 0; i < this.info.length; i += 1) {
		inf = this.info[i];
		if (inf !== undefined) {
			str = inf.text;
			if (inf.func !== undefined) { str += inf.func(); }			
			lines.push( {text: str, color: inf.color, indent: 0, icon: "", font: fnt } );
		} else {
			lines.push( {text: "", color: "black", indent: 0, icon: "", font: fnt } );
		}	
	}
	// Now draw the lines
	this._drawLines(lines);
};

// Add information to a line
TGFConsole.prototype.addInfo = function(line, text, func, color) {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	if (color === undefined) { color = this.textColor; }
	this.info[line] = { text: text, func: func, color: color };
	this._drawInfo();
};

// Remove information to a line
TGFConsole.prototype.removeInfo = function(line) {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	this.info[line] = undefined;
	this._drawInfo();
};

// Clears the info information
TGFConsole.prototype.clearInfo = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	this.info = [];
	this._drawInfo();
};

// Update the info
TGFConsole.prototype._updateInfo = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mode !== 0) { return; }
	this._drawInfo();
};


// ***************************************
// Deal with watches
// ***************************************

// Show the watches tab
TGFConsole.prototype._setWatchesTab = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mode === 1) { return; }
	this.mode = 1;
	// Set the slider
	this.sliderPosition = 0;
	// Now draw everything for the first time
	this._drawTabs();
	this._drawWatches();
};

// Draw the watches
TGFConsole.prototype._drawWatches = function() {
	"use strict";
	var lines = [], i, watch, obj, str, icon, 
		fnt = this.textFontSize + "px " + this.textFontName;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mode !== 1) { return; }
	// Convert the watches into lines
	for (i = 0; i < this.watches.length; i += 1) {
		watch = this.watches[i];
		obj = watch.obj;
		if (watch.propName !== undefined) { obj = obj[watch.propName]; }
		str = watch.name + ": ";
		icon = "";
		if (obj === undefined) {
			str += "undefined";
		} else if (obj === null) {
			str += "null";
		} else if (Object.prototype.toString.call(obj) === "[object Array]") {
			str += "Array[" + obj.length + "]";
			icon = watch.expanded ? "arrowD" : "arrowR";
		} else if (typeof obj === "object") {
			str += "Object";
			icon = watch.expanded ? "arrowD" : "arrowR";
		} else if (typeof obj === "function") {
			str += "Function";
		} else if (typeof obj === "string") {
			str += "\"" + obj + "\"";
		} else {
			str += obj.toString();
		}
		lines.push( {text: str, color: watch.color, indent: watch.indent, icon: icon, font: fnt } );
	}
	// Now draw the lines
	this._drawLines(lines);
};

// Add a property to the list of watches
TGFConsole.prototype._addWatchProperty = function(ind, name, obj, propName, color, indent) {
	"use strict";
	var newobj = obj, addit = true;
	if (newobj !== undefined && propName !== undefined) { newobj = newobj[propName]; }
	if (newobj === undefined && !this.watchUndefined) { addit = false; }
	if (newobj === null && !this.watchNull) { addit = false; }
	if (typeof newobj === "function" && !this.watchFunctions) { addit = false; }
	if (addit) {
		this.watches.splice(ind, 0, {name: name, obj: obj, propName: propName, color: color, expanded: false, indent: indent} );
	}
	return addit;
};

// Sorts part of the watches by name
TGFConsole.prototype._sortWatches = function(ind1, ind2) {
	"use strict";
	var i, j, tmp;
	for (i = ind1; i < ind2; i += 1) {
		for (j = i+1; j <= ind2; j += 1) {
			if (this.watches[j].name < this.watches[i].name) {
				tmp = this.watches[i];
				this.watches[i] = this.watches[j];
				this.watches[j] = tmp;
			}
		}
	}
};

// Expand a watch
TGFConsole.prototype._expandWatch = function(ind) {
	"use strict";
	var obj, watch, i, subobj, n = 0;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (ind < 0 || ind >= this.watches.length) { return; }
	watch = this.watches[ind];
	if (watch === undefined || watch.expanded) { return; }
	obj = watch.obj;
	if (obj !== undefined && watch.propName !== undefined) { obj = obj[watch.propName]; }
	if (Object.prototype.toString.call(obj) === "[object Array]") {
		watch.expanded = true;
		for (i = obj.length-1; i >= 0; i -= 1) {
			if (this._addWatchProperty(ind+1, i.toString(), obj, i.toString(), watch.color, watch.indent+1)) { n += 1; }
		}
	} else if (typeof obj === "object") {
		watch.expanded = true;
		for (subobj in obj) {
			if (obj.hasOwnProperty(subobj) || !this.watchOnlyOwn) {
				if (this._addWatchProperty(ind+1, subobj, obj, subobj, watch.color, watch.indent+1)) { n += 1; }
			}
		}		
	}
	if (this.sortExpandedWatches) { this._sortWatches(ind+1, ind+n); } 
	this._drawWatches();
};
		
// Collapse a watch
TGFConsole.prototype._collapseWatch = function(ind) {
	"use strict";
	var watch, n;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (ind < 0 || ind >= this.watches.length) { return; }
	watch = this.watches[ind];
	if (watch === undefined || !watch.expanded) { return; }
	watch.expanded = false;
	n = 0;
	while (ind+n+1 < this.watches.length && this.watches[ind+n+1].indent > watch.indent) { n += 1; }
	this.watches.splice(ind+1, n);
	this._drawWatches();
};
		
// Add a watch
TGFConsole.prototype.addWatch = function(name, obj, propName, color) {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	if (color === undefined) { color = this.textColor; }
	this.watches.push( {name: name, obj: obj, propName: propName, color: color, expanded: false, indent: 0} );
	this._drawWatches();
};

// Remove a watch
TGFConsole.prototype.removeWatch = function(name) {
	"use strict";
	var i, ind = -1;
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	// Find the watch
	for (i = 0; i < this.watches.length; i += 1) {
		if (this.watches[i].name === name && this.watches[i].indent === 0) {
			ind = i;
			break;
		}
	}
	if (ind < 0) { return; }
	this._collapseWatch(ind);
	this.watches.splice(ind, 1);
	this._drawWatches();
};

// Clears the watches information
TGFConsole.prototype.clearWatches = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	this.watches = [];
	this._drawWatches();
};

// Update the watches information
TGFConsole.prototype._updateWatches = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mode !== 1) { return; }
	this._drawWatches();
};


// ***************************************
// User interaction
// ***************************************

// Handle a button click
TGFConsole.prototype._handleButton = function(button) {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	switch (button) {
		case 0:				// Pause/resume the game
			this.gamePaused = !this.gamePaused;
			this.pauseNextStep = false;
			if (this.gamePaused) {
				tbGame.pauseTokens();
				tbGame.resumeToken(this);
			} else {
				tbGame.pauseToken(this);
				tbGame.resumeTokens();
			}
			this._drawButtons();
			break;
		case 1:				// Do a single step
			if (this.gamePaused) {
				tbGame.pauseToken(this);
				tbGame.resumeTokens();
				this.gamePaused = false;
			}
			this.pauseNextStep = true;
			break;
		case 2:				// Restart the game
			location.reload(this.forceReload);
			break;
		case 3:				// Toggle location
			this.hide();
			this.show(!this._alternative);
			break;
		case 4:				// Hide the console
			this.hide();
			break;
	}
};

// Handle a mouse click or touch
TGFConsole.prototype._handleMouseDown = function(x, y) {
	"use strict";
	var w = Math.min(100, Math.round((this.consoleCanvas.width - 4 * this.margin)/3)), mode, line, button;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	this._computeArea();
	if (y < this.buttonAreaHeight) {
		// Deal with the buttons
		button = Math.floor((x-this.margin/2)/this.buttonAreaHeight);
		this._handleButton(button);
	} else if (y < this.buttonAreaHeight + this.headerAreaHeight) {
		// Deal with the headers
		mode = Math.floor((x - this.margin/2) / (w + this.margin));
		switch (mode) {
			case 0: this._setInfoTab(); break;
			case 1: this._setWatchesTab(); break;
			case 2: this._setMessagesTab(); break;
		}
	} else if (y <= this.areaTop + this.areaHeight && x >= this.areaLeft + this.areaWidth - this.sliderWidth) {
		// Deal with sliders
		this.sliderSliding = true;
	} else if (this.mode === 1  && y <= this.areaTop + this.areaHeight) {
		// Deal with expanding watches
		line = Math.floor(this.sliderPosition * this.watches.length + (y-this.areaTop)/this.textHeight);
		if (line >= 0 && line < this.watches.length) {
			if (this.watches[line].expanded) {
				this._collapseWatch(line);
			} else {
				this._expandWatch(line);
			}
		}
	}
};

// Handle a mouse move
TGFConsole.prototype._handleMouseMove = function(x, y) {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	// Deal with the slider
	this._computeArea();
	if (this.sliderSliding) {
		this.sliderPosition = (y-this.areaTop)/this.areaHeight - this.sliderSize / 2;
		if (this.sliderPosition < 0) { this.sliderPosition = 0; }
		if (this.sliderPosition + this.sliderSize > 1) { this.sliderPosition = 1 - this.sliderSize; }
		switch (this.mode) {
			case 0: this._drawInfo(); break;
			case 1: this._drawWatches(); break;
			case 2: this._drawMessages(); break;
		}
	}
};

// Handle a mouse up
TGFConsole.prototype._handleMouseUp = function(x, y) {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	// Deal with the slider
	if (this.sliderSliding) { this.sliderSliding = false; }
};


// ***************************************
// Drawing the console
// ***************************************

// Compute the area
TGFConsole.prototype._computeArea = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	this.areaLeft = this.margin + 1;
	this.areaTop = this.margin + this.buttonAreaHeight + this.headerAreaHeight + 1;
	this.areaWidth = this.consoleCanvas.width - 2 * this.margin - 2;
	this.areaHeight = this.consoleCanvas.height - this.areaTop - this.margin - 2;
};

// Draw the tabs and the background
TGFConsole.prototype._drawTabs = function() {
	"use strict";
	var m, l, t, cw, ch, w, h, fnt, i;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	m = this.margin;
	l = m;
	t = m + this.buttonAreaHeight;
	cw = this.consoleCanvas.width;
	ch = this.consoleCanvas.height;
	w = Math.min(100, Math.round((cw - 4 * m)/3));
	h = this.headerAreaHeight-m;
	fnt = this.headerFontSize + "px " + this.headerFontName;
	tbGraphics.setCanvas(this.consoleCanvas);
	tbGraphics.clearColor(this.buttonBackColor);
	// Compute the area size
	this._computeArea();
	// Draw the tabs
	for (i=0; i < 3; i += 1) {
		tbGraphics.drawRoundedRectangle(l + i*(w+m), t, w, h + tgfScale(6), tgfScale(6), i === this.mode ? this.headerColorLight : this.headerColorDark, "black");
	}
	tbGraphics.drawText("Info", l + tgfScale(8), t + Math.round(0.65 * h), this.headerColorText, fnt);
	tbGraphics.drawText("Watch", l + (w+m) + tgfScale(8), t + Math.round(0.65 * h), this.headerColorText, fnt);
	tbGraphics.drawText("Messages", l + 2*(w+m) + tgfScale(8), t + Math.round(0.65 * h), this.headerColorText, fnt);
	// Draw the global areas in the form
	tbGraphics.drawRectangle(0, t+h, cw, ch-t-h, this.headerColorLight, "black");
	tbGraphics.drawLine(l + this.mode*(w+m) + 1, t+h, l + this.mode*(w+m) + w - 2, t+h, this.headerColorLight, 2);
	tbGraphics.drawRectangle(this.areaLeft-1, this.areaTop-1, this.areaWidth+2, this.areaHeight+2, this.textBackColor, "black");
	// Draw the other elements
	this._drawButtons();
	this._drawFps();
};

// Draw the buttons
TGFConsole.prototype._drawButtons = function() {
	"use strict";
	var w, l, t, h, icon;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	l = this.margin;
	t = this.margin;
	h = this.buttonAreaHeight - this.margin;
	w = h;
	tbGraphics.setCanvas(this.consoleCanvas);
	tbGraphics.drawRoundedRectangle(l, t, w, h, tgfScale(6), this.buttonColor, "black");
	icon = this.gamePaused ? s_tgf_console_play : s_tgf_console_pause;
	icon.drawSimple(0, l + w/2, t + h/2);
	l += w + this.margin;
	tbGraphics.drawRoundedRectangle(l, t, w, h, tgfScale(6), this.buttonColor, "black");
	s_tgf_console_step.drawSimple(0, l + w/2, t + h/2);
	l += w + this.margin;
	tbGraphics.drawRoundedRectangle(l, t, w, h, tgfScale(6), this.buttonColor, "black");
	s_tgf_console_restart.drawSimple(0, l + w/2, t + h/2);
	l += w + this.margin;
	tbGraphics.drawRoundedRectangle(l, t, w, h, tgfScale(6), this.buttonColor, "black");
	s_tgf_console_position.drawSimple(0, l + w/2, t + h/2);
	l += w + this.margin;
	tbGraphics.drawRoundedRectangle(l, t, w, h, tgfScale(6), this.buttonColor, "black");
	s_tgf_console_close.drawSimple(0, l + w/2, t + h/2);
	l += w + this.margin;
};

// Draw the slider bar
TGFConsole.prototype._drawSlider = function() {
	"use strict";
	var w, l, t, h;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	w = this.sliderWidth;
	l = this.areaLeft + this.areaWidth - w;
	t = this.areaTop + Math.round(this.sliderPosition*this.areaHeight);
	h = Math.round(this.sliderSize*this.areaHeight);
	tbGraphics.setCanvas(this.consoleCanvas);
	tbGraphics.drawRectangle(l, this.areaTop, w, this.areaHeight, this.sliderColorLight);
	tbGraphics.drawRectangle(l+2, t+2, w-4, h-4, this.sliderColorDark, "black");
};

// Draw the fps information
TGFConsole.prototype._drawFps = function() {
	"use strict";
	var cw, ch, l, t1, t2, fnt;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (!this.showFps) { return; }
	cw = this.consoleCanvas.width;
	ch = this.consoleCanvas.height;
	fnt = this.headerFontSize + "px " + this.headerFontName;
	l = cw - tbGraphics.textWidth(this.fpsString, fnt) - tgfScale(10);
	t1 = Math.round(1.2*this.buttonAreaHeight/3);
	t2 = Math.round(2.8*this.buttonAreaHeight/3);
	tbGraphics.setCanvas(this.consoleCanvas);
	tbGraphics.drawRectangle(l, 0, cw-l, this.buttonAreaHeight, this.buttonBackColor);
	tbGraphics.drawText(this.fpsString, l, t1, this.textColor, fnt);
	tbGraphics.drawText(tgfDictionary.getLanguage(), l, t2, this.textColor, fnt);
};

// Draw a line of text
TGFConsole.prototype._drawLine = function(l, t, line) {
	"use strict";
	var xc, yc;
	if (line === undefined) { return; } 
	tbGraphics.drawText(line.text, l + (line.indent + 1) * this.textIndent, t + Math.round(0.75 * this.textHeight), line.color, line.font);
	xc = l + (line.indent + 0.5) * this.textIndent;
	yc = t + this.textHeight/2;
	if (line.icon === "disk") { tbGraphics.drawDisk(xc, yc, tgfScale(4), this.textMarkerColor); }	
	if (line.icon === "arrowR") { tbGraphics.drawPolygon(
									[xc-tgfScale(4), xc-tgfScale(4), xc+tgfScale(4)],
									[yc-tgfScale(4), yc+tgfScale(4), yc],
									this.textMarkerColor); }	
	if (line.icon === "arrowD") { tbGraphics.drawPolygon(
									[xc-tgfScale(4), xc+tgfScale(4), xc],
									[yc-tgfScale(4), yc-tgfScale(4), yc+tgfScale(4)],
									this.textMarkerColor); }	
};

// Draw the background part of the console
TGFConsole.prototype._drawLines = function(lines) {
	"use strict";
	var i, yy, visibleLines;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	tbGraphics.setCanvas(this.consoleCanvas);
	// Set the slider
	this._computeArea();
	visibleLines = Math.floor(this.areaHeight/this.textHeight);
	this.sliderSize = lines.length === 0 ? 1 : Math.min(1, visibleLines / lines.length);
	if (this.sliderPosition + this.sliderSize > 1) { this.sliderPosition = 1 - this.sliderSize; }
	this._drawSlider();
	// Set the clipping area
	tbGraphics.context.save();
	tbGraphics.context.beginPath();
	tbGraphics.context.rect(this.areaLeft, this.areaTop, this.areaWidth - this. sliderWidth, this.areaHeight);
	tbGraphics.context.clip();
	// Draw the lines
	tbGraphics.drawRectangle(this.areaLeft, this.areaTop, this.areaWidth, this.areaHeight, this.textBackColor);
	for (i = 0; i < lines.length; i += 1) {
		yy = this.areaTop + i * this.textHeight - this.sliderPosition * lines.length * this.textHeight;
		if (yy <= this.areaTop - this.textHeight || yy >= this.areaTop + this.areaHeight) { continue; }
		this._drawLine(this.areaLeft, yy, lines[i]);
	}
	// Restore the clipping area
	tbGraphics.context.restore();
};


// ***************************************
// The callback methods
// ***************************************

// handleRemove is called when the token is removed from the game.
TGFConsole.prototype.handleRemove = function() {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	this.hide();
};

// handleBeginStep is called each step before processing other events.
TGFConsole.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.pauseNextStep) {
		tbGame.pauseTokens();
		tbGame.resumeToken(this);
		this.gamePaused = true;
		this.pauseNextStep = false;
		this._drawButtons();
	}
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
TGFConsole.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";
	var xx, yy, ch = "X";
	if (!this.initialized) { return; }
	// Deal with the tabbing sequence
	if (this.tabSequence !== "" && !this.shown()) {
		if (x < tbGraphics.width/3 && y < tbGraphics.height/3) { ch = "A"; }
		if (x > 2*tbGraphics.width/3 && y < tbGraphics.height/3) { ch = "B"; }
		if (x < tbGraphics.width/3 && y > 2*tbGraphics.height/3) { ch = "C"; }
		if (x > 2*tbGraphics.width/3 && y > 2*tbGraphics.height/3) { ch = "D"; }
		this.tabString += ch;
		if (this.tabSequence.indexOf(this.tabString) !== 0) {
			this.tabString = "";
			this.tabTime = 0;
		}
		if (this.tabString === this.tabSequence) {
			this.show();
			this.tabString = "";
			this.tabTime = 0;			
		}
	}
	// Deal with the actual console
	if (!this.isActive()) { return; }
	xx = tgfGraphics.translateCoordinateX(tgfGraphics.mainCanvas, this.consoleCanvas, x);
	yy = tgfGraphics.translateCoordinateY(tgfGraphics.mainCanvas, this.consoleCanvas, y);
	if (xx >= 0 && xx < this.consoleCanvas.width && yy >=0 && yy < this.consoleCanvas.height) {
		this.mouseDown = true;
		this.mouseFinger = finger;
		this._handleMouseDown(xx, yy);
		this._handleMouseMove(xx, yy);
		return true;
	}
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
TGFConsole.prototype.handleTouchUp = function(finger, x, y) { 
	"use strict";
	var xx, yy;
	if (!this.initialized) { return; }
	if (!this.isActive()) { return; }
	if (this.mouseDown && this.mouseFinger === finger) {
		this.mouseDown = false;
		xx = tgfGraphics.translateCoordinateX(tgfGraphics.mainCanvas, this.consoleCanvas, x);
		yy = tgfGraphics.translateCoordinateY(tgfGraphics.mainCanvas, this.consoleCanvas, y);
		this._handleMouseUp(xx, yy);
		return true;
	}
};

// handleKeyDown is called if the key with the given keyCode is pressed.
TGFConsole.prototype.handleKeyDown = function(keyCode) { 
	"use strict";
	if (!this.initialized) { return; }
	if (!this.isActive(false)) { return; }
	if (keyCode === this.toggleKey) { this.toggle(); }
};

// handleEndStep is called each step after processing other events (before draw).
TGFConsole.prototype.handleEndStep = function(timePassed) { 
	"use strict";
	var xx, yy;
	if (!this.initialized) { return; }
	// Deal with the tabbing sequence
	if (this.tabSequence !== "" && !this.shown()) {
		if (this.tabString !== "") { this.tabTime += timePassed/1000; }
		if (this.tabTime > this.tabDuration) {
			this.tabTime = 0;
			this.tabString = "";
		}
	}
	if (!this.isActive()) { return; }
	// Deal with showing the fps
	if (this.showFps) {
		this.fpsTime += timePassed/1000;
		if (this.fpsTime >= this.fpsUpdateInterval) {
			this._updateFps();
			this.fpsTime = 0;
		}
	}		
	// Deal with updating information
	if (this.updateInterval > 0) {
		this.updateTime += timePassed/1000;
		if (this.updateTime >= this.updateInterval) {
			this._updateMessages();
			this._updateInfo();
			this._updateWatches();
			this.updateTime = 0;
		}
	}
	// Deal with mouse moves
	if (this.mouseDown) {
		xx = tgfGraphics.translateCoordinateX(tgfGraphics.mainCanvas, this.consoleCanvas, tbGame.touchX(this.mouseFinger));
		yy = tgfGraphics.translateCoordinateY(tgfGraphics.mainCanvas, this.consoleCanvas, tbGame.touchY(this.mouseFinger));
		this._handleMouseMove(xx, yy);
	}
};

// ***************************************
// Create the object
// ***************************************

var tgfConsole = new TGFConsole();

//******************************************************
//*****    Script Resource: tgfErrors
//******************************************************

// ***************************************
// tgfErrors
//
// This object deals with error handling/reporting.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 19-6-2015
// ***************************************

// Directives for jslint
/*global tbGame */
/*global tgfFunctions, tgfSettings, tgfDialogs, tgfScale, tgfComponents, tgfFramework */
/*global console */

tgfSettings.errorsDefaults = {
	showMessages: true,							// Whether to show all messages to the player
	showWarnings: true,							// Whether to show all warnings to the player
	showErrors: true,							// Whether to show all errors to the player
	showId: false,								// Whether to show the error id for errors
	showVersion: false,							// Whether to show version information for errors
	reportMessages: false,						// Whether to report messages to us
	reportWarnings: false,						// Whether to report warnings to us
	reportErrors: true,							// Whether to report errors to us
	reportId: true,								// Whether to report the error id for errors
	reportVersion: true,						// Whether to report version information for errors
	reportMethod: "console",					// Reporting methods. Currently only "none" or "console". Can be an array.
	dialogProperties: {							// The properties for the dialog to show errors
		width: tgfScale(640), height: tgfScale(400),
		buttonHorizontalSize: tgfScale(200),
		versionX: -280, versionY: 150,
		versionFont: {fontFace: "ff_tgf_normal", fontSize: 14, align: "left", baseline: "top"}
	}						
};

// The constructor
var TGFErrors = function () {
	"use strict";
};


// ***************************************
// Initialization
// ***************************************

// Initialize the error handling
TGFErrors.prototype.initialize = function(settings) {
	"use strict";
	this._setProperties(tgfSettings.errorsDefaults);
	this._setProperties(settings);
	// Determine the default version string
	this.versionString = "F: " + tgfFramework.id + "_" + tgfFramework.version;
	if (tgfSettings.game) {
		this.versionString  += ", G: " + tgfSettings.game.id + "_" + tgfSettings.game.version;
	}
	if (tgfSettings.theme) {
		this.versionString  += ", T: " + tgfSettings.theme.id + "_" + tgfSettings.theme.version;
	}
	if (tgfSettings.client) {
		this.versionString  += ", C: " + tgfSettings.client.id + "_" + tgfSettings.client.version;
	}
};

// Set a number of properties
TGFErrors.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

// Set the version string
TGFErrors.prototype.setVersionString = function(version) {
	"use strict";
	this.versionString = version;
};


// ***************************************
// Showing errors
// ***************************************

// Show a message to the player
TGFErrors.prototype.showMessage = function(title, description, force, id) {
	"use strict";
	if (!this.showMessages && !force) { return; }
	this.show(title, description, id, "message");
};

// Show a warning to the player
TGFErrors.prototype.showWarning = function(title, description, force, id) {
	"use strict";
	if (!this.showWarnings && !force) { return; }
	this.show(title, description, id, "warning");
};

// Show an error to the player
TGFErrors.prototype.showError = function(title, description, force, id) {
	"use strict";
	if (!this.showErrors && !force) { return; }
	this.show(title, description, id, "error");
};

// Show the actual error
TGFErrors.prototype.show = function(title, description, id, severity) {
	"use strict";
	var idString = "",
		dialog = new tgfDialogs.QuestionBox(this.dialogProperties);
		dialog.setProperties( { titleText: title, messageText: description, buttons: [ {text: "Close"} ] });
	// Add error id and version information
	if (id && this.showId && severity === "error") {
		idString += "Error Id: " + id + "\n";
	}
	if (this.showVersion && severity === "error") {
		if (idString === "") { idString = "\n"; }
		idString += "Version: " + this.versionString;
	}
	if (idString !== "") { 
		dialog.components.push( new tgfComponents.Label( {
			x: this.dialogProperties.versionX !== undefined ? this.dialogProperties.versionX : -dialog.width/2 + dialog.marginLeft, 
			y: this.dialogProperties.versionY !== undefined ? this.dialogProperties.versionY : dialog.height/2 - dialog.marginBottom - tgfScale(12),
			font: this.dialogProperties.versionFont !== undefined ? this.dialogProperties.versionFont : {fontFace: "ff_tgf_normal", fontSize: 14, align: "left", baseline: "top"},
			text: idString
		} ));
	}
	//Pick the correct dialog icon
	switch (severity) {
		case "message": dialog.iconImage = s_tgf_notification_message; break;
		case "warning": dialog.iconImage = s_tgf_notification_warning; break;
		default: dialog.iconImage = s_tgf_notification_error;
	}
	// Now show it, pausing the rest of the game
	dialog.onHide = function(dialog) {
		dialog.hide();
		tbGame.resumeTokens();
	};
	tbGame.pauseTokens();
	dialog.show();
};


// ***************************************
// Reporting errors to "us"
// ***************************************

// Report a message to us
TGFErrors.prototype.reportMessage = function(title, description, force, id) {
	"use strict";
	if (!this.reportMessages && !force) { return; }
	this.report(title, description, id, "message");
};

// Report a warning to us
TGFErrors.prototype.reporWarning = function(title, description, force, id) {
	"use strict";
	if (!this.reportWarnings && !force) { return; }
	this.report(title, description, id, "warning");
};

// Report an error to us
TGFErrors.prototype.reportError = function(title, description, force, id) {
	"use strict";
	if (!this.reportErrors && !force) { return; }
	this.report(title, description, id, "error");
};

// Report an error to us
TGFErrors.prototype.report = function(title, description, id, severity) {
	"use strict";
	var i, methods = [].concat(this.reportMethod);
	for (i = 0; i < methods.length; i += 1) {
		switch (methods[i]) {
			case "console": this.reportConsole(title, description, id, severity); break;
		}
	}
};

// Report an error on the console
TGFErrors.prototype.reportConsole = function(title, description, id, severity) {
	"use strict";
	var idString = (id !== undefined && this.reportId) ? " " + id : "";
	switch (severity) {
		case "message": console.log("MESSAGE" + idString + ": " + title); break;
		case "warning": console.log("WARNING" + idString + ": " + title); break;
		case "error": console.log("ERROR" + idString + ": " + title); break;
		default: console.log("ERROR: " + title);
	}
	if (description) { console.log("    Description: " + description); }
	if (this.reportVersion) { console.log("    Version: " + this.versionString); }
};


// ***************************************
// Create the object
// ***************************************

var tgfErrors = new TGFErrors();

//******************************************************
//*****    Script Resource: tgfAudio
//******************************************************

// ***************************************
// tgfAudio
//
// This object deals with the audio.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 26-6-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbBrowser, tbAudio */
/*global tgfFunctions, tgfSettings, tgfStatus */
/*global a_tgf_silence */
/*global window */

tgfSettings.audioDefaults = {
		silentSound: a_tgf_silence,						// Silent sound to play at start for initialization
		effectsTag: ["sfx", "effect", "game"],			// Tag used for sound effects (can be an array)
		musicTag: "music",								// Tag used for music (can be an array)
		effectsAvailable: true,							// Whether the game has sound effects
		musicAvailable: true,							// Whether the game has background music
		effectsAllowed: true,							// Whether to allow the playing of sound effects
		musicAllowed: true,								// Whether to allow the playing of background music
		musicMuted: false,								// Whether the background music is muted
		effectsMuted: false,							// Whether the sound effects are muted
		musicGain: 1,									// Global gain for the music
		effectsGain: 1									// Global gain for the sound effects
	};

// The constructor
var TGFAudio = function () {
	"use strict";
};


// ***************************************
// Initialization
// ***************************************

// Initialize the audio
TGFAudio.prototype.initialize = function(settings) {
	"use strict";
	var preferences = tgfStatus.getPreferencesData();
	this._setProperties(tgfSettings.audioDefaults);
	this._setProperties(settings);
	// Play the first silent sound
	this._handleFirstSound();
	// Read the settings from the player
	if (preferences.effectsGain !== undefined) { this.effectsGain = preferences.effectsGain; }
	if (preferences.musicGain !== undefined) { this.musicGain = preferences.musicGain; }
	if (preferences.effectsMuted !== undefined) { this.effectsMuted = preferences.effectsMuted; }
	if (preferences.musicMuted !== undefined) { this.musicMuted = preferences.musicMuted; }
	// Set the global gain and mute
	this.setEffectsGain(this.effectsGain);
	this.setMusicGain(this.musicGain);
	if (this.effectsMuted) { this.muteEffects(); } else { this.unmuteEffects(); }
	if (this.musicMuted) { this.muteMusic(); } else { this.unmuteMusic(); }
};

// Set a number of properties
TGFAudio.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};


// ***************************************
// Deal with playing first sound in user event
//		- This is required by e.g. iOS
// ***************************************

// Returns whether the sound is an effect
TGFAudio.prototype._handleFirstSound = function() {
	"use strict";
	var self = this;
	if (this.silentSound === undefined) { return; }
	this.silentSoundPlayed = false;
	// Define the callback function
	this.playSilentSound = function () {
		// Check whether already done
		if (self.silentSoundPlayed) { return; }
		self.silentSoundPlayed = true;
		// Play the sound
		tbAudio.play(self.silentSound);
		// Remove the event listeners
		window.removeEventListener('click', self.playSilentSound, false);
		window.removeEventListener('mousedown', self.playSilentSound, false);
		window.removeEventListener('touchstart', self.playSilentSound, false);
	};
	// Add it in a few event listeners
	window.addEventListener('click', this.playSilentSound, false);
	window.addEventListener('mousedown', this.playSilentSound, false);
	window.addEventListener('touchstart', this.playSilentSound, false);
};

// ***************************************
// Checking what a sound is
// ***************************************

// Returns whether the sound is an effect
TGFAudio.prototype.isEffect = function(sound) {
	"use strict";
	var soundTags = sound.getTags(),
		tags = [].concat(this.effectsTag),
		i;
	for (i = 0; i < tags.length; i += 1) {
		if (soundTags.indexOf(tags[i]) >= 0) { return true; }
	}
	return false;
};

// Returns whether the sound is music
TGFAudio.prototype.isMusic = function(sound) {
	"use strict";
	var soundTags = sound.getTags(),
		tags = [].concat(this.musicTag),
		i;
	for (i = 0; i < tags.length; i += 1) {
		if (soundTags.indexOf(tags[i]) >= 0) { return true; }
	}
	return false;
};

// Returns whether a sound can be played
TGFAudio.prototype.canPlay = function(sound) {
	"use strict";
	if (this.isEffect(sound) && this.effectsAvailable && this.effectsAllowed ) { return true; }
	if (this.isMusic(sound) && this.musicAvailable && this.musicAllowed ) { return true; }
	return false;
};


// ***************************************
// Muting and setting the global gain
// ***************************************

// Mute all effects
TGFAudio.prototype.muteEffects = function() {
	"use strict";
	var i, tags = [].concat(this.effectsTag);
	if (this.effectsAvailable && this.effectsAllowed) {
		for (i = 0; i < tags.length; i += 1) { tbAudio.mute(tags[i]); }
	}
};

// Mute all music
TGFAudio.prototype.muteMusic = function() {
	"use strict";
	var i, tags = [].concat(this.musicTag);
	if (this.musicAvailable && this.musicAllowed) {
		for (i = 0; i < tags.length; i += 1) { tbAudio.mute(tags[i]); }
	}
};

// Mute all effects
TGFAudio.prototype.unmuteEffects = function() {
	"use strict";
	var i, tags = [].concat(this.effectsTag);
	if (this.effectsAvailable && this.effectsAllowed) {
		for (i = 0; i < tags.length; i += 1) { tbAudio.unmute(tags[i]); }
	}
};

// Mute all music
TGFAudio.prototype.unmuteMusic = function() {
	"use strict";
	var i, tags = [].concat(this.musicTag);
	if (this.musicAvailable && this.musicAllowed) {
		for (i = 0; i < tags.length; i += 1) { tbAudio.unmute(tags[i]); }
	}
};

// Set gain for all effects
TGFAudio.prototype.setEffectsGain = function(gain) {
	"use strict";
	var i, tags = [].concat(this.effectsTag);
	if (this.effectsAvailable && this.effectsAllowed) {
		for (i = 0; i < tags.length; i += 1) { tbAudio.setGain(tags[i], gain); }
	}
};

// Set gain for all music
TGFAudio.prototype.setMusicGain = function(gain) {
	"use strict";
	var i, tags = [].concat(this.musicTag);
	if (this.musicAvailable && this.musicAllowed) {
		for (i = 0; i < tags.length; i += 1) { tbAudio.setGain(tags[i], gain); }
	}
};


// ***************************************
// Playing sound effects and music
//		- These simply replace the same methods in tbAudio
// ***************************************

TGFAudio.prototype.play = function(item, delay, fadeDuration, fadeEase) {
	"use strict";
	return this.canPlay(item) ? tbAudio.play(item, delay, fadeDuration, fadeEase) : undefined;
};

TGFAudio.prototype.stop = function(tag, fadeDuration, fadeEase) {
	"use strict";
	if (tag !== undefined) { tbAudio.stop(tag, fadeDuration, fadeEase); }
};

TGFAudio.prototype.isPlaying = function(id) {
	"use strict";
	return id !== undefined ? tbAudio.isPlaying(id) : false;
};

TGFAudio.prototype.isActive = function(id) {
	"use strict";
	return id !== undefined ? tbAudio.isActive(id) : false;
};

TGFAudio.prototype.pause = function(tag, duration, fadeDuration, fadeEase) {
	"use strict";
	if (tag !== undefined) { tbAudio.pause(tag, duration, fadeDuration, fadeEase); }
};

TGFAudio.prototype.resume = function(tag, fadeDuration, fadeEase) {
	"use strict";
	if (tag !== undefined) { tbAudio.resume(tag, fadeDuration, fadeEase); }
};

TGFAudio.prototype.isPaused = function(id) {
	"use strict";
	return id !== undefined ? tbAudio.isPaused(id) : false;
};

TGFAudio.prototype.fade = function(tag, targetValue, duration, easeFunction, callback) {
	"use strict";
	if (tag !== undefined) { tbAudio.fade(tag, targetValue, duration, easeFunction, callback); }
};

TGFAudio.prototype.getFading = function(id) {
	"use strict";
	return id !== undefined ? tbAudio.getFading(id) : 0;
};

TGFAudio.prototype.setLooping = function(tag, looping) {
	"use strict";
	if (tag !== undefined) { tbAudio.setLooping(tag, looping); }
};

TGFAudio.prototype.isLooping = function(id) {
	"use strict";
	return id !== undefined ? tbAudio.isLooping(id) : false;
};


// ***************************************
// Create the object
// ***************************************

var tgfAudio = new TGFAudio();

//******************************************************
//*****    Script Resource: tgfFramework
//******************************************************

// ***************************************
// tgfFramework
//
// This object deals with the global framework.
//
// Copyright 2015-2016 Tingly Games B.V.
// Last Changed: 04-03-2016
// ***************************************

// Directives for jslint
/*global tbGame, tbBrowser */
/*global tgfFunctions, tgfDialogs, tgfComponents, tgfProfile, tgfStatus, tgfDictionary, tgfGraphics, tgfSettings, tgfAnalytics, tgfAudio, tgfErrors, tgfConsole */
/*global window, document */

// TODO: Deal with some global checking, event handlers, etc.
// TODO: Is the event handling related to focus working correctly???? Probably not good enough, so improve


tgfSettings.frameworkDefaults = {
		name: "Tingly Games Framework",				// Name of the framework
		id: "tgf",									// Id of the framework
		version: "3.0.0",							// Version of the framework
		load: {										// The framework loading settings
			moments: [ "start", "startImages", "startAudio", "startFonts", "frameworkImages", "frameworkAudio", "frameworkFonts" ],	// The moments that must be loaded by the framework
			required: [ "start", "startImages", "frameworkImages"],																	// The moments that must be completed before continuing
			minTime: 0,															// Minimal loading time (in seconds) before continuing
			maxTime: 1															// Maximal loading time (in seconds) for the other moments before continuing
		},
		initErrors: true,							// Whether to initialize tgfErrors
		initGraphics: true,							// Whether to initialize tgfGraphics
		initConsole: true,							// Whether to initialize tgfConsole
		initProfile: true,							// Whether to initialize tgfProfile
		initStatus: true,							// Whether to initialize tgfStatus
		initDictionary: true,						// Whether to initialize tgfDictionary
		initAnalytics: true,						// Whether to initialize tgfAnalytics
		initAudio: true,							// Whether to initialize tgfAudio
		
		pauseOnHide: true,							// Whether to pause the game when the document (tab) is hidden
		pauseOnLosingFocus: true,					// Whether to pause the game on losing focus
		
		extraLoadMoments: [],						// Extra loading moments
		extraLoadRequired: []						// Extra required loading moments
	};

// The constructor
var TGFFramework = function () {
	"use strict";
};


// ***************************************
// Initialization
// ***************************************

// Initialize the framework
TGFFramework.prototype.initialize = function (settings, onSuccess, onFail) {
	"use strict";
	var self = this;
	// Initialize the framework itself
	this._setProperties(tgfSettings.frameworkDefaults);
	this._setProperties(settings);
	// Initialize the various framework components that can be done now (the order might matter!)
	if (this.initErrors) { tgfErrors.initialize(tgfSettings.errors); }
	if (this.initGraphics) { tgfGraphics.initialize(tgfSettings.graphics); }
	if (this.initConsole) { tgfConsole.initialize(tgfSettings.console); }
	if (this.initProfile) { tgfProfile.initialize(tgfSettings.profile);	}
	if (this.initStatus) { tgfStatus.initialize(tgfSettings.statusStorage, tgfSettings.status); }
	// Start the loading of the resources
	this._loadResources(this.extraLoadMoments, this.extraLoadRequired);
	// Create the timer to check whether initialization is ready
	this.initComplete = false;
	this.initFailed = false;
	this.initOnSuccess = onSuccess;
	this.initOnFail = onFail;
	this.initState = 0;
	this.initTimer = window.setInterval(
		function() { TGFFramework.prototype.checkInitState.call(self); },		
		50
	);
};

// Check the initialization state
TGFFramework.prototype.checkInitState = function() {
	"use strict";
	if (this.initState === 0) {				// Waiting for the status to be initialized
		if (!this.initStatus || tgfStatus.initComplete || tgfStatus.initFailed) {
			this.initState = 1;
			if (this.initDictionary) { tgfDictionary.initialize(tgfSettings.dictionary); }
			if (this.initAnalytics) { 
				tgfAnalytics.initialize(tgfSettings.analytics);
				tgfAnalytics.startSession();
			}
		}
	}
	if (this.initState === 1) {				// Waiting for the loading to be completed
		if (tgfFunctions.loadComplete()) {
			this.initState = 2;
			if (this.initAudio) { tgfAudio.initialize(tgfSettings.audio); }
			// Apply a hack to clear browser back buffer on Android stock browser
			tgfGraphics.performBufferClearHack();
		}
	}
	if (this.initState === 2) {				// Ready
		this.initComplete = true;
		this.initFailed = false;
		if (this.initStatus) { this.initComplete = this.initComplete && tgfStatus.initComplete; }
		if (this.initStatus) { this.initFailed = this.initFailed || tgfStatus.initFailed; }
		window.clearInterval(this.initTimer);
		if (this.initComplete && this.initOnSuccess) { this.initOnSuccess(); }
		if (this.initFailed && this.initOnFail) { this.initOnFail(); }
		this._initEvents();
	}
};


// ***************************************
// Internal methods
// ***************************************

// Set a number of properties
TGFFramework.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

// Load the framework resources
TGFFramework.prototype._loadResources = function (extraMoments, extraRequired) {
	"use strict";
	var moments = [], required = [];
	if (extraMoments === undefined) { extraMoments = []; }
	if (extraRequired === undefined) { extraRequired = []; }
	moments = moments.concat(this.load.moments);
	moments = moments.concat(extraMoments);
	required = required.concat(this.load.required);
	required = required.concat(extraRequired);
	tgfFunctions.loadStart( { moments: moments, required: required, minTime: this.load.minTime, maxTime: this.load.maxTime } );
	this.loadHandled = false;
};


// ***************************************
// Handling a number of events
// ***************************************

// Initialize the event handlers
TGFFramework.prototype._initEvents = function () {
	"use strict";
	var self = this;
	if (this.pauseOnHide) {
		document.addEventListener("visibilitychange", self._handleVisibilityChange, false);
	}
	if (this.pauseOnLosingFocus) {
		tgfGraphics.container.onfocus = self._handleFocus;
		tgfGraphics.container.onblur = self._handleBlur;
//		tgfGraphics.container.addEventListener("onfocus", self._handleFocus, false);
//		tgfGraphics.container.addEventListener("onblur", self._handleBlur, false);
	}
};

TGFFramework.prototype._handleVisibilityChange = function() {
	"use strict";
//	tgfConsole.addMessage("Event: visibilitychange. hidden: " + document.hidden);
	if (document.hidden) {
		tgfFunctions.pauseAll();
	} else {
		tgfFunctions.resumeAll();
	}
};

TGFFramework.prototype._handleFocus = function() {
	"use strict";
// PWH- Removed for Harvest Honors because multiplayer games need to keep going, even if one player looks at a different window.
//      If you add this back in, test the game in Internet Explorer, because IE will trigger the focus event
//      every time you click in the window. Even if the window was already focused.
//	tgfConsole.addMessage("Event: onfocus");
//	tgfFunctions.resumeAll();
};

TGFFramework.prototype._handleBlur = function() {
	"use strict";
//  PWH - Removed for Harvest Honors because multiplayer games need to keep going, even if one player looks at a different window.
//	tgfConsole.addMessage("Event: onblur");
//	tgfFunctions.pauseAll();
};


// ***************************************
// Create the object
// ***************************************

var tgfFramework = new TGFFramework();

//******************************************************
//*****    Script Resource: tgfHooks
//******************************************************

// ***************************************
// tgfHooks
//
// This namespace object deals with the hooks for the client. 
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 2-11-2015
// ***************************************

// Directives for jslint
/*global tbAudio, tbGame */
/*global flowController, gameController */
/*global window */

// Create the name space object
var tgfHooks = { };
window["tgfHooks"] = tgfHooks;			// Such that is still works after obfuscation

// Initialize the hooks, dealing with obfuscation
tgfHooks.initialize = function() {
	"use strict";
	// Getting information about the client
	if (!tgfHooks["getClientName"]) { tgfHooks["getClientName"] = tgfHooks.getClientName; }
	if (!tgfHooks["getClientId"]) { tgfHooks["getClientId"] = tgfHooks.getClientId; }
	if (!tgfHooks["getClientVersion"]) { tgfHooks["getClientVersion"] = tgfHooks.getClientVersion; }
	if (!tgfHooks["getAnalyticsTracking"]) { tgfHooks["getAnalyticsTracking"] = tgfHooks.getAnalyticsTracking; }
	if (!tgfHooks["getSiteLocks"]) { tgfHooks["getSiteLocks"] = tgfHooks.getSiteLocks; }
	if (!tgfHooks["getTimeLock"]) { tgfHooks["getTimeLock"] = tgfHooks.getTimeLock; }
	if (!tgfHooks["getInitialLanguage"]) { tgfHooks["getInitialLanguage"] = tgfHooks.getInitialLanguage; }
	if (!tgfHooks["getAvailableLanguages"]) { tgfHooks["getAvailableLanguages"] = tgfHooks.getAvailableLanguages; }
	if (!tgfHooks["getMoreGamesUrl"]) { tgfHooks["getMoreGamesUrl"] = tgfHooks.getMoreGamesUrl; }
	if (!tgfHooks["getMoreGamesFunction"]) { tgfHooks["getMoreGamesFunction"] = tgfHooks.getMoreGamesFunction; }
	if (!tgfHooks["getSplashScreenImage"]) { tgfHooks["getSplashScreenImage"] = tgfHooks.getSplashScreenImage; }
	if (!tgfHooks["getSplashScreenColor"]) { tgfHooks["getSplashScreenColor"] = tgfHooks.getSplashScreenColor; }
	if (!tgfHooks["getSplashScreenDuration"]) { tgfHooks["getSplashScreenDuration"] = tgfHooks.getSplashScreenDuration; }
	if (!tgfHooks["getClientLogo"]) { tgfHooks["getClientLogo"] = tgfHooks.getClientLogo; }
	if (!tgfHooks["getClientUrl"]) { tgfHooks["getClientUrl"] = tgfHooks.getClientUrl; }
	if (!tgfHooks["getClientFunction"]) { tgfHooks["getClientFunction"] = tgfHooks.getClientFunction; }
	if (!tgfHooks["getClientReplace"]) { tgfHooks["getClientReplace"] = tgfHooks.getClientReplace; }
	// Called during the flow
	if (!tgfHooks["beforeInitializing"]) { tgfHooks["beforeInitializing"] = tgfHooks.beforeInitializing; }
	if (!tgfHooks["afterInitializing"]) { tgfHooks["afterInitializing"] = tgfHooks.afterInitializing; }
	if (!tgfHooks["loadingProgress"]) { tgfHooks["loadingProgress"] = tgfHooks.loadingProgress; }
	if (!tgfHooks["afterLoading"]) { tgfHooks["afterLoading"] = tgfHooks.afterLoading; }
	if (!tgfHooks["beforeTitleScreen"]) { tgfHooks["beforeTitleScreen"] = tgfHooks.beforeTitleScreen; }
	if (!tgfHooks["beforeLevelScreen"]) { tgfHooks["beforeLevelScreen"] = tgfHooks.beforeLevelScreen; }
	if (!tgfHooks["beforePlay"]) { tgfHooks["beforePlay"] = tgfHooks.beforePlay; }
	if (!tgfHooks["playStart"]) { tgfHooks["playStart"] = tgfHooks.playStart; }
	if (!tgfHooks["playWon"]) { tgfHooks["playWon"] = tgfHooks.playWon; }
	if (!tgfHooks["playLost"]) { tgfHooks["playLost"] = tgfHooks.playLost; }
	if (!tgfHooks["playStage"]) { tgfHooks["playStage"] = tgfHooks.playStage; }
	if (!tgfHooks["playEnd"]) { tgfHooks["playEnd"] = tgfHooks.playEnd; }
	if (!tgfHooks["playRestart"]) { tgfHooks["playRestart"] = tgfHooks.playRestart; }
	if (!tgfHooks["stepGame"]) { tgfHooks["stepGame"] = tgfHooks.stepGame; }
	if (!tgfHooks["stepPlay"]) { tgfHooks["stepPlay"] = tgfHooks.stepPlay; }
	if (!tgfHooks["gameCompleted"]) { tgfHooks["gameCompleted"] = tgfHooks.gameCompleted; }	
	// TODO: Add other hooks here
	// Retrieve the data for the client using the different calls and putting it in the settings
	tgfHooks.retrieveInfo();
};

// Retrieve all the information from the client
tgfHooks.retrieveInfo = function() {
	"use strict";
	tgfSettings.client = tgfSettings.client || {};
	if (tgfHooks["getClientName"]) { tgfSettings.client.name = tgfHooks.execute("getClientName"); }
	if (tgfHooks["getClientId"]) { tgfSettings.client.id = tgfHooks.execute("getClientId"); }
	if (tgfHooks["getClientVersion"]) { tgfSettings.client.version = tgfHooks.execute("getClientVersion"); }
	if (tgfHooks["getAnalyticsTracking"]) { tgfSettings.client.analyticsTracking = tgfHooks.execute("getAnalyticsTracking"); }
	if (tgfHooks["getInitialLanguage"]) { tgfSettings.client.initialLanguage = tgfHooks.execute("getInitialLanguage"); }
	if (tgfHooks["getAvailableLanguages"]) { tgfSettings.client.availableLanguages = tgfHooks.execute("getAvailableLanguages"); }
	if (tgfHooks["getMoreGamesUrl"]) { tgfSettings.client.moreGameUrl = tgfHooks.execute("getMoreGamesUrl"); }
	if (tgfHooks["getMoreGamesFunction"]) { tgfSettings.client.moreGamesFunction = tgfHooks.execute("getMoreGamesFunction"); }
	if (tgfHooks["getSplashScreenImage"]) { tgfSettings.client.splashScreenImage = tgfHooks.execute("getSplashScreenImage"); }
	if (tgfHooks["getSplashScreenColor"]) { tgfSettings.client.splashScreenColor = tgfHooks.execute("getSplashScreenColor"); }
	if (tgfHooks["getSplashScreenDuration"]) { tgfSettings.client.splashScreenDuration = tgfHooks.execute("getSplashScreenDuration"); }
	if (tgfHooks["getClientLogo"]) { tgfSettings.client.logo = tgfHooks.execute("getClientLogo"); }
	if (tgfHooks["getClientUrl"]) { tgfSettings.client.logoUrl = tgfHooks.execute("getClientUrl"); }
	if (tgfHooks["getClientFunction"]) { tgfSettings.client.logoFunction = tgfHooks.execute("getClientFunction"); }
	if (tgfHooks["getClientReplace"]) { tgfSettings.client.logoReplace = tgfHooks.execute("getClientReplace"); }
};

// ***************************************
// Executing hooks, to be used in the flow object
// ***************************************

// Execute a hook
tgfHooks.execute = function(name, arg0, arg1, arg2, arg3, arg4) {
	"use strict";
	if (tgfHooks[name]) {
		return tgfHooks[name](arg0, arg1, arg2, arg3, arg4);
	}
	return undefined;
};



// ***************************************
// Dealing with pausing and resuming
// The client hooks can call these special hook functions to pause and resume
// It works both with obfuscated and non-obfuscated code
// ***************************************

// Pause the audio
tgfHooks.pauseAudio = function() {
	"use strict";
	tbAudio.pause("master");
};

// Resume the audio
tgfHooks.resumeAudio = function() {
	"use strict";
	tbAudio.resume("master");
};

// Pause the flow
tgfHooks.pauseFlow = function() {
	"use strict";
	flowController.pauseFlow();
};

// Resume the flow
tgfHooks.resumeFlow = function() {
	"use strict";
	tbGame.clearClickEvents();
	tbGame.clearTouchEvents();
	tbGame.clearKeyboardEvents();
	flowController.resumeFlow(false);
};

// Pause the game
tgfHooks.pauseGame = function() {
	"use strict";
	gameController.pausePlay();
};

// Resume the game
tgfHooks.resumeGame = function() {
	"use strict";
	tbGame.clearClickEvents();
	tbGame.clearTouchEvents();
	tbGame.clearKeyboardEvents();
	gameController.resumePlay(false);
};

// Pause everything
tgfHooks.pauseAll = function() {
	"use strict";
	tgfHooks.pauseFlow();
	tgfHooks.pauseGame();
	tgfHooks.pauseAudio();
};

// Resume everything
tgfHooks.resumeAll = function() {
	"use strict";
	tgfHooks.resumeFlow();
	tgfHooks.resumeGame();
	tgfHooks.resumeAudio();
};

// Deal with obfuscation
if (!tgfHooks["pauseFlow"]) { tgfHooks["pauseFlow"] = tgfHooks.pauseFlow; }
if (!tgfHooks["resumeFlow"]) { tgfHooks["resumeFlow"] = tgfHooks.resumeFlow; }
if (!tgfHooks["pauseGame"]) { tgfHooks["pauseGame"] = tgfHooks.pauseGame; }
if (!tgfHooks["resumeGame"]) { tgfHooks["resumeGame"] = tgfHooks.resumeGame; }
if (!tgfHooks["pauseAudio"]) { tgfHooks["pauseAudio"] = tgfHooks.pauseAudio; }
if (!tgfHooks["resumeAudio"]) { tgfHooks["resumeAudio"] = tgfHooks.resumeAudio; }
if (!tgfHooks["pauseAll"]) { tgfHooks["pauseAll"] = tgfHooks.pauseAll; }
if (!tgfHooks["resumeAll"]) { tgfHooks["resumeAll"] = tgfHooks.resumeAll; }


// ***************************************
// Converting and loading images
// ***************************************

// Converts an HTML image to a tbImage
tgfHooks.convertImage = function(name, image) {
	"use strict";
	return tbImageFromImage(name, image, image.width, image.height, 0, 0);
};

// Converts an HTML image file into a tbImage (will be asynchronous)
tgfHooks.convertImageFile = function(name, fname, width, height) {
	"use strict";
	return tbImageLoad(name, fname, width, height, 0, 0);
};

// Deal with obfuscation
if (!tgfHooks["convertImage"]) { tgfHooks["convertImage"] = tgfHooks.convertImage; }
if (!tgfHooks["convertImageFile"]) { tgfHooks["convertImageFile"] = tgfHooks.convertImageFile; }


// ***************************************
// Useful information for the hooks
// ***************************************

// Returns the id of the game
tgfHooks.gameId = function() {
	"use strict";
	return tgfSettings.game.id;
};

// Deal with obfuscation
if (!tgfHooks["gameId"]) { tgfHooks["gameId"] = tgfHooks.gameId; }

// TODO: Add info about scores, etc.
// TODO: Add analytics calls
// TODO: Add possibility to reset/set the highscore, etc.


// ***************************************
// The default empty information hooks that better be overriden by the client
// ***************************************

// Called to get the name of the client.
tgfHooks.getClientName = function() {
	"use strict";
	return "Unknown";
};

// Called to get the unique id of the client.
tgfHooks.getClientId = function() {
	"use strict";
	return "unknown";
};

// Called to get the version of the client hooks.
tgfHooks.getClientVersion = function() {
	"use strict";
	return "1.0";
};

// Called to get whether we track analytics for this client
tgfHooks.getAnalyticsTracking = function() {
	"use strict";
	return true;
};

// Called to get an array with the site locks (MD5 hashed) for the origins for this client
// (An origin is for example: "http://www.google.nl")
// When undefined, the game won't run, except in text mode
tgfHooks.getSiteLocks = function() {
	"use strict";
	return undefined;
};

// Called to get a time lock (date). When undefined the game will always run.
tgfHooks.getTimeLock = function() {
	"use strict";
	return undefined;
};

// Called to get the initial language for this client. Undefined for default.
tgfHooks.getInitialLanguage = function() {
	"use strict";
	return undefined;
};

// Called to get an array of the available languages for this client. Undefined for all.
tgfHooks.getAvailableLanguages = function() {
	"use strict";
	return undefined;
};

// Called to get the more games url.
tgfHooks.getMoreGamesUrl = function() {
	"use strict";
	return undefined;
};

// Called to get the function for more games.
tgfHooks.getMoreGamesFunction = function() {
	"use strict";
	return undefined;
};

// Called to get a splash screen tbImage or tbSurface.
tgfHooks.getSplashScreenImage = function() {
	"use strict";
	return undefined;
};

// Called to get a splash screen background color
tgfHooks.getSplashScreenColor = function() {
	"use strict";
	return undefined;
};

// Called to get a splash screen duration in seconds
tgfHooks.getSplashScreenDuration = function() {
	"use strict";
	return undefined;
};

// Called to get a client logo tbImage or tbSurface.
tgfHooks.getClientLogo = function() {
	"use strict";
	return undefined;
};

// Called to get a client url that is used when clicking the client image.
tgfHooks.getClientUrl = function() {
	"use strict";
	return undefined;
};

// Called to get a client function that is called when clicking the client image.
tgfHooks.getClientFunction = function() {
	"use strict";
	return undefined;
};

// Called to see whether the client logo should replace our logo
tgfHooks.getClientReplace = function() {
	"use strict";
	return undefined;
};


// ***************************************
// The default empty flow hooks that can be overriden by the client
// ***************************************

// Called before any initialization takes place. Settings for flow, theme, game, and client have been
// filled in. This is the default place to initialize client API's and request/set-up
// logo's and/splash screen images for the loading and start page.
tgfHooks.beforeInitializing = function() {
	"use strict";
};

// Called after the framework has been initialized. Also all images with the "start" moment have now
// been loaded. The other loading has not yet happened not has the load screen been shown. This
// can be used to draw splash-screens of which images are included in the "start" sprite sheets
tgfHooks.afterInitializing = function() {
	"use strict";
};

// Called every step during loading to inform of loading progress. Parameter: loading progress in percentages
tgfHooks.loadingProgress = function(progress) {
	"use strict";
};

// Called when loading has finished and start screen (i.e. buttons and logo) are about to be shown
tgfHooks.afterLoading = function() {
	"use strict";
};

// Called each time before the tile screen is shown, Here you could show an ad,
// or save some statistics.
tgfHooks.beforeTitleScreen = function() {
	"use strict";
};

// Called each time before the level selection screen is shown, Here you could show an ad,
// or save some statistics.
tgfHooks.beforeLevelScreen = function() {
	"use strict";
};

// Called each time a play is started, before any game related stuff is shown or initialized
tgfHooks.beforePlay = function() {
	"use strict";
};

// Called each time a play is started, just before the start game screen dialog is shown
// mode indicated the mode starting with 1 (undefined if no mode)
// level indicates the level starting with 1 (undefined if no levels)
// Return the action to take ("dialog", "nodialog") Default is to show the dialog
tgfHooks.playStart = function(mode, level) {
	"use strict";
};

// Called each time a play is won. Score, time, stars, and moves are the results of the play
// They might be undefined if this information is not relevant for the game
// This is called just before our own end of play dialog is shown
// Return the action to take ("dialog", "title", "level", "restart", "next") Default is to show the dialog
tgfHooks.playWon = function(score, time, stars, moves) {
	"use strict";
};

// Called each time a play is lost.
// This is called just before our own end of play dialog is shown
// Return the action to take ("dialog", "title", "level", "restart", "next") Default is to show the dialog
tgfHooks.playLost = function() {
	"use strict";
};

// Called each time a stage is completed. stage is the number of the stage (starting with 1)
// Score, time, stars, and moves are the results of the stage
// They might be undefined if this information is not relevant for the game
// This is called just before our own stage completed dialog is shown
// Return the action to take ("dialog", "nodialog") Default is to show the dialog
tgfHooks.playStage = function(stage, score, time, stars, moves) {
	"use strict";
};

// Called at the end of the play, when  everything is cleaned up. (also when the player quit the game through the menu)
// quit indicates whether the player quit through the menu and, hence,  did not finish the play
// This is the ideal place to show ads
tgfHooks.playEnd = function(quit) {
	"use strict";
};

//Called when game restarted
tgfHooks.playRestart = function(){
	"use strict";
};

// Called each step during the running of the game (also during the framework dialogs)
tgfHooks.stepGame = function(timePassed) {
	"use strict";
};

// Called each step during the playing only
tgfHooks.stepPlay = function(timePassed) {
	"use strict";
};

// Called when the game is completed and the game complete screen is shown (so after playEnd)
// Does only happen for level based games
tgfHooks.gameCompleted = function() {
	"use strict";
};


//******************************************************
//*****    Token Resource: TokenFPS
//******************************************************

/////////////////////////////////////////////////////////////
// tokenFPS: A token that displays the current frame rate (in fps).
// You can also indicate whether to also show the milliseconds per frame.
//
// The token is automatically created, but only when in test mode.
// You should change the creation call to change the position, etc.
//
// Written by Mark Overmars
// Copyright 2013 Tingly Games
// Last Changed: 24-12-2013
/////////////////////////////////////////////////////////////

function tokenFPS(labelComponent, showMin, showAvg, showSize, showMs) {
	"use strict";
	this.depth = -1000;         // Make sure it is above everything
	this.visible = true;                // Draw it
	this.active = true;                 // Handle it
	this.group = "special";             // Different from default
	this.labelComponent = labelComponent;
	// Your own properties
	// this.x = x;
	// this.y = y;
	// this.color = color || "black";
	// this.font = font || "bold 16px Arial";
	this.frameTimeList = [];
	this.showMs = showMs || false;
	this.showSize = showSize || false;
	this.showMin = showMin || false;
	this.showAvg = showAvg || false;
	this.showCurrent = true;
	this.lastFPS = 0;
	this.oldFPS = 0;
	this.currentFPS = 0;
	this.steps = 0;
	this.min = -1;
	this.avg = 0;
	this.totFPS = 0;
	this.totTime = 0;
	this.totalTimePassed = 0;
	//TG.functions.setLayerAndCanvas(this, TG.gameEffectsLayer);
	
	this.redraw = true;
	//this.surface = new tbSurface(500, 20);

	// Finally, add it to the game engine
	tbGame.addToken(this);
}

tokenFPS.prototype.getAverageFPSAndLows = function (lowsRange) {
	
	var frames = this.frameTimeList.sort(function (a, b) { return b - a; });
	var lows = 0;
	var lowCount = 0;
	var average = 0;
	
	for (var a = 0; a < frames.length; a++) {
		
		if (a < lowsRange * frames.length) {
			
			lows += frames[a];
			lowCount++;
		}
		
		average += frames[a];
	}
	
	return [(lowCount / (0.001 * lows)).toFixed(1), (frames.length / (0.001 * average)).toFixed(1)];
};

tokenFPS.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	// Each step, update the number of steps until a second has passed
	//this.steps = Math.round(1000.0/timePassed);
	
	this.frameTimeList.push(timePassed);
	
	this.totTime += timePassed;
	this.steps += 1;

	var oldFPS = this.currentFPS;

	this.currentFPS = Math.round(1000 / timePassed);

	if (Math.abs(oldFPS - this.currentFPS) < 5) {
		this.currentFPS = oldFPS;
	} else {
		this.oldFPS = oldFPS;
	}

	if(this.totTime >= 1000){
		this.lastFPS = this.steps;
		this.totFPS += this.lastFPS;
		this.totTime = 0;
		
		this.redraw = true;
		//this.canvas.drawTokens = true;
		
		this.steps = 0;
		this.min = -1;

		if(this.lastFPS > 0 && (this.min < 0 || this.lastFPS < this.min)){
			this.min = this.lastFPS;
		}

		this.avg = Math.round(this.totFPS/this.totalTimePassed);

	}

	/*
	this.lastFPS = this.steps;
	this.totFPS += this.lastFPS;
	this.totTime += 1;
	*/
	this.totalTimePassed += timePassed/1000;

};

tokenFPS.prototype.handleDraw = function() {
	"use strict";
	
	if (this.redraw) {
		this.redraw = false;
		this.drawSurface();
	}
	//
	// this.surface.drawSimple(this.x, this.y);
};

tokenFPS.prototype.drawSurface = function() {
	"use strict";
	
	// this.surface.setTarget();
	// this.surface.clear();
	
	var str = "FPS: " + this.lastFPS;
	if(this.showMin){
		str += " min: "+this.min;
	}
	if(this.showAvg && this.totTime > 0){
		str += " avg: "+ this.avg;
	}
	if(this.showMs && this.lastFPS > 0){
		str += " (" + Math.round(1000/this.lastFPS) + " ms)";
	}
	if (this.showCurrent && this.currentFPS > 0) {
		str += " cur: "+this.oldFPS + "-" +this.currentFPS;
	}

	str += " tokens: "+tbGame._tokens.length;

	if(this.showSize){
		str += "\n MAX_TEXTURES " + PIXI["settings"]["SPRITE_MAX_TEXTURES"];
	}



    this.labelComponent.setText(str);
	// str += " drawCallsBitmap: " + tbGraphics.drawCallsBitmap;
	//tbGraphics.drawCallsBitmap = 0;
	// str += " drawCallsFont: " + tbGraphics.drawCallsFont;
	//tbGraphics.drawCallsFont = 0;
	

	//tbGraphics.drawText(str, 1, 13, "black", this.font);
	//tbGraphics.drawText(str, 0, 12, this.color, this.font);



	// this.surface.resetTarget();
};

// Change the creation call when desired
//TG.fps = new tokenFPS(5 + TG.gameOffsetX, 16 + TG.gameOffsetY + TG.gameHeight, (TG.fpsColor || "white"), (TG.fpsFont || "bold 16px Arial"), true, false, true, false);



//******************************************************
//*****    Script Resource: tgfComponents
//******************************************************

// ***************************************
// tgfComponents
//
// This object contains all the components and some useful
// global methods related to the components
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 2-6-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


var tgfComponents = {};

// Create the settings group for the components
tgfSettings.componentDefaults = {};

// Let component C inherit the prototype of P, using the Holy Grail inheritance (JavaScript Patterns, page 127)
tgfComponents.inherit = function(C, P) {
	"use strict";
	var F = function(){};
	F.prototype = P.prototype;
	C.prototype = new F();
	C.uber = P.prototype;
	C.prototype.constructor = C;
};
//******************************************************
//*****    Script Resource: tgfComponentsDesignSupport
//******************************************************

// ***************************************
// tgfComponentsDesignSupport
//
// This object contains all some functions that helps designing the
// component placements in dialogs
//
// THIS IS A BIT OF A HACK
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 25-10-2015
// ***************************************

// Directives for jslint
/*global console */
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame, testMode, tbKeyCodes */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */

// ***************************************
// Definition of the token handing the design support
// ***************************************

// The constructor for the tgfComponentsDesignSupport game token. 
var TgfComponentsDesignSupport = function() {
	"use strict";
	// Properties used by the engine
	this.depth = -100000;	
	this.layer = -100000;
	this.visible = false;
	this.active = true;
	// Your own properties
	this.drawOutlines = false;						// Whether to draw outlines
	this.drawPositions = false;						// Whether to draw positions of the components
	this.drawNames = false;							// Whether to draw the component names
	this.selectedComponent = null;					// The component that is currently being moved
	this.movingComponent = false;					// Whether a component is being moved
	this.moveTimer = 0;								// Timer for moving with arrow keys
	this.moveHor = 0;								// Horizontal movement speed
	this.moveVert = 0;								// Vertical movement speed
	// Add it to the game engine
	tbGame.addToken(this);
};

// checks whether the design key combination is pressed.
TgfComponentsDesignSupport.prototype.checkKeyCombination = function() { 
	"use strict";
	if (!tbGame.keyboardKeyDown(tbKeyCodes.vkControl)) { return false; }
	if (!tbGame.keyboardKeyDown(tbKeyCodes.vkAlt)) { return false; }
	if (!tbGame.keyboardKeyDown(tbKeyCodes.vkShift)) { return false; }
	return true;
};

// handleKeyDown is called if the key with the given keyCode is pressed.
TgfComponentsDesignSupport.prototype.handleKeyDown = function(keyCode) { 
	"use strict";
	var languages, language, i, ind = 0;
	if (!this.checkKeyCombination()) { return; }
	switch (keyCode) {
		case tbKeyCodes.vkL: 
			languages = tgfDictionary.getAvailableLanguages();
			language = tgfDictionary.getLanguage();
			for (i = 0; i < languages.length; i += 1) { 
				if (languages[i] === language) { ind = (i+1) % languages.length; }
			}
			tgfDictionary.setLanguage(languages[ind]);
			break;
		case tbKeyCodes.vkO: this.drawOutlines = !this.drawOutlines; break;
		case tbKeyCodes.vkP: this.drawPositions = !this.drawPositions; break;
		case tbKeyCodes.vkN: this.drawNames = !this.drawNames; break;
		case tbKeyCodes.vkC: 
			if (this.selectedComponent) {
				console.log("x: tgfScale(" + Math.round(this.selectedComponent.designSupportData.moveX + this.selectedComponent.x) + "),\n" + 
					"y: tgfScale(" + Math.round(this.selectedComponent.designSupportData.moveY + this.selectedComponent.y) + "),\n");
			}
			break;
		case tbKeyCodes.vkLeft:
			if (this.selectedComponent) {
				this.selectedComponent.designSupportData.moveX -= 1;
				this.moveTimer = 0.5;
				this.moveHor = -1;
			}
			break;
		case tbKeyCodes.vkRight:
			if (this.selectedComponent) {
				this.selectedComponent.designSupportData.moveX += 1;
				this.moveTimer = 0.5;
				this.moveHor = 1;
			}
			break;
		case tbKeyCodes.vkUp:
			if (this.selectedComponent) {
				this.selectedComponent.designSupportData.moveY -= 1;
				this.moveTimer = 0.5;
				this.moveVert = -1;
			}
			break;
		case tbKeyCodes.vkDown:
			if (this.selectedComponent) {
				this.selectedComponent.designSupportData.moveY += 1;
				this.moveTimer = 0.5;
				this.moveVert = 1;
			}
			break;
	}
};

// handleKeyUp is called if the key with the given keyCode is released.
TgfComponentsDesignSupport.prototype.handleKeyUp = function(keyCode) { 
	"use strict";
	switch (keyCode) {
		case tbKeyCodes.vkLeft: this.moveHor = 0; break;
		case tbKeyCodes.vkRight: this.moveHor = 0; break;
		case tbKeyCodes.vkUp: this.moveVert = 0; break;
		case tbKeyCodes.vkDown: this.moveVert = 0; break;
	}
};

// handleEndStep is called each step after processing other events (before draw).
TgfComponentsDesignSupport.prototype.handleEndStep = function(timePassed) { 
	"use strict";
	var touchX, touchY;
	if (!this.checkKeyCombination()) { return; }	
	// Handle the movement by dragging
	if (this.movingComponent && this.selectedComponent) {
		touchX = tbGame.touchX(0);
		touchY = tbGame.touchY(0);
		this.selectedComponent.designSupportData.moveX += touchX - this.selectedComponent.designSupportData.startX;
		this.selectedComponent.designSupportData.moveY += touchY - this.selectedComponent.designSupportData.startY;
		this.selectedComponent.designSupportData.startX = touchX;
		this.selectedComponent.designSupportData.startY = touchY;
	}
	// Handle the movement by arrow keys
	if (this.selectedComponent) {
		this.moveTimer -= timePassed/1000;
		if (this.moveTimer <= 0) {
			this.selectedComponent.designSupportData.moveX += this.moveHor * timePassed / 100;
			this.selectedComponent.designSupportData.moveY += this.moveVert * timePassed / 100;
		}
	}
};

// Initialize the design information for a component
TgfComponentsDesignSupport.prototype.componentInitialize = function(component) {
	"use strict";
	component.designSupportData = {
		moveX: 0,				// Amount shifted horizontally
		moveY: 0,				// Amount shifted vertically
		startX: 0,				// Start x-position when touching it
		startY: 0				// Start y-position when touching it
	};
};

// Handles the design support aspects for the touch down event for a component
TgfComponentsDesignSupport.prototype.componentTouchDown = function(component, finger, x, y) {
	"use strict";
	var xm, ym, xx, yy, ww, hh;
	if (!this.checkKeyCombination()) { return; }	
	xm = component.screenToComponentX(x, y);
	ym = component.screenToComponentY(x, y);
	ww = component.getWidth();
	hh = component.getHeight();
	xx = component.getLeft();
	yy = component.getTop();
	if (ww && hh && xm > xx && xm < xx + ww && ym > yy && ym < yy + hh) {
		component.designSupportData.startX = x;
		component.designSupportData.startY = y;
		this.selectedComponent = component;
		this.movingComponent = true;
		return true;
	}
	return false;
};

// Handles the design support aspects for the touch up event for a component
TgfComponentsDesignSupport.prototype.componentTouchUp = function(component, finger, x, y) {
	"use strict";
	this.movingComponent = false;
};

// Draw the design information for a component
TgfComponentsDesignSupport.prototype.componentDraw = function(component) {
	"use strict";
	var xx, yy, ww, hh, col, txt, tx, ty, tw, th, fnt;
	// Draw the outlines
	if (this.drawOutlines) {
		ww = component.getWidth();
		hh = component.getHeight();
		xx = component.getLeft();
		yy = component.getTop();
		col = this.selectedComponent === component ? "red" : "blue";
		if (ww  && hh) {
			tbGraphics.drawRectangle(xx, yy, ww, hh, undefined, "white", 3);
			tbGraphics.drawRectangle(xx, yy, ww, hh, undefined, col, 1);
		}
	}
	// Draw the names
	if (this.drawNames) {
		txt = component.name === undefined ? "undefined" : component.name;
		fnt = "bold 12px Arial";
		col = this.selectedComponent === component ? "red" : "blue";
		tw = tbGraphics.textWidth(txt, fnt) + 4; 
		th = 16;
		tx = component.getLeft();
		ty = component.getTop();
		tbGraphics.drawRectangle(tx, ty, tw, th, "rgba(255, 255, 255, 0.8)" );
		tbGraphics.drawText(txt, tx+2, ty+th-4, col, fnt);
	}
	// Draw the positions
	if (this.drawPositions) {
		txt = "X: " + Math.round(component.designSupportData.moveX + component.x) + " Y: " + Math.round(component.designSupportData.moveY + component.y);
		fnt = "bold 12px Arial";
		tw = tbGraphics.textWidth(txt, fnt) + 4; 
		th = 16;
		tx = - Math.round(tw/2);
		ty = - Math.round(th/2);
		tbGraphics.drawRectangle(tx, ty, tw, th, "rgba(255, 255, 255, 0.8)" );
		tbGraphics.drawText(txt, tx+2, ty+th-4, "black", fnt);
	}
};

// Create the token or an undefined object in non-test mode
var tgfComponentsDesignSupport = testMode ? new TgfComponentsDesignSupport() : undefined;

//******************************************************
//*****    Script Resource: tgfEffects
//******************************************************

// ***************************************
// tgfEffects
//
// This object contains all available effects
// for components. Feel free to extend
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 17-6-2015
// ***************************************

//TODO: Add more effects here

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */

var tgfEffects = { };

// Return the effect with the given name
tgfEffects.effect = function(name) {
	"use strict";
	switch (name) {
		case "nothing" : return tgfEffects.nothing;
		case "show" : return tgfEffects.show;
		case "hide" : return tgfEffects.hide;
		case "fadeIn" : return tgfEffects.fadeIn;
		case "fadeOut" : return tgfEffects.fadeOut;
		case "move" : return tgfEffects.move;
		case "scale" : return tgfEffects.scale;
		case "rotate" : return tgfEffects.rotate;
		case "alpha" : return tgfEffects.alpha;
		case "transform" : return tgfEffects.transform;
		case "blink" : return tgfEffects.blink;
		default: return tgfEffects.nothing;
	}
};

// An effect that does absolutely nothing
tgfEffects.nothing = function(component, effect, time) {
	"use strict";
};

// Simply showing the components
tgfEffects.show = function(component, effect, time) {
	"use strict";
	component.setAlpha(1);
};

// Simply hiding the components
tgfEffects.hide = function(component, effect, time) {
	"use strict";
	component.setAlpha(0);
};

// Simple effect to make components appear using alpha
tgfEffects.fadeIn = function(component, effect, time) {
	"use strict";
	var ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease;
	component.setAlpha(ease(time, 0, 1, effect.duration, effect.easeArgument));
};

// Simple effect to make components appear using alpha
tgfEffects.fadeOut = function(component, effect, time) {
	"use strict";
	var ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease;
	component.setAlpha(ease(time, 1, -1, effect.duration, effect.easeArgument));
};

// Simple effect to make components move
tgfEffects.move = function(component, effect, time) {
	"use strict";
	var ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease,
		easeArgument = effect.easeArgument === undefined ? undefined : effect.easeArgument,
		startX = effect.startX === undefined ? 0 : effect.startX,
		endX = effect.endX === undefined ? 0 : effect.endX,
		startY = effect.startY === undefined ? 0 : effect.startY,
		endY = effect.endY === undefined ? 0 : effect.endY;

	var x = (effect.startX !== undefined || effect.endX !== undefined) ?
		ease(time, startX, endX-startX, effect.duration, easeArgument) :
		component.x;

	var y = (effect.startY !== undefined || effect.endY !== undefined) ?
		ease(time, startY, endY-startY, effect.duration, easeArgument) :
		component.y;
	
	component.setPosition(x, y);

};

// Simple effect to make components rotate
tgfEffects.rotate = function(component, effect, time) {
	"use strict";
	var ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease,
		easeArgument = effect.easeArgument === undefined ? undefined : effect.easeArgument,
		startAngle = effect.startAngle === undefined ? 0 : effect.startAngle,
		endAngle = effect.endAngle === undefined ? 0 : effect.endAngle;
	component.setAngle(ease(time, startAngle, endAngle-startAngle, effect.duration, easeArgument));
};

// Simple effect to make components scale
tgfEffects.scale = function(component, effect, time) {
	"use strict";
	var	ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease,
		easeArgument = effect.easeArgument === undefined ? undefined : effect.easeArgument,
		startScale = effect.startScale === undefined ? 1 : effect.startScale,
		endScale = effect.endScale === undefined ? 1 : effect.endScale;
	var scale = ease(time, startScale, endScale-startScale, effect.duration, easeArgument);
	component.setScale(scale, scale);
};

// Simple effect to change the alpha of the components
tgfEffects.alpha = function(component, effect, time) {
	"use strict";
	var	ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease,
		easeArgument = effect.easeArgument === undefined ? undefined : effect.easeArgument,
		startAlpha = effect.startAlpha === undefined ? 1 : effect.startAlpha,
		endAlpha = effect.endAlpha === undefined ? 1 : effect.endAlpha;

	component.setAlpha(ease(time, startAlpha, endAlpha-startAlpha, effect.duration, easeArgument));
};

// Effect to make components transform, with alpha
tgfEffects.transform = function(component, effect, time) {
	"use strict";
	var ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease,
		easeArgument = effect.easeArgument === undefined ? undefined : effect.easeArgument,
		startX = effect.startX === undefined ? 0 : effect.startX,
		endX = effect.endX === undefined ? 0 : effect.endX,
		startY = effect.startY === undefined ? 0 : effect.startY,
		endY = effect.endY === undefined ? 0 : effect.endY,
		easeMove = effect.easeMove === undefined ? ease : effect.easeMove,
		easeMoveArgument = effect.easeMoveArgument === undefined ? easeArgument : effect.easeMoveArgument,
		startScale = effect.startScale === undefined ? 1 : effect.startScale,
		endScale = effect.endScale === undefined ? 1 : effect.endScale,
		easeScale = effect.easeScale === undefined ? ease : effect.easeScale,
		easeScaleArgument = effect.easeScaleArgument === undefined ? easeArgument : effect.easeScaleArgument,
		startAngle = effect.startAngle === undefined ? 0 : effect.startAngle,
		endAngle = effect.endAngle === undefined ? 0 : effect.endAngle,
		easeRotate = effect.easeRotate === undefined ? ease : effect.easeRotate,
		easeRotateArgument = effect.easeRotateArgument === undefined ? easeArgument : effect.easeRotateArgument,
		startAlpha = effect.startAlpha === undefined ? 1 : effect.startAlpha,
		endAlpha = effect.endAlpha === undefined ? 1 : effect.endAlpha,
		easeAlpha = effect.easeAlpha === undefined ? ease : effect.easeAlpha,
		easeAlphaArgument = effect.easeAlphaArgument === undefined ? easeArgument : effect.easeAlphaArgument;
	
	var x = easeMove(time, startX, endX-startX, effect.duration, easeMoveArgument);
	var y = easeMove(time, startY, endY-startY, effect.duration, easeMoveArgument);
	component.setPosition(x, y);

	var scale = easeScale(time, startScale, endScale-startScale, effect.duration, easeScaleArgument);
	component.setScale(scale, scale);
	component.setAngle(easeRotate(time, startAngle, endAngle-startAngle, effect.duration, easeRotateArgument));
	component.setAlpha(easeAlpha(time, startAlpha, endAlpha-startAlpha, effect.duration, easeAlphaArgument));
};

// Blinking effect
tgfEffects.blink = function(component, effect, time) {
	"use strict";
	var frequency = effect.frequency === undefined ? 1 : effect.frequency,
		fade = effect.fade === undefined ? 0 : effect.fade,
		stepTime = 1 / (2*frequency),
		step = Math.floor(time/stepTime),
		on = step % 2 === 0,
		prog = time % stepTime;
	if (on) {
		component.setAlpha(Math.min(1, prog / fade));
	} else {
		component.setAlpha(1 - Math.min(1, prog / fade));
	}
};



//******************************************************
//*****    Script Resource: ComponentBase
//******************************************************

// ***************************************
// tgfComponents.Base
//
// This component contains the basic functionality of all components
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 27-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame, tbVector */
/*global tgfFunctions, tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings, tgfComponentsDesignSupport */


tgfSettings.componentDefaults.base = {
	tags: [],							// The tags
	// Position and size
	x: 0,								// The x-position of the center of component, relative to the parent
	y: 0,								// The y-position of the center of component, relative to the parent
	width: 0,							// Width of the component
	height: 0,							// Height of the component
	// Transformation
	xScale: 1,							// Horizontal scale factor
	yScale: 1,							// Vertical scale factor
	angle: 0,							// Rotation angle
	alpha: 1,							// Alpha transparency
	// Effects
	effects: null,						// The effect or array of effects to apply
	pauseEffectsOnDeactivate: false,	// Whether to pause when not being active
	repeatEffect: 99999999,				// Number of times to repeat the effects
	effectWaitSteps: 2,					// Number of steps to wait before updating the effect timer (to avoid hick-ups)
	onEffectStart: null,				// Called when the effects starts
	onEffectEnd: null,					// Called when the effects ends
	onSubEffectStart: null,				// Called when a sub effect starts (sub-effect index is passed as argument)
	onSubEffectEnd: null,				// Called when a sub effect ends (sub-effect index is passed as argument)
    baseContainer: null
};


// The constructor for the base component (not called for inherited components!)
/**
 * @constructor
 */
tgfComponents.Base = function(properties) {
	"use strict";
	// Initialize properties
	this.initialize();
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};


// ***************************************
// General methods
// ***************************************

tgfComponents.Base.prototype.addChild = function(child){
	"use strict";
    this.baseContainer.addChild(child);
};

// Initialize the properties of the component
tgfComponents.Base.prototype.initialize = function(properties) {
	"use strict";
	this.setProperties(tgfSettings.componentDefaults.base);	// The base properties must always be included first
	this.setProperties(properties);
	this.parent = null;					// The parent component or dialog
	this.kind = "component";			// The kind (must be "component")
	this.isPrepared = false;			// Whether prepared (true, false)
	this.isVisible = false;				// Whether visible (true, false)
	this.isActive = false;				// Whether active (true, false)
	this._components = [];				// The child components
	// Handle design support
	if (tgfComponentsDesignSupport) {
		tgfComponentsDesignSupport.componentInitialize(this);
	}
};

tgfComponents.Base.prototype.setPosition = function(x, y){
    "use strict";
	this.x = x;
	this.y = y;
};

tgfComponents.Base.prototype.setAngle = function(angle){
    "use strict";
    this.angle = angle;
};

tgfComponents.Base.prototype.setAlpha = function(alpha) {
	this.alpha = alpha;
}

tgfComponents.Base.prototype.setScale = function(xScale, yScale) {
	"use strict";
	this.xScale = xScale;
	this.yScale = yScale;
};

// Set a number of properties of the component
tgfComponents.Base.prototype.setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

// Set the parent of the component to a component or dialog
tgfComponents.Base.prototype.setParent = function(parent) {
	"use strict";
	if (this.parent !== null) {
		parent.removeComponent(this);
	}
	parent.addComponent(this);
};

// Returns the parent
tgfComponents.Base.prototype.getParent = function() {
	"use strict";
	return this.parent;
};

// Returns the dialog the component belongs to
tgfComponents.Base.prototype.getDialog = function() {
	"use strict";
	var result = this.parent;
	while (result !== null && result.kind !== "dialog") {
		result = result.parent;
	}
	return result;
};

// Transform the screen (x,y)-coordinate to the component x-coordinate
tgfComponents.Base.prototype.screenToComponentX = function(screenX, screenY) {
	"use strict";
	var x, y, rot = this.angle * Math.PI / 180;
	// Find position with respect to parent
	if (this.parent !== null) {
		x = this.parent.screenToComponentX(screenX, screenY);
		y = this.parent.screenToComponentY(screenX, screenY);
	} else {
		x = screenX;
		y = screenY;
	}
	// Adapt during design support
	if (tgfComponentsDesignSupport) {
		x -= this.designSupportData.moveX;
		y -= this.designSupportData.moveY;
	}
	// Compute position after the transformation
	x = x - this.x;
	if (this.angle !== 0) {	x = x * Math.cos(rot) - y * Math.sin(rot); }
	if (this.xScale !== 0 && this.xScale !== 1) { x /= this.xScale; }
	return x;
};

// Transform the screen (x,y)-coordinate to the component y-coordinate
tgfComponents.Base.prototype.screenToComponentY = function(screenX, screenY) {
	"use strict";
	var x, y, rot = this.angle * Math.PI / 180;
	// Find position with respect to parent
	if (this.parent !== null) {
		x = this.parent.screenToComponentX(screenX, screenY);
		y = this.parent.screenToComponentY(screenX, screenY);
	} else {
		x = screenX;
		y = screenY;
	}
	// Adapt during design support
	if (tgfComponentsDesignSupport) {
		x -= this.designSupportData.moveX;
		y -= this.designSupportData.moveY;
	}
	// Compute position after the transformation
	y = y - this.y;
	if (this.angle !== 0) { y = x * Math.sin(rot) + y * Math.cos(rot); }
	if (this.yScale !== 0 && this.yScale !== 1) { y /= this.yScale; }
	return y;
};

// Transform the screen (x,y)-coordinate to a component-space vector
tgfComponents.Base.prototype.screenToComponentVector = function(screenX, screenY) {
	"use strict";
	return new tbVector(this.screenToComponentX(screenX, screenY), this.screenToComponentY(screenX, screenY));
};

// Transform the component (x,y)-coordinate to the screen x-coordinate
tgfComponents.Base.prototype.componentToScreenX = function(componentX, componentY) {
	"use strict";
	var x = componentX, y = componentY, rot = this.angle * Math.PI / 180;
	x *= this.xScale === 0 ? 1 : this.xScale; 
	y *= this.yScale === 0 ? 1 : this.yScale;
	if (this.angle !== 0) {	
		x = x * Math.cos(rot) - y * Math.sin(rot);
		y = x * Math.sin(rot) + y * Math.cos(rot);
	}
	// Adapt during design support
	if (tgfComponentsDesignSupport) {
		x -= this.designSupportData.moveX;
		y -= this.designSupportData.moveY;
	}
	// Find position with respect to parent if it exists
	if (this.parent !== null) {
		return this.parent.componentToScreenX(x + this.x, y + this.y);
	}
	return x + this.x;
};

// Transform the component (x,y)-coordinate to the screen y-coordinate
tgfComponents.Base.prototype.componentToScreenY = function(componentX, componentY) {
	"use strict";
	var x = componentX, y = componentY, rot = this.angle * Math.PI / 180;
	x *= this.xScale === 0 ? 1 : this.xScale; 
	y *= this.yScale === 0 ? 1 : this.yScale;
	if (this.angle !== 0) {	
		x = x * Math.cos(rot) - y * Math.sin(rot);
		y = x * Math.sin(rot) + y * Math.cos(rot);
	}
	// Adapt during design support
	if (tgfComponentsDesignSupport) {
		x -= this.designSupportData.moveX;
		y -= this.designSupportData.moveY;
	}
	// Find position with respect to parent if it exists
	if (this.parent !== null) {
		return this.parent.componentToScreenY(x + this.x, y + this.y);
	}
	return y + this.y;
};

// Transform the component (x,y)-coordinate to a tbVector representing the screen position
tgfComponents.Base.prototype.componentToScreenVector = function(componentX, componentY) {
	"use strict";
	return new tbVector(this.componentToScreenX(componentX, componentY), this.componentToScreenY(componentX, componentY));
};

// Returns the x-position of the finger with respect to the component
tgfComponents.Base.prototype.touchX = function(finger) {
	"use strict";
	return this.screenToComponentX(tbGame.touchX(finger), tbGame.touchY(finger));
};

// Returns the y-position of the finger with respect to the component
tgfComponents.Base.prototype.touchY = function(finger) {
	"use strict";
	return this.screenToComponentY(tbGame.touchX(finger), tbGame.touchY(finger));
};


// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Base.prototype.getWidth = function() {
	"use strict";
	return this.width === undefined ? 0 : this.width;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.Base.prototype.getHeight = function() {
	"use strict";
	return this.height === undefined ? 0 : this.height;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.Base.prototype.getLeft = function() {
	"use strict";
	return -this.getWidth() / 2;
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.Base.prototype.getTop = function() {
	"use strict";
	return -this.getHeight() / 2;
};


// ***************************************
// Dealing with tags
// ***************************************

// Clears the tags
tgfComponents.Base.prototype.clearTags = function() {
	"use strict";
	this.tags = [];
};

// Returns (a copy of) the tags
tgfComponents.Base.prototype.getTags = function() {
	"use strict";
	return this.tags.slice(0);
};

// Add tags
tgfComponents.Base.prototype.addTags = function(tags) {
	"use strict";
	var t;
	tags = [].concat(tags);				// Such that it also works for a single value
	for (t = 0; t < tags.length; t += 1) {
		if (this.tags.indexOf(tags[t]) < 0) {
			this.tags.push(tags[t]);
		}
	}
};

// Remove tags
tgfComponents.Base.prototype.removeTags = function(tags) {
	"use strict";
	var t, ind;
	tags = [].concat(tags);				// Such that it also works for a single value
	for (t = 0; t < tags.length; t += 1) {
		ind = this.tags.indexOf(tags[t]);
		if (ind >= 0) { this.tags.splice(ind, 1); }
	}
};

// Returns whether the tags contain one or all of the given values
tgfComponents.Base.prototype.containsTags = function(tags, all) {
	"use strict";
	var t, ind;
	if (all === undefined) { all = false; }
	tags = [].concat(tags);				// Such that it also works for a single value
	for (t = 0; t < tags.length; t += 1) {
		ind = this.tags.indexOf(tags[t]);
		if (ind >= 0 && !all) { return true; }
		if (ind < 0 && all) { return false; }
	}
	return true;
};


// ***************************************
// Dealing with child components
// ***************************************

// Add a child component
tgfComponents.Base.prototype.addComponent = function(component) {
	"use strict";
	component.parent = this;
	this._components.push(component);
};

// Insert a child component
tgfComponents.Base.prototype.insertComponent = function(index, component) {
	"use strict";
	component.parent = this;
	if (index < 0) { index = 0; }
	if (index > this._components.length) { index = this._components.length; }
	this._components.splice(index, 0, component);
};

// Returns the component with the given name
tgfComponents.Base.prototype.findComponent = function(name, recursive) {
	"use strict";
	var i, result = null;
	if (recursive === undefined) { recursive = false; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].name === name) { result = this._components[i]; }
		if (recursive){
			result = this._components[i].findComponent(name, recursive);
			if (result !== null) { return result; }
		}
	}
	return result;
};

// Removes all components
tgfComponents.Base.prototype.removeAllComponents = function() {
	"use strict";
	this._components = [];
};

// Removes the component
tgfComponents.Base.prototype.removeComponent = function(component, recursive) {
	"use strict";
	var i;
	if (recursive === undefined) { recursive = false; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (recursive){
			this._components[i].removeComponent(component, recursive);
		}
		if (this._components[i] === component) { this._components.splice(i, 1); }
	}
};

// Removes the component with the given name
tgfComponents.Base.prototype.removeComponentByName = function(name, recursive) {
	"use strict";
	var i;
	if (recursive === undefined) { recursive = false; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (recursive){
			this._components[i].removeComponent(name, recursive);
		}
		if (this._components[i].name === name) { this._components.splice(i, 1); }
	}
};

// Returns the components whose tags contain one or all of the values
tgfComponents.Base.prototype.findComponentsByTags = function(tags, all, recursive) {
	"use strict";
	var i, result = [], result2;
	if (all === undefined) { all = false; }
	if (recursive === undefined) { recursive = false; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].containsTags(tags, all)) { result.push(this._components[i]); }
		if (recursive){
			result2 = this._components[i].findComponentsByTags(tags, all, recursive);
			result = result.concat(result2);
		}
	}
	return result;
};

// Removes the components whose tags contain one or all of the values
tgfComponents.Base.prototype.removeComponentsByTags = function(tags, all, recursive) {
	"use strict";
	var i;
	if (all === undefined) { all = false; }
	if (recursive === undefined) { recursive = false; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (recursive){
			this._components[i].removeComponentsByTags(tags, all, recursive);
		}
		if (this._components[i].containsTags(tags, all)) { this._components.splice(i, 1); }
	}
};


// ***************************************
// External methods related to effects
// ***************************************

// Restarts the effect (to be called after making changes)
tgfComponents.Base.prototype.restartEffect = function() {
	"use strict";
	this._startEffects();
};

// Returns the index of the current sub-effect
tgfComponents.Base.prototype.getSubEffect = function() {
	"use strict";
	var i, len = 0;
	if (this.effects === null) { return -1; }
	if (Object.prototype.toString.call(this.effects) === "[object Array]" && this.effects.length === 0) { return -1; }
	if (this.effectRepeat <= 0) { return -1; }
	if (Object.prototype.toString.call(this.effects) !== "[object Array]") { return 0; }
	for (i = 0; i < this.effects.length; i += 1) {
		len += this._getEffectDuration(this.effects[i], false);
		if (this.effectTime < len) { return i; }
	}
	return 0;
};

// Move to the next sub-effect
tgfComponents.Base.prototype.nextSubEffect = function() {
	"use strict";
	this.startSubEffect(this.getSubEffect() + 1);
};

// Move to the previous sub-effect
tgfComponents.Base.prototype.previousSubEffect = function() {
	"use strict";
	this.startSubEffect(this.getSubEffect() - 1);
};

// Repeats the current sub-effect
tgfComponents.Base.prototype.repeatSubEffect = function() {
	"use strict";
	this.startSubEffect(this.getSubEffect());
};

// Starts the indicated sub-effect
tgfComponents.Base.prototype.startSubEffect = function(index) {
	"use strict";
	var i;
	// Easy case
	this.effectTime = 0;
	if (Object.prototype.toString.call(this.effects) !== "[object Array]") { return; }
	// Correct the index
	if (index === undefined) { index = 0; }
	if (index < 0) { index = 0; }
	if (index >= this.effects.length) { index = this.effects.length-1; }
	for (i = 0; i < index; i += 1) {
		this.effectTime += this._getEffectDuration(this.effects[i], false);
	}
};


// ***************************************
// Internal methods related to effects
// ***************************************

// Returns the duration of the (sub-effect)
tgfComponents.Base.prototype._getEffectDuration = function(effect, sequential) {
	"use strict";
	var i, len, result = 0;
	if (sequential === undefined) { sequential = true; }
	// Easy cases
	if (effect === null) { return 0; }
	if (Object.prototype.toString.call(effect) === "[object Array]" && effect.length === 0) { return 0; }
	if (Object.prototype.toString.call(effect) !== "[object Array]") { return effect.duration; }
	// Otherwise, compute it from the array elements
	for (i = 0; i < effect.length; i += 1) {
		len = this._getEffectDuration(effect[i], !sequential);
		if (sequential) {
			result += len;
		} else {
			result = Math.max(result, len);
		}
	}
	return result;
};

// Starts the effects sequence
tgfComponents.Base.prototype._startEffects = function() {
	"use strict";
	if (this.effects === null) { return; }
	if (Object.prototype.toString.call(this.effects) === "[object Array]" && this.effects.length === 0) { return; }
	this.effectDuration = this._getEffectDuration(this.effects, true);	// The combined duration of the effects
	this.effectTime = 0;												// The progress in seconds in the current effect
	this.effectWait = this.effectWaitSteps;								// Number of steps to wait
	this.effectRepeat = this.repeatEffect;								// How often the effects must still be performed
	this.effectCurrent = [];											// List of current effects
};

// Updates the effect
tgfComponents.Base.prototype._updateEffects = function(timePassed) {
	"use strict";
	if (this.effects === null) { return; }
	if (Object.prototype.toString.call(this.effects) === "[object Array]" && this.effects.length === 0) { return; }
	if (this.effectRepeat <= 0) { return; }
	// Wait before updating the effect timer (to avoid initial hick-ups)
	if (this.effectWait > 0) {
		this.effectWait -= 1;
	} else {
		this.effectTime += timePassed/1000;
	}
	// Check whether an effect sequence is finished
	if (this.effectTime >= this.effectDuration) {
		if (this.onEffectEnd) { this.onEffectEnd(this); }
		this.effectRepeat -= 1;
		if (this.effectRepeat <= 0) { return; }
		this.effectTime = this.effectTime - this.effectDuration;
		if (this.onEffectStart) { this.onEffectStart(this); }
	}
};

// Returns an array the effects that must be performed at moment time
tgfComponents.Base.prototype._findEffects = function(effect, time, sequential, result) {
	"use strict";
	var i, len, inc;
	// Easy cases
	if (effect === null) { return; }
	if (Object.prototype.toString.call(effect) === "[object Array]" && effect.length === 0) { return; }
	if (Object.prototype.toString.call(effect) !== "[object Array]") {
		if (time < effect.duration) { result.push( { effect: effect, time: time } ); }
		return;
	}
	// The difficult cases
	if (sequential) {
		len = 0;
		for (i = 0; i < effect.length; i += 1) {
			inc = this._getEffectDuration(effect[i], !sequential);
			if (len + inc > time) {
				this._findEffects(effect[i], time - len, !sequential, result);
				return;
			}
			len += inc;
		}
	} else {
		for (i = 0; i < effect.length; i += 1) {
			this._findEffects(effect[i], time, !sequential, result);
		}
	}
};

// Perform the effects
tgfComponents.Base.prototype._performEffects = function() {
	"use strict";
	var effectNew = [], ef, i, j, found;
	if (this.effects === null) { return; }
	if (Object.prototype.toString.call(this.effects) === "[object Array]" && this.effects.length === 0) { return; }
	if (this.effectRepeat <= 0) { return; }
	// Find the new set of effect
	this._findEffects(this.effects, this.effectTime, true, effectNew);
	// Handle the sub-effect that must are stopped
	for (j = 0; j < this.effectCurrent.length; j += 1) {
		ef = this.effectCurrent[j];
		found = false;
		for (i = 0; i < effectNew.length; i += 1) {
			if (effectNew[i].effect === ef.effect) { found = true; break; }
		}
		if (!found) {
			// Perform the end of the effect to make sure the transformation is final
			if (typeof(ef.effect.effect) === "function") {
				ef.effect.effect(this, ef.effect, ef.effect.duration);
			} else {
				tgfEffects.effect(ef.effect.effect)(this, ef.effect, ef.effect.duration);
			}
			// Call the call-back
			if (this.onSubEffectEnd) { this.onSubEffectEnd(this, ef.effect); }
		}
	}
	// Handle the sub-effect that must are started
	for (j = 0; j < effectNew.length; j += 1) {
		ef = effectNew[j];
		found = false;
		for (i = 0; i < this.effectCurrent.length; i += 1) {
			if (this.effectCurrent[i].effect === ef.effect) { found = true;  break; }
		}
		if (!found) {
			// Call the call-back
			if (this.onSubEffectStart) {this.onSubEffectStart(this, ef.effect); }
			// Perform the start of the effect to make sure the transformation is initialized
			if (typeof(ef.effect.effect) === "function") {
				ef.effect.effect(this, ef.effect, 0);
			} else {
				tgfEffects.effect(ef.effect.effect)(this, ef.effect, 0);
			}
		}
	}
	// Now perform the effects at the current moment of time
	for (i = 0; i < effectNew.length; i += 1) {
		ef = effectNew[i];
		if (typeof(ef.effect.effect) === "function") {
			ef.effect.effect(this, ef.effect, ef.time);
		} else {
			tgfEffects.effect(ef.effect.effect)(this, ef.effect, ef.time);
		}
	}
	// Done
	this.effectCurrent = effectNew;
};


// ***************************************
// Preparing, showing and activating
// ***************************************

// Prepare the component (and its children) for use
tgfComponents.Base.prototype.prepare = function(alsoChildren) {
	"use strict";
	var i;
    this.baseContainer = this.baseContainer || this.parent.baseContainer;
    this.x = this.x + this.parent.x;
    this.y = this.y + this.parent.y;

	if (alsoChildren === undefined) { alsoChildren = true; }
	if (this.isPrepared) { return; }
	if (this.onPrepare) {
		if (this.onPrepare(this)) { return; }
	}
	this.isPrepared = true;
	if (this.doPrepare) { this.doPrepare(); }
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].prepare();
		}
	}
};

// Free the component (and its children) from use
tgfComponents.Base.prototype.free = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (!this.isPrepared) { return; }
	if (this.onFree) {
		if (this.onFree(this)) { return; }
	}
	if (this.isVisible) { this.hide(); }
	this.isPrepared = false;
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].free();
		}
	}
	if (this.doFree) { this.doFree(); }
};

// Show the component (and its children)
tgfComponents.Base.prototype.show = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (this.isVisible) { return; }
	if (!this.isPrepared) { this.prepare(); }
	if (this.onShow) {
		if (this.onShow(this)) { return; }
	}
	this.isVisible = true;
	this._startEffects();
	if (this.doShow) { this.doShow(); }
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].show();
		}
	}
};

// Hide the component (and its children)
tgfComponents.Base.prototype.hide = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (!this.isVisible) { return; }
	if (this.isActive) { this.deactivate(); }
	if (this.onHide) {
		if (this.onHide(this)) { return; }
	}
	this.isVisible = false;
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].hide();
		}
	}
	if (this.doHide) { this.doHide(); }
};

// Activate the component (and its children)
tgfComponents.Base.prototype.activate = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (this.isActive) { return; }
	if (this.onActivate) {
		if (this.onActivate(this)) { return; }
	}
	if (!this.isVisible) { this.show(); }
	this.isActive = true;
	if (alsoChildren) {
	if (this.doActivate) { this.doActivate(); }
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].activate();
		}
	}
};

// Deactivate the component (and its children)
tgfComponents.Base.prototype.deactivate = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (!this.isActive) { return; }
	if (this.onDeactivate) {
		if (this.onDeactivate(this)) { return; }
	}
	this.isActive = false;
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].deactivate();
		}
	}
	if (this.doDeactivate) { this.doDeactivate(); }
};


// ***************************************
// Methods called by parent component when events happen
// ***************************************

// Called at the beginning of each step of the dialog that contains the component
tgfComponents.Base.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	var i;
	if (this.isActive && this.isVisible) {
		// Deal with the effect
		if (this.pauseEffectsOnDeactivate) {
			this._updateEffects(timePassed);
		}
		// Handle the component itself
		if (this.onBeginStep) { this.onBeginStep(this, timePassed); }
		if (this.doBeginStep) { if (this.doBeginStep(timePassed)) { return true; } }
		// Handle the sub-components
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleBeginStep(timePassed)) { return true; }
		}
	}
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.Base.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";
	var i, xx, yy;
	if (this.isActive && this.isVisible) {
		// Handle the sub-components
		for (i = this._components.length-1; i >= 0; i -= 1) {
			if (this._components[i].handleTouchDown(finger, x, y)) { return true; }
		}
		// Handle design support
		if (tgfComponentsDesignSupport) {
			if (tgfComponentsDesignSupport.componentTouchDown(this, finger, x, y)) { return true; }
		}
		// Handle the component itself
		xx = this.screenToComponentX(x, y);
		yy = this.screenToComponentY(x, y);
		if (this.onTouchDown) { this.onTouchDown(this, finger, xx, yy); }
		if (this.doTouchDown) { if (this.doTouchDown(finger, xx, yy)) { return true; } }
	}
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.Base.prototype.handleTouchUp = function(finger, x, y) {
	"use strict";
	var i, xx, yy;
	if (this.isActive && this.isVisible) {
		// Handle the sub-components
		for (i = this._components.length-1; i >= 0; i -= 1) {
			if (this._components[i].handleTouchUp(finger, x, y)) { return true; }
		}
		// Handle design support
		if (tgfComponentsDesignSupport) {
			tgfComponentsDesignSupport.componentTouchUp(this, finger, x, y);
		}
		// Handle the component itself
		xx = this.screenToComponentX(x, y);
		yy = this.screenToComponentY(x, y);
		if (this.onTouchUp) { this.onTouchUp(this, finger, xx, yy); }
		if (this.doTouchUp) { if (this.doTouchUp(finger, xx, yy)) { return true; } }
	}
};

// Called when the position of the mouse wheel is changed
tgfComponents.Base.prototype.handleMouseWheel = function(delta, x, y) {
	"use strict";
	var i, xx, yy;
	if (this.isActive && this.isVisible) {
		// Handle the sub-components
		for (i = this._components.length-1; i >= 0; i -= 1) {
			if (this._components[i].handleMouseWheel(delta, x, y)) { return true; }
		}
		// Handle the component itself
		xx = this.screenToComponentX(x, y);
		yy = this.screenToComponentY(x, y);
		if (this.onMouseWheel) { this.onMouseWheel(this, delta, xx, yy); }
		if (this.doMouseWheel) { if (this.doMouseWheel(delta, xx, yy)) { return true; } }
	}
};

// Called immediately when a touch is started or if a mouse button is pressed
tgfComponents.Base.prototype.handleImmediateTouchDown = function(finger, x, y) {
	"use strict";
	var i, xx, yy;
	if (this.isActive && this.isVisible) {
		// Handle the sub-components
		for (i = this._components.length-1; i >= 0; i -= 1) {
			if (this._components[i].handleImmediateTouchDown(finger, x, y)) { return true; }
		}
		// Handle the component itself
		xx = this.screenToComponentX(x, y);
		yy = this.screenToComponentY(x, y);
		if (this.onImmediateTouchDown) { this.onImmediateTouchDown(this, finger, xx, yy); }
		if (this.doImmediateTouchDown) { if (this.doImmediateTouchDown(finger, xx, yy)) { return true; } }
	}
};

// Called immediately when a touch is ended or if a mouse button is released
tgfComponents.Base.prototype.handleImmediateTouchUp = function(finger, x, y) {
	"use strict";
	var i, xx, yy;
	if (this.isActive && this.isVisible) {
		// Handle the sub-components
		for (i = this._components.length-1; i >= 0; i -= 1) {
			if (this._components[i].handleImmediateTouchUp(finger, x, y)) { return true; }
		}
		// Handle the component itself
		xx = this.screenToComponentX(x, y);
		yy = this.screenToComponentY(x, y);
		if (this.onImmediateTouchUp) { this.onImmediateTouchUp(this, finger, xx, yy); }
		if (this.doImmediateTouchUp) { if (this.doImmediateTouchUp(finger, xx, yy)) { return true; } }
	}
};

// Called if the key with the given keyCode is pressed
tgfComponents.Base.prototype.handleKeyDown = function(keyCode) {
	"use strict";
	var i;
	if (this.isActive && this.isVisible) {
		// Handle the component itself
		if (this.onKeyDown) { this.onKeyDown(this, keyCode); }
		if (this.doKeyDown) { if (this.doKeyDown(keyCode)) { return true; } }
		// Handle the sub-components
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleKeyDown(keyCode)) { return true; }
		}
	}
};

// Called if the key with the given keyCode is released
tgfComponents.Base.prototype.handleKeyUp = function(keyCode) {
	"use strict";
	var i;
	if (this.isActive && this.isVisible) {
		// Handle the component itself
		if (this.onKeyUp) { this.onKeyUp(this, keyCode); }
		if (this.doKeyUp) { if (this.doKeyUp(keyCode)) { return true; } }
		// Handle the sub-components
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleKeyUp(keyCode)) { return true; }
		}
	}
};

// Called if a global alarm is reached for the dialog that contains the component
tgfComponents.Base.prototype.handleAlarm = function(alarm) {
	"use strict";
	var i;
	if (this.isActive && this.isVisible) {
		// Handle the component itself
		if (this.onAlarm) { this.onAlarm(this, alarm); }
		if (this.doAlarm) { if (this.doAlarm(alarm)) { return true; } }
		// Handle the sub-components
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleAlarm(alarm)) { return true; }
		}
	}
};

// Called if a special or user-defined event happens for the dialog that contains the component
tgfComponents.Base.prototype.handleSpecial = function(id, args) {
	"use strict";
	var i;
	if (this.isActive && this.isVisible) {
		// Handle the component itself
		if (this.onSpecial) { this.onSpecial(this, id, args); }
		if (this.doSpecial) { if (this.doSpecial(id, args)) { return true; } }
		// Handle the sub-components
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleSpecial(id, args)) { return true; }
		}
	}
};

// Called at the end of each step of the dialog that contains the component
tgfComponents.Base.prototype.handleEndStep = function(timePassed) {
	"use strict";
	var i;
	if (this.isActive && this.isVisible) {
		// Handle the component itself
		if (this.onEndStep) { this.onEndStep(this, timePassed); }
		if (this.doEndStep) { if (this.doEndStep(timePassed)) { return true; } }
		// Handle the sub-components
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleEndStep(timePassed)) { return true; }
		}
	}
};

// Called just before drawing (also when not active)
tgfComponents.Base.prototype.handleUpdateVisuals = function(timePassed) {
	"use strict";
	var i;
	if (this.isVisible) {
		// Deal with the effect
		if (!this.pauseEffectsOnDeactivate) {
			this._updateEffects(timePassed);
		}
		this._performEffects();
		// Handle the component itself
		if (this.onUpdateVisuals) { this.onUpdateVisuals(this, timePassed); }
		if (this.doUpdateVisuals) { if (this.doUpdateVisuals(timePassed)) { return true; } }
		// Handle the sub-components
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleUpdateVisuals(timePassed)) { return true; }
		}
	}
};

// Called when the component must be drawn
tgfComponents.Base.prototype.handleDraw = function() {
	"use strict";
	var i;
	if (this.isVisible) {
		if (Math.abs(this.xScale) < 0.000001 || Math.abs(this.yScale) < 0.000001) { return; }
		// Set the transformation
		// tbGraphics.context.save();
		if (tgfComponentsDesignSupport) {
			// tbGraphics.context.translate(this.designSupportData.moveX, this.designSupportData.moveY);
		}
		// tbGraphics.context.translate(this.x, this.y);
		if (this.xScale !== 1 || this.yScale !== 1) { /*tbGraphics.context.scale(this.xScale, this.yScale);*/ }
		//if (this.angle !== 0) { tbGraphics.context.rotate(-this.angle * Math.PI/180);  }    // from degrees to radians and counter-clockwise
		// tbGraphics.context.globalAlpha *= this.alpha;
		// Draw the component
		if (this.onDraw) { this.onDraw(this); }
		if (this.doDraw) { if (this.doDraw()) { /*tbGraphics.context.restore();*/ return true; } }
		// Draw the sub-component
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleDraw()) { /*tbGraphics.context.restore();*/ return true; }
		}
		// End draw the component
		if (this.onEndDraw) { this.onEndDraw(this); }
		if (this.doEndDraw) { if (this.doEndDraw()) { /*tbGraphics.context.restore();*/ return true; } }
		// Handle outline drawing for design support
		if (tgfComponentsDesignSupport) {
			tgfComponentsDesignSupport.componentDraw(this);
		}
		// Reset transformation
		// tbGraphics.context.restore();
	}
};


//******************************************************
//*****    Script Resource: ComponentTemplate
//******************************************************

// ***************************************
// tgfComponents.Template
//
// This is an empty template for a new component
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 25-9-2015
// ***************************************

// TODO: Everywhere replace Template and template by the appropriate name

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.template = {
	components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Template = function(properties) {
	"use strict";
	this.name = "Template";			// The name of the component
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.template);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Template, tgfComponents.Base);



// ***************************************
// Size information (e.g. for design support)
// TODO: Override these when not default
// ***************************************

/*
// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Template.prototype.getWidth = function() {
	"use strict";
	return this.width === undefined ? 0 : this.width;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.Template.prototype.getHeight = function() {
	"use strict";
	return this.height === undefined ? 0 : this.height;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.Template.prototype.getLeft = function() {
	"use strict";
	return -this.getWidth() / 2;
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.Template.prototype.getTop = function() {
	"use strict";
	return -this.getHeight() / 2;
};
*/

// ***************************************
// Specific methods for this component
// ***************************************



// ***************************************
// Internal methods
// ***************************************



// ***************************************
// Preparing, showing and activating
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.Template.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Add the child components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

// Processing required when freeing the component from use
tgfComponents.Template.prototype.doFree = function() {
	"use strict";
	//call free on all pixi objects here
};

// Processing required when showing the component
tgfComponents.Template.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the component
tgfComponents.Template.prototype.doHide = function() {
	"use strict";
};

// Processing required when activating the component
tgfComponents.Template.prototype.doActivate = function() {
	"use strict";
};

// Processing required when deactivating the component
tgfComponents.Template.prototype.doDeactivate = function() {
	"use strict";
};


// ***************************************
// Methods called when events must be processed
//      - These can be removed when no processing is required
//      - When they return true, this event is no further processed
//          by other components in the dialog
//      - Never call these methods yourself in other components,
//          Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.Template.prototype.doBeginStep = function(timePassed) {
	"use strict";
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.Template.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.Template.prototype.doTouchUp = function(finger, x, y) { 
	"use strict";
};

// Called when the position of the mouse wheel is changed
tgfComponents.Template.prototype.doMouseWheel = function(delta, x, y) {
	"use strict";
};

// Called immediately when a touch is started or if a mouse button is pressed
tgfComponents.Template.prototype.doImmediateTouchDown = function(finger, x, y) {
	"use strict";
};

// Called immediately when a touch is ended or if a mouse button is released
tgfComponents.Template.prototype.doImmediateTouchUp = function(finger, x, y) { 
	"use strict";
};

// Called if the key with the given keyCode is pressed
tgfComponents.Template.prototype.doKeyDown = function(keyCode) { 
	"use strict";
};

// Called if the key with the given keyCode is released
tgfComponents.Template.prototype.doKeyUp = function(keyCode) { 
	"use strict";
};

// Called if a global alarm is reached
tgfComponents.Template.prototype.doAlarm = function(alarm) { 
	"use strict";
};

// Called if a special or user-defined event happens
tgfComponents.Template.prototype.doSpecial = function(id, args) { 
	"use strict";
};

// Called at the end of each step
tgfComponents.Template.prototype.doEndStep = function(timePassed) { 
	"use strict";
};

// Called just before drawing (also when not active)
tgfComponents.Template.prototype.doUpdateVisuals = function(timePassed) { 
	"use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Template.prototype.doDraw = function() {
	"use strict";
};

// Called after drawing the sub-components
tgfComponents.Template.prototype.doEndDraw = function() {
	"use strict";
};


//******************************************************
//*****    Script Resource: ComponentScrollBox
//******************************************************

// ***************************************
// tgfComponents.ScrollBox
//
// This is a scrollbox in which you can scroll
// and clip other components
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 5-7-2015
// ***************************************

// TODO: Add zoom factor

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.scrollBox = {
	scrollHorizontal: true,				// Whether to allow horizontal scrolling
	scrollVertical: true,				// Whether to allow vertical scrolling
	areaWidth: 0,						// The width of the area in the box
	areaHeight: 0,						// The height of the area in the box
	clip: true,							// Whether to clip the subcomponents
	showHorizontalScrollBar: false,		// Whether to show the horizontal scroll bar when required
	showVerticalScrollBar: false,		// Whether to show the vertical scroll bar when required
	cancelEvents: true,					// Whether to cancel the touch events when treated by the scrollbox

	scrollBarProperties: null,
	horizontalScrollBarProperties: null,
	verticalScrollBarProperties: null,

	scrollBackDuration: 600,

	snapIntervals: 0,
	maxSpeedForSnap: 500,
	snapCallback: null,
// TODO: Add scrollbar images
	components: []						// Components to add as children in the box
};

// The constructor for the component
/** @constructor
 *  @base tgfComponents.Base
 */
tgfComponents.ScrollBox = function(properties) {
	"use strict";
	this.name = "ScrollBox";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.scrollBox);


	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }

	this.scrollBackTimer = new tbVector(0, 0);
	this.scrollBackFrom = new tbVector(0, 0);
	this.scrollBackTo = new tbVector(0, 0);

	this._drawComponents = [];

	this.scroll = new tbVector(0, 0);
	this.touchStartScroll = new tbVector(0, 0);

	this.centerOffset = new tbVector(0, 0);

};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ScrollBox, tgfComponents.Base);


// clearElements - remove all the elements in the scrollBox.

tgfComponents.ScrollBox.prototype.clearElements = function() {
	"use strict";
	this.scrollContainer.removeAllComponents();
}

tgfComponents.ScrollBox.prototype.getScroll = function() {

	return this.scroll;
}

// setWidthHeight - change the width and height of the scrollbox to adapt to a new screen resolution

tgfComponents.ScrollBox.prototype.setWidthHeight = function(width, height) {
	"use strict";
	
	if(this.width === width && this.height === height) return;
	
	this.width   = width;
	this.height  = height;
	// this.surface = new tbSurface(this.width - (this.verticalScrollBar?this.verticalScrollBar.getWidth():0), this.height - (this.horizontalScrollBar?this.horizontalScrollBar.getHeight():0));
	// this.surface.context.translate(Math.round(this.width / 2), Math.round(this.height / 2));
}

// ***************************************
// Preparing, showing and activating
//		- These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.ScrollBox.prototype.doPrepare = function() {
	"use strict";
	var i, ww = Math.round(this.width/2), hh = Math.round(this.height/2);
	this.scroll.x = 0;
	this.scroll.y = 0;

	this.touchStart = new tbVector(0, 0);
	this.touchEnd = new tbVector(0, 0);

	this.speed = new tbVector(0, 0);

	if (this.showVerticalScrollBar && this.scrollVertical) {
		this.verticalScrollBar = new tgfComponents.ScrollBar();
		this.verticalScrollBar.setProperties(this.scrollBarProperties);
		this.verticalScrollBar.setProperties(this.verticalScrollBarProperties);

		this.verticalScrollBar.x = (this.width - this.verticalScrollBar.getWidth()) / 2;
		this.verticalScrollBar.y = 0;
		this.verticalScrollBar.height = this.height;
		this.addComponent(this.verticalScrollBar);

		ww -= this.verticalScrollBar.getWidth() / 2;
	}

	if (this.showHorizontalScrollBar && this.scrollHorizontal) {
		this.horizontalScrollBar = new tgfComponents.ScrollBar({direction: tgfComponents.ScrollBarDirection.Horizontal });
		this.horizontalScrollBar.setProperties(this.scrollBarProperties);
		this.horizontalScrollBar.setProperties(this.horizontalScrollBarProperties);

		this.horizontalScrollBar.x = 0;
		this.horizontalScrollBar.y = (this.height - this.horizontalScrollBar.getHeight()) / 2;
		this.horizontalScrollBar.width = this.width;
		this.addComponent(this.horizontalScrollBar);

		hh -= this.horizontalScrollBar.getHeight() / 2;
	}

	if (this.verticalScrollBar && this.horizontalScrollBar) {
		this.verticalScrollBar.height -= this.horizontalScrollBar.getHeight();
		this.verticalScrollBar.y -= this.horizontalScrollBar.getHeight() / 2;
		this.horizontalScrollBar.width -= this.verticalScrollBar.getWidth();
		this.horizontalScrollBar.x -= this.verticalScrollBar.getWidth() / 2;
	}

	this.finger = -1;
	// this.surface = new tbSurface(this.width - (this.verticalScrollBar?this.verticalScrollBar.getWidth():0), this.height - (this.horizontalScrollBar?this.horizontalScrollBar.getHeight():0));
	
	
	// this.scrollContainer = new tgfComponents.Container( { x: this.scroll.x, y: this.scroll.y } );
	this.scrollContainer = new tbContainer( this.areaWidth, this.areaHeight );
	this.scrollContainer.x = this.scroll.x;
	this.scrollContainer.y = this.scroll.y;

	
	var x = Math.round(this.x - this.width / 2);
	var y = Math.round(this.y - this.height/ 2);
	var w = this.scrollContainer.width;
	var h = this.scrollContainer.height;

	// var rect = tbGraphics.drawRectangle(x, y, w, h, 0x00ff00, null, 0, 0.5);
	// this.scrollContainer.addChild(rect);

	// surface => clipping mask
// <<<<<<< HEAD
	this.surface = tbGraphics.drawRectangle(this.x, this.y, this.width - (this.verticalScrollBar?this.verticalScrollBar.getWidth():0), this.height - (this.horizontalScrollBar?this.horizontalScrollBar.getHeight():0), 0x0000ff, null, 0, .15);
// =======
// 	// this.surface = tbGraphics.drawRectangle(this.x - this.width / 2, this.y - this.height / 2, this.width - (this.verticalScrollBar?this.verticalScrollBar.getWidth():0), this.height - (this.horizontalScrollBar?this.horizontalScrollBar.getHeight():0), 0x0000ff, null, 0, .15);
// >>>>>>> d836305bc58ebd716b3cc5c3734e0c1551ebb341
	// this.surface.height = 400;

	// this.surface.x =  Math.round(this.surface.width / 2);
	// this.surface.y =  Math.round(this.height / 2);

	// add containers
	this.baseContainer.addChild(this.scrollContainer);

	if (this.clip) {
		this.baseContainer.addChild(this.surface);
		this.scrollContainer.container.mask = this.surface;
	}


	this.centerOffset.x = -Math.round(this.width - this.surface.width)/2;
	this.centerOffset.y = -Math.round(this.height - this.surface.height)/2;

	// Add the child components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {

			this.components[i].baseContainer = this.scrollContainer;
			this.addComponent(this.components[i]);
		}
	}
	
	if(this.startPosition) {
		if (this.scrollVertical) {
			var areaHeight = Math.max(this.areaHeight, this.surface.height);
			var minY = -(areaHeight - this.surface.height);			
			this.scroll.y = this.startPosition * minY;
		}
		else if (this.scrollHorizontal) {
			var areaWidth = Math.max(this.areaWidth, this.surface.width);
			var minX = -(areaWidth - this.surface.width);
			this.scroll.x = this.startPosition * minX;
		}	
	}
};

// Processing required when freeing the component from use
tgfComponents.ScrollBox.prototype.doFree = function() {
	"use strict";
	
	if (this.surface)	{
        this.baseContainer.removeChild(this.surface);
		// this.surface.free();
		// this.surface = null;
	}

	if (this.scrollContainer)	{
		this.scrollContainer.remove(this.baseContainer);
		this.scrollContainer.free();
		this.scrollContainer = null;
	}
};

// Processing required when showing the component
tgfComponents.ScrollBox.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the component
tgfComponents.ScrollBox.prototype.doHide = function() {
	"use strict";
};

// Processing required when activating the component
tgfComponents.ScrollBox.prototype.doActivate = function() {
	"use strict";
};

// Processing required when deactivating the component
tgfComponents.ScrollBox.prototype.doDeactivate = function() {
	"use strict";
};

// Methods for forcing what the min and max scrolling coordinates should be.

tgfComponents.ScrollBox.prototype.getMinX = function() {
	"use strict";
	if(this.forcedMinX)
		return this.forcedMinX;
	var areaWidth = Math.max(this.areaWidth, this.width);
	return -(areaWidth - this.width);
}

tgfComponents.ScrollBox.prototype.getMaxX = function() {
	"use strict";
	if(this.forcedMaxX)
		return this.forcedMaxX;
	return 0;
}

tgfComponents.ScrollBox.prototype.getMinY = function() {
	"use strict";
	if(this.forcedMinY)
		return this.forcedMinY;
	var areaHeight = Math.max(this.areaHeight, this.height);
	return -(areaHeight - this.height);
}

tgfComponents.ScrollBox.prototype.getMaxY = function() {
	"use strict";
	if(this.forcedMaxY)
		return this.forcedMaxY;
	return 0;
}

// ***************************************
// Methods called when events must be processed
//		- These can be removed when no processing is required
//		- When they return true, this event is no further processed
//			by other components in the dialog
//		- Never call these methods yourself in other components,
//			Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.ScrollBox.prototype.doBeginStep = function(timePassed) {
	"use strict";
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.ScrollBox.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
	var ww = Math.round(this.width), hh = Math.round(this.height);
	// Check whether the touch the scrollbox
	if (x >= 0 && x <= ww && y >= 0 && y <= hh) {


	// console.log('down in box');

		this.finger = finger;
		x = this.touchX(this.finger);
		y = this.touchY(this.finger);

		this.scrollBackTimer.x = 0;
		this.scrollBackTimer.y = 0;

		this.touchStart.x = x;
		this.touchStart.y = y;

		this.touchStartScroll.x = this.scroll.x;
		this.touchStartScroll.y = this.scroll.y;

		if (this.cancelEvents) { return true; }
	}
};

//Called when a touch is started or if a mouse button is pressed
tgfComponents.ScrollBox.prototype.doMouseWheel = function(delta, x, y) {
	"use strict";

	console.log('CSB::doMouseWheel', delta, x, y);

	var ww = Math.round(this.width), hh = Math.round(this.height);
	// Check whether the touch the scrollbox
	if (x >= 0 && x <= ww && y >= 0 && y <= hh) {

		if (this.scrollVertical) {
			this.scroll.y += delta * 100;

			var maxY = this.getMaxY();
			var minY = this.getMinY();			
			
			if (this.scroll.y > maxY) {
				this.scroll.y = 0;
			}
			if (this.scroll.y < minY) {
				this.scroll.y = minY;
			}
		}
		else if (this.scrollHorizontal) {

			this.scroll.x += delta * 100;

			var maxX = this.getMaxX();
			var minX = this.getMinX();
			
			if (this.scroll.x > maxX) {
				this.scroll.x = 0;
			}
			if (this.scroll.x < minX) {
				this.scroll.x = minX;
			}

		}

	}
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.ScrollBox.prototype.doTouchUp = function(finger, x, y) {
	"use strict";
	if (this.finger !== finger) { return; }
	this.finger = -1;

	this._checkScrollOvershootX();
	this._checkScrollOvershootY();
};

tgfComponents.ScrollBox.prototype.cancelTouches = function() {
	"use strict";
	this.finger = -1;
	this._checkScrollOvershootX();
	this._checkScrollOvershootY();	
}

tgfComponents.ScrollBox.prototype._checkScrollOvershootX = function() {
	"use strict";	
	var maxX = this.getMaxX();
	var minX = this.getMinX();

	if (this.scroll.x > maxX) {
		this.scrollBackTimer.x = this.scrollBackDuration;
		this.scrollBackFrom.x = this.scroll.x;
		this.scrollBackTo.x = maxX;
		if (this.snapCallback) {
			this.snapCallback(Math.round(maxX / this.snapIntervals));
		}
	}	
	if (this.scroll.x < minX) {
		this.scrollBackTimer.x = this.scrollBackDuration;
		this.scrollBackFrom.x = this.scroll.x;
		this.scrollBackTo.x = minX;
		if (this.snapCallback) {
			this.snapCallback(Math.round(minX / this.snapIntervals));
		}
	}
};

tgfComponents.ScrollBox.prototype._checkScrollOvershootY = function() {
	"use strict";
	var maxY = this.getMaxY();
	var minY = this.getMinY();

	if (this.scroll.y > maxY) {
		this.scrollBackTimer.y = this.scrollBackDuration;
		this.scrollBackFrom.y = this.scroll.y;
		this.scrollBackTo.y = maxY;
		if (this.snapCallback) {
			this.snapCallback(Math.round(maxY / this.snapIntervals));
		}
	}
	if (this.scroll.y < minY) {
		this.scrollBackTimer.y = this.scrollBackDuration;
		this.scrollBackFrom.y = this.scroll.y;
		this.scrollBackTo.y = minY;
		if (this.snapCallback) {
			this.snapCallback(Math.round(minY / this.snapIntervals));
		}
	}
};

tgfComponents.ScrollBox.prototype._checkSnapIntervalX = function() {
	"use strict";

	if (this.snapIntervals && this.scroll.x < this.getMaxX() && this.scroll.x > this.getMinX()) {
		var nearestSnap = this._findNearestSnap(this.scroll.x);
		if (nearestSnap != this.scroll.x) {
			this.scrollBackTimer.x = this.scrollBackDuration;
			this.scrollBackFrom.x = this.scroll.x;
			this.scrollBackTo.x = nearestSnap;
			if (this.snapCallback) {
				this.snapCallback(Math.round(this.scrollBackTo.x / this.snapIntervals));
			}
		}
	}
};

tgfComponents.ScrollBox.prototype._checkSnapIntervalY = function() {
	"use strict";

	if (this.snapIntervals && this.scroll.y < this.getMaxY() && this.scroll.y > this.getMinY()) {
		var nearestSnap = this._findNearestSnap(this.scroll.y);
		if (nearestSnap != this.scroll.y) {
			this.scrollBackTimer.y = this.scrollBackDuration;
			this.scrollBackFrom.y = this.scroll.y;
			this.scrollBackTo.y = nearestSnap;
			if (this.snapCallback) {
				this.snapCallback(Math.round(this.scrollBackTo.y / this.snapIntervals));
			}
		}
	}
};

tgfComponents.ScrollBox.prototype._findNearestSnap = function(position) {
	var positionIntervalOffset = Math.abs(position % this.snapIntervals);

	if (positionIntervalOffset > this.snapIntervals / 2) {
		return Math.floor(position / this.snapIntervals) * this.snapIntervals;
	} else {
		return Math.ceil(position / this.snapIntervals) * this.snapIntervals;
	}
};

// Called if the key with the given keyCode is pressed
tgfComponents.ScrollBox.prototype.doKeyDown = function(keyCode) {
	"use strict";
};

// Called if the key with the given keyCode is released
tgfComponents.ScrollBox.prototype.doKeyUp = function(keyCode) {
	"use strict";
};

// Called if a global alarm is reached
tgfComponents.ScrollBox.prototype.doAlarm = function(alarm) {
	"use strict";
};

// Called if a special or user-defined event happens
tgfComponents.ScrollBox.prototype.doSpecial = function(id, args) {
	"use strict";
};

// Called at the end of each step
tgfComponents.ScrollBox.prototype.doEndStep = function(timePassed) {
	"use strict";
	var x, y;

	var minY, minX, maxX, maxY, normalizedScrollValue;

	var areaHeight = Math.max(this.areaHeight, this.surface.height);
	var areaWidth = Math.max(this.areaWidth, this.surface.width);

	minX = this.getMinX();
	minY = this.getMinY();
	maxX = this.getMaxX();
	maxY = this.getMaxY();
	
	if (this.finger !== -1) {
		if (this.scrollHorizontal) {
			x = this.touchX(this.finger);

			this.touchEnd.x = x;
			var scrollXValue = this.touchStartScroll.x + this.touchEnd.x - this.touchStart.x;

			this.speed.x = (this.speed.x + (scrollXValue - this.scroll.x) / (timePassed / 1000)) / 2;

			this.scroll.x = scrollXValue;

			if (this.scroll.x > maxX) {
				this.scroll.x = maxX + Math.min(this.surface.width / 2, tbEase.easeOutCubic(scrollXValue - maxX, 0, this.surface.width / 2, this.surface.width)) / 2;
			}

			if (this.scroll.x < minX) {
				normalizedScrollValue = scrollXValue - minX;
				this.scroll.x = minX + Math.max(-this.surface.width / 2, tbEase.easeOutCubic(normalizedScrollValue, 0, -this.surface.width / 2, -this.surface.width)) / 2;
			}
		}
		if (this.scrollVertical) {
			y = this.touchY(this.finger);
			this.touchEnd.y = y;

			var scrollYValue = this.touchStartScroll.y + this.touchEnd.y - this.touchStart.y;

			this.speed.y = (this.speed.y + (scrollYValue - this.scroll.y) / (timePassed / 1000)) / 2;

			this.scroll.y = scrollYValue;

			if (this.scroll.y > maxY) {
				this.scroll.y = maxY + Math.min(this.surface.height / 2, tbEase.easeOutCubic(scrollYValue - maxY, 0, this.surface.height / 2, this.surface.height)) / 2;
			}

			if (this.scroll.y < minY) {
				normalizedScrollValue = scrollYValue - minY;
				this.scroll.y = minY + Math.max(-this.surface.height / 2, tbEase.easeOutCubic(normalizedScrollValue, 0, -this.surface.height / 2, -this.surface.height)) / 2;
			}
		}
	}
	else {

		if (this.scrollBackTimer.x > 0) {

			this.scrollBackTimer.x -= timePassed;
			this.scrollBackTimer.x = Math.max(0, this.scrollBackTimer.x);

			this.scroll.x = tbEase.easeOutOvershoot(this.scrollBackDuration - this.scrollBackTimer.x, this.scrollBackFrom.x, this.scrollBackTo.x
					- this.scrollBackFrom.x, this.scrollBackDuration);

			this.speed.x = 0;
		}
		else {

			if (Math.abs(this.speed.x) > 0) {
				this.speed.x = this.speed.x * Math.pow(0.99, timePassed);

				if (Math.abs(this.speed.x) > 1) {

					this.scroll.x += this.speed.x * (timePassed / 1000);

					if (this.scroll.x > 0 || this.scroll.x < minX) {
						this.speed.x = 0;
						this._checkScrollOvershootX();
					}

				}
				else {
					this.speed.x = 0;
				}
			}
			if (Math.abs(this.speed.x) < this.maxSpeedForSnap && this.snapIntervals) {
				this.speed.x = 0;
				this._checkSnapIntervalX();
			}
		}

		if (this.scrollBackTimer.y > 0) {

			this.scrollBackTimer.y -= timePassed;
			this.scrollBackTimer.y = Math.max(0, this.scrollBackTimer.y);

			this.scroll.y = tbEase.easeOutOvershoot(this.scrollBackDuration - this.scrollBackTimer.y, this.scrollBackFrom.y, this.scrollBackTo.y
					- this.scrollBackFrom.y, this.scrollBackDuration);

			this.speed.y = 0;
		}
		else {

			if (Math.abs(this.speed.y) > 0) {
				this.speed.y = this.speed.y * Math.pow(0.99, timePassed);

				if (Math.abs(this.speed.y) > 1) {

					this.scroll.y += this.speed.y * (timePassed / 1000);

					if (this.scroll.y > 0 || this.scroll.y < minY) {
						this.speed.y = 0;
						this._checkScrollOvershootY();
					}

				}
				else {
					this.speed.y = 0;
				}
			}
			if (Math.abs(this.speed.y) < this.maxSpeedForSnap && this.snapIntervals) {
				this.speed.y = 0;
				this._checkSnapIntervalY();
			}
		}
	}

	if (this.verticalScrollBar) {

		this.verticalScrollBar.scrollRange = areaHeight - this.surface.height;
		this.verticalScrollBar.scrollPosition =  Math.min(-minY, Math.max(0, -this.scroll.y));

		if (this.verticalScrollBar.touchScrollPosition !== undefined) {
			this.scroll.y = -this.verticalScrollBar.touchScrollPosition;
		}
	}

	if (this.horizontalScrollBar) {

		this.horizontalScrollBar.scrollRange = areaWidth - this.surface.width;
		this.horizontalScrollBar.scrollPosition =  Math.min(-minX, Math.max(0, -this.scroll.x));

		if (this.horizontalScrollBar.touchScrollPosition !== undefined) {
			this.scroll.x = -this.horizontalScrollBar.touchScrollPosition;
		}
	}

	var sx = this.scroll.x;// + this.centerOffset.x;
	var sy = this.scroll.y;// + this.centerOffset.y;
	
	this.scrollContainer.setPosition(sx, sy);
};

tgfComponents.ScrollBox.prototype.goToSnapPointX = function(snapPoint) {
	this.scrollBackTimer.x = this.scrollBackDuration;
	this.scrollBackFrom.x = this.scroll.x;
	this.scrollBackTo.x = snapPoint * this.snapIntervals;
	if (this.snapCallback) {
		this.snapCallback(Math.round(this.scrollBackTo.x / this.snapIntervals));
	}
};

// tgfComponents.ScrollBox.prototype.addComponent = function(component) {
// 	"use strict";
// 	tgfComponents.ScrollBox.uber.addComponent.call(this, component);

// 	if (component !== this.scrollContainer) {
// 		this._drawComponents.push(component);
// 	}
// };

// Called just before drawing (also when not active)
tgfComponents.ScrollBox.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.ScrollBox.prototype.doDraw = function() {
	"use strict";
	var ww = Math.round(this.width/2), hh = Math.round(this.height/2);
	// Draw the sub-components on a surface
	// this.surface.setTarget();
	// this.surface.context.clearRect(-ww,-hh, this.surface.width, this.surface.height);
	
	// console.log(this.scroll);
	// console.log(this.scrollContainer.y);



	// console.log('1', this.components);
	// console.log(this.surface);
	// console.log(this.scrollContainer);
	// console.log(this.scrollContainer.components);
	// console.log('----');
	// for (var i = 0; i < this.components.length; i++) {
	// 	console.log(this.components[i].y);
	// 	this.components[i].y = this.scrollContainer.y;
	// }


	// this.scrollContainer.y -= 1;
	// console.log(this.scrollContainer);
	// console.log(this.components[0]);

	// console.log(this.components);
	// console.log(this.components.length);
	// console.log(this.scrollContainer.components.length);

	// console.log('---');

	// this.scrollContainer.handleDraw();
	// this.surface.handleDraw();


	// console.log(this.scroll);

	// Draw the surface with the sub-components on the canvas
	// this.surface.resetTarget();
	// this.surface.drawSimple(-this.width / 2, -this.height / 2);



	// this._tempComponents = this._components;
	// this._components = this._drawComponents;
};

// Called after drawing the sub-components
// tgfComponents.ScrollBox.prototype.doEndDraw = function() {
// 	"use strict";
// 	// this._components = this._tempComponents;

// };


//******************************************************
//*****    Script Resource: ComponentLayoutVertical
//******************************************************

// ***************************************
// tgfComponents.LayoutVertical
//
// This component lays out a number of components vertically
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 2-7-2015
// ***************************************

// Directives for jslint
/*global tgfComponents, tgfScale, tgfSettings */


tgfSettings.componentDefaults.layoutVertical = {
	width: tgfScale(400),			// Width of the layout area
	height: tgfScale(400),			// Height of the layout area
	alignment: "top",				// Alignment: "top", "middle", "bottom", "spread"
	componentHeight: tgfScale(90),	// Height of each component, can be an array
	componentGap: tgfScale(8),		// Gap between the components
	adaptHeight: true,				// Whether to adapt the height of the components (can be an array)
	adaptWidth: true,				// Whether to adapt the width of the components (can be an array)
	components: []					// Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.LayoutVertical = function(properties) {
	"use strict";
	this.name = "LayoutVertical";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.layoutVertical);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.LayoutVertical, tgfComponents.Base);


// ***************************************
// Specific methods for this component
// ***************************************

// Layout (reposition and resize) the sub components based on the (changed) settings
tgfComponents.LayoutVertical.prototype.layout = function() {
	"use strict";
	var i, adaptWidth, adaptHeight, componentHeight, totHeight, gap, top, h;
	// Change the sizes of the components
	adaptWidth = [].concat(this.adaptWidth);
	adaptHeight = [].concat(this.adaptHeight);
	componentHeight = [].concat(this.componentHeight);
	totHeight = 0;
	for (i = 0; i < this.components.length; i += 1) {
		h =  componentHeight[i % componentHeight.length];
		if (adaptWidth[i % adaptWidth.length]) {
			this.components[i].width = this.width;
		}
		if (adaptHeight[i % adaptHeight.length]) {
			this.components[i].height = h;
		}
		totHeight += h;
	}
	totHeight += (this.components.length-1) * this.componentGap;
	// Set the alignment
	gap = this.componentGap;
	switch (this.alignment) {
		case "top": top = -this.height/2; break;
		case "middle": top = -totHeight/2; break;
		case "bottom": top = this.height/2 - totHeight; break;
		case "spread":
			top = -this.height/2;
			gap += (this.height - totHeight)/(this.components.length-1);
			break;
		default: top = -this.height/2;
	}
	// Now set the y-position
	for (i = 0; i < this.components.length; i += 1) {
		h =  componentHeight[i % componentHeight.length];
		this.components[i].y = Math.round(top + h/2);
		top += h + gap;
	}
};

// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
tgfComponents.LayoutVertical.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Layout the child components
	this.layout();
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

//******************************************************
//*****    Script Resource: ComponentLayoutHorizontal
//******************************************************

// ***************************************
// tgfComponents.LayoutHorizontal
//
// This component lays out a number of components horizontally
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tgfComponents, tgfScale, tgfSettings */


tgfSettings.componentDefaults.layoutHorizontal = {
	width: tgfScale(400),			// Width of the layout area
	height: tgfScale(400),			// Height of the layout area
	alignment: "center",				// Alignment: "left", "center", "right", "spread"
	componentWidth: tgfScale(90),	// Width of each component, can be an array
	componentGap: tgfScale(8),		// Gap between the components
	adaptHeight: true,				// Whether to adapt the height of the components (can be an array)
	adaptWidth: true,				// Whether to adapt the width of the components (can be an array)
	components: []					// Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.LayoutHorizontal = function(properties) {
	"use strict";
	this.name = "LayoutHorizontal";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.layoutHorizontal);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.LayoutHorizontal, tgfComponents.Base);


// ***************************************
// Specific methods for this component
// ***************************************

// Layout (reposition and resize) the sub components based on the (changed) settings
tgfComponents.LayoutHorizontal.prototype.layout = function() {
	"use strict";
	var i, adaptWidth, adaptHeight, componentWidth, totWidth, gap, left, w;
	// Change the sizes of the components
	adaptWidth = [].concat(this.adaptWidth);
	adaptHeight = [].concat(this.adaptHeight);
	componentWidth = [].concat(this.componentWidth);
	totWidth = 0;
	for (i = 0; i < this.components.length; i += 1) {
		w =  componentWidth[i % componentWidth.length];
		if (adaptWidth[i % adaptWidth.length]) {
			this.components[i].width = w;
		}
		if (adaptHeight[i % adaptHeight.length]) {
			this.components[i].height = this.height;
		}
		totWidth += w;
	}
	totWidth += (this.components.length-1) * this.componentGap;
	// Set the alignment
	gap = this.componentGap;
	switch (this.alignment) {
		case "left": left = -this.width/2; break;
		case "center": left = -totWidth/2; break;
		case "right": left = this.width/2 - totWidth; break;
		case "spread": 
			left = -this.width/2; 
			gap += (this.width - totWidth)/(this.components.length-1);
			break;
		default: left = -this.width/2;
	}
	// Now set the x-position
	for (i = 0; i < this.components.length; i += 1) {
		w =  componentWidth[i % componentWidth.length];
		this.components[i].x = Math.round(left + w/2);
		left += w + gap;
	}
};

// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
tgfComponents.LayoutHorizontal.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Layout the child components
	this.layout();
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

//******************************************************
//*****    Script Resource: ComponentTimer
//******************************************************

// ***************************************
// tgfComponents.Timer
//
// This is a timer component that ticks
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 26-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.timer = {
	enabled: true,						// Whether the timer is running
	interval: 1,						// The interval between ticks
	repeat: 99999999,					// How often to repeat
	components: [],						// Components to add as children
	onTick: null						// Called when the timer ticks
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Timer = function(properties) {
	"use strict";
	this.name = "Timer";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.timer);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Timer, tgfComponents.Base);


// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Timer.prototype.getWidth = function() {
	"use strict";
	return tgfScale(32);
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.Timer.prototype.getHeight = function() {
	"use strict";
	return tgfScale(32);
};


// ***************************************
// Specific methods for this component
// ***************************************

// Reset the timer
tgfComponents.Timer.prototype.reset = function() {
	"use strict";
	this.lifeTime = 0;
};


// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
tgfComponents.Timer.prototype.doPrepare = function() {
	"use strict";
	var i;
	this.reset();
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};


// ***************************************
// Methods called when events must be processed
// ***************************************

// Called at the beginning of each step
tgfComponents.Timer.prototype.doBeginStep = function(timePassed) {
	"use strict";
	var tickOld, tickNew;
	if (this.enabled) {
		tickOld = Math.floor(this.lifeTime / this.interval);
		this.lifeTime += timePassed/1000;
		tickNew = Math.floor(this.lifeTime / this.interval);
		if (tickOld !== tickNew && tickNew <= this.repeat && this.onTick) {
			this.onTick(this);
		}
	}
};

//******************************************************
//*****    Script Resource: ComponentContainer
//******************************************************

// ***************************************
// tgfComponents.Container
//
// This component contains a number of other components
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 26-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */

tgfSettings.componentDefaults.container = {
	components: [],						// Components to add as children
	mask: null
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Container = function(properties) {
	"use strict";
	this.name = "Container";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.container);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Container, tgfComponents.Base);


// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Container.prototype.getWidth = function() {
	"use strict";
	return tgfScale(32);
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.Container.prototype.getHeight = function() {
	"use strict";
	return tgfScale(32);
};


// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
tgfComponents.Container.prototype.doPrepare = function() {
	"use strict";
	var i;

	this.x = this.x;
	this.y = this.y;

	this.width = this.width || tgfGraphics.areaWidth;
	this.height = this.height || tgfGraphics.areaWidth;

	this.parentBaseContainer = this.baseContainer;

	this._container = new tbContainer(this.width, this.height);
	this.baseContainer.addChild(this._container);

	this.baseContainer = this._container;

	if (this.mask && this.mask instanceof PIXI["Graphics"]) {
		this._container.addChild(this.mask);
		this._container.container.mask = this.mask;
	}

	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

tgfComponents.Container.prototype.setPosition = function(x, y) {

	this.x = x;
	this.y = y;

	this.baseContainer.setPosition(this.x, this.y);
};

tgfComponents.Container.prototype.setAlpha = function(alpha) {

	this.alpha = alpha;

	this.baseContainer.setAlpha(this.alpha);
};

tgfComponents.Container.prototype.doFree = function() {
	"use strict";

	if (this.mask && this.mask instanceof PIXI["Graphics"]) {
		this._container.remove(this.mask);
	}

	if (this._container)	{
		this._container.remove(this.parentBaseContainer);
		this._container.free();
		this._container = null;
		this.baseContainer = null;
	}	
};
//******************************************************
//*****    Script Resource: ComponentLabel
//******************************************************

// ***************************************
// tgfComponents.Label
//
// This component displays a text label using a string or dictionary tag
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame, testMode */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */

tgfSettings.componentDefaults.label = {
	text: "",								// The text for the label
	dictionaryKey: "",						// The dictionary key to get the text (if not empty)
	font: f_tgf_text,						// Font to be used
	align: undefined,						// Override font alignment unless undefined
	baseline: undefined,					// Override font baseline unless undefined
	fitToBox: true,							// Whether to fit the font size to the box size
	splitLines: false,						// Whether to allow for splitting of the lines
	surfaceMargin: tgfScale(4),				// Extra size of the surface to make sure the text fits
	roundPosition: true,					// Whether to round the position when the size is odd
	components: [],							// Components to add as children
	onClick: null,							// Called when the player clicks the picture
	textWidth: tgfScale(0),
	textHeight: tgfScale(0),
	drawDebug: false
};

tgfSettings.styleTranslation = {
	//tbVectorFont > Pixi
	fontFace : "fontFamily",
	fontCase : "fontVariant",
	fillColor : "fill",
	strokeColor : "stroke",
	strokeWidth : "strokeThickness",
	strokeJoin : "lineJoin",

	spacing : "letterSpacing"
}

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Label = function(properties) {
	"use strict";
	this.name = "Label";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.label);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Label, tgfComponents.Base);


// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Label.prototype.getWidth = function() {
	"use strict";
	return this.font.textWidth() - this.surfaceMargin * 2;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.Label.prototype.getHeight = function() {
	"use strict";
	return this.font.textHeight() - this.surfaceMargin * 2;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.Label.prototype.getLeft = function() {
	"use strict";
	// var xx;
	// switch (this.font.align) {
	// 	case "left":
	// 		return 0;
	// 	case "right":
	// 		return -this.textSurface.width + this.surfaceMargin * 2;
	// 	default:
	// 		xx = -this.textSurface.width/2 + this.surfaceMargin;
	// 		return this.roundPosition ? Math.floor(xx) : xx;
	// }
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.Label.prototype.getTop = function() {
	"use strict";
	// var yy;
	// switch (this.font.baseline) {
	// 	case "top":
	// 		return 0;
	// 	case "bottom":
	// 		return -this.textSurface.height + this.surfaceMargin * 2 + Math.round(this.font.offsetFactor * this.font.fontSize);
	// 	default:
	// 		yy = -this.textSurface.height / 2 + this.surfaceMargin + Math.round(this.font.offsetFactor * this.font.fontSize) / 2;
	// 		return this.roundPosition ? Math.floor(yy) : yy;
	// }
};


// ***************************************
// Specific methods for this component
// ***************************************

// Recreate the surface, when something has changed
tgfComponents.Label.prototype.recreate = function() {
	"use strict";
	//this.createSurface();
};

tgfComponents.Label.prototype.setText = function(text){
	"use strict";
	this.text = text ? text : this.text;

	this.font.setText(this.text);
};

tgfComponents.Label.prototype.bringToFront = function() {
	this.baseContainer.removeChild(this.font);
	this.baseContainer.addChild(this.font);
};

tgfComponents.Label.prototype.setPosition = function(x, y) {
	this.x = x;
	this.y = y;
	this.font.setPosition(x, y);
};

// ***************************************
// Internal methods
// ***************************************

// Update the text when the dictionaryKey changes
tgfComponents.Label.prototype.findText = function() {
	"use strict";
	if (this.dictionaryKey !== "") {
		return tgfDictionary.getText(this.dictionaryKey, "<" + this.dictionaryKey + ">");
	} else {
		return this.text === undefined ? "<UNDEFINED>" : this.text;
	}
};

// Create the surface
tgfComponents.Label.prototype.createSurface = function() {
	"use strict";
	var xx, yy, ww, hh, oldSize, newSize, fnt, oldAlign, oldBaseline, height,
		text = this.findText();

	// Create the correct font
	if (this.font instanceof tbVectorFont) {
        this.font = this.font.clone();

		// console.log('send in the clones', this.font.fontSize, this.font);
	} else {
		// console.log('dont you clone me');
		fnt = new tbVectorFont();
		fnt.setProperties(this.font);
		//fnt = fnt.clone();
		this.font = fnt;
	}

	if (this.breakWords !== undefined) {
		this.font.breakWords = this.breakWords;
		this.font.setStyle();
	}

    if(this.splitLines && this.width){
        this.font.setWordWrap(this.splitLines, this.width);
    }

    this.font.setText(text);

    // Determine the box for the text
	ww = this.width > 0 ? this.width : this.font.textWidth(text);
    this.textWidth = ww;
	hh = this.height > 0 ? this.height : this.font.textHeight(text);
	this.textHeight = hh;

	// Adapt the alignment when overriden
	oldAlign = this.font.align;
	if (this.align !== undefined) {
        this.font.setAlign(this.align);
	}
	oldBaseline = this.font.baseline;
	if (this.baseline !== undefined) {
        this.font.setBaseline(this.baseline);
	}

	var resetSize = true;
	oldSize = this.font.getFontSize();
	if (this.fitToBox && this.width > 0) {

		// console.log('never show me this', text);

		height = this.height;
		if (height <= 0) {
			height = hh;
		}
		// textFitSize not working in currentVersion
		newSize = this.font.textFitSize(text, this.width, height, this.splitLines);
		if(newSize < oldSize) { 
			this.font.setFontSize(newSize); 
			resetSize = false;
		};
	}

	this._xOffset = 0;
	this._yOffset = 0;

	if (this.centerBox) {

		// y-axis
		height = this.height;

		if (height <= 0) {
			height = hh;
		}


		var lineInfo = this.font.lineInfo();
		var lines = lineInfo.lines;
		var lineHeight = lineInfo.lineHeight;
		
		var areaHeight = lineHeight * lines.length;
		
		this._yOffset = height / 2 - areaHeight/2;
	}

	

	// Now determine the position
	// switch (this.font.align) {
	// 	case "left": xx = this.surfaceMargin; break;
	// 	case "center": xx = this.surfaceMargin + ww/2 - this.font.textWidth(text) / 2; break;
	// 	case "right": xx = this.surfaceMargin + ww - this.font.textWidth(text); break;
	// }
	// switch (this.font.baseline) {
	// 	case "top": yy = this.surfaceMargin; break;
	// 	case "middle": yy = this.surfaceMargin + hh/2 - this.font.textHeight(text) / 2; break;
	// 	case "bottom": yy = this.surfaceMargin + hh - this.font.textHeight(text); break;
	// }

	// if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	// Create the surface
	// this.textSurface = new tbSurface(ww + 2*this.surfaceMargin, hh + 2*this.surfaceMargin);
	// this.textSurface.setTarget();
	// Compute the size
	
	// Draw the text
	// if (this.splitLines && this.width > 0) {
	// 	//fnt.drawSimple(text, xx, yy, this.width);
	// } else {
		//fnt.drawSimple(text, xx, yy);
// }
	// Restore the size
	if(resetSize) {
		this.font.setFontSize(oldSize);
	}
	// Restore the alignment
	if (this.align === undefined) {
        this.font.setAlign(oldAlign);
	}
	if (this.baseline !== undefined) {
        this.font.setBaseline(oldBaseline);
	}

    this.font.setPosition(this.x, this.y + this._yOffset);
    // this.font.setPosition(this.x, 200);

	this.font.setScale(this.xScale, this.yScale);

	this.font.setRotation(this.angle);
	
	if (this.styles) {
		this.setStyles(this.styles);
		this.createMultiStyleSurface();
	}

	this.font.setAlpha(this.alpha);

    // Clean up
	// this.textSurface.resetTarget();
	// this.parent.addChild(this.font);
};

tgfComponents.Label.prototype.setStyles = function (styles) {
	var resultObject = {};
	for (var style in styles) {
		resultObject[style] = {};
		for (var key in styles[style]) {
			if (tgfSettings.styleTranslation[key]) {
				resultObject[style][tgfSettings.styleTranslation[key]] = styles[style][key];
			} else {
				resultObject[style][key] = styles[style][key];
			}
		}
	}

	this.styles = resultObject;
};

tgfComponents.Label.prototype.setAlpha = function (alpha) {
	this.alpha = alpha;

	this.font.setAlpha(alpha);
};

tgfComponents.Label.prototype.setScale = function (xScale, yScale) {
	this.xScale = xScale;
	this.yScale = yScale;
	this.font.setScale(xScale, yScale);
};

// Create the surface
tgfComponents.Label.prototype.createMultiStyleSurface = function() {
	"use strict";

	if (!this.styles.hasOwnProperty("default")) { // Add default to styles if missing.
		this.styles.default = {};
	}

	if (this.font instanceof tbVectorFont) {
		this.styles.default["fontFace"] = this["font"]["fontFace"];
		this.styles.default["wordWrapWidth"] = this["width"];

		var textStyle = this.font["textStyle"]();

		for (var style in textStyle) {
			if (!textStyle.hasOwnProperty(style)) continue;
			
			this.styles["default"][style] = (typeof this.styles["default"][style] === 'undefined') ? textStyle[style] : this.styles["default"][style];
		}

		// xOrigin wasn't explicitly defined, overwrite it.
		if (typeof(this.xOrigin) === 'undefined') {

			var align = (typeof this.styles["default"]["align"] === 'undefined') ? this.align : this.styles["default"]["align"];
			switch (align) {
				default:
				case 'left':
					this.xOrigin = 0.0;
					break;
				case 'center':
					this.xOrigin = 0.5;
                    break;
                case 'right':
					this.xOrigin = 1.0;
					break;
			}
		}
		
		// yOrigin wasn't explicitly defined, overwrite it.
		if (typeof(this.yOrigin) === 'undefined') {

			var baseline = (typeof this["styles"]["default"]["baseline"] === 'undefined') ? this.baseline : this["styles"]["default"]["baseline"];
			switch (baseline) {
				default:
				case 'top':
					this.yOrigin = 0.0;
					break;
				case 'middle':
					this.yOrigin = 0.5;
					break;
				case 'bottom':
					this.yOrigin = 1.0;
					break;
			}
		}

		this.font["remove"](this.baseContainer);
		this.font["free"]();
	}
	this.font = new MultiStyleText(this["text"], this["styles"], this.styles["default"]);

	if (this.onClick) {
		this.font["interactive"] = true;
		this.font["on"]("pointerdown", this.onClick);
	}
	
};

tgfComponents.Label.prototype.doEndStep = function(timePassed) {
	if (this.baseContainer && !this.added) {
		this.baseContainer.addChild(this["font"]);
		this.added = true;
	}
};

// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
tgfComponents.Label.prototype.doPrepare = function() {
	"use strict";
	var i;

	// this.baseline = 'middle';
	// this.align = 'center';

	// Create the surface
	this.createSurface();
 

	// draw debug box
	if (this.drawDebug) {

		var w = this.width || this.getWidth();
		var h = this.height || this.getHeight();

		var rect = tbGraphics.drawRectangle(this.x, this.y, w, h, 0xff0000, null, 0, 0.5);
		this.baseContainer.addChild(rect);
	}

	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when freeing the component after use
tgfComponents.Label.prototype.doFree = function() {
	"use strict";
	
	if (this.font)	{
		if (this.styles) {
			if (this.font["parent"]) {
				this.baseContainer.removeChild(this.font);
			}
			this.font["destroy"](true);
			this.font = null;
		} else {
			this.font["remove"](this.baseContainer);
			this.font["free"]();
			this.font = null;
		}
	}
};

tgfComponents.Label.prototype.onHide = function () {
	"use strict";
    if(this.font) {
		if (this.styles) {
			this.font["visible"] = false;
		} else {
			this.font["hide"]();
		}
	}
};

tgfComponents.Label.prototype.onShow = function () {
	"use strict";
    if(this.font) {
		if (this.styles) {
			this.font["visible"] = true;
		} else {
			this.font["show"]();
		}
	}
};


// ***************************************
// Methods called when events must be processed
// ***************************************

// Called when a touch is started or if a mouse button is pressed
tgfComponents.Label.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
	var xx, yy, ww, hh;
	if (this.onClick === null) { return; }
	// Determine the position of the text surface
	xx = -this.textWidth/2;
	yy = -this.textHeight/2;
	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	switch (this.font.align) {
		case "left": xx = -this.surfaceMargin; break;
		case "right": xx = -this.textWidth + this.surfaceMargin; break;
	}
	switch (this.font.baseline) {
		case "top":  yy = -this.surfaceMargin; break;
		case "bottom": yy = -this.textHeight + this.surfaceMargin; break;
	}
	ww = this.textWidth - 2*this.surfaceMargin;
	hh = this.textHeight - 2*this.surfaceMargin;
	if (x >= xx && x <= xx+ww && y >= yy && y <= yy+hh) {
		this.onClick(this);
	}
};

// Called if a special or user-defined event happens
tgfComponents.Label.prototype.doSpecial = function(id, args) {
	"use strict";
	// if (id === "languageSet") { this.createSurface(); }
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Label.prototype.doDraw = function() {
	"use strict";
	// Determine the position of the text surface
	// var xx = -this.textSurface.width/2, yy = -this.textSurface.height/2;
	// if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	// switch (this.font.align) {
	// 	case "left": xx = -this.surfaceMargin; break;
	// 	case "right": xx = -this.textSurface.width + this.surfaceMargin; break;
	// }
	// switch (this.font.baseline) {
	// 	case "top":  yy = -this.surfaceMargin; break;
	// 	case "bottom": yy = -this.textSurface.height + this.surfaceMargin; break;
	// }
	// // Now draw it
	// this.textSurface.drawSimple(xx, yy);
		
	if (this.added) {
		if (this.styles) {
			this.font["x"] = this.x - this.font["width"] * this.xOrigin;
			this.font["y"] = this.y - this.font["height"] * this.yOrigin;
		} else {
			this.font["setPosition"](this.x + this._xOffset, this.y + this._yOffset);
		}
	}
};


//******************************************************
//*****    Script Resource: ComponentPicture
//******************************************************

// ***************************************
// tgfComponents.Picture
//
// This component displays an animated picture
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 18-6-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.picture = {
	image: s_tgf_frame,						// The image or surface resource to display
	mask: undefined,
	animationSpeed: 0,						// The animation speed, in frames per second (can be negative, or 0 for static)
	startSubImage: 0,						// The sub-image at which the animation starts
	loopAnimation: true,					// Whether to loop when the animation is completed
	roundSubImage: true,					// Whether to round the sub-images or floor them
	combineSubImages: false,				// Whether to combine the sub-images in one big image
	createFromSlices: false,				// Create from 3 or 9 slices (overwrites combineSubImages)
	sliceMargins: 10,						// If 9 slice is used, make the corners this many by this many pixels
	sliceMarginsArray: [],						// If 9 slice is used, make the corners this many by this many pixels
	onAnimationComplete: null,				// Called when the animation is complete
	roundPosition: true,					// Whether to round the position when the size is odd
	maintainAspectRatio: true,				// Whether to maintain the aspect ratio of the image
	components: [],							// Components to add as children
	onClick: null,							// Called when the player clicks the picture
	tint: 0xFFFFFF							// The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Picture = function(properties) {
	"use strict";
	this.name = "Picture";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.picture);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Picture, tgfComponents.Base);

// Overriden to return the correct width
tgfComponents.Picture.prototype.getWidth = function() {
	"use strict";
	if (this.width > 0) {
		return this.width;
	} else if (!this.image) {
		return 0;
	} else if (this.combineSubImages) {
		return this.image.combinedWidth;
	} else {
		return this.image.width;
	}
};

// Overriden to return the correct width
tgfComponents.Picture.prototype.getHeight = function() {
	"use strict";
	if (this.height > 0) {
		return this.height;
	} else if (!this.image) {
		return 0;
	} else if (this.combineSubImages) {
		return this.image.combinedHeight;
	} else {
		return this.image.height;
	}
};

// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
tgfComponents.Picture.prototype.doPrepare = function() {
	"use strict";
	var i, self = this;

	if(!this.image){
		return;
	}

	this.image = this.image.clone();

	if(this.createFromSlices){
		var xOrigin = this.image.xOrigin,
			yOrigin = this.image.yOrigin;

		// this.image = this.image.getNineSlice(0, Math.floor(this.image.width / 2) - 2, Math.floor(this.image.width / 2) - 2, Math.floor(this.image.height / 2) - 2, Math.floor(this.image.height / 2) - 2);
		
		if (this.sliceMarginsArray.length > 0) {

			this.image = this.image.getNineSlice(0, this.sliceMarginsArray[0], this.sliceMarginsArray[1], this.sliceMarginsArray[2], this.sliceMarginsArray[3]);
		}
		else {
			this.image = this.image.getNineSlice(0, this.sliceMargins, this.sliceMargins, this.sliceMargins, this.sliceMargins);
		}
		this.image.xOrigin = xOrigin;
        this.image.yOrigin = yOrigin;
	}
	
	this.image.setDimensions(this.getWidth(), this.getHeight());
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}

	this.image.add(this.baseContainer);
	
	if(this.mask){
		this.baseContainer.addChild(this.mask);
		this.mask.position.set(this.x, this.y);
		this.image.setMask(this.mask);
	}

	this.image.setScale(this.xScale, this.yScale);
	if(this.onClick){
        this.image.setCallback(function () {
            if(!self.isActive || !self.isVisible) { return; }
			self.onClick();
        }, true);
	}

    this.image.setRotation(this.angle);
	this.image.setAlpha(this.alpha);
	this.image.setTint(this.tint);
};

tgfComponents.Picture.prototype.changeImage = function(image) {
	"use strict";
	if(this.image && image){
		this.image.remove(this.baseContainer);
		this.image.free();

        this.image = image.clone();

		this.image.setAlpha(this.alpha);
		this.image.setTint(this.tint);

        // if(this.mask){
        //     this.image.setMask(this.mask);
        // }

        if(this.createFromSlices){
            var xOrigin = this.image.xOrigin,
                yOrigin = this.image.yOrigin;

            // this.image = this.image.getNineSlice(0, Math.floor(this.image.width / 2) - 2, Math.floor(this.image.width / 2) - 2, Math.floor(this.image.height / 2) - 2, Math.floor(this.image.height / 2) - 2);

            if (this.sliceMarginsArray.length > 0) {

                this.image = this.image.getNineSlice(0, this.sliceMarginsArray[0], this.sliceMarginsArray[1], this.sliceMarginsArray[2], this.sliceMarginsArray[3]);
            }
            else {
                this.image = this.image.getNineSlice(0, this.sliceMargins, this.sliceMargins, this.sliceMargins, this.sliceMargins);
            }
            this.image.xOrigin = xOrigin;
            this.image.yOrigin = yOrigin;
        }

        this.image.setDimensions(this.getWidth(), this.getHeight());

        this.image.add(this.baseContainer);

        this.image.setScale(this.xScale, this.yScale);
        if(this.onClick){
            this.image.setCallback(function () {
                if(!self.isActive || !self.isVisible) { return; }
                self.onClick();
            }, true);
        }

        this.image.setRotation(this.angle);
	}
};

tgfComponents.Picture.prototype.bringToFront = function() {
	this.image.remove(this.baseContainer);
	this.image.add(this.baseContainer);
};

tgfComponents.Picture.prototype.setDimensions = function(width, height) {
	this.width = width;
	this.height = height;
	this.image.setDimensions(width, height)
};

// Processing required when showing the component
tgfComponents.Picture.prototype.setSubImage = function(index) {

	"use strict";

	var frame = Math.min(index, this.image.sprites.length-1);
	this.image.gotoAndStop(frame);
};

tgfComponents.Picture.prototype.setTint = function(tint) {
	this.tint = tint;
    this.image.setTint(this.tint);
}

tgfComponents.Picture.prototype.setAlpha = function(alpha){
	"use strict";
	this.alpha = alpha;
    this.image.setAlpha(this.alpha);
};

tgfComponents.Picture.prototype.setAngle = function(angle){
    "use strict";
    this.angle = angle;
    this.image.setRotation(this.angle);
};

tgfComponents.Picture.prototype.doShow = function() {
	"use strict";
	// this.subImage = this.startSubImage;
	// this.animating = true;
	//this.image.add();
	//this.parent.addChild(this.image);

	this.image.show();
};

tgfComponents.Picture.prototype.doHide =function() {
	"use strict";
	//TODO is actually hide
	//this.image.remove();
	
	this.image.hide();
};

tgfComponents.Picture.prototype.setScale = function(scaleX, scaleY) {
	"use strict";
	this.xScale = scaleX;
	this.yScale = scaleY;
	this.image.setScale(this.xScale, this.yScale);
};

tgfComponents.Picture.prototype.doFree = function() {
	"use strict";

	if (this.image)	{
		this.image.remove(this.baseContainer);
		this.image.free();
		this.image = null;
	}	
};


// ***************************************
// Methods called when events must be processed
// ***************************************

// Called when a touch is started or if a mouse button is pressed
tgfComponents.Picture.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
	// var ww, hh;
	// if (!this.onClick) { return; }
	// if (this.image === null) { return; }
	// if (this.combineSubImages && this.image instanceof tbImage) {
	// 	ww = this.width > 0 ? this.width : this.image.combinedWidth;
	// 	hh = this.height > 0 ? this.height : this.image.combinedHeight;
	// } else {
	// 	ww = this.width > 0 ? this.width : this.image.width;
	// 	hh = this.height > 0 ? this.height : this.image.height;
	// }
	// if (x >= -ww/2 && x <= ww/2 && y >= -hh/2 && y <= hh/2) {
	// 	this.onClick(this);
	// }
};

// Called just before drawing (also when not active)
tgfComponents.Picture.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
	// Compute the correct sub-image
	// if (this.image !== null && this.image instanceof tbImage && this.animating) {
	// 	this.subImage += this.animationSpeed * timePassed/1000;
	// 	if (this.animationSpeed > 0 && this.subImage >= this.image.number) {
	// 		if (this.loopAnimation) {
	// 			this.subImage -= this.image.number;
	// 		} else {
	// 			this.subImage = this.image.number-1;
	// 			this.animating = false;
	// 		}
	// 		if (this.onAnimationComplete) { this.onAnimationComplete(this); }
	// 	} else if (this.animationSpeed < 0 && this.subImage < 0) {
	// 		if (this.loopAnimation) {
	// 			this.subImage += this.image.number;
	// 		} else {
	// 			this.subImage = 0;
	// 			this.animating = false;
	// 		}
	// 		if (this.onAnimationComplete) { this.onAnimationComplete(this); }
	// 	}
	// }
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Picture.prototype.doDraw = function() {
	"use strict";
    var subImg, ww, hh, xx, yy, screenAspectRatio, imageAspectRatio;
    if (this.image === null) { return; }

    ww = this.width > 0 ? this.width : this.image.width;
	hh = this.height > 0 ? this.height : this.image.height;
	xx = -ww/2; yy = -hh/2;

    if (ww === this.image.width && hh === this.image.height) {
		this.image.setPosition(this.x, this.y);//xx + this.image.xOrigin, yy + this.image.yOrigin);
	}

	// var subImg, ww, hh, xx, yy, screenAspectRatio, imageAspectRatio;
	// if (this.image === null) { return; }
	// if (this.image instanceof tbSurface) {
	// 	ww = this.width > 0 ? this.width : this.image.width;
	// 	hh = this.height > 0 ? this.height : this.image.height;
	// 	xx = -ww/2; yy = -hh/2;
	// 	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	// 	if (this.createFromSlices) {
	// 		this.image.drawNineSlice(xx, yy, ww, hh, tbGraphics.context.alpha,
	// 			Math.floor(this.image.width / 2) - 2, Math.floor(this.image.width / 2) - 2, Math.floor(this.image.height / 2) - 2, Math.floor(this.image.height / 2) - 2);
    //
	// 	} else if (ww === this.image.width && hh === this.image.height) {
	// 		this.image.drawSimple(xx + this.image.xOrigin, yy + this.image.yOrigin);
	// 	} else {
    //
	// 		if (this.maintainAspectRatio) {
    //
	// 			screenAspectRatio = ww / hh;
	// 			imageAspectRatio = this.image.width / this.image.height;
    //
	// 			if (screenAspectRatio < imageAspectRatio) {
	// 				yy += (hh - ww / imageAspectRatio) / 2;
	// 				hh = ww / imageAspectRatio;
	// 			}
	// 			else {
	// 				xx += (ww - hh * imageAspectRatio) / 2;
	// 				ww = hh * imageAspectRatio;
	// 			}
	// 		}
	// 		this.image.drawStretched(xx, yy, ww, hh, tbGraphics.context.alpha);
	// 	}
	// } else if (this.image instanceof tbImage) {
	// 	ww = this.width > 0 ? this.width : this.image.width;
	// 	hh = this.height > 0 ? this.height : this.image.height;
	// 	xx = -ww/2; yy = -hh/2;
	// 	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	// 	subImg = this.roundSubImage ? this.subImage : Math.min(this.image.number-1, Math.floor(this.subImage));
	// 	if (this.createFromSlices) {
	// 		this.image.drawNineSlice(subImg, xx, yy, ww, hh, tbGraphics.context.alpha,
	// 			Math.floor(this.image.width / 2) - 2, Math.floor(this.image.width / 2) - 2, Math.floor(this.image.height / 2) - 2, Math.floor(this.image.height / 2) - 2);
	// 	} else if (this.combineSubImages) {
	// 		ww = this.width > 0 ? this.width : this.image.combinedWidth;
	// 		hh = this.height > 0 ? this.height : this.image.combinedHeight;
	// 		xx = -ww/2; yy = -hh/2;
	// 		if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	// 		if (ww === this.image.combinedWidth && hh === this.image.combinedHeight) {
	// 			this.image.drawCombinedSimple(xx + this.image.xOrigin, yy + this.image.yOrigin);
	// 		} else {
    //
	// 			if (this.maintainAspectRatio) {
    //
	// 				screenAspectRatio = ww / hh;
	// 				imageAspectRatio = this.image.combinedWidth / this.image.combinedHeight;
    //
	// 				if (screenAspectRatio < imageAspectRatio) {
	// 					yy += (hh - ww / imageAspectRatio) / 2;
	// 					hh = ww / imageAspectRatio;
	// 				}
	// 				else {
	// 					xx += (ww - hh * imageAspectRatio) / 2;
	// 					ww = hh * imageAspectRatio;
	// 				}
	// 			}
	// 			this.image.drawCombinedStretched(xx, yy, ww, hh, tbGraphics.context.alpha);
	// 		}
	// 	} else {
	// 		if (ww === this.image.width && hh === this.image.height) {
	// 			this.image.drawSimple(subImg, xx + this.image.xOrigin, yy + this.image.yOrigin);
	// 		} else {
	// 			if (this.maintainAspectRatio) {
    //
	// 				screenAspectRatio = ww / hh;
	// 				imageAspectRatio = this.image.width / this.image.height;
    //
	// 				if (screenAspectRatio < imageAspectRatio) {
	// 					yy += (hh - ww / imageAspectRatio) / 2;
	// 					hh = ww / imageAspectRatio;
	// 				}
	// 				else {
	// 					xx += (ww - hh * imageAspectRatio) / 2;
	// 					ww = hh * imageAspectRatio;
	// 				}
	// 			}
	// 			this.image.drawStretched(subImg, xx, yy, ww, hh, tbGraphics.context.alpha);
	// 		}
	// 	}
	// }
};

//******************************************************
//*****    Script Resource: ComponentProgressBar
//******************************************************

// ***************************************
// tgfComponents.ProgressBar
//
// This component displays a progress bar
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 26-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.progressBar = {
	imageBack: s_tgf_progressbar_back,		// The image or surface resource for the background
	imageFront: null,						// The image or surface resource for the front
	imageFill: s_tgf_progressbar_fill,		// The image or surface resource for the filling
	fillMode: "slice",						// Way of filling (slice, stretch, tile)
	fillDirection: "right",					// The direction in which to fill the bar (left, right, up, down)
	fillOffsetX: 0,							// Horizontal offset for the fill image
	fillOffsetY: 0,							// Vertical offset for the fill image
	fillOffsetW: 0,							// Width offset for the fill image
	fillOffsetH: 0,							// Height offset for the fill image
	animationSpeed: 0,						// The animation speed, in frames per second (can be negative, or 0 for static)
	startSubImage: 0,						// The sub-image at which the animation starts
	loopAnimation: true,					// Whether to loop when the animation is completed
	roundSubImage: true,					// Whether to round the sub-images or floor them
	progressInitial: 0,						// Initial progress
	progressFunction: null,					// When not null, the progress is read from this function in every step
	progressSpeed: 100,						// Maximal progress change per second
	roundPosition: true,					// Whether to round the position when the size is odd
	components: [],							// Components to add as children
	onFull: null,							// Called when the progress bar becomes full
	onEmpty: null,							// Called when the progress bar becomes empty
	onAnimationComplete: null				// Called when an animation cycle is complete
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.ProgressBar = function(properties) {
	"use strict";
	this.name = "ProgressBar";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.progressBar);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ProgressBar, tgfComponents.Base);

// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.ProgressBar.prototype.getWidth = function() {
	"use strict";
	if (this.width) {
		return this.width;
	}
	if (this.imageBack && this.imageBack.width) {
		return this.imageBack.width;
	}
	return 0;
};

// Returns the height of the component. Must be overriden if it is not the width property
tgfComponents.ProgressBar.prototype.getHeight = function() {
	"use strict";
	if (this.height) {
		return this.height;
	}
	if (this.imageBack && this.imageBack.height) {
		return  this.imageBack.height;
	}
	return 0;
};


// ***************************************
// Specific methods for this component
// ***************************************

// Sets the new progress
tgfComponents.ProgressBar.prototype.setProgress = function(percentage, immediate) {
	"use strict";
	this.progress = percentage;
	if (immediate) { this.currentProgress = this.progress; }
};

// Gets the current progress
tgfComponents.ProgressBar.prototype.getProgress = function(shown) {
	"use strict";
	if (shown) {
		return this.currentProgress;
	} else {
		return this.progress;
	}
};


// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
tgfComponents.ProgressBar.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when showing the component
tgfComponents.ProgressBar.prototype.doShow = function() {
	"use strict";
	this.subImage = this.startSubImage;
	this.setProgress(this.progressInitial, true);
};

// ***************************************
// Methods called when events must be processed
// ***************************************

// Called just before drawing (also when not active)
tgfComponents.ProgressBar.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
	var newSubImage, oldProgress, diff, maxDiff;
	// Find the new progress
	if (this.progressFunction) { this.progress = this.progressFunction(); }
	// Update the currently shown progress
	oldProgress = this.currentProgress;
	diff = this.progress - this.currentProgress;
	maxDiff = this.progressSpeed * timePassed / 1000;
	if (Math.abs(diff) <= maxDiff) {
		this.currentProgress = this.progress;
	} else if (diff < 0) {
		this.currentProgress -= maxDiff;
	} else {
		this.currentProgress += maxDiff;
	}
	this.currentProgress = Math.min(100, Math.max(0, this.currentProgress));
	if (oldProgress < 100 && this.currentProgress >= 100 && this.onFull) {
		this.onFull(this);
	} else if (oldProgress > 0 && this.currentProgress <= 0 && this.onEmpty) {
		this.onEmpty(this);
	}
	// Compute the correct sub-image
	if (this.imageBack !== null && this.imageBack instanceof tbImage) {
		newSubImage = this.subImage + this.animationSpeed * timePassed/1000;
		if (this.subImage < this.imageBack.number && newSubImage >= this.imageBack.number) {
			if (this.loopAnimation) {
				this.subImage = newSubImage - this.imageBack.number;
			} else {
				this.subImage = this.imageBack.number;
			}
			if (this.onAnimationComplete) { this.onAnimationComplete(this); }
		} else if (this.subImage > 0 && newSubImage < 0) {
			if (this.loopAnimation) {
				this.subImage = this.imageBack.number + newSubImage;
			} else {
				this.subImage = 0;
			}
			if (this.onAnimationComplete) { this.onAnimationComplete(this); }
		} else {
			this.subImage = newSubImage;
		}
	}
};

// Draw the image in the indicated way
tgfComponents.ProgressBar.prototype.drawImage = function(image, xx, yy, ww, hh, kind) {
	"use strict";
	var subImg;
	if (image === null) { return; }
	if (image instanceof tbSurface) {
		switch (kind) {
			case "slice":
				image.drawNineSlice(xx, yy, ww, hh, tbGraphics.context.alpha,
					Math.floor(image.width / 2) - 2, Math.floor(image.width / 2) - 2, Math.floor(image.height / 2) - 2, Math.floor(image.height / 2) - 2);
				break;
			case "stretch": image.drawStretched(xx, yy, ww, hh, tbGraphics.context.alpha); break;
			case "tile": image.drawTiledOffset(image.xOrigin, image.yOrigin, xx, yy, ww, hh, tbGraphics.context.alpha); break;
		}
	} else if (image instanceof tbImage) {
		subImg = this.roundSubImage ? this.subImage : Math.min(image.number-1, Math.floor(this.subImage));
		switch (kind) {
			case "slice":
				image.drawNineSlice(subImg, xx, yy, ww, hh, tbGraphics.context.alpha,
					Math.floor(image.width / 2) - 2, Math.floor(image.width / 2) - 2, Math.floor(image.height / 2) - 2, Math.floor(image.height / 2) - 2);
				break;
			case "stretch": image.drawStretched(subImg, xx, yy, ww, hh, tbGraphics.context.alpha); break;
			case "tile": image.drawTiledOffset(subImg, image.xOrigin, image.yOrigin, xx, yy, ww, hh, tbGraphics.context.alpha); break;
		}
	}
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.ProgressBar.prototype.doDraw = function() {
	"use strict";
	var ww = this.width > 0 ? this.width : this.imageBack.width,
		hh = this.height > 0 ? this.height : this.imageBack.height,
		xx = -ww/2, yy = -hh/2, xf, yf, wf, hf;
	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	xf = xx + this.fillOffsetX;
	yf = yy + this.fillOffsetY;
	wf = ww + this.fillOffsetW;
	hf = hh + this.fillOffsetH;
	// Draw the images
	this.drawImage(this.imageBack, xx, yy, ww, hh, "slice");
	switch (this.fillDirection) {
		case "right": wf *= this.currentProgress / 100; break;
		case "left": xf +=  wf * (1 - this.currentProgress / 100); wf *= this.currentProgress / 100; break;
		case "down": hf *= this.currentProgress / 100; break;
		case "up": yf +=  hf * (1 - this.currentProgress / 100); hf *= this.currentProgress / 100; break;
	}
	this.drawImage(this.imageFill, xf, yf, wf, hf, this.fillMode);
	this.drawImage(this.imageFront, xx, yy, ww, hh, "slice");
};

//******************************************************
//*****    Script Resource: ComponentDarkener
//******************************************************

// ***************************************
// tgfComponents.Darkener
//
// This component darkens and lightens the background
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 26-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings, tgfGraphics */


tgfSettings.componentDefaults.darkener = {
	width: undefined,						// To take the full canvas
	height: undefined,						// To take the full canvas
	darkColor: "#000000",					// Color to darken to
	darkAlpha: 0.6,							// Alpha to darken to
	duration: 0.2,							// Duration for darkening and lighting in seconds
	startImmediately: true,					// Whether to immediately start darkening
	components: [],							// Components to add as children
	onDark: null,							// Called when the it is fully dark
	onLight: null							// Called when the it is fully light again
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Darkener = function(properties) {
	"use strict";
	this.name = "Darkener";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.darkener);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Darkener, tgfComponents.Base);

// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Darkener.prototype.getWidth = function() {
	"use strict";
	if (this.width) {
		return this.width;
	}
	return tbGraphics.width;
};

// Returns the height of the component. Must be overriden if it is not the width property
tgfComponents.Darkener.prototype.getHeight = function() {
	"use strict";
	if (this.height) {
		return this.height;
	}
	return tbGraphics.height;
};


// ***************************************
// Specific methods for this component
// ***************************************

// Make the world dark
tgfComponents.Darkener.prototype.makeDark = function(duration, delay) {
	"use strict";
	if (duration === undefined) { duration = this.duration; }
	if (delay === undefined) { delay = 0; }
	this.mode = "darkening";
	this.startAlpha = 0;
	this.goalAlpha = this.darkAlpha;
	this.darkDuration = duration;
	this.darkTimer = duration + delay;
};

// Make the world light
tgfComponents.Darkener.prototype.makeLight = function(duration, delay) {
	"use strict";
	if (duration === undefined) { duration = this.duration; }
	if (delay === undefined) { delay = 0; }
	this.mode = "lighting";
	this.startAlpha = this.darkAlpha;
	this.goalAlpha = 0;
	this.darkDuration = duration;
	this.darkTimer = duration + delay;
};



// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
tgfComponents.Darkener.prototype.doPrepare = function() {
	"use strict";
	var i;
	this.mode = "idle";
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when showing the component
tgfComponents.Darkener.prototype.doShow = function() {
	"use strict";
	if (this.startImmediately) { this.makeDark(); }
};


// ***************************************
// Methods called when events must be processed
//		- These can be removed when no processing is required
//		- When they return true, this event is no further processed
//			by other components in the dialog
//		- Never call these methods yourself in other components,
//			Use the inherited handle methods instead
// ***************************************

// Called just before drawing (also when not active)
tgfComponents.Darkener.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
	if (this.mode === "idle") { return; }
	if (this.darkTimer <= 0) { return; }
	this.darkTimer -= timePassed/1000;
	if (this.darkTimer <= 0 ) {
		if (this.mode === "darkening" && this.onDark !== null) { this.onDark(this); }
		if (this.mode === "lighting" && this.onLight !== null) { this.onLight(this); }
	}
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Darkener.prototype.doDraw = function() {
	"use strict";
	var alpha = 0, oldAlpha, ww = this.getWidth(), hh = this.getHeight();
	if (tbGraphics.canvas !== tgfGraphics.mainCanvas) {
		return;
	}
	if (this.mode === "idle") { return; }
	if (this.darkTimer >= this.darkDuration) {
		alpha = this.startAlpha;
	} else if (this.darkTimer <= 0) {
		alpha = this.goalAlpha;
	} else {
		alpha = this.startAlpha + (1 - this.darkTimer/this.darkDuration) * (this.goalAlpha - this.startAlpha);
	}
	if (alpha === 0) { return; }
	oldAlpha = tbGraphics.context.globalAlpha;
	tbGraphics.context.globalAlpha *= alpha;
	tbGraphics.drawRectangle(-ww/2, -hh/2, ww, hh, this.darkColor);
	tbGraphics.context.globalAlpha = oldAlpha;
};

//******************************************************
//*****    Script Resource: ComponentButton
//******************************************************

// ***************************************
// tgfComponents.Button
//
// This component displays and handles a button with an image
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 26-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings, tbMath */


tgfSettings.componentDefaults.button = {
	image: s_tgf_button,					// The image or surface (when two sub-image, first one is for up and second for down)
	createFromSlices: false,					// Create from 3 or 9 slices
    mask: undefined,
	marginLeft: tgfScale(24),				// Margin from the left side of the button
	marginRight: tgfScale(24),				// Margin from the right side of the button
	marginTop: tgfScale(24),				// Margin from the top side of the button
	marginBottom: tgfScale(24),				// Margin from the bottom side of the button
	icon: null,								// The image or surface for the icon (when two sub-image, first one is for up and second for down)
	iconPosition: "left",					// Position of the icon ("left", "right", "center", "top", "bottom")
	iconTextDistance: tgfScale(24),			// Distance between the icon and the text
	iconAlpha: 1,
	text: "",								// The text on the button
	dictionaryKey: "",						// The dictionary key to read the text from (if not empty)
	fontDown: null,							// Font to be used when in down state
	fontUp: f_tgf_button,					// Font to be used when in up state
	splitLines: false,						// Whether to allow for splitting of the lines
	fitToBox: true,							// Whether to fit the text to the button bounds
	offsetXUp: 0,							// Horizontal offset when the button is up
	offsetYUp: 0,							// Vertical offset when the button is up
	offsetXDown: 0,							// Horizontal offset when the button is down
	offsetYDown: 0,							// Vertical offset when the button is down
	soundDown: a_tgf_button_down,			// Sound to play when pressing down
	soundUp: null,							// Sound to play when going up
	toggleIndex: 0,							// Current toggle index to show
	toggleAutomatic: false,					// Whether toggling happens automatically when clicking
	toggleCount: 0,							// Number of toggles. When 0,determines automatically
	touchMargin: 0,							// Extra margin for the touch events around the image
	touchMarginBox: null,					// Detailed touch margins for each side, array of format [left, top, right, bottom], overrides touchMargin
	shortcutKey: null,						// Shortcut keycode for the button
	anyKey: false,							// Whether it reacts to any key
	reactOnDown: false,						// Whether to react when the button goes down, rather than up
	cancelEvents: true,						// Whether to cancel the touch and key events when treated by the button
	useImmediateInput: false,    			// Should immediate touch function be used to process touches?
	roundPosition: true,					// Whether to round the position when the size is odd
	components: [],							// Components to add as children
	onClick: null,   						// Called when the player clicks the button
	allowedTouchMotion: 10000,				// How far a touch on the button can move before the button press is canceled.
	canClick: true,
	iconDownScale: .9,
	fontDownScale: .95,
	iconXScale: 1,
	iconYScale: 1,
	tint: 0xFFFFFF,
};

// The constructor for the component
/** @constructor
 *  @base tgfComponents.Base
 */
tgfComponents.Button = function(properties) {
	"use strict";
	this.name = "Button";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.button);
	this.touchStart = new tbVector(0,0);

	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Button, tgfComponents.Base);


// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Button.prototype.getWidth = function() {
	"use strict";
	return this.width;
};

// Returns the height of the component. Must be overriden if it is not the width property
tgfComponents.Button.prototype.getHeight = function() {
	"use strict";
	return this.height;
};


// ***************************************
// Methods that are specific for this component
// ***************************************

// Recreate the surfaces, when something has changed
tgfComponents.Button.prototype.recreate = function() {
	"use strict";
};


// ***************************************
// Internal methods
// ***************************************

// Returns the actual text
tgfComponents.Button.prototype.findText = function() {
	"use strict";
	var text = this.text, key = this.dictionaryKey;
	// Find the correct value for toggle buttons
	if (Object.prototype.toString.call(this.text) === "[object Array]") {
		text = this.text[this.toggleIndex % this.text.length];
	}
	if (Object.prototype.toString.call(this.dictionaryKey) === "[object Array]") {
		key = this.dictionaryKey[this.toggleIndex % this.dictionaryKey.length];
	}
	// Now determine the actual text
	if (key !== "") {
		text = tgfDictionary.getText(key, "<" + key + ">");
	}
	return text;
};

// Draws the icon (if any)
tgfComponents.Button.prototype.drawIcon = function() {
	"use strict";
	var xx, yy, image = this.icon;
	if (!image) { return; }

	if (this._iconCreated) {
		image = this.icon;
	}
	else {

		image = this.icon.clone();
		this._iconCreated = true;
	}

	// Determine the position
	switch (this.iconPosition) {
		case "left": xx = this.marginLeft; yy = (this.marginTop - this.marginBottom + this.image.height - image.height) / 2; break;
		case "center": xx = (this.image.width - image.width)/2; yy = (this.marginTop - this.marginBottom + this.image.height - image.height) / 2; break;
		case "right": xx = this.image.width - image.width - this.marginRight; yy = (this.marginTop - this.marginBottom + this.image.height - image.height) / 2; break;
		case "top": xx = (this.image.width - image.width)/2; yy = this.marginTop; break;
		case "bottom": xx = (this.image.width - image.width)/2; yy = this.image.width - image.width - this.marginBottom; break;
	}
	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }	

	image.setPosition(xx + image.xOrigin, yy + image.yOrigin);
	image.setScale(this.iconXScale, this.iconYScale);

	this.image.addChild(image);
	image.setAlpha(this.iconAlpha);

	this.icon = image;
};

// Draws the text in the correct way at position x, y
tgfComponents.Button.prototype.drawText = function() {
	"use strict";
	var xx, yy, ww, hh, oldSize, newSize, font, fnt,
		text = this.findText(),
		image = this.icon;

	if(text === ""){
		return;
	}

	this._text = null;
	// if (this.icon && Object.prototype.toString.call(this.icon) === "[object Array]") {
    // 	image = this.icon[this.toggleIndex % this.icon.length];
    // }
	// Create the correct font
	if(this.icon) {
		image = this.icon.clone();
	}

	if (this.fontDown) {
		font = this.fontDown;
	} else {
		font = this.fontUp;
	}

	if (font instanceof tbVectorFont) {
		fnt = font.clone();
	} else {
		fnt = new tbVectorFont();
		fnt.setProperties(font);
	}

	fnt.setText(text);
	this._font = fnt;

	// Determine the box for the text
	xx = this.marginLeft;
	yy = this.marginTop;
	ww = this.width - this.marginLeft - this.marginRight;
	hh = this.height - this.marginTop - this.marginBottom;
	if (image) {
		switch (this.iconPosition) {
			case "left": xx += image.width + this.iconTextDistance; ww -= image.width + this.iconTextDistance; break;
			case "center": break;
			case "right": ww -= image.width + this.iconTextDistance; break;
			case "top": yy += image.height + this.iconTextDistance; hh -= image.height + this.iconTextDistance; break;
			case "bottom": hh -= image.height + this.iconTextDistance; break;
		}
	}
	switch (fnt.align) {
		case "left": break;
		case "center": xx += ww/2; break;
		case "right": xx += ww; break;
	}
	switch (fnt.baseline) {
		case "top": break;
		case "middle": yy += hh/2; break;
		case "bottom": yy += hh; break;
	}
	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }

    if(this.splitLines && this.width){
        fnt.setWordWrap(this.splitLines, ww);
    }
	// Deal with the offset
	// if (state === "down") {
	// 	xx += this.offsetXDown; yy += this.offsetYDown;
	// } else {
		xx += this.offsetXUp; yy += this.offsetYUp;
	// }
	// Compute the size
	oldSize = fnt.getFontSize();

    //Optionally fit the text to the bounds of the button
    if (this.fitToBox) {
        var height = this.height;
        if (height <= 0) {
            height = hh;
        }
        newSize = fnt.textFitSize(text, ww, height, this.splitLines);
        if (newSize < oldSize) { 
            fnt.setFontSize(newSize); 
        }
    }

	// Draw the text
	// if (this.splitLines) {
	// 	fnt.drawSimple(text, xx, yy, ww);
	// } else {
	// 	fnt.drawSimple(text, xx, yy);
	// }
	this.image.addChild(fnt);

	fnt.setPosition(xx, yy);
	// Restore the size
	//fnt.setFontSize(oldSize);
	this.fontText = fnt;
};

tgfComponents.Button.prototype.setText = function(text){
    "use strict";
    this.text = text ? text : this.text;

    this.fontText.setText(this.text);
};

// Set the state of the button to up or down
tgfComponents.Button.prototype._setStateUp = function() {
	"use strict";
	var self = this;

	if(!self.isActive || !self.isVisible || !self.canClick || !self.isDown) { return; }

    self.finger = -1;

	//self.image.changeFrame(self._imageCollection[0]);

	if (self.soundUp) { tgfAudio.play(self.soundUp); }

	if (self.onClick) { self.onClick(self); }
};

// Set the state of the button to up or down
tgfComponents.Button.prototype._setStateDown = function() {
    "use strict";
    var self = this;

    if(!self.isActive || !self.isVisible || !self.canClick) { return; }

	//self.image.changeFrame(self._imageCollection[1]);
	self.isDown = true;

    if (self.soundUp) { tgfAudio.play(self.soundUp); }

    if (self.onClick) { self.onClick(self); }
};

tgfComponents.Button.prototype._resetButtonState = function() {
    "use strict";
    this.canClick = false;
	this.isDown = false;

    this.changeImageFrame(0);
    // this.image.changeFrame(this._imageCollection[0]);
    
    if(this.icon){
        this.icon.setScale(this.iconXScale, this.iconYScale);
    }
    if(this.fontText){
        this.fontText.setScale(1, 1);
    }
};

tgfComponents.Button.prototype._iconDown = function() {
    "use strict";
    if(this.icon){
        //this.icon.setScale(this.iconDownScale, this.iconDownScale);
        this.icon.setScale(0.9 * this.iconXScale, 0.9 * this.iconYScale);
	}
    if(this.fontText){
        this.fontText.setScale(this.fontDownScale, this.fontDownScale);
    }
};

tgfComponents.Button.prototype._iconUp = function() {
    "use strict";
    if(this.icon){
		this.icon.setScale(this.iconXScale, this.iconYScale);
    }
    if(this.fontText){
        this.fontText.setScale(1, 1);
	}
};

// ***************************************
// Preparing, showing and activating
// ***************************************

// Prepare the component for use; returns whether already prepared
tgfComponents.Button.prototype.doPrepare = function() {
	"use strict";
	var i, self = this;
    this.toggleCount = 2;

    var nineSliceOffsetX = this.nineSliceOffsetX || 0;
    var nineSliceOffsetY = this.nineSliceOffsetY || 0;

    this._imageCollection = [];
	this.image = this.image.clone();

	this.image.setTint(this.tint)

	for(var j = 0; j < this.toggleCount; j++){
	    this._imageCollection.push(this.image.getTexture(this.image.getFrame(j)));
	}

	if(!this.createFromSlices){
		this.image.sprite = this.image.getFrame(0);
	} else {

		this._imageNineSlices = [];
		this._imageNineSlices[0] = this.image.getNineSlice(0, Math.floor(this.image.width / 2) - 2 + nineSliceOffsetX, Math.floor(this.image.width / 2) - 2 - nineSliceOffsetX, Math.floor(this.image.height / 2) - 2 + nineSliceOffsetY, Math.floor(this.image.height / 2) - 2 - nineSliceOffsetY);
		this._imageNineSlices[1] = this.image.getNineSlice(1, Math.floor(this.image.width / 2) - 2 + nineSliceOffsetX, Math.floor(this.image.width / 2) - 2 - nineSliceOffsetX, Math.floor(this.image.height / 2) - 2 + nineSliceOffsetY, Math.floor(this.image.height / 2) - 2 - nineSliceOffsetY);


        this.image = s_tgf_transparent.clone();
		this.image.setDimensions(this.width, this.height);

		for (var s = 0; s < this._imageNineSlices.length; s++) {

			// console.log('slice', s);
			this._imageNineSlices[s].setDimensions(this.width, this.height);
			this._imageNineSlices[s].add(this.image);

			if (s > 0) {
				this._imageNineSlices[s].setAlpha(0);
			}
		}
	}

	if(this.width <= 0){
		this.width = this.image.width;
	}

	if(this.height <= 0){
		this.height = this.image.height;
	}
	
	this.image.setAlpha(this.alpha);

    if(this.mask){
        this.image.setMask(this.mask);
    }

    var callbackUp = function() {
		
		if(!self.isActive || !self.isVisible || !self.canClick || !self.isDown) { self.isDown = false; return; }

        if(!self.reactOnDown){
			self._setStateUp();
		}
		
		self.isDown = false;
        self._iconUp();
        self.changeImageFrame(0);
    };

    var callbackDown = function(){

		if(!self.isActive || !self.isVisible || !self.canClick) { return; }
		
		self.isDown = true;
    	if(self.reactOnDown){
			self._setStateDown();
		}
        self._iconDown();
        self.changeImageFrame(1);
    };

    var callbackCancel = function(){
    	self._resetButtonState();
	};

    this.image.setCallback(callbackUp, false);
    this.image.setCallback(callbackDown, true);

    this.image.cancelCallback(callbackCancel);

    this.drawText();
    this.drawIcon();

    this.image.add(this.baseContainer);

	this.finger = -1;
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}

	// Set touchMarginBox from touchMargin if not set already
	if (this.touchMargin && !this.touchMarginBox) {
		this.touchMarginBox = [this.touchMargin, this.touchMargin, this.touchMargin, this.touchMargin];
	}

	if (this.touchMarginBox && this.touchMarginBox.length == 4){
		this.image["sprite"]["hitArea"] = new PIXI["Rectangle"](
			0 - this.touchMarginBox[0],
			0 - this.touchMarginBox[1],
			this.image["sprite"]["width"] + this.touchMarginBox[0] + this.touchMarginBox[2],
			this.image["sprite"]["height"] + this.touchMarginBox[1] + this.touchMarginBox[3]
		);
	}
};

// Processing required when freeing the component after use
tgfComponents.Button.prototype.changeImageFrame = function(frame) {
	"use strict";
	
	if (!this.image) { return; }

	if (this.createFromSlices) {
		
		// update ninesliced image		
		
		for (var s = 0; s < this._imageNineSlices.length; s++) {
			
			if (!this._imageNineSlices[s]) continue;

			if (s == frame) {
				this._imageNineSlices[s].setAlpha(1);				
			}
			else {
				this._imageNineSlices[s].setAlpha(0);				
			}
		}
	}
	else {

		this.image.changeFrame(this._imageCollection[frame]);
	}
};

tgfComponents.Button.prototype.changeIcon = function(icon) {
	"use strict";
	
	// recreating icon, so set to false
	this._iconCreated = false;

	this.image.removeChild(this.icon);
	this.icon = icon;
	this.drawIcon();
};

tgfComponents.Button.prototype.doFree = function() {
	"use strict";

	if (this.icon && this.image)
	{
		this.icon.remove(this.image);
		this.icon.free();
		this.icon = null;
	}
	
	if (this.fontText && this.image)
	{
		this.fontText.remove(this.image);
		this.fontText.free();
		this.fontText = null;
	}

	if (this.image)	{
		this.image.remove(this.baseContainer);
		this.image.free();
		this.image = null;
	}

	if (this._imageNineSlices) {
		for (var i = 0; i < this._imageNineSlices.length; i++) {
			this._imageNineSlices[i].free();
			this._imageNineSlices[i] = null;
		}		
		this._imageNineSlices = null;
	}
};


// ***************************************
// Methods called when events must be processed
// ***************************************

//Called when a touch is started or if a mouse button is pressed
tgfComponents.Button.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
	// if (!this.useImmediateInput) {
	// 	return this.doTouchDownInternal(finger, x, y);
	// }
    this.finger = finger;

    this.touchStart.x = tbGame.touchX(this.finger);
    this.touchStart.y = tbGame.touchY(this.finger);
};

//Called when a touch is ended or if a mouse button is released
tgfComponents.Button.prototype.doTouchUp = function(finger, x, y) {
	"use strict";
    this.finger = -1;
    this.canClick = true;
};

//Called when a touch is started or if a mouse button is pressed
tgfComponents.Button.prototype.doImmediateTouchDown = function(finger, x, y) {
	"use strict";
};

//Called when a touch is ended or if a mouse button is released
tgfComponents.Button.prototype.doImmediateTouchUp = function(finger, x, y) {
	"use strict";
};

// Do the actual work when a touch is started or if a mouse button is pressed
tgfComponents.Button.prototype.doTouchDownInternal = function(finger, x, y) {
	"use strict";
};

// Do the actual work when a touch is ended or if a mouse button is released
tgfComponents.Button.prototype.doTouchUpInternal = function(finger, x, y) {
	"use strict";
};

// Called if the key with the given keyCode is pressed
tgfComponents.Button.prototype.doKeyDown = function(keyCode) {
	"use strict";
	if (this.anyKey || (this.shortcutKey && keyCode === this.shortcutKey)) {
		if (this.cancelEvents) { return true; }
	}
};

// Called if the key with the given keyCode is released
tgfComponents.Button.prototype.doKeyUp = function(keyCode) {
	"use strict";
	if (this.anyKey || (this.shortcutKey && keyCode === this.shortcutKey)) {
		if (this.cancelEvents) { return true; }
	}
};

// Called at the end of each step
tgfComponents.Button.prototype.doEndStep = function(timePassed) {
	"use strict";
	var xx, yy,
		ww = this.width + 2 * this.touchMargin,
		hh = this.height + 2 * this.touchMargin;

	// Check whether the finger moves on or off the button
	if (this.finger !== -1) {	
		xx = tbGame.touchX(this.finger);
		yy = tbGame.touchY(this.finger);

		var dist = tbMath.distance(this.touchStart.x, this.touchStart.y, xx, yy);

		if(dist >= this.allowedTouchMotion){

			this._resetButtonState();
            this.finger = -1;
		}
	}
};

// Called if a special or user-defined event happens
tgfComponents.Button.prototype.doSpecial = function(id, args) {
	"use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Button.prototype.doDraw = function() {
    "use strict";
    var ww = this.width, hh = this.height,
        xx = -ww / 2, yy = -hh / 2;
    if (this.roundPosition) {
        xx = Math.floor(xx);
        yy = Math.floor(yy);
    }

    this.image.setPosition(xx + this.x, yy + this.y);
    this.image.setScale(this.xScale, this.yScale);
};

tgfComponents.Button.prototype.setAlpha = function(alpha) {
	"use strict";
	this.alpha = alpha;

	if (this.image) {
		this.image.setAlpha(this.alpha);
	}
};

tgfComponents.Button.prototype.setIconAlpha = function(alpha) {
	"use strict";
	if (this.icon) {
		this.icon.setAlpha(alpha);
	}
};

tgfComponents.Button.prototype.onHide = function() {
	"use strict";
	if(this.image) this.image.hide();
    if(this.icon) this.icon.hide();
    if(this.fontText) this.fontText.hide();
};

tgfComponents.Button.prototype.onShow = function() {
    "use strict";
    if(this.image) this.image.show();
    if(this.icon) this.icon.show();
    if(this.fontText) this.fontText.show();
};

tgfComponents.Button.prototype.onDeactivate = function() {
	"use strict";
	this._resetButtonState();
};

tgfComponents.Button.prototype.onActivate = function() {
	"use strict";
    this.canClick = true;
};

tgfComponents.Button.prototype.setTint = function(tint) {
	this.tint = tint;
	this.image.setTint(tint);
};
//******************************************************
//*****    Script Resource: ComponentSlider
//******************************************************

// ***************************************
// tgfComponents.Slider
//
// This component displays and handles slider
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */
/*global s_tgf_slider_back, s_tgf_slider_slider, f_tgf_text */

tgfSettings.componentDefaults.slider = {
	imageBack: s_tgf_slider_back,			// The image or surface for the background of the slider (when two subimages, first is for left and second for right of slider)
	imageSlider: s_tgf_slider_slider,		// The image or surface for the slider
	icon: null,								// The image or surface for the icon
	iconPercentages: undefined,				// An array of value ranges (in percentages) for the different sub icons. When undefined we are clever.
	iconPosition: "left",					// Position of the icon ("left", "right", "top", "bottom")
	direction: "horizontal",				// Sliding direction ("horizontal", "vertical")
	minValue: 0,							// The minimal value
	maxValue: 100,							// The maximal value
	initialValue: 50,						// The initial value when showing the dialog
	roundValue: false,						// Whether to round the value to an integer
	showValue: false,						// Whether to show the value
	valuePosition: "left",					// Position of the value ("left", "right", "top", "bottom")
	valueWidth: tgfScale(48),				// Width of the value text box
	valueHeight: tgfScale(48),				// Height of the value text box
	valueFont: f_tgf_text,					// Font for showing the value
	gap: tgfScale(8),						// Gap between icon and value and slider
	touchMargin: tgfScale(8),				// The additional margin around the slider in which you can touch the slider
	cancelEvents: true,						// Whether to cancel the touch events when treated by the slider
	roundPosition: true,					// Whether to round the position when the size is odd
	components: [],							// Components to add as children
	onChange: null,							// Called when the value of the slider changes
	onIconClick: null						// Called when the player clicks on the icon
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Slider = function(properties) {
	"use strict";
	this.name = "Slider";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.slider);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Slider, tgfComponents.Base);


// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Slider.prototype.getWidth = function() {
	"use strict";
	if (this.width) {
		return this.width;
	}
	if (this.imageBack && this.imageBack.width) {
		return this.imageBack.width;
	}
	return 0;
};

// Returns the height of the component. Must be overriden if it is not the width property
tgfComponents.Slider.prototype.getHeight = function() {
	"use strict";
	if (this.height) {
		return this.height;
	}
	if (this.imageBack && this.imageBack.height) {
		return  this.imageBack.height;
	}
	return 0;
};


// ***************************************
// Methods that are specific for this component
// ***************************************

// Recreate the surface, when something changes
tgfComponents.Slider.prototype.recreate = function() {
	"use strict";
	this.createSurface();
};

// Sets the value of the slider, nocall indicates not to call the callback
tgfComponents.Slider.prototype.setValue = function(value, nocall) {
	"use strict";	
	value = Math.max(this.minValue, Math.min(this.maxValue, value));
	if (this.roundValue) { value = Math.round(value); }
	if (value !== this.value) {
		this.value = value;
		if (!nocall && this.onChange) { this.onChange(this, this.value); }
		this._calculatePositions();
		this._calculateIconNumber();
		this.recreate();
	}
};

// Returns the value of the slider
tgfComponents.Slider.prototype.getValue = function() {
	"use strict";
	return this.value;
};


// ***************************************
// Internal methods
// ***************************************

// Calculate the various positions
tgfComponents.Slider.prototype._calculatePositions = function() {
	"use strict";
	var xx = 0, yy = 0,
		ww = this.width === 0 ? this.imageBack.width : this.width,
		hh = this.height === 0 ? this.imageBack.height : this.height;
	if (this.direction === "vertical") {
		if (this.icon) {
			if (this.iconPosition === "bottom") {
				this.iconY = Math.round(yy + hh/2 - this.icon.height/2);
				this.iconX = 0;
				hh -= this.icon.height + this.gap;
				yy -= Math.round((this.icon.height + this.gap)/2);
			} else {
				this.iconY = Math.round(yy - hh/2 + this.icon.height/2);
				this.iconX = 0;
				hh -= this.icon.height + this.gap;
				yy += Math.round((this.icon.height + this.gap)/2);
			}
		}
		if (this.showValue) {
			if (this.valuePosition === "bottom") {
				this.valueY = Math.round(yy + hh/2 - this.valueHeight/2);
				this.valueX = 0;
				hh -= this.valueHeight + this.gap;
				yy -= Math.round((this.valueHeight + this.gap)/2);
			} else {
				this.valueY = Math.round(yy - hh/2 + this.valueHeight/2);
				this.valueC = 0;
				hh -= this.valueHeight + this.gap;
				yy += Math.round((this.valueHeight + this.gap)/2);
			}
		}
		this.sliderTop = Math.round(yy - hh/2);
		this.sliderBottom = Math.round(yy + hh/2);
		this.sliderY = Math.round(this.sliderBottom - (this.sliderBottom-this.sliderTop) * (this.value - this.minValue) / (this.maxValue - this.minValue));
		this.sliderX = 0;
	} else {
		if (this.icon) {
			if (this.iconPosition === "right") {
				this.iconX = Math.round(xx + ww/2 - this.icon.width/2);
				this.iconY = 0;
				ww -= this.icon.width + this.gap;
				xx -= Math.round((this.icon.width + this.gap)/2);
			} else {
				this.iconX = Math.round(xx - ww/2 + this.icon.width/2);
				this.iconY = 0;
				ww -= this.icon.width + this.gap;
				xx += Math.round((this.icon.width + this.gap)/2);
			}
		}
		if (this.showValue) {
			if (this.valuePosition === "right") {
				this.valueX = Math.round(xx + ww/2 - this.valueWidth/2);
				this.valueY = 0;
				ww -= this.valueWidth + this.gap;
				xx -= Math.round((this.valueWidth + this.gap)/2);
			} else {
				this.valueX = Math.round(xx - ww/2 + this.valueWidth/2);
				this.valueY = 0;
				ww -= this.valueWidth + this.gap;
				xx += Math.round((this.valueWidth + this.gap)/2);
			}
		}
		this.sliderLeft = Math.round(xx - ww/2);
		this.sliderRight = Math.round(xx + ww/2);
		this.sliderX = Math.round(this.sliderLeft + (this.sliderRight-this.sliderLeft) * (this.value - this.minValue) / (this.maxValue - this.minValue));
		this.sliderY = 0;
	}
};

// Calculate the correct icon number
tgfComponents.Slider.prototype._calculateIconNumber = function() {
	"use strict";
	var i, tot = 0, perc = 100 * (this.value - this.minValue) / (this.maxValue - this.minValue);
	if (this.iconPercentages === undefined) {
		if (this.icon.number === 1) {
			this.iconNumber = 0;
		} else if (this.icon.number === 2) {
			this.iconNumber = this.value === this.minValue ? 0 : 1;
		} else {
			this.iconNumber = 1 + Math.floor(perc/100 * (this.icon.number-2));
			if (this.value === this.minValue) { this.iconNumber = 0; }
			if (this.value === this.maxValue) { this.iconNumber = this.icon.number-1; }
		}
	} else {
		for (i = 0; i < this.iconPercentages.length; i += 1) {
			tot += this.iconPercentages[i];
			if (perc <= tot) {
				this.iconNumber = i;
				return;
			}
		}
		this.iconNumber = this.icon.number-1;
	}
};

// Draws a horizontal background part of the slider
tgfComponents.Slider.prototype._drawBackHor = function(context, image, x1, x2, x3, y) {
	"use strict";
	var w = Math.floor(image.width/2), h = Math.floor(image.height/2);
	if (image instanceof tbSurface) {
		image.drawNineSlice(x1, y, x3-x1, image.height, 1, w-2, w-2, h-2, h-2);
	} else if (image.number === 1) {
		image.drawNineSlice(0, x1, y, x3-x1, image.height, 1, w-2, w-2, h-2, h-2);
	} else {
		context.save();
		image.drawNineSlice(0, x1, y, x3-x1, image.height, 1, w-2, w-2, h-2, h-2);
		context.rect(x2, 0, x3-x2, context.canvas.height);
		context.clip();
		image.drawNineSlice(1, x1, y, x3-x1, image.height, 1, w-2, w-2, h-2, h-2);	
		context.restore();
	}
};

// Draws a vertical background part of the slider
tgfComponents.Slider.prototype._drawBackVert = function(context, image, y1, y2, y3, x) {
	"use strict";
	var w = Math.floor(image.width/2), h = Math.floor(image.height/2);
	if (image instanceof tbSurface) {
		image.drawNineSlice(x, y1, image.width, y3-y1, 1, w-2, w-2, h-2, h-2);
	} else if (image.number === 1) {
		image.drawNineSlice(0, x, y1, image.width, y3-y1, 1, w-2, w-2, h-2, h-2);
	} else {
		context.save();
		image.drawNineSlice(0, x, y1, image.width, y3-y1, 1, w-2, w-2, h-2, h-2);
		context.rect(0, y2, context.canvas.width, y3-y2);
		context.clip();
		image.drawNineSlice(1, x, y1, image.width, y3-y1, 1, w-2, w-2, h-2, h-2);
		context.restore();
	}
};

// Draws the slider
tgfComponents.Slider.prototype.drawSlider = function(context, x, y) {
	"use strict";
	var xxx, yyy, txt, fnt;
	// Draw the background
	if (this.direction === "vertical") { 
		this._drawBackVert(context, this.imageBack, y + this.sliderTop, y + this.sliderY, y + this.sliderBottom, x + Math.round(-this.imageBack.width/2));
	} else {
		this._drawBackHor(context, this.imageBack, x + this.sliderLeft, x + this.sliderX, x + this.sliderRight, y + Math.round(-this.imageBack.height/2));
	}
	// Draw the slider
	xxx =  x + Math.round(-this.imageSlider.width/2) + this.imageSlider.xOrigin;
	yyy =  y + Math.round(-this.imageSlider.height/2) + this.imageSlider.yOrigin;
	if (this.imageSlider instanceof tbSurface) {
		this.imageSlider.drawSimple(this.sliderX + xxx, this.sliderY + yyy);
	} else {
		this.imageSlider.drawSimple(0, this.sliderX + xxx, this.sliderY + yyy);
	}
	// Draw the icon
	if (this.icon) {
		xxx =  x + Math.round(-this.icon.width/2) + this.icon.xOrigin;
		yyy =  y + Math.round(-this.icon.height/2) + this.icon.yOrigin;
		if (this.icon instanceof tbSurface) {
			this.icon.drawSimple(this.iconX + xxx, this.iconY + yyy);
		} else {
				this.icon.drawSimple(this.iconNumber, this.iconX + xxx, this.iconY + yyy);
		}
	}
	// Draw the value
	if (this.showValue) {
		txt = Math.round(this.value).toString();
		if (this.valueFont instanceof tbVectorFont) {
			fnt = this.valueFont.clone();
		} else {
			fnt = new tbVectorFont();
			fnt.setProperties(this.valueFont);
		}
		fnt.baseLine = "middle";
		fnt.align = "center";
		fnt.size = fnt.textFitSize(txt, this.valueWidth, this.valueHeight);
		fnt.drawSimple(txt, x + this.valueX, y + this.valueY);
	}
};

// Create the surface for the slider
tgfComponents.Slider.prototype.createSurface = function() {
	"use strict";
	var ww = this.width === 0 ? this.imageBack.width : this.width,
		hh = this.height === 0 ? this.imageBack.height : this.height;
	ww = Math.max(ww, this.imageSlider.width) + 4;
	hh = Math.max(hh, this.imageSlider.height) + 4;
	this.surface = new tbSurface(ww, hh);
	this.surface.setTarget();
	this.drawSlider(this.surface.context, Math.round(ww/2), Math.round(hh/2));
	this.surface.resetTarget();
};


// ***************************************
// Preparing, showing and activating
// ***************************************

// Prepare the component for use; returns whether already prepared
tgfComponents.Slider.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Initialize the value (will also create the surface)
	this.value = undefined;
	this.setValue(this.initialValue, true);
	this.finger = -1;
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when freeing the component after use
tgfComponents.Slider.prototype.doFree = function() {
	"use strict";
	// Free the surface
	this.surface = undefined;
};


// ***************************************
// Methods called when events must be processed
// ***************************************

// Called when a touch is started or if a mouse slider is pressed
tgfComponents.Slider.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
	var tw = this.imageSlider.width/2, th = this.imageSlider.height/2, iw, ih;
	if (this.touchMargin) {
		tw += this.touchMargin;
		th += this.touchMargin;
	}
	// Check whether the touch the slider
	if (x >= this.sliderX - tw && x <= this.sliderX + tw && 
		y >= this.sliderY - th && y <= this.sliderY + th) {
		this.finger = finger;
		this.touchXOff = x - this.sliderX;
		this.touchYOff = y - this.sliderY;
		if (this.cancelEvents) { return true; }
	}
	// Check whether we click the icon
	if (this.icon && this.onIconClick) {
		iw = this.icon.width/2;
		ih = this.icon.height/2;
		if (this.touchMargin) {
			iw += this.touchMargin;
			ih += this.touchMargin;
		}
		if (x >= this.iconX - iw && x <= this.iconX + iw && 
			y >= this.iconY - ih && y <= this.iconY + ih) {
			this.onIconClick(this);
			if (this.cancelEvents) { return true; }
		}
	}
};

// Called when a touch is ended or if a mouse slider is released
tgfComponents.Slider.prototype.doTouchUp = function(finger, x, y) {
	"use strict";
	// Stop sliding
	if (this.finger !== finger) { return; }
	this.finger = -1;
};

// Called at the end of each step
tgfComponents.Slider.prototype.doEndStep = function(timePassed) { 
	"use strict";
	var x, y, val;
	// Check whether the slider position must be changed
	if (this.finger !== -1) {
		x = this.touchX(this.finger) - this.touchXOff;
		y = this.touchY(this.finger) - this.touchYOff;
		if (this.direction === "vertical" ) {
			val = this.maxValue - (this.maxValue - this.minValue) * (y - this.sliderTop) / (this.sliderBottom - this.sliderTop);
		} else {
			val = this.minValue + (this.maxValue - this.minValue) * (x - this.sliderLeft) / (this.sliderRight - this.sliderLeft);
		}
		this.setValue(val);
	}
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Slider.prototype.doDraw = function() {
	"use strict";
	if (this.roundPosition) {
		this.surface.drawSimple(Math.round(-this.surface.width/2), Math.round(-this.surface.height/2));
	} else {
		this.surface.drawSimple(-this.surface.width/2, -this.surface.height/2);
	}
};

//******************************************************
//*****    Script Resource: ComponentScrollBar
//******************************************************

// ***************************************
// tgfComponents.ScrollBar
//
// This component displays a progress bar
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 18-6-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfComponents.ScrollBarDirection = {
	Vertical: 0,
	Horizontal: 1
};

tgfSettings.componentDefaults.scrollBar = {
	imageBack: s_tgf_progressbar_back,		// The image or surface resource for the background
	imageHandle: s_tgf_progressbar_fill,		// The image or surface resource for the filling
	direction: tgfComponents.ScrollBarDirection.Vertical,
	width: undefined,
	height: tgfScale(200),
	marginLeft: 0,
	marginRight: 0,
	marginTop: 0,
	marginBottom: 0
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.ScrollBar = function(properties) {
	"use strict";
	this.name = "ScrollBar";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.scrollBar);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }

	this.scrollPosition = 0;
	this.scrollRange = this.height;

	this.touchFinger = -1;

	this.touchScrollPosition = undefined;
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ScrollBar, tgfComponents.Base);

// ***************************************
// Methods called when events must be processed
// ***************************************

// Draw the image in the indicated way
tgfComponents.ScrollBar.prototype.drawImage = function(image, xx, yy, ww, hh, kind) {
	"use strict";
	if (image === null) { return; }
	if (image instanceof tbSurface) {
		switch (kind) {
			case "slice":
				image.drawNineSlice(xx, yy, ww, hh, tbGraphics.context.alpha,
					Math.floor(image.width / 2) - 2, Math.floor(image.width / 2) - 2, Math.floor(image.height / 2) - 2, Math.floor(image.height / 2) - 2);
				break;
			case "stretch": image.drawStretched(xx, yy, ww, hh, tbGraphics.context.alpha); break;
			case "tile": image.drawTiledOffset(image.xOrigin, image.yOrigin, xx, yy, ww, hh, tbGraphics.context.alpha); break;
		}
	} else if (image instanceof tbImage) {
		switch (kind) {
			case "slice":
				image.drawNineSlice(0, xx, yy, ww, hh, tbGraphics.context.alpha,
					Math.floor(image.width / 2) - 2, Math.floor(image.width / 2) - 2, Math.floor(image.height / 2) - 2, Math.floor(image.height / 2) - 2);
				break;
			case "stretch": image.drawStretched(0, xx, yy, ww, hh, tbGraphics.context.alpha); break;
			case "tile": image.drawTiledOffset(0, image.xOrigin, image.yOrigin, xx, yy, ww, hh, tbGraphics.context.alpha); break;
		}
	}
};

tgfComponents.ScrollBar.prototype.handleTouchDown = function(finger, screenX, screenY) {
	"use strict";

	var xx = this.screenToComponentX(screenX, screenY);
	var yy = this.screenToComponentY(screenX, screenY);

	var ww = this.getWidth();
	var hh = this.getHeight();

	if (xx > -ww / 2 + this.marginLeft && xx < ww / 2 - this.marginRight && yy > -hh / 2 + this.marginTop && yy < hh / 2 - this.marginBottom) {
		this.touchFinger = finger;
		this._updateScrollPosition(xx, yy);
		return true;
	}
	return false;
};

tgfComponents.ScrollBar.prototype.handleTouchUp = function(finger, screenX, screenY) {
	"use strict";
	if (this.touchFinger === finger) {
		this.touchFinger = -1;
		this.touchScrollPosition = undefined;
		return true;
	}
	return false;
};

tgfComponents.ScrollBar.prototype.handleEndStep = function(timePassed) {
	"use strict";

	if (this.touchFinger !== -1) {
		var touchX = tbGame.touchX(this.touchFinger);
		var touchY = tbGame.touchY(this.touchFinger);

		var xx = this.screenToComponentX(touchX, touchY);
		var yy = this.screenToComponentY(touchX, touchY);

		this._updateScrollPosition(xx, yy);
	}
};

tgfComponents.ScrollBar.prototype._updateScrollPosition = function(touchX, touchY) {
	"use strict";
	var ww = this.getWidth() - this.marginLeft - this.marginRight;
	var hh = this.getHeight() - this.marginTop - this.marginBottom;

	var xx = touchX - this.marginLeft;
	var yy = touchY - this.marginTop;

	var barLength;
	var minHandleLength;
	if (this.direction === tgfComponents.ScrollBarDirection.Vertical) {
		barLength = hh;
		minHandleLength = Math.ceil(this.imageHandle.height / 3 * 2);
	} else {
		barLength = ww;
		minHandleLength = Math.ceil(this.imageHandle.width / 3 * 2);
	}

	var handleLength = Math.min(barLength, Math.max(minHandleLength, (barLength / this.scrollRange) * barLength));

	if (isNaN(handleLength)) {
		handleLength = barLength;
	}

	var handlePosition;
	if (this.direction === tgfComponents.ScrollBarDirection.Vertical) {
		handlePosition = ((yy + hh / 2));
	}
	else {
		handlePosition = ((xx + ww / 2));
	}

	if (isNaN(handlePosition)) {
		handlePosition = 0;
	}

	this.scrollPosition = Math.min(this.scrollRange, Math.max(0, (handlePosition - handleLength / 2) / (barLength - handleLength) * this.scrollRange));
	if (isNaN(this.scrollPosition)) {
		this.scrollPosition = 0;
	}
	this.touchScrollPosition = this.scrollPosition;
};


tgfComponents.ScrollBar.prototype.getWidth = function() {
	"use strict";
	return this.width > 0 ? this.width : (this.imageBack.width + this.marginLeft + this.marginRight);
};

tgfComponents.ScrollBar.prototype.getHeight = function() {
	"use strict";
	return this.height > 0 ? this.height : (this.imageBack.height + this.marginTop + this.marginBottom);
};



// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.ScrollBar.prototype.doDraw = function() {
	"use strict";
	var ww = this.width > 0 ? (this.width - this.marginLeft - this.marginRight) : this.imageBack.width;
	var hh = this.height > 0 ? (this.height - this.marginTop - this.marginBottom) : this.imageBack.height;

	var xx = -(ww + this.marginLeft + this.marginRight)/2;
	var yy = -(hh + this.marginTop + this.marginBottom)/2;

	xx += this.marginLeft;
	yy += this.marginTop;

	if (this.roundPosition) {
		xx = Math.floor(xx);
		yy = Math.floor(yy);
	}

	// Draw the images
	var xf = xx;
	var yf = yy;
	var wf = ww;
	var hf = hh;

	var barLength;
	var minHandleLength;
	if (this.direction === tgfComponents.ScrollBarDirection.Vertical) {
		barLength = hh;
		minHandleLength = Math.ceil(this.imageHandle.height / 3 * 2);
	} else {
		barLength = ww;
		minHandleLength = Math.ceil(this.imageHandle.width / 3 * 2);
	}

	var handleLength = Math.min(barLength, Math.max(minHandleLength, (barLength / this.scrollRange) * barLength));
	if (isNaN(handleLength)) {
		handleLength = barLength;
	}
	var handlePosition = (barLength - handleLength) * (this.scrollPosition / this.scrollRange);
	if (isNaN(handlePosition)) {
		handlePosition = 0;
	}

	this.drawImage(this.imageBack, xx, yy, ww, hh, "slice");
	switch (this.direction) {
	case tgfComponents.ScrollBarDirection.Vertical:
		yf += handlePosition;
		hf = handleLength;
		break;
	case tgfComponents.ScrollBarDirection.Horizontal:
		xf += handlePosition;
		wf = handleLength;
		break;
	}
	this.drawImage(this.imageHandle, xf, yf, wf, hf, "slice");
};

//******************************************************
//*****    Script Resource: tgfDialogs
//******************************************************

// ***************************************
// tgfDialogs
//
// This object contains all the dialogs and some useful
// global methods related to the dialogs
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 17-6-2015
// ***************************************

// Directives for jslint
/*global tgfSettings */


var tgfDialogs = {};

// Create the settings group for the dialogs
tgfSettings.dialogDefaults = {};

// Let dialog C inherit the prototype of P, using the Holy Grail inheritance (JavaScript Patterns, page 127)
tgfDialogs.inherit = function(C, P) {
	"use strict";
	var F = function(){};
	F.prototype = P.prototype;
	C.prototype = new F();
	C.uber = P.prototype;
	C.prototype.constructor = C;
};
//******************************************************
//*****    Script Resource: DialogBase
//******************************************************

// ***************************************
// tgfDialogs.Base
//
// This dialog contains the basic functionality of all dialogs
//
// Copyright 2015-2016 Tingly Games B.V.
// Last Changed: 11-1-2016
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbKeyCodes, tbLoader, tbVector */
/*global tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfFunctions */


tgfSettings.dialogDefaults.base = {
	canvas: null,						// The canvas for the dialog
	layer: -1000,						// The layer for the dialog
	depth: 0,							// The depth for the dialog
	x: 0,								// The x-position of the center of the dialog
	y: 0,								// The y-position of the center of the dialog
	width: 0,							// Width of the dialog
	height: 0,							// Height of the dialog
	propagateCancelEvents: true,			// Whether cancel events components must propagate to other tokens
	baseContainer: null
};


// The constructor for the base dialog (not called for inherited components!)
/**
 * @constructor
 */
tgfDialogs.Base = function(properties) {
	"use strict";
	// Initialize properties
	this.initialize();
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};


// ***************************************
// General methods (can be overridden)
// ***************************************

// Initialize the properties of the dialog
tgfDialogs.Base.prototype.initialize = function(properties) {
	"use strict";

	// console.log('Container::', properties.container);

	properties = properties || {};

	this.setProperties(tgfSettings.dialogDefaults.base);	// The base properties must always be included first
	this.setProperties(properties);
    this.baseContainer = new tbContainer(tgfGraphics.areaWidth, tgfGraphics.areaHeight);
    this.baseContainer.name = this.name;
    this.baseContainer.dialog = this;

    // this.baseContainer = properties.container || new tbContainer(tgfGraphics.areaWidth, tgfGraphics.areaHeight);
	this.parent = null;					// Dialogs do not have parents (yet)
	this.parentDialog = properties.parentDialog;					// Dialogs do not have parents (yet)
	this.kind = "dialog";				// The kind (must be "dialog")
	this._components = [];				// The components in the dialog
	this.isPrepared = false;			// Whether prepared (true, false)
	this.isVisible = false;				// Whether visible (true, false)
	this.isActive = false;				// Whether active (true, false)

	if (this.canvas === null) { this.canvas = tgfGraphics.mainCanvas; }
};

// Sets a number of properties of the dialog
tgfDialogs.Base.prototype.setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

// Transform the screen (x,y)-coordinate to the component x-coordinate
tgfDialogs.Base.prototype.screenToComponentX = function(screenX, screenY) {
	"use strict";
	if (this.parent !== null) {
		return this.parent.screenToComponentX(screenX, screenY) - this.x;
	}
	return screenX - this.x;
};

// Transform the screen (x,y)-coordinate to the component y-coordinate
tgfDialogs.Base.prototype.screenToComponentY = function(screenX, screenY) {
	"use strict";
	if (this.parent !== null) {
		return this.parent.screenToComponentY(screenX, screenY) - this.y;
	}
	return screenY - this.y;
};

// Transform the screen (x,y)-coordinate to a component-space vector
tgfDialogs.Base.prototype.screenToComponentVector = function(screenX, screenY) {
	"use strict";
	return new tbVector(this.screenToComponentX(screenX, screenY), this.screenToComponentY(screenX, screenY));
};

// Transform the component (x,y)-coordinate to the screen x-coordinate
tgfDialogs.Base.prototype.componentToScreenX = function(componentX, componentY) {
	"use strict";
	if (this.parent !== null) {
		return this.parent.componentToScreenX(componentX + this.x, componentY + this.y);
	}
	return componentX + this.x;
};

// Transform the component (x,y)-coordinate to the screen y-coordinate
tgfDialogs.Base.prototype.componentToScreenY = function(componentX, componentY) {
	"use strict";
	if (this.parent !== null) {
		return this.parent.componentToScreenY(componentX + this.x, componentY + this.y);
	}
	return componentY + this.y;
};

// Transform the component (x,y)-coordinate to a screen-space vector
tgfDialogs.Base.prototype.componentToScreenVector = function(componentX, componentY) {
	"use strict";
	return new tbVector(this.componentToScreenX(componentX, componentY), this.componentToScreenY(componentX, componentY));
};

// Returns the x-position of the finger with respect to the component
tgfDialogs.Base.prototype.touchX = function(finger) {
	"use strict";
	return this.screenToComponentX(tbGame.touchX(finger), tbGame.touchY(finger));
};

// Returns the y-position of the finger with respect to the component
tgfDialogs.Base.prototype.touchY = function(finger) {
	"use strict";
	return this.screenToComponentY(tbGame.touchX(finger), tbGame.touchY(finger));
};


// ***************************************
// Dealing with child components
// ***************************************
tgfDialogs.Base.prototype.addChild = function(child) {
	"use strict";
	if(child){
		this.baseContainer.addChild(child);
	}
};

tgfDialogs.Base.prototype.removeChild = function(child) {
    "use strict";
    if(child){
        this.baseContainer.removeChild(child);
    }
};

// Add a child component
tgfDialogs.Base.prototype.addComponent = function(component) {
	"use strict";
	component.parent = this;
	this._components.push(component);
};

// Insert a child component
tgfDialogs.Base.prototype.insertComponent = function(index, component) {
	"use strict";
	component.parent = this;
	if (index < 0) { index = 0; }
	if (index > this._components.length) { index = this._components.length; }
	this._components.splice(index, 0, component);
};

// Returns the component with the given name
tgfDialogs.Base.prototype.findComponent = function(name, recursive) {
	"use strict";
	var i, result = null;
	if (recursive === undefined) { recursive = false; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].name === name) { result = this._components[i]; }
		if (recursive){
			result = this._components[i].findComponent(name, recursive);
			if (result !== null) { return result; }
		}
	}
	return result;
};

// Removes all components
tgfDialogs.Base.prototype.removeAllComponents = function() {
	"use strict";
	this._components = [];
};

// Removes the component
tgfDialogs.Base.prototype.removeComponent = function(component, recursive) {
	"use strict";
	var i;
	if (recursive === undefined) { recursive = false; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (recursive){
			this._components[i].removeComponent(component, recursive);
		}
		if (this._components[i] === component) { this._components.splice(i, 1); }
	}
};

// Removes the component with the given name
tgfDialogs.Base.prototype.removeComponentByName = function(name, recursive) {
	"use strict";
	var i;
	if (recursive === undefined) { recursive = false; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (recursive){
			this._components[i].removeComponent(name, recursive);
		}
		if (this._components[i].name === name) { this._components.splice(i, 1); }
	}
};

// Returns the components whose tags contain one or all of the values
tgfDialogs.Base.prototype.findComponentsByTags = function(tags, all, recursive) {
	"use strict";
	var i, result = [], result2;
	if (all === undefined) { all = false; }
	if (recursive === undefined) { recursive = false; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].containsTags(tags, all)) { result.push(this._components[i]); }
		if (recursive){
			result2 = this._components[i].findComponentsByTags(tags, all, recursive);
			result = result.concat(result2);
		}
	}
	return result;
};

// Removes the components whose tags contain one or all of the values
tgfDialogs.Base.prototype.removeComponentsByTags = function(tags, all, recursive) {
	"use strict";
	var i;
	if (all === undefined) { all = false; }
	if (recursive === undefined) { recursive = false; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (recursive){
			this._components[i].removeComponentsByTags(tags, all, recursive);
		}
		if (this._components[i].containsTags(tags, all)) { this._components.splice(i, 1); }
	}
};


// ***************************************
// Preparing, freeing,showing and hiding
// ***************************************

// Prepare the dialog for use
tgfDialogs.Base.prototype.prepare = function(alsoChildren) {
	"use strict";
	var i;
    //this.baseContainer.setPosition(this.x, this.y);
    this.baseContainer.hide();
    this.baseContainer.add(this.parentDialog);

	if (alsoChildren === undefined) { alsoChildren = true; }
	if (this.isPrepared) { return; }
	if (this.onPrepare) {
		if (this.onPrepare(this)) { return; }
	}
	this.isPrepared = true;
	if (this.doPrepare) { this.doPrepare(); }
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].prepare();
		}
	}
};

// Fee the dialog from use
tgfDialogs.Base.prototype.free = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (!this.isPrepared) { return; }
	if (this.onFree) {
		if (this.onFree(this)) { return; }
	}
	if (this.isVisible) { this.hide(); }
	this.isPrepared = false;
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].free();
		}
	}
	if (this.doFree) { this.doFree(); }
};

tgfDialogs.Base.prototype.doFree = function() {
	"use strict";

	var self = this;

	if (self.baseContainer)	{
		self.baseContainer.remove(this.parentDialog);
		self.baseContainer.free();
		self.baseContainer.dialog = null;
		self.baseContainer = null;
	}
};

// Show the dialog, making it visible
tgfDialogs.Base.prototype.show = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (this.canvas === null) { this.canvas = tgfGraphics.mainCanvas; }
	if (this.isVisible) { return; }
	if (!this.isPrepared) { this.prepare(); }
	if (this.onShow) {
		if (this.onShow(this)) { return; }
	}
	this.isVisible = true;
	this.baseContainer.show();
	this.activate();
	// Show the components (the order matters such that the dialog can hide certain components later)
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].show();
		}
	}
	if (this.doShow) { this.doShow(); }
	// Add it to the game engine
	this.visible = true;
	this.active = true;
	tbGame.addToken(this);
};

// Hide the dialog, making it invisible
tgfDialogs.Base.prototype.hide = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (!this.isVisible) { return; }
	if (this.onHide) {
		if (this.onHide(this)) { return; }
	}
	this.deactivate();
	this.isVisible = false;
    if (this.baseContainer) this.baseContainer.hide();
	// Hide the components (the order matters such that the dialog can show certain components later)
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].hide();
		}
	}
	if (this.doHide) { this.doHide(); }
	// Remove it from the game engine
	this.visible = false;
	this.active = false;
	tbGame.removeToken(this);
};

// Activates the dialog
tgfDialogs.Base.prototype.activate = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (this.isActive) { return; }
	if (this.onActivate) {
		if (this.onActivate(this)) { return; }
	}
	this.isActive = true;
	// Activate the components
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].activate();
		}
	}
	if (this.doActivate) { this.doActivate(); }
};

// Deactivates the dialog
tgfDialogs.Base.prototype.deactivate = function(alsoChildren) {
	"use strict";
	var i;
	if (alsoChildren === undefined) { alsoChildren = true; }
	if (!this.isActive) { return; }
	if (this.onDeactivate) {
		if (this.onDeactivate(this)) { return; }
	}
	this.isActive = false;
	// Deactivate the components
	if (alsoChildren) {
		for (i = 0; i < this._components.length; i += 1) {
			this._components[i].deactivate();
		}
	}
	if (this.doDeactivate) { this.doDeactivate(); }
};


// ***************************************
// Event handlers
// ***************************************

// handleAdd is called when the token is (re-) added to the game.
tgfDialogs.Base.prototype.handleAdd = function() {
	"use strict";
};

// handleRemove is called when the token is removed from the game.
tgfDialogs.Base.prototype.handleRemove = function() {
	"use strict";
};

// handleBeginStep is called each step before processing other events.
tgfDialogs.Base.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].handleBeginStep(timePassed)) { return this.propagateCancelEvents; }
	}
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
tgfDialogs.Base.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (this._components[i].handleTouchDown(finger, x, y)) { return this.propagateCancelEvents; }
	}
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
tgfDialogs.Base.prototype.handleTouchUp = function(finger, x, y) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (this._components[i].handleTouchUp(finger, x, y)) { return this.propagateCancelEvents; }
	}
};

// handleMouseWheel is called when the player changes the position of the mouse wheel.
tgfDialogs.Base.prototype.handleMouseWheel = function(delta, x, y) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (this._components[i].handleMouseWheel(delta, x, y)) { return this.propagateCancelEvents; }
	}
};

//handleImmediateTouchDown is called immediately when a touch is started or if a mouse button is pressed.
tgfDialogs.Base.prototype.handleImmediateTouchDown = function(finger, x, y) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (this._components[i].handleImmediateTouchDown(finger, x, y)) { return this.propagateCancelEvents; }
	}
};

// handleImmediateTouchUp is called immediately when a touch is ended or if a mouse button is released.
tgfDialogs.Base.prototype.handleImmediateTouchUp = function(finger, x, y) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = this._components.length-1; i >= 0; i -= 1) {
		if (this._components[i].handleImmediateTouchUp(finger, x, y)) { return this.propagateCancelEvents; }
	}
};

// handleKeyDown is called if the key with the given keyCode is pressed.
tgfDialogs.Base.prototype.handleKeyDown = function(keyCode) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].handleKeyDown(keyCode)) { return this.propagateCancelEvents; }
	}
};

// handleKeyUp is called if the key with the given keyCode is released.
tgfDialogs.Base.prototype.handleKeyUp = function(keyCode) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].handleKeyUp(keyCode)) { return this.propagateCancelEvents; }
	}
};

// handleAlarm is called if a global alarm is reached.
tgfDialogs.Base.prototype.handleAlarm = function(alarm) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].handleAlarm(alarm)) { return this.propagateCancelEvents; }
	}
};

// handleSpecial is called if a special or user-defined event happens.
tgfDialogs.Base.prototype.handleSpecial = function(id, args) {
	"use strict";
	var i;
	if (!this.isActive) { return; }
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].handleSpecial(id, args)) { return this.propagateCancelEvents; }
	}
};

// handleEndStep is called each step after processing other events (before draw).
tgfDialogs.Base.prototype.handleEndStep = function(timePassed) {
	"use strict";
	var i, result = false;
	if (this.isActive) {
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleEndStep(timePassed)) { result = this.propagateCancelEvents; break; }
		}
	}
	if (this.isVisible) {
		for (i = 0; i < this._components.length; i += 1) {
			if (this._components[i].handleUpdateVisuals(timePassed)) { result = this.propagateCancelEvents; break; }
		}
	}
	return result;
};

// handleDraw is called at the end of a step to draw the token.
tgfDialogs.Base.prototype.handleDraw = function() {
	"use strict";
	// return;
	var i, result = false;
	// if (!this.isVisible) { return; }
	// tbGraphics.context.save();
	// tbGraphics.context.translate(this.x, this.y);
	for (i = 0; i < this._components.length; i += 1) {
		if (this._components[i].handleDraw()) { result = this.propagateCancelEvents; break; }
	}
	// tbGraphics.context.restore();
	return result;
};



//******************************************************
//*****    Script Resource: DialogTemplate
//******************************************************

// ***************************************
// tgfDialogs.Template
//
// A template for new dialogs
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// TODO: Everywhere replace Template and template by the appropriate name

// Directives for jslint
/*global tgfSettings, tgfDialogs, tgfComponents */

tgfSettings.dialogDefaults.template = {
	components: []					// The additional components to add
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.Template = function(properties) {
	"use strict";
	this.name = "Template";			// The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.template);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.Template, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************


// ***************************************
// Internal methods
// ***************************************


// ***************************************
// Preparing and showing
//		- These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.Template.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

// Processing required when showing the dialog
tgfDialogs.Template.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the dialog
tgfDialogs.Template.prototype.doHide = function() {
	"use strict";
};

//******************************************************
//*****    Script Resource: DialogContainer
//******************************************************

// ***************************************
// tgfDialogs.Container
//
// A simple container dialog that contains a number of components
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tgfSettings, tgfDialogs, tgfComponents */


tgfSettings.dialogDefaults.container = {
	components: [],										// The additional components to add
	// Additional properties for the components
	containerProperties: null							// Properties for the effect container
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.Container = function(properties) {
	"use strict";
	this.name = "Container";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.container);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.Container, tgfDialogs.Base);


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.Container.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Create the container
	this.container = new tgfComponents.Container( { } );
	this.container.setProperties(this.containerProperties);
	this.addComponent(this.container);
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.Container.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();

	if (this.container)	{
		this.container.remove(this.baseContainer);
		this.container.free();
		this.container = null;
	}
};

//******************************************************
//*****    Script Resource: DialogPopUp
//******************************************************

// ***************************************
// tgfDialogs.PopUp
//
// A simple popUp dialog that contains a number of components on a background that can appear using effects
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbEase */
/*global tgfFunctions, tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfAnalytics, tgfScale, tgfEffects */


tgfSettings.dialogDefaults.popUp = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	backgroundImage: null,								// The background image
	darken: false,										// Whether to darken the background
	appearEffect: {effect: tgfEffects.show, duration: 0},		// Effect for appearing
	disappearEffect: {effect: tgfEffects.hide, duration: 0},	// Effect for disappearing
	lifeTime: 99999,									// How long it will stay visible before disappearing
	disappearOnClick: false,							// Whether to disappear when the screen is clicked
	components: [],										// The additional components to add
	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	backgroundProperties: null							// Properties for the background component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.PopUp = function(properties) {
	"use strict";
	this.name = "PopUp";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.popUp);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.PopUp, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.PopUp.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2); 
};

// ***************************************
// Internal methods
// ***************************************

// Add a component to the dialog and returns it
tgfDialogs.PopUp.prototype._addComponent = function(parent, Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.addComponent(comp);
	return comp;
};


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.PopUp.prototype.doPrepare = function() {
	"use strict";
	var i, self = this, darkener;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Create the darkener
	if (this.darken) {
		darkener = this._addComponent(this, tgfComponents.Darkener, { 
				width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
			}, this.darkenerProperties);
	}
		// Create the background image container
	this.container = this._addComponent(this, tgfComponents.Picture, { 
			image: this.backgroundImage,
			createFromSlices: true,
			width: this.width === 0 && this.backgroundImage ? this.backgroundImage.width : this.width,
			height: this.height === 0 && this.backgroundImage ? this.backgroundImage.height : this.height,
			effects: [ this.appearEffect, { effect: "show", duration: this.lifeTime }, this.disappearEffect ],
			onSubEffectStart: function (component, effect) {
					if (effect === self.disappearEffect && self.darken) {
						darkener.makeLight(darkener.duration, self.container.effects[2].duration-darkener.duration);
					}
				},
			onEffectEnd: function (component) {
					self.hide();
				}
		}, this.backgroundProperties);
	if (this.disappearOnClick) {
		this.container.onTouchDown = function (component) { 
				tgfDialogs.ButtonBox.prototype.disappear.call(self);
			};
	}
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.PopUp.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.container = undefined;
};

//******************************************************
//*****    Script Resource: DialogButtonBox
//******************************************************

// ***************************************
// tgfDialogs.ButtonBox
//
// This dialog displays a box with a number of buttons.
// It can e.g. be used for options, settings, or a menu.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbEase */
/*global tgfFunctions, tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfAnalytics, tgfScale, tgfEffects */


tgfSettings.dialogDefaults.buttonBox = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,						// The background image
	backgroundX: tgfScale(0),
	backgroundY: tgfScale(0),
	marginLeft: tgfScale(40),							// Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),							// Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),							// Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),							// Bottom margin whether there is no text, images, etc.
	titlePercentage: 10,								// Percentage of the box for the title
	messagePercentage: 0,								// Percentage of the box for the message (if any)
	buttonPercentage: 90,								// Percentage of the box for the buttons
	titleText: "",										// Text for the title
	titleDictionaryKey: "",								// Dictionary key for the title
	titleFont: f_tgf_title,								// Font to be used for the title
	messageText: "",									// Text for the message
	messageDictionaryKey: "",							// Dictionary key for the message
	messageFont: f_tgf_text,							// Font to be used for the message
	iconImage: null,									// Image for the icon
	iconPosition: "right",								// Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,								// Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),						// Width of the close button
	closeButtonHeight: tgfScale(96),					// Height of the close button
	closeButtonId: "close",								// Id of the close button
	buttonHorizontal: false,							// Whether the buttons must be placed horizontally
	buttonHorizontalSize: tgfScale(0),					// Total horizontal size for the buttons (0 = use maximum)
	buttonHorizontalGap: tgfScale(8),					// Horizontal gap between the buttons
	buttonVerticalGap: tgfScale(8),						// Vertical gap between the buttons
	buttonVerticalAlignment: "middle",					// Vertical alignment for the buttons ("top", "middle", "bottom")
	buttonDefaultHide: false,							// Whether to hide the dialog on clicking the button
	buttonDefaultImage: s_tgf_button,					// Default image for the buttons
	buttonDefaultFont: f_tgf_button,					// Default font to be used for the buttons
	buttonDefaultProperties: null,						// Default additional properties for the button components
	buttons: [],										// Array of (array of) information about the buttons; can contain:
														//		sliced, text, dictionaryKey, image, icon, font, id, properties, hide
	darken: false,										// Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	doNothing: { effect: "show", duration: this.lifeTime },
	lifeTime: 9999999,									// How long it will stay visible before disappearing automatically
	disappearOnClick: false,							// Whether to disappear when the screen is clicked
	components: [],										// The additional components to add
	onClick: null,										// Function to be called when clicking the button: function(dialog, buttonId)
	onClose: null,										// Function to be called when clicking the close button
	onArrive: null,

	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	backgroundProperties: null,							// Properties for the background container component
	titleProperties: null,								// Properties for the title component
	messageProperties: null,							// Properties for the message component
	iconProperties: null,								// Properties for the icon component
	closeButtonProperties: null							// Properties for the close button component,
};

// The constructor for the dialog
/** @constructor
 *  @base tgfDialogs.Base
 */
tgfDialogs.ButtonBox = function(properties) {
	"use strict";
	this.name = "ButtonBox";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.buttonBox);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.ButtonBox, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.ButtonBox.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************

// Add a component to the dialog and returns it
tgfDialogs.ButtonBox.prototype._addComponent = function(parent, Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.addComponent(comp);
	return comp;
};

// Add a button to the dialog and returns it
tgfDialogs.ButtonBox.prototype._addButton = function(parent, button, n, x, y, w) {
	"use strict";
	var self = this;
	return this._addComponent(parent, tgfComponents.Button, {
			x: x, y: y, width: button.sliced === undefined ? w : 0, height: 0,
			image: button.image === undefined ? this.buttonDefaultImage : button.image,
			text: button.text === undefined ? "" : button.text,
			dictionaryKey: button.key === undefined ? "" : button.key,
			icon: button.icon, iconPosition: "left",
			font: button.font === undefined ? this.buttonDefaultFont : button.font,
			buttonId: button.id === undefined ? n : button.id,
			buttonHide: button.hide === undefined ? this.buttonDefaultHide : button.hide,
			cancelEvents: true,
			onClick: function (component) {
				if (component.buttonHide) { tgfDialogs.ButtonBox.prototype.disappear.call(self); }
				if (self.onClick) { self.onClick(self, component.buttonId); }
			}
		}, this.buttonDefaultProperties, button.properties);
};


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.ButtonBox.prototype.doPrepare = function() {
	"use strict";
	var self = this, i, j, n,
		blockLeft = [], blockTop = [], blockWidth = [], blockHeight = [],
		ww, hh, closeX, closeY,
		buttons, buttonLeft, buttonTop, buttonVDistance, buttonHDistance, buttonWidth, buttonHeight,
		darkener;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Determine the position and sizes of the blocks
	ww = this.width === 0 ? this.backgroundImage.width : this.width;
	hh = this.height === 0 ? this.backgroundImage.height : this.height;
	blockLeft[0] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[0] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[0] = Math.round(-hh/2 + this.marginTop);
	blockHeight[0] = Math.round(this.titlePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	blockLeft[1] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[1] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[1] = Math.round(blockTop[0] + blockHeight[0]);
	blockHeight[1] = Math.round(this.messagePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	if (this.iconImage) {
		blockWidth[2] = this.iconImage.width;
		blockLeft[2] = blockLeft[1] + blockWidth[1] - blockWidth[2];
		blockTop[2] = blockTop[1];
		blockHeight[2] = blockHeight[1];
		blockWidth[1] -= blockWidth[2] + tgfScale(32);
		if (this.iconPosition === "left") {
			blockLeft[2] = blockLeft[1];
			blockLeft[1] += blockWidth[2] + tgfScale(32);
		}
	}
	blockLeft[3] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[3] = Math.round(ww - this.marginLeft - this.marginRight);
	if (this.buttonHorizontalSize > 0) {
		blockLeft[3] = Math.round(-this.buttonHorizontalSize / 2);
		blockWidth[3] = this.buttonHorizontalSize;
	}
	blockTop[3] = Math.round(blockTop[1] + blockHeight[1]);
	blockHeight[3] = Math.round(this.buttonPercentage * (hh - this.marginTop - this.marginBottom) / 100);
	// Create the darkener
	if (this.darken) {
		darkener = this._addComponent(this, tgfComponents.Darkener, {
				width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
			}, this.darkenerProperties);
	}
	// Create the background image container
	this.container = this._addComponent(this, tgfComponents.Picture, {
			x: this.backgroundX,
			y: this.backgroundY,
			image: this.backgroundImage,
			createFromSlices: true,
			width: this.width === 0 ? this.backgroundImage.width : this.width,
			height: this.height === 0 ? this.backgroundImage.height : this.height,
		}, this.backgroundProperties);
	if (this.disappearOnClick) {
		this.container.onTouchDown = function (component) {
				if (self.onClose) { self.onClose(self); }
				tgfDialogs.ButtonBox.prototype.disappear.call(self);
			};
	}
	// Create title
	if (this.titlePercentage) {
		this._addComponent(this.container, tgfComponents.Label, {
				x: Math.round(blockLeft[0] + blockWidth[0]/2), y: Math.round(blockTop[0] + blockHeight[0]/2),
				width: blockWidth[0], height: blockHeight[0],
				text: this.titleText, dictionaryKey: this.titleDictionaryKey,
				font: this.titleFont, fitToBox: true, splitLines: false, surfaceMargin: tgfScale(20)
			}, this.titleProperties);
	}
	// Create message
	if (this.messagePercentage) {
		this._addComponent(this.container, tgfComponents.Label, {
				x: Math.round(blockLeft[1] + blockWidth[1]/2), y: Math.round(blockTop[1] + blockHeight[1]/2),
				width: blockWidth[1], height: blockHeight[1],
				text: this.messageText, dictionaryKey: this.messageDictionaryKey,
				font: this.messageFont, fitToBox: true, splitLines: true, surfaceMargin: tgfScale(20)
			}, this.messageProperties);
	}
	// Create the icon
	if (this.messagePercentage && this.iconImage) {
		this._addComponent(this.container, tgfComponents.Picture, {
				image: this.iconImage,
				x: Math.round(blockLeft[2] + blockWidth[2]/2), y: Math.round(blockTop[2] + blockHeight[2]/2)
			}, this.iconProperties );
	}
	// Create close button
	if (this.hasCloseButton) {
		closeX = Math.round((this.width === 0 ? this.backgroundImage.width : this.width) / 2 - this.closeButtonWidth / 2);
		closeY = Math.round(-(this.height === 0 ? this.backgroundImage.height : this.height) / 2 + this.closeButtonHeight / 2);
		this._addComponent(this.container, tgfComponents.Button, {
				x: closeX, y: closeY, width: this.closeButtonWidth, height: this.closeButtonHeight,
				image: s_tgf_transparent, buttonId: this.closeButtonId,
				onClick: function(component) {
						if (self.onClose) { self.onClose(self); }
						if(self.onClick){ self.onClick(self, component.buttonId); }
						tgfDialogs.ButtonBox.prototype.disappear.call(self);
					}
			}, this.closeButtonProperties);
	}
	// Create the buttons
	if (this.buttonPercentage) {
		if (this.buttonHorizontal) { buttons = [this.buttons]; } else { buttons = this.buttons; }
		buttonHeight = this.buttonDefaultImage.height;
		buttonVDistance = buttonHeight + this.buttonVerticalGap;
		buttonTop = Math.round(blockTop[3] + buttonHeight/2);
		switch (this.buttonVerticalAlignment) {
			case "top": break;
			case "bottom": buttonTop += blockHeight[3] - buttons.length * buttonVDistance - this.buttonVerticalGap; break;
			default: buttonTop += Math.round((blockHeight[3] - buttons.length * buttonVDistance - this.buttonVerticalGap) / 2); break;
		}
		n = 0;
		for (i = 0; i < buttons.length; i += 1) {
			if (Object.prototype.toString.call(buttons[i]) === "[object Array]") {
				buttonWidth = Math.round((blockWidth[3] - this.buttonHorizontalGap * (buttons[i].length - 1)) / buttons[i].length);
				buttonHDistance = buttonWidth + this.buttonHorizontalGap;
				buttonLeft = Math.round(blockLeft[3] + buttonWidth / 2);
				for (j = 0; j < buttons[i].length; j += 1) {
					this._addButton(this.container, buttons[i][j], n, buttonLeft + j * buttonHDistance, buttonTop + i * buttonVDistance, buttonWidth);
					n += 1;
				}
			} else {
				this._addButton(this.container, buttons[i], n, Math.round(blockLeft[3] + blockWidth[3] / 2), buttonTop + i * buttonVDistance, blockWidth[3]);
				n += 1;
			}
		}
	}
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.ButtonBox.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.container = undefined;
};

//******************************************************
//*****    Script Resource: DialogMessageBox
//******************************************************

// ***************************************
// tgfDialogs.MessageBox
//
// This dialog displays a message box. This is a special version of the button box.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbEase */
/*global tgfDialogs, tgfSettings, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.messageBox = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,						// The background image
	marginLeft: tgfScale(40),							// Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),							// Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),							// Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),							// Bottom margin whether there is no text, images, etc.
	titlePercentage: 25,								// Percentage of the box for the title
	messagePercentage: 75,								// Percentage of the box for the message (if any)
	titleText: "",										// Text for the title
	titleDictionaryKey: "",								// Dictionary key for the title
	titleFont: f_tgf_title,								// Font to be used for the title
	messageText: "",									// Text for the message
	messageDictionaryKey: "",							// Dictionary key for the message
	messageFont: f_tgf_text,							// Font to be used for the message
	iconImage: null,									// Image for the icon
	iconPosition: "right",								// Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,								// Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),						// Width of the close button
	closeButtonHeight: tgfScale(96),					// Height of the close button
	darken: true,										// Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 4,										// How long it will stay visible before disappearing
	disappearOnClick: true,								// Whether to disappear when the screen is clicked
	components: [],										// The additional components to add
	onClose: null,										// Function to be called when clicking the close button

	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	backgroundProperties: null,							// Properties for the background container component
	titleProperties: null,								// Properties for the title component
	messageProperties: null,							// Properties for the message component
	iconProperties: null,								// Properties for the icon component
	closeButtonProperties: null							// Properties for the close button component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.ButtonBox
 */
tgfDialogs.MessageBox = function(properties) {
	"use strict";
	this.name = "MessageBox";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.messageBox);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the button box dialog
tgfDialogs.inherit(tgfDialogs.MessageBox, tgfDialogs.ButtonBox);

//******************************************************
//*****    Script Resource: DialogQuestionBox
//******************************************************

// ***************************************
// tgfDialogs.QuestionBox
//
// This dialog displays a question box. This is a special version of the button box.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbEase */
/*global tgfDialogs, tgfSettings, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.questionBox = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,						// The background image
	marginLeft: tgfScale(40),							// Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),							// Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),							// Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),							// Bottom margin whether there is no text, images, etc.
	titlePercentage: 15,								// Percentage of the box for the title
	messagePercentage: 55,								// Percentage of the box for the message (if any)
	buttonPercentage: 30,								// Percentage of the box for the buttons
	titleText: "",										// Text for the title
	titleDictionaryKey: "",								// Dictionary key for the title
	titleFont: f_tgf_title,								// Font to be used for the title
	messageText: "",									// Text for the message
	messageDictionaryKey: "",							// Dictionary key for the message
	messageFont: f_tgf_text,							// Font to be used for the message
	iconImage: null,									// Image for the icon
	iconPosition: "right",								// Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,								// Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),						// Width of the close button
	closeButtonHeight: tgfScale(96),					// Height of the close button
	buttonHorizontal: true,								// Whether the buttons must be placed horizontally
	buttonHorizontalSize: tgfScale(0),					// Total horizontal size for the buttons (0 = use maximum)
	buttonHorizontalGap: tgfScale(8),					// Horizontal gap between the buttons
	buttonVerticalGap: tgfScale(8),						// Vertical gap between the buttons
	buttonVerticalAlignment: "middle",					// Vertical alignment for the buttons ("top", "middle", "bottom")
	buttonDefaultHide: true,							// Whether to hide the dialog on clicking the button
	buttonDefaultImage: s_tgf_button,					// Default image for the buttons
	buttonDefaultFont: f_tgf_button,					// Default font to be used for the buttons
	buttonDefaultProperties: null,						// Default additional properties for the button components
	buttons: [],										// Array of (array of) information about the buttons; can contain:
														//		sliced, text, dictionaryKey, image, icon, font, id, properties, hide
	darken: true,										// Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 9999999,									// How long it will stay visible before disappearing automatically
	disappearOnClick: false,							// Whether to disappear when the screen is clicked
	components: [],										// The additional components to add
	onClick: null,										// Function to be called when clicking the button: function(dialog, buttonId)	
	onClose: null,										// Function to be called when clicking the close button
	
	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	backgroundProperties: null,							// Properties for the background container component
	titleProperties: null,								// Properties for the title component
	messageProperties: null,							// Properties for the message component
	iconProperties: null,								// Properties for the icon component
	closeButtonProperties: null							// Properties for the close button component
};


// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.ButtonBox
 */
tgfDialogs.QuestionBox = function(properties) {
	"use strict";
	this.name = "QuestionBox";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.questionBox);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the button box dialog
tgfDialogs.inherit(tgfDialogs.QuestionBox, tgfDialogs.ButtonBox);

//******************************************************
//*****    Script Resource: SpineComponent
//******************************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.spineComponent = {
	spineAnimation: undefined,
	spineClone: undefined,
	animationClip: "animation",
	delay: -1,
	scale: 1,
	repeat: false,
	onComplete: null,
	onEvent: null,
	play: true,
	hasDelay: true,
	flip: false,
	skin: null,

	imagesToSlots: [],
	labelsToSlots: [],
	imageToSlotRotation: Math.PI,
	flipImagesToSlot: true,

	components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.SpineComponent = function(properties) {
	"use strict";
	this.name = "SpineComponent";         // The name of the component
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.spineComponent);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.SpineComponent, tgfComponents.Base);


// ***************************************
// Specific methods for this component
// ***************************************



// ***************************************
// Internal methods
// ***************************************

tgfComponents.SpineComponent.prototype.setSkin = function(skin){
	this.skin = skin;

	if(this.spineClone) {
		this.spineClone.setSkin(this.skin);
	}
};

tgfComponents.SpineComponent.prototype.setAnimation = function(animation, onComplete){
	"use strict";
	var self = this;

	if(this.spineClone){
		this.spineClone.setAnimation(animation, this.repeat);
		this.spineClone.setOnComplete(function(){
			self._onCompleteCallback(onComplete);
		});
	}
};

tgfComponents.SpineComponent.prototype.setAlpha = function(alpha) {
	"use strict";
	if(this.spineClone){
		this.spineClone.setAlpha(alpha);
	}
};

tgfComponents.SpineComponent.prototype.setPosition = function(x, y) {
	this.x = x;
	this.y = y;

	if(this.spineClone) {
		this.spineClone.setPosition(this.x, this.y);
	}
};

tgfComponents.SpineComponent.prototype.bringToFront = function() {
	this.baseContainer.removeChild(this.spineClone);
	this.baseContainer.addChild(this.spineClone);
};

tgfComponents.SpineComponent.prototype._setAnimation = function(){
	"use strict";
	var self = this;
	this.spineClone.setAnimation(this.animationClip, this.repeat);
	this.spineClone.setOnComplete(function(){
		self._onCompleteCallback(self.onComplete);
	});
};

tgfComponents.SpineComponent.prototype.setEvent = function(event){
    "use strict";
    var self = this;
	this.spineClone.setEventCallback(event, this._onEventCallback, self);
};

tgfComponents.SpineComponent.prototype.clearEvents = function(){
    "use strict";
    var self = this;
    this.spineClone.clearAllEventCallbacks();
};

tgfComponents.SpineComponent.prototype.unPause = function(){
	"use strict";

	this._setAnimation();
	// this.play = true;
};

tgfComponents.SpineComponent.prototype.getSlot = function(slotIndex) {
	return this.spineClone.animation.slotContainers[slotIndex];
};

tgfComponents.SpineComponent.prototype._addFontToSlot = function(slotIndex, font) {


	var image = s_tgf_transparent.clone();

	image.addChild(font);

	var slot = this.getSlot(slotIndex);

	slot.addChild(image.sprite);
	
	console.log('label.font', image);

	image.setRotation(this.imageToSlotRotation);

	if(this.flipImagesToSlot) {
		image.setScale(-1, 1);
	}
};

tgfComponents.SpineComponent.prototype.addLabelToSlot = function(slotIndex, label) {

	this.labelsToSlots.push({
		slotIndex: slotIndex,
		label: label
	});

	if(this.spineClone) {
		var font;

		if(!(label.font instanceof tbVectorFont)) {
			font = new tbVectorFont();
	
			font.setProperties(label.font);

			font.setText(label.text);

			font.setPosition(label.x, label.y);
		} else {
			font = label.font;
		}

		this._addFontToSlot(slotIndex, font);
	}
};

tgfComponents.SpineComponent.prototype.addImageToSlot = function(slotIndex, image) {

	this.imagesToSlots.push({
		slotIndex: slotIndex,
		image: image
	});

	if(this.spineClone) {
		var slot = this.getSlot(slotIndex);

		var clone = image.clone();

		slot.addChild(clone.sprite);

		clone.setRotation(this.imageToSlotRotation);

		clone.setTint(image.tint ? image.tint : 0xFFFFFF);

		clone.setScale(image.scaleX, image.scaleY);

		clone.setPosition(image.x, image.y);

		if(this.flipImagesToSlot) {
			clone.setScale(clone.scaleX * -1, clone.scaleY * 1);
		}
	}
};

tgfComponents.SpineComponent.prototype.removeImageInSlot = function(slotIndex, image) {
	var indexToRemove = [];
	for (var i = 0; i < this.imagesToSlots.length; i += 1) {
		if(this.imagesToSlots[i].slotIndex != slotIndex) {
			continue;
		}

		if(this.imagesToSlots[i].image.name !== image.name) {
			continue;
		}

		indexToRemove.push(i);

		if(this.spineClone) {
			var slot = this.getSlot(this.imagesToSlots[i].slotIndex);

			slot.removeChild(this.imagesToSlots[i].image);
		}
	}

	for (var i = 0; i < indexToRemove.length; i += 1) {
		this.imagesToSlots.splice(indexToRemove[i], 1);
	}
};


// ***************************************
// Preparing, showing and activating
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.SpineComponent.prototype.doPrepare = function() {
	"use strict";
	var i;

	if(this.play && this.delay > 0){
		this.delay = -1;
	}

	this.spineClone = this.spineAnimation.clone();

	this._setAnimation();

    this.spineClone.setPosition(this.x, this.y);

	this.baseContainer.addChild(this.spineClone);
	
	this.spineClone.setAlpha(this.alpha);

	this.spineClone.setScale(this.scale);

	if(this.skin) {
		this.spineClone.setSkin(this.skin);
	}
	
	if(this.imagesToSlots) {
		for (var i = 0; i < this.imagesToSlots.length; i += 1) {
			var image = this.imagesToSlots[i].image;
			var clone = image.clone();

			var slot = this.getSlot(this.imagesToSlots[i].slotIndex);

			slot.addChild(clone.sprite);		

			clone.setRotation(this.imageToSlotRotation);

			clone.setTint(image.tint ? image.tint : 0xFFFFFF);

			clone.setScale(image.scaleX, image.scaleY);

			clone.setPosition(image.x, image.y);

			if(this.flipImagesToSlot) {
				clone.setScale(clone.scaleX * -1, clone.scaleY * 1);
			}
		}
	}

	if(this.labelsToSlots) {
		for (var i = 0; i < this.labelsToSlots.length; i += 1) {
			var label = this.labelsToSlots[i].label;
			var font;

			if(!(label.font instanceof tbVectorFont)) {

				console.log('label.if');

				font = new tbVectorFont();
		
				font.setProperties(label.font);

				font.setText(label.text);

				font.setPosition(label.x, label.y);
			} else {
				console.log('label.else');
				font = label.font;
			}
			
			this._addFontToSlot(this.labelsToSlots[i].slotIndex, font);
		}
	}

    if(this.flip){
        this.spineClone.flip();
	}
	// Add the child components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

// Processing required when freeing the component from use
tgfComponents.SpineComponent.prototype.doFree = function() {
	"use strict";
	
	if (this.spineClone) {
		this.spineClone.remove(this.baseContainer);
		this.spineClone.free();
		this.spineClone = null;
	}
};

// Processing required when showing the component
tgfComponents.SpineComponent.prototype.doShow = function() {
	"use strict";
    this.spineClone.show();
};

// Processing required when hiding the component
tgfComponents.SpineComponent.prototype.doHide = function() {
	"use strict";
    //this.baseContainer.removeChild(this.spineClone);
    this.spineClone.hide();
};

tgfComponents.SpineComponent.prototype.remove = function(){
    "use strict";
    this.baseContainer.removeChild(this.spineClone);
};

tgfComponents.SpineComponent.prototype.add = function(){
    "use strict";
    this.baseContainer.addChild(this.spineClone);
};

// Processing required when activating the component
tgfComponents.SpineComponent.prototype.doActivate = function() {
	"use strict";
};

// Processing required when deactivating the component
tgfComponents.SpineComponent.prototype.doDeactivate = function() {
	"use strict";
};


// ***************************************
// Methods called when events must be processed
//      - These can be removed when no processing is required
//      - When they return true, this event is no further processed
//          by other components in the dialog
//      - Never call these methods yourself in other components,
//          Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.SpineComponent.prototype.doBeginStep = function(timePassed) {
	"use strict";

	if(!this.hasDelay || this.delay > 0) {
		this.delay -= timePassed;
		return;
	}

	this.play = true;

	if (this.onCompleteFireDelay >= 0) {
		this.onCompleteFireDelay -= timePassed;

		if (this.onCompleteFireDelay < 0) {

			this.onCompleteFireDelay = -69;

			if(this.delayedOnComplete) {
				this.delayedOnComplete(this);
				this.delayedOnComplete = null;
			}
		}
	}

	if (this.onEventFireDelay >= 0) {
		this.onEventFireDelay -= timePassed;

		if (this.onEventFireDelay < 0) {

			this.onEventFireDelay = -69;

			if(this.onEvent) {
				this.onEvent(this);
			}
		}
	}

	
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.SpineComponent.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.SpineComponent.prototype.doTouchUp = function(finger, x, y) {
	"use strict";
};

// Called when the position of the mouse wheel is changed
tgfComponents.SpineComponent.prototype.doMouseWheel = function(delta, x, y) {
	"use strict";
};

// Called immediately when a touch is started or if a mouse button is pressed
tgfComponents.SpineComponent.prototype.doImmediateTouchDown = function(finger, x, y) {
	"use strict";
};

// Called immediately when a touch is ended or if a mouse button is released
tgfComponents.SpineComponent.prototype.doImmediateTouchUp = function(finger, x, y) {
	"use strict";
};

// Called if the key with the given keyCode is pressed
tgfComponents.SpineComponent.prototype.doKeyDown = function(keyCode) {
	"use strict";
};

// Called if the key with the given keyCode is released
tgfComponents.SpineComponent.prototype.doKeyUp = function(keyCode) {
	"use strict";
};

// Called if a global alarm is reached
tgfComponents.SpineComponent.prototype.doAlarm = function(alarm) {
	"use strict";
};

// Called if a special or user-defined event happens
tgfComponents.SpineComponent.prototype.doSpecial = function(id, args) {
	"use strict";
};

// Called at the end of each step
tgfComponents.SpineComponent.prototype.doEndStep = function(timePassed) {
	"use strict";
	// if(!this.play){
	// 	return;
	// }
	// this.spineClone.updateTime(timePassed);
};

// Called just before drawing (also when not active)
tgfComponents.SpineComponent.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.SpineComponent.prototype.doDraw = function() {
	"use strict";
	// if(!this.play){
	// 	return;
	// }
	// this.spineClone.drawSimple(this.x, this.y);

};

// Called after drawing the sub-components
tgfComponents.SpineComponent.prototype.doEndDraw = function() {
	"use strict";
};

// Called after drawing the sub-components
tgfComponents.SpineComponent.prototype._onCompleteCallback = function(callback) {
	"use strict";
	this.onCompleteFireDelay = 100; //ms
	this.delayedOnComplete = callback;
};

// Called after drawing the sub-components
tgfComponents.SpineComponent.prototype._onEventCallback = function() {
	"use strict";
	this.onEventFireDelay = 100; //ms
};



//******************************************************
//*****    Script Resource: tgfAds
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.adsDefault = {
	
	//General properies
	providers: "none",                                                 //Ad provider "none","google", "poki", "woobi"
	tmpDiv: undefined,
	viewport: undefined,
	percentageLeft: 0,
	hasFrame: true,
	googleAdsReady: false,
	pokiAdsReady: false,
	woobiAdsReady: false,
	testMode: true,
	hasReward: false,
	customReward: -1,
	isMobile: false,
	mobileProviders: "none",                                  // Ad provider for Mobile "none", "admob", "chartboost"
	adTimer: tgfScale(-1),
	setTimer: -1,
	hasAdBlock: false,
	showedPreroll: false,
	
	//AdMob ads properties
	adMobBanner: false,
	adMobInterstitial: true,
	adMobBannerId_Android: "ca-app-pub-9362790118294805/1178913377",
	adMobInterstitialId_Android: "ca-app-pub-9362790118294805/3214049773",
	adMobBannerId_iOS: "ca-app-pub-9362790118294805/5050709772",
	adMobInterstitialId_iOS: "ca-app-pub-9362790118294805/3573976572",
	adMobBannerId_WinP: "ca-app-pub-9362790118294805/9480909379",
	adMobInterstitialId_WinP: "ca-app-pub-9362790118294805/8004176173",
	admobid: {},
	
	//ChartBoost
	mainChartboostAppId: "",
	mainChartboostAppSignature: "",
	chartboostAppId_Android: "565eaaadf789823be08c4b1d",
	chartboostAppSignature_Android: "5f1ed7c97da30349b3797ed3b09ec383dae8d43c",
	chartboostAppId_iOS: "565eafbaa8b63c592bcd1c50",
	chartboostAppSignature_iOS: "4e1d6b0510d750f9a2c294a240da48b3856c64db",
			
	//Google ads properties
	slotname: "8420994579",
	adServerUrl: "http://googleads.g.doubleclick.net/pagead/ads",
	clientId: "ca-games-pub-7949653012476008",
	description: "http://www.tinglygames.com/html5-games",
	hasPreroll: false,
	hasInterstitial: true,
	forceLanguage: undefined,
	adDisplayContainer: undefined,
	googleSdk: "//imasdk.googleapis.com/js/sdkloader/ima3.js",
	sdkGoogleLoaded: false,
	generateUrl: true,
	googleAdManager: undefined,
	googleContainer:undefined,
	adsLoader: undefined,
	googleStartTime: -1,
	adTime: -1,
	
	preroll: {
		adTypes: {
			unskippable_video: true,
			skippable_video: true,
			text: true,
			flash: true,
			image: true
		},
		max_ad_duration: 120000,
		non_linear_ad_duration: 15 * 1000
	},
	interstitial: {
		adTypes: {
			unskippable_video: true,
			skippable_video: true,
			text: true,
			flash: true,
			image: true
		},
		max_ad_duration: 120000,
		non_linear_ad_duration: 15 * 1000
	},
	
	//Poki properties
	pokiPartnerId: 0,
	pokiGameId: 0,
	pokiSdk: "//game-cdn.poki.com/scripts/1.0.0/poki-ads.min.js",
	sdkPokiLoaded: false,
	sdkPokiReady: false,
	pokiAdManager: undefined,
	pokiContainer: undefined,
	
	//WOOBI PROPERTIES
	woobiAppId: 17726,          // Test App Id
	woobiClientId: 0,       // Test Client Id
	woobiSdk: "http://js.tokenads.com/woobi-min.js",
	woobiCss: "http://js.tokenads.com/vidget.css",
	jQuerySdk: "//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js",
	sdkWoobiLoaded:false,
	woobiContainer: undefined,
	
	onReward: null
};

// Constructor
var TGFAds = function(){
	"use strict";
	
};

TGFAds.prototype.initialize = function(settings){
	"use strict";
	
	this._setProperties(tgfSettings.adsDefault);
	this._setProperties(settings);
	
	if(!this.isMobile){
		if(Object.prototype.toString.call(this.providers) === '[object Array]'){
			for(var i = 0; i < this.providers.length; i++){
				this.loadSDK(this.providers[i]);
			}
		} else {
			this.loadSDK(this.providers);
		}
	} else {
		//Problem with early call// Fix to call it from AdDialog
		
//      switch(this.mobileProviders){
//      case "admob":
//          this.makeAdMobContainer();
//          break;
//      case "chartboost":
//          this.makeChartboostContainer();
//          break;
//      }
	}
	
	this.setAdTimer();
};

TGFAds.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

TGFAds.prototype.setAdTimer = function(){
	"use strict";
	this.setTimer = (this.adTimer * 60) * 1000;
	flowController.adTimer = this.setTimer;
};

TGFAds.prototype.generatedUrl = function(){
	"use strict";
	var settings;

	if (this.hasPreroll) {
		settings = this.preroll;
	}
	else {
		settings = this.interstitial;
	}
	
	var url = "";
	var types = [];
	
	url += this.adServerUrl;
	url += "?ad_type=";
	
	if (tbBrowser.os.ios && tbBrowser.features.mobile) {
		// Don't use video ads on iPhone
	}
	else {
		if (settings.adTypes.skippable_video && settings.adTypes.unskippable_video) {
			types.push("video");
		}
		else if (settings.adTypes.skippable_video) {
			types.push("skippablevideo");
		}
		else if (settings.adTypes.unskippable_video) {
			types.push("standardvideo");
		}
	}

	if (settings.adTypes.image) {
		types.push("image");
	}
	if (settings.adTypes.text) {
		types.push("text");
	}
	if (settings.adTypes.flash) {
		types.push("flash");
	}

	for (var i = 0; i < types.length; ++i) {
		url += types[i];
		if (i < types.length - 1) {
			url += "_";
		}
	}
	
	url += "&client=" + this.clientId;
	
	if(this.slotname){
		url += "&slotname=" + this.slotname
	}
	
	url += "&videoad_start_delay=0";
	
	url += "&description_url=" + encodeURIComponent(this.description);
	
	if (this.forceLanguage) {
		url += "&hl=" + this.forceLanguage;
	}
	
	if (settings.max_ad_duration) {
		url += "&max_ad_duration=" + settings.max_ad_duration;
	}

	if (this.testMode) {
		url += "&adtest=on";
	}
	
	return url;
}

TGFAds.prototype.loadSDK = function(_provider){
	"use strict";
	var self = this;
	var scriptElement = document.getElementsByTagName("script")[0];
	var tmpScriptElement = document.createElement("script");
	tmpScriptElement.type = "text/javascript";
	tmpScriptElement.async = true;
	
	switch(_provider){
	case "google":
		tmpScriptElement.src = this.googleSdk;
		break;
	case "poki":
		if( window["publisherSettings"] && window["publisherSettings"]["pokiads"] && window["publisherSettings"]["pokiads"]["scriptUrl"]){
			this.pokiSdk = window["publisherSettings"]["pokiads"]["scriptUrl"];
		} else {
			console.log("Default SDK");
		}
		tmpScriptElement.src = this.pokiSdk;
		break;
	case "woobi":
		//this.extraSDK("jQuery", this.jQuerySdk);
		tmpScriptElement.src = this.woobiSdk;
		//this.loadCSS(_provider);
		break;
	}
	
	if(typeof tmpScriptElement.addEventListener !== undefined){
		tmpScriptElement.addEventListener("load", function() {self.loadCallback(_provider);}, false);
		tmpScriptElement.addEventListener("error", function(){ self.setAdBlock(); console.log("ERRor");}, false);
	}
	
	scriptElement.parentNode.insertBefore(tmpScriptElement, scriptElement);
};

TGFAds.prototype.setAdBlock = function(){
	this.hasAdBlock = true;
};

TGFAds.prototype.extraSDK = function(sdkName ,sdk){
	var self = this;
	var scriptElement = document.getElementsByTagName("script")[0];
	var tmpScriptElement = document.createElement("script");
	tmpScriptElement.type = "text/javascript";
	tmpScriptElement.async = true;
	tmpScriptElement.src = sdk;
	
	if(typeof tmpScriptElement.addEventListener !== undefined){
		tmpScriptElement.addEventListener("load", function() {console.log(sdkName + " Loaded");}, false);
		tmpScriptElement.addEventListener("error", function(){console.log(sdkName + " ERRor");}, false);
	}
	
	scriptElement.parentNode.insertBefore(tmpScriptElement, scriptElement);
};

TGFAds.prototype.loadCSS = function(_provider){
	var self = this;
	var scriptElement = document.getElementsByTagName("script")[0];
	var tmpLinkElement = document.createElement("link");
	tmpLinkElement.rel = "stylesheet";
	tmpLinkElement.type = "text/css";
	switch(_provider){
	case "woobi":
		tmpLinkElement.href = this.woobiCss;
		break;
	}
	
	scriptElement.parentNode.insertBefore(tmpLinkElement, scriptElement);
};

TGFAds.prototype._createContainer = function(_provider, ll, tt, ww, hh){
	"use strict";
	this.userTouch = false;
	this.googleAdsReady = false;
	this.pokiAdsReady = false;
	this.woobiAdsReady = false;
	this.resetTimer();
	
	switch(_provider) {
		case "google":
			if (this.sdkGoogleLoaded) {
				this.makeGoogleAdContainer(ll, tt, ww, hh);
			}
			break;
		case "poki":
			if (this.sdkPokiLoaded) {
				this.makePokiAdContainer(ll, tt, ww, hh);
			}
			break;
		case "woobi":
			if (this.sdkWoobiLoaded) {
				this.makeWoobiContainer();
			}
			break;
	}
};

TGFAds.prototype.initContainer = function(){
	if(!this.userTouch && this.sdkGoogleLoaded){
		// Must be done as the result of a user action on mobile
		this.adDisplayContainer["initialize"]();
		this.userTouch = true;
	} else if(!this.userTouch && this.sdkPokiLoaded && this.sdkPokiReady){
		var adPosition = poki["ads"]["position"]["midrollPositive"];
		if(!this.showedPreroll){
			adPosition =  poki["ads"]["position"]["preroll"];
			this.showedPreroll = true;
		}
		window["POKI_ADS"]["requestAd"]({"position": adPosition});
		this.userTouch = true;
	}
};

TGFAds.prototype.makeAdMobContainer = function(){
	var self = this;
	if( /(android)/i.test(navigator.userAgent) ) { // for android & amazon-fireos
		this.admobid = {
			banner: this.adMobBannerId_Android, // or DFP format "/6253334/dfp_example_ad"
			interstitial: this.adMobInterstitialId_Android
		};
	} else if(/(ipod|iphone|ipad)/i.test(navigator.userAgent)) { // for ios
		this.admobid = {
			banner: this.adMobBannerId_iOS, // or DFP format "/6253334/dfp_example_ad"
			interstitial: this.adMobInterstitialId_iOS
		};
	} else { // for windows phone
		this.admobid = {
			banner: this.adMobBannerId_WinP, // or DFP format "/6253334/dfp_example_ad"
			interstitial: this.adMobInterstitialId_WinP
		};
	}
	if(( /(ipad|iphone|ipod|android|windows phone)/i.test(navigator.userAgent) )) {
		document.addEventListener('deviceready', function(){self.initAdMob();}, false);
	
		document.addEventListener('onAdFailLoad', function(data){ 
			alert('error: ' + data.error + 
					', reason: ' + data.reason + 
					', adNetwork:' + data.adNetwork + 
					', adType:' + data.adType + 
					', adEvent:' + data.adEvent); // adType: 'banner', 'interstitial', etc.
		});
	}
};

TGFAds.prototype.initAdMob = function(){
	if (! AdMob ) { alert( 'admob plugin not ready' ); return; }
	
	if(this.adMobBanner){
		if(AdMob){
			AdMob.createBanner( {
				adID: this.admobid.banner,
				isTesting: true,
				adSize: 'SMART_BANNER',
				position: AdMob.AD_POSITION.BOTTOM_CENTER,
				autoShow: true
			});
		}
	} else if(this.adMobInterstitial){
		if(AdMob) AdMob.prepareInterstitial( {adId: this.admobid.interstitial, autoShow:false} );
	}
};

TGFAds.prototype.makeChartboostContainer = function(){
	var appId, appSignature, self = this;
	
	//android
	if (navigator.userAgent.match(/Android/i)) {
		this.mainChartboostAppId = this.chartboostAppId_Android;
		this.mainChartboostAppSignature = this.chartboostAppSignature_Android;
	}
	//ios
	else if (navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i)) {
		this.mainChartboostAppId = this.chartboostAppId_iOS;
		this.mainChartboostAppSignature = this.chartboostAppSignature_iOS;
	}
	console.log("Made chartboost container " + this.mainChartboostAppId + "   " + this.mainChartboostAppSignature);
	document.addEventListener('deviceready', function(){self.initChartBoost();}, false);
//  this.initChartBoost();
};

TGFAds.prototype.initChartBoost = function(){
	
	console.log("Init ids " + this.mainChartboostAppId + "   " + this.mainChartboostAppSignature);
	
	window.chartboost.setUp(this.mainChartboostAppId, this.mainChartboostAppSignature);
	
	window.chartboost.onInterstitialAdPreloaded = function(location) {
		console.log('onInterstitialAdPreloaded: ' + location);
	};
	window.chartboost.onInterstitialAdLoaded = function(location) {
		console.log('onInterstitialAdLoaded: ' + location);
	};
	window.chartboost.onInterstitialAdShown = function(location) {
		console.log('onInterstitialAdShown: ' + location);
	};
	window.chartboost.onInterstitialAdHidden = function(location) {
		console.log('onInterstitialAdHidden: ' + location);
	};
	window.chartboost.onMoreAppsAdPreloaded = function(location) {
		console.log('onMoreAppsAdPreloaded: ' + location);
	};
	window.chartboost.onMoreAppsAdLoaded = function(location) {
		console.log('onMoreAppsAdLoaded: ' + location);
	};
	window.chartboost.onMoreAppsAdShown = function(location) {
		console.log('onMoreAppsAdShown: ' + location);
	};
	window.chartboost.onMoreAppsAdHidden = function(location) {
		console.log('onMoreAppsAdHidden: ' + location);
	}; 
	window.chartboost.onRewardedVideoAdPreloaded = function(location) {
		console.log('onRewardedVideoAdPreloaded: ' + location);
	};
	window.chartboost.onRewardedVideoAdLoaded = function(location) {
		console.log('onRewardedVideoAdLoaded: ' + location);
	};
	window.chartboost.onRewardedVideoAdShown = function(location) {
		console.log('onRewardedVideoAdShown: ' + location);
	};
	window.chartboost.onRewardedVideoAdHidden = function(location) {
		console.log('onRewardedVideoAdHidden: ' + location);
	};  
	window.chartboost.onRewardedVideoAdCompleted = function(location) {
		console.log('onRewardedVideoAdCompleted: ' + location);
	};

	console.log("Chartboost INIT");
};

TGFAds.prototype.makeGoogleAdContainer = function(ll, tt, ww, hh){
	"use strict";
	var self = this;
	var _thisProvider = "google";
	
	this.tmpDiv = document.createElement("div");
	this.viewport = tgfGraphics.container;
	this.tmpDiv.id = "adContainer"
	this.viewport.appendChild(this.tmpDiv);
	
	this.googleContainer= document.getElementById("adContainer");
	this.adDisplayContainer = new google["ima"]["AdDisplayContainer"](document.getElementById("adContainer"));
	//Init first window size
	var scale = this.viewport.clientWidth / tgfGraphics.visibleWidth;
	
	var width = Math.round(ww * scale);
	var height = Math.round(hh * scale);
	
	var top = Math.round((tt  - tgfGraphics.visibleTop) * scale) + "px";
	var left = Math.round((ll - tgfGraphics.visibleLeft) * scale) + "px";
	
	this.tmpDiv["style"]["width"] = width + "px";
	this.tmpDiv["style"]["height"] = height + "px";
	this.tmpDiv["style"]["z-index"] = 300;
	this.tmpDiv["style"]["position"] = "absolute";
	this.tmpDiv["style"]["top"] =  top;
	this.tmpDiv["style"]["left"] = left;
	this.tmpDiv["style"]["display"] = "block";
	
	//To prevent crash
	var tmpObj = {"currentTime": 0};
		
	var adsLoader = new google["ima"]["AdsLoader"](this.adDisplayContainer);
	
	// Add event listeners
	adsLoader.addEventListener(
			google["ima"]["AdsManagerLoadedEvent"]["Type"]["ADS_MANAGER_LOADED"],
		onAdsManagerLoaded,
		false);
	adsLoader.addEventListener(
			google["ima"]["AdErrorEvent"]["Type"]["AD_ERROR"],
		onAdError,
		false);

	function onAdError(adErrorEvent) {
		  // Handle the error logging and destroy the AdsManager
		self.googleAdsReady = false;
		  console.log(adErrorEvent.getError());
		  if(self.googleAdManager){ self.googleAdManager.destroy() };
		  
		  self.adFailed(adErrorEvent);
		}
	// An event listener to tell the SDK that our content video
	// is completed so the SDK can play any post-roll ads.
//  var contentEndedListener = function() {adsLoader.contentComplete();};
//  videoContent.onended = contentEndedListener;

	// Request video ads.
	var adsRequest = new google["ima"]["AdsRequest"]();
	
	adsRequest["adTagUrl"] = 'http://pubads.g.doubleclick.net/gampad/ads?' +
		'sz=640x360&iu=/6062/iab_vast_samples/skippable&ciu_szs=300x250,728x90&' +
		'impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&' +
		'url=[referrer_url]&correlator=[timestamp]';
	
	if(tbBrowser.os.ios && tbBrowser.features.mobile){
		console.log("iOS");
		adsRequest["adTagUrl"] = 'http://pubads.g.doubleclick.net/gampad/ads?sz=400x300&'
			+ 'iu=%2F6062%2Fiab_vast_samples&ciu_szs=300x250%2C728x90&gdfp_req=1&' + 'env=vp&output=xml_vast2&unviewed_position_start=1&url='
			+ '[referrer_url]&correlator=[timestamp]&cust_params=iab_vast_samples' + '%3Dlinear';
	}
		
	if(this.generateUrl){
		adsRequest["adTagUrl"] = this.generatedUrl();
	}
	
	if(width < 250){
		width = 250;
	}
	if(height < 250){
		height = 250;
	}
	
	// Specify the linear and nonlinear slot sizes. This helps the SDK to
	// select the correct creative if multiple are returned.
	adsRequest["linearAdSlotWidth"] = width;
	adsRequest["linearAdSlotHeight"] = height;
	adsRequest["nonLinearAdSlotWidth"] = width;
	adsRequest["nonLinearAdSlotHeight"] = height;
	
	adsLoader["requestAds"](adsRequest);
	
	function onAdsManagerLoaded(adsManagerLoadedEvent) {
		  //self.adsAvailable(_thisProvider);
		  
		  // Get the ads manager.
		  self.googleAdManager = adsManagerLoadedEvent["getAdsManager"](
				  tmpObj);  // See API reference for contentPlayback
		  // Add listeners to the required events.
		  self.googleAdManager.addEventListener(
				  google["ima"]["AdErrorEvent"]["Type"]["AD_ERROR"],
			  onAdError);
		  self.googleAdManager.addEventListener(
				  google["ima"]["AdEvent"]["Type"]["CONTENT_PAUSE_REQUESTED"],
			  onContentPauseRequested);
		  self.googleAdManager.addEventListener(
				  google["ima"]["AdEvent"]["Type"]["CONTENT_RESUME_REQUESTED"],
			  onContentResumeRequested);
		  self.googleAdManager.addEventListener(
				  google["ima"]["AdEvent"]["Type"]["COMPLETE"],
				  onContentPauseRequested);
		  self.googleAdManager.addEventListener(
				  google["ima"]["AdEvent"]["Type"]["USER_CLOSE"],
				  onUserClosed);
		  self.googleAdManager.addEventListener(
				  google["ima"]["AdEvent"]["Type"]["STARTED"],
				  onStarted);
		  self.googleAdManager.addEventListener(
				  google["ima"]["AdEvent"]["Type"]["LOADED"],
				  onLoaded);
		  try {
			// Initialize the ads manager. Ad rules playlist will start at this time.
			  self.googleAdManager["init"](width, height, google["ima"]["ViewMode"]["NORMAL"]);
//			  self.googleAdsReady = true;
			// Call start to show ads. Single video and overlay ads will
			// start at this time; this call will be ignored for ad rules, as ad rules
			// ads start when the adsManager is initialized.
//            self.googleAdManager.start();
		  } catch (adError) {
			  self.googleAdsReady = false;
			// An error may be thrown if there was a problem with the VAST response.
			  self.adFailed(adError);
		  }
	}
	
	function onContentPauseRequested() {
	  // This function is where you should setup UI for showing ads (e.g.
	  // display ad timer countdown, disable seeking, etc.)
	  //this.videoContent.removeEventListener('ended', contentEndedListener);
	  //this.videoContent.pause();
//      self.googleStartTime = self.googleAdManager["getRemainingTime"]() * 1000;
//      self.adTime = self.googleStartTime;
//      console.log("TIME: " + self.googleStartTime);
//      if(self.googleStartTime < 0){
//          console.log("IS LINEAR");
//      }
		console.log("Completeeeed");
	}

	function onContentResumeRequested() {
	  // This function is where you should ensure that your UI is ready
	  // to play content.
//    this.videoContent.addEventListener('ended', contentEndedListener);
//    this.videoContent.play();
		self.userSkip = true;
//      tbGame.addSpecial("Ad Completed", {});
		self.adCompleted();
//      if(self.baseDialog !== null){
//          self.baseDialog.adFinish();
//      }
	}
	
	function onLoaded(){
		self.googleStartTime = -1;
		self.adTime = -1;
		self.googleAdsReady = true;
	}
	
	function onStarted(){
		self.googleStartTime = self.googleAdManager["getRemainingTime"]() * 1000;
		self.adTime = self.googleStartTime;
		if(self.googleStartTime < 0){
			if(self.hasPreroll){
				self.googleStartTime = self["preroll"]["max_ad_duration"];
				self.adTime = self.googleStartTime;
			} else if(self.hasInterstitial){
				self.googleStartTime = self["interstitial"]["max_ad_duration"];
				self.adTime = self.googleStartTime;
			}
		}
	}
	
	function onUserClosed() {
		console.log("Ad Closed");
		self.tmpDiv["style"]["display"] = "none";
		self.adCompleted();
	}
	
	function onComplete(){
		console.log("Ad Completed");
	}
};

TGFAds.prototype.makePokiAdContainer = function(ll, tt, ww, hh){
	"use strict";
	var self = this;
	this.tmpDiv = document.createElement("div");
	this.viewport = tgfGraphics.container;
	this.tmpDiv.id = "poki-sdk-container"
	this.viewport.appendChild(this.tmpDiv);
	
	//Init first window size
	var scale = this.viewport.clientWidth / tgfGraphics.visibleWidth;
	
	var width = Math.round(ww * scale);
	var height = Math.round(hh * scale);
	
	var top = Math.round((tt  - tgfGraphics.visibleTop) * scale) + "px";
	var left = Math.round((ll - tgfGraphics.visibleLeft) * scale) + "px";
	
	this.tmpDiv["style"]["width"] = width + "px";
	this.tmpDiv["style"]["height"] = height + "px";
	this.tmpDiv["style"]["z-index"] = 300;
	this.tmpDiv["style"]["position"] = "absolute";
	this.tmpDiv["style"]["top"] =  top;
	this.tmpDiv["style"]["left"] = left;
	this.tmpDiv["style"]["display"] = "block";
	
	this.pokiContainer = document.getElementById("poki-sdk-container");
	
	window["POKI_DISPATCHER"].addEventListener(poki["ready"], function(adEvent){self.onPokiReady(adEvent);});
	window["POKI_DISPATCHER"].addEventListener(poki["ads"]["ready"], function(adEvent){self.onPokiAdStart(adEvent);});
	window["POKI_DISPATCHER"].addEventListener(poki["ads"]["completed"], function(adEvent){self.adCompleted();});
	window["POKI_DISPATCHER"].addEventListener(poki["ads"]["limit"], function(adEvent){self.adFailed(adEvent);});
	window["POKI_DISPATCHER"].addEventListener(poki["ads"]["error"], function(adEvent){self.adFailed(adEvent);});
	window["POKI_DISPATCHER"].addEventListener(poki["ads"]["update"], function(adEvent){ self._setTimer(adEvent["percentageComplete"]); });
	window["POKI_DISPATCHER"].addEventListener(poki["adblocked"], function(){ self.setAdBlock(); });
	
	if(width < 250){
		width = 250;
	}
	if(height < 250){
		height = 250;
	}
	
	var params;
	if(this.testMode){
		params = {
			//"partnerId": 1,
			//"gameId": 10001,
			//"timeUpdateInterval":100,
			"debug": true,
			//"staticAd": true,
			"width": width,
			"height": height
		}
	}else {
		params = {
			"partnerId": this.pokiPartnerId,
			"gameId": this.pokiGameId,
			"timeUpdateInterval":100,
			"debug": false,
			"width": width,
			"height": height
		}
	}
	
	if(window["publisherSettings"] && window["publisherSettings"]["pokiads"] && window["publisherSettings"]["pokiads"]["initParams"]){
		var initParams = window["publisherSettings"]["pokiads"]["initParams"];
		var param;
		for(param in initParams){
			//if(initParams.hasOwnProperties(param)){
				params[param] = initParams[param];
			//}
		}
	}

	window["POKI_ADS"]["init"](params);
};

TGFAds.prototype.onPokiReady = function(adEvent){
	"use strict";
	this.sdkPokiReady = true;   
};

TGFAds.prototype.onPokiAdStart = function(adEvent){
	"use strict";
	var _thisProvider = "poki";
	//this.adsAvailable(_thisProvider);
	this.pokiAdsReady = true;
	console.log("ads start");
};

TGFAds.prototype.makeWoobiContainer = function(ll, tt, ww, hh){
	"use strict";
	var self = this;
	var _thisProvider = "woobi";
	tokenads["config"]["appId"] = [this.woobiAppId];
	tokenads["config"]["clientId"] = [this.woobiClientId];
	tokenads["settings"]["position"]["centerPlayer"] = true;
	tokenads["settings"]["view"]["draggable"] = false;
	tokenads["settings"]["offersLimit"] = 1;
	tokenads["config"]["listener"]["onError"] = function(error){self.adFailed(error);};
	tokenads["config"]["listener"]["onClose"] = function(){self.adCompleted();};
	tokenads["config"]["listener"]["onCredit"] = function(credits){self.adCompleted(credits);};
	tokenads["checkInventory"](function(num){if(num > 0){ self.woobiAdsReady = true; }
										  else{ self.adFailed(); }});
	tokenads["settings"]["view"]["colorTheme"] = "#954217";
	tokenads["settings"]["view"]["showTitle"] = false;
};

TGFAds.prototype._onResize = function(resizeFunction, base){
	window.addEventListener("resize", function(){ resizeFunction(base); }, true);
};

TGFAds.prototype.doResize = function(_provider, ll, tt, ww, hh){
	
	if(ww < 250){
		ww = 250;
	}
	if(hh < 250){
		hh = 250;
	}
	
	switch(_provider){
	case "google":
		this.googleAdManager["resize"](ww, hh, google["ima"]["ViewMode"]["NORMAL"]);
		this.googleContainer["style"]["top"] = tt;
		this.googleContainer["style"]["left"] = ll;
		break;
	case "poki":
		window["POKI_ADS"]["resize"](ww, hh);
		this.pokiContainer["style"]["top"] = tt;
		this.pokiContainer["style"]["left"] = ll;
		break;
	case "woobi":
		
		break;
	}
};

TGFAds.prototype.loadCallback = function(_provider){
	switch(_provider){
	case "google":
		this.sdkGoogleLoaded = true;
		break;
	case "poki":
		this.sdkPokiLoaded = true;
		break;
	case "woobi":
		this.sdkWoobiLoaded = true;
		break;
	}
	if(!this.testMode){return;}
	console.log(_provider + " SDK LOADED");
};

TGFAds.prototype.adsAvailable = function(provider){ 
	switch(provider){
	case "google":
		if(this.googleAdsReady){return true;}
		break;
	case "poki":
		if(this.pokiAdsReady){return true;}
		break;
	case "woobi":
		if(this.woobiAdsReady){return true;}
		var tmp = document.getElementById("ta-player");
		console.log(tmp);
		break;
	}
};

TGFAds.prototype.showAds = function(provider){
	switch(provider){
	case "google":
		this.googleAdManager["start"]();
		break;
	case "poki":
		window["POKI_ADS"]["startAd"]();
		break;
	case "woobi":
		tokenads["showPlayer"]();
		break;
	}
	
	if(this.isMobile){
	
		switch(this.mobileProviders){
		case "admob":
			if(this.adMobInterstitial){
				if(AdMob) AdMob.showInterstitial();
			}
			break;
		case "chartboost":
			window.chartboost.showRewardedVideoAd('Default');
			console.log("Show chartboost ad");
			//Chartboost.showInterstitial(function(){console.log("SHOW success");}, function(){console.log("SHOW error");}, "Default");
			break;
		}
	}
};

TGFAds.prototype.adCompleted = function(reward){
	
	if(this.hasReward && reward === undefined && this.customReward < 0){
		reward = 0;
		tbGame.addSpecial("Ad Reward", {_reward: reward});
		if(this.onReward) {this.onReward(reward);}
	} else if(this.hasReward && reward === undefined && this.customReward > -1){
		reward = this.customReward;
		tbGame.addSpecial("Ad Reward", {_reward: reward});
		if(this.onReward) {this.onReward(reward);}
	} else if(reward !== undefined){
		tbGame.addSpecial("Ad Reward", {_reward: reward});
		if(this.onReward) {this.onReward(reward);}
	}else {
		tbGame.addSpecial("Ad Completed", {});
	}
	if(this.tmpDiv){
		this.tmpDiv["style"]["display"] = "none";
	}
	
	var element = document.getElementById("adContainer");
	if(element){
		element.parentNode.removeChild(element);
	}
};

TGFAds.prototype.removeContainer = function(){
	"use strict";
	this.pokiAdsReady = false;
	//if(this.pokiContainer){
	//	this.viewport.removeChild(this.pokiContainer);
	//	this.pokiContainer = undefined;
	//}
};

TGFAds.prototype.adFailed = function(error){
	tbGame.addSpecial("Ad Failed", {error: error});
	this.removeContainer();
};

TGFAds.prototype.setTimer = function(_percentageLeft){

	this.percentageLeft = _percentageLeft;
};

TGFAds.prototype._setTimer = function(_percentageLeft){
	
	this.percentageLeft = _percentageLeft;
};

TGFAds.prototype.getTimer = function(_provider, timePassed){
	switch(_provider){
	case "google":
	  if(this.googleStartTime > -1 && this.adTime > -1){
			if(this.googleAdManager["getRemainingTime"]() > -1){
				this.adTime = this.googleAdManager["getRemainingTime"]() * 1000;
			} else {
				this.adTime -= timePassed;
			}
			var reverseTime = this.googleStartTime - this.adTime;
			
			var prog = Math.round((reverseTime / this.googleStartTime) * 100);
			
			return prog;
		} 
		break;
	case "poki":
		return this.percentageLeft;
		break;
	}
};

TGFAds.prototype.resetTimer = function(){
	this.percentageLeft = 0;
};
//***************************************
//Create the object
//***************************************

var tgfAds = new TGFAds();





//******************************************************
//*****    Script Resource: tgfFirebase
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.firebaseDefault = {
		firebaseAPI: "https://cdn.firebase.com/js/client/2.2.1/firebase.js",
		jQueryAPI: "https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js",
		jQueryUiAPI: "https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js",
		mainUrl:  "https://incandescent-inferno-1440.firebaseio.com/",
		testUrl: "https://testten.firebaseio.com/",
		dataUrl: null,
		
		hasFirebase: false,
		firebaseLocal:false,
		
		dataRef: undefined,
		defaultProfileImage: typeof s_avatar80 !== "undefined" ? s_avatar80 : undefined,
		defaultProfileImageBig: typeof s_avatar140 !== "undefined" ? s_avatar140 : undefined,
		facebookUserImagePath: undefined,
		facebookUserImagePathBig: undefined,
		existingFacebookData: undefined,
		
		imageCollection: [],

		//newest test
		firebaseSource: "https://www.gstatic.com/firebasejs/3.7.5/firebase.js",


		apiKey: "AIzaSyAVWrLLREBoqw__mFFRQ_QzsL7W_WWh2hs",
		authDomain: "lead-2c64d.firebaseapp.com",
		databaseURL: "https://lead-2c64d.firebaseio.com",
		projectId: "lead-2c64d",
		storageBucket: "lead-2c64d.appspot.com",
		messagingSenderId: "266300273815",

		fire: undefined
};

//Constructor
var TGFFirebase = function(){
	"use strict";
};


TGFFirebase.prototype.initialize = function(settings){
	"use strict";
	this._setProperties(tgfSettings.firebaseDefault);
	this._setProperties(settings);

	if(this.firebaseLocal){
		this.dataURL = "https://testten.firebaseio.com/";
	} else {
		this.dataURL = "https://incandescent-inferno-1440.firebaseio.com/";
	}

	if(this.hasFirebase){
        this.loadAPI();
    }

    this.config = {
        firebaseSource: this.firebaseSource,
        apiKey: this.apiKey,
        authDomain: this.authDomain,
        databaseURL: this.databaseURL,
        projectId: this.projectId,
        storageBucket: this.storageBucket,
        messagingSenderId: this.messagingSenderId
	}



//  this.loadJquery();
//  this.loadJqueryUi();
};

TGFFirebase.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

TGFFirebase.prototype.loadAPI = function(){
	"use strict";
	var self = this;
	var scriptElement = document.getElementsByTagName("script")[0];
	var tmpScriptElement = document.createElement("script");
	tmpScriptElement.type = "text/javascript";
	tmpScriptElement.async = true;
	
	tmpScriptElement.src = this.firebaseSource;
	
	if(typeof tmpScriptElement.addEventListener !== undefined){
		tmpScriptElement.addEventListener("load", function() {self.createRef();}, false);
		tmpScriptElement.addEventListener("error", function(){console.log("Error loading");}, false);
	}
	
	scriptElement.parentNode.insertBefore(tmpScriptElement, scriptElement);
};

TGFFirebase.prototype.loadJquery = function(){
	var self = this;
	var scriptElement = document.getElementsByTagName("script")[0];
	var tmpScriptElement = document.createElement("script");
	tmpScriptElement.type = "text/javascript";
	tmpScriptElement.async = true;
	
	tmpScriptElement.src = this.jQueryAPI;
	
	if(typeof tmpScriptElement.addEventListener !== undefined) {
		tmpScriptElement.addEventListener("load", function() { self.loadJqueryUi(); console.log("Jquery loaded");}, false);
		tmpScriptElement.addEventListener("error", function(){console.log("Error loading");}, false);
	}
};

TGFFirebase.prototype.loadJqueryUi = function(){
	var self = this;
	var scriptElement = document.getElementsByTagName("script")[0];
	var tmpScriptElement = document.createElement("script");
	tmpScriptElement.type = "text/javascript";
	tmpScriptElement.async = true;
	
	tmpScriptElement.src = this.jQueryUiAPI;
	
	if(typeof tmpScriptElement.addEventListener !== undefined){
		tmpScriptElement.addEventListener("load", function() {console.log("JqueryUi loaded");}, false);
		tmpScriptElement.addEventListener("error", function(){console.log("Error loading");}, false);
	}
};

TGFFirebase.prototype.createRef = function(){
	"use strict";
	console.log("Create Reference");
	// this.dataRef = new Firebase(this.dataURL);
	//this.loadJquery();

	this.fire = window["firebase"]["initializeApp"](this.config);
};

TGFFirebase.prototype.getDataRef = function(){
	"use strict";
	if(this.dataRef){
		return this.dataRef; 
	} else {
		return undefined;
	}
};

TGFFirebase.prototype.guestConnect = function(error, authData){
	"use strict";
	var self = this;
	this.dataRef.authAnonymously(error, authData);
};

TGFFirebase.prototype.handleAnonymusData = function(data){
	"use strict";
	var self = this;
	var randName = this.makeId();
	var playerCollection = this.dataRef.child('players');
	playerCollection.once('value', function(snapshot){
		if(!snapshot.hasChild(data.uid)){
			playerCollection.child(data.uid).set({
				uid: data.uid,
				name: randName,
				xp: 0,
				points: 0,
				coins: 0
			});
			self.existingFacebookData = {
				uid: data.uid,
				name: randName,
				xp: 0,
				points: 0,
				coins: 0    
			};
		} else {
			playerCollection.child(data.uid).once('value', function(snap){
				self.existingFacebookData = snap.val();
			});
		}
	});
};

TGFFirebase.prototype.makeId = function(){
	"use strict";
	   
	var text = "Guest-";
	var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

	for( var i=0; i < 5; i++ )
		text += possible.charAt(Math.floor(Math.random() * possible.length));

	return text;
};

TGFFirebase.prototype.fbConnect = function(access){
	"use strict";
	var self = this;
	this.dataRef.authWithOAuthToken("facebook", access, function(error, authData) {
	  if (error) {
		console.log("Login Failed!", error);
	  } else {
		console.log("Authenticated successfully with payload:", authData);
		self.handleFbData(authData);
	  }
	});
};


TGFFirebase.prototype.handleFbData = function(data){
	"use strict";
	var self = this;
	
	FacebookWrapper.instance.getProfilePicture("me", FacebookFriendImageSize._80x80, function(result) {
		if (result["data"] || result["picture"]["data"]) {
			var res = result["data"] || result["picture"]["data"];
			self.facebookUserImagePath = res.url;
		}
	});
	
	FacebookWrapper.instance.getProfilePicture("me", FacebookFriendImageSize._160x160, function(result) {
		if (result["data"] || result["picture"]["data"]) {
			var res = result["data"] || result["picture"]["data"];
			self.facebookUserImagePathBig = res.url;
		}
	});
	
//  this.facebookUserImage = data.facebook.profileImageURL;
	var playerCollection = this.dataRef.child('players');
	playerCollection.once('value', function(snapshot){
		if(!snapshot.hasChild(data.uid)){
			playerCollection.child(data.uid).set({
				uid: data.uid,
				name: data.facebook.displayName,
				xp: 0,
				points: 0,
				coins: 0
			});
			self.existingFacebookData = {
				uid: data.uid,
				name: data.facebook.displayName,
				xp: 0,
				points: 0,
				coins: 0    
			};
		} else {
			playerCollection.child(data.uid).once('value', function(snap){
				self.existingFacebookData = snap.val();
			});
		}
	});
};

TGFFirebase.prototype.getUser = function(){
	"use strict";
	var user = {
		profilePicturePath: this.facebookUserImagePath,
		profilePicturePathBig: this.facebookUserImagePathBig,
		info: this.existingFacebookData
	};
	
	return user;
};

TGFFirebase.prototype.createImage = function(url, dimention){
	
	if(this.imageCollection[url]){
		return this.imageCollection[url];
	} else if(url === undefined || url === "noUrl"){
		return this.defaultProfileImage;
	} else {
		var image = tbImageLoad(url, url, dimention, dimention, 0, 0);
		this.imageCollection[url] = image;
		return image;
	}
};

TGFFirebase.prototype.createGame = function(){
	"use strict";

	var curGames = 0;//this.dataRef.child("game").val();
//  console.log(curGames);
//  this.dataRef.child("game").push("game" + curGames);
//  
//  this.dataRef.child("game").set(curGames++);
};



var tgfFirebase = new TGFFirebase();


//******************************************************
//*****    Script Resource: FrameworkDefaults
//******************************************************



var screens = screens || {};

screens.enterEffect = function(component, effect, time) {
	"use strict";
	var ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease;
	component.alpha = ease(time, 0, 1, effect.duration, effect.easeArgument);
	var y_offset = ease(time, tgfScale(-100), tgfScale(100), effect.duration, effect.easeArgument);
	if (component.y_offset === undefined) {
		component.y += y_offset;
	}
	else {
		component.y += -component.y_offset + y_offset;
	}
	component.y_offset = y_offset;
};

screens.exitEffect = function(component, effect, time) {
	"use strict";
	var ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease;
	component.alpha = ease(time, 1, -1, effect.duration, effect.easeArgument);
	var y_offset = ease(time, tgfScale(0), tgfScale(100), effect.duration, effect.easeArgument);
	if (component.y_offset === undefined) {
		component.y += y_offset;
	}
	else {
		component.y += -component.y_offset + y_offset;
	}
	component.y_offset = y_offset;
};

screens.defaultAppearEffect = {
	effect: screens.enterEffect,
	duration: 0.5,
	ease: tbEase.easeOutCubic
};

screens.defaultDisappearEffect = {
	effect: screens.exitEffect,
	duration: 0.5,
	endAlpha: 0,
	ease: tbEase.easeOutCubic
};

screens.defaultComponentEffects = [screens.defaultAppearEffect, {
	effect: tgfEffects.show,
	duration: 9999999
}, screens.defaultDisappearEffect];

screens.defaultContainerSettings = {
	effects: screens.defaultComponentEffects,
	onEffectEnd: function(component) {
		"use strict";
		component.hide();
	}
};

tgfComponents.Base.prototype.fadeOut = function(duration, callback) {
	"use strict";
	this.effects = [{
		duration: duration,
		effect: "fadeOut"
	}];
	this.repeatEffect = 1;
	this.restartEffect();

	var previousOnEffectEnd = this.onEffectEnd;

	this.onEffectEnd = function() {
		if (previousOnEffectEnd) {
			previousOnEffectEnd.call(this, this);
		}
		if (callback) {
			callback.call(this, this);
		}
		this.hide();
	};
};

screens.effects = {};
screens.effects.ScaleIn = {
	effect: tgfEffects.scale,
	duration: 0.3,
	startScale: 0,
	endScale: 1,
	ease: function(time, begin, change, duration) {
		"use strict";
		return tbEase.easeOutOvershoot(time, begin, change, duration);
	}
};

screens.effects.ScaleOut = {
	effect: tgfEffects.scale,
	duration: 0.3,
	startScale: 1,
	endScale: 0,
	ease: tbEase.easeInOvershoot
};

screens.PopupDialogSettings = function() {
	"use strict";
	return {
		appearEffect: screens.defaultAppearEffect,
		disappearEffect: screens.defaultDisappearEffect,
		width: tgfScale(600),
		height: tgfScale(400),
		depth: -2,
		backgroundImage: sprites.flow.ui.s_dialog_load_frame,
		cancelEvents: true,
		darken: true
	};
};

/**
 * @constructor
 * @base tgfDialogs.Base
 */
screens.BaseScreen = function(properties) {
	"use strict";
	tgfDialogs.Base.call(this, properties);
};

//Inherit the base dialog
tgfDialogs.inherit(screens.BaseScreen, tgfDialogs.Base);

screens.BaseScreen.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
};
//******************************************************
//*****    Script Resource: FacebookWrapper
//******************************************************

/* global
	flowController,
	GameSparksWrapper,
	facebook_config
 */


var FacebookFriendImageSize = {
	_80x80: 80,
	_160x160: 130
};

function FacebookWrapper() {
	"use strict";

	this.inUse = false;
	this.isMobile = false;
	this.isGuest = false;
	//Mobile Properties
	this.mPermissions = ["public_profile", "user_friends"];
	this.mStatus = null;
	this.mApi = null;
	this.timesChecked = 0;

	//Web Properties
	this.fb = null;
	this.fbApi = null;
	this.onInit = [];
	this.loginStatus = null;

	var _this = this;

	if(this.isMobile || !this.inUse){
		//console.log("FB on Mobile or not in use");
		return;
	}

	window["fbAsyncInit"] = function() {
		_this.fb = window["FB"];
		_this.fbApi = _this.fb["api"];

		_this.fb["init"]({
			"appId": facebook_config.appId,
			"cookie": true, // enable cookies to allow the server to access
			// the session
			"xfbml": false, // parse social plugins on this page
			"version": "v2.5" // use version 2.4
		});

		_this.fb["getLoginStatus"](function(response) {
			_this._loginCallback(response);
			for (var i = 0; i < _this.onInit.length; ++i) {
				_this.onInit[i]();
			}
			_this.onInit = [];
		});

	};

	// Load the SDK asynchronously
	(function(d, s, id) {
		var js, fjs = d.getElementsByTagName(s)[0];
		if (d.getElementById(id)) {
			return;
		}
		js = d.createElement(s);
		js.id = id;
		js.src = "//connect.facebook.net/en_US/sdk.js";
		fjs.parentNode.insertBefore(js, fjs);
	}(document, "script", "facebook-jssdk"));
}

FacebookWrapper.prototype.init = function(callback) {
	"use strict";

		if(this.isMobile){
			return;
		}

		if (callback) {
		if (this.fb) {
			callback();
		}
		else {
			this.onInit.push(callback);
		}
	}
};

FacebookWrapper.prototype._isGuest = function(){
	"use strict";
	this.isGuest = true;
	console.log("Is Guest: " + this.isGuest);
};

FacebookWrapper.prototype.initMobile = function(){
	"use strict";
	var _this = this;

	if(this.isGuest){
		return;
	}

	if(!this.isMobile){
		return;
	}

	console.log("MOBILE INIT CALLED");
	facebookConnectPlugin["getLoginStatus"](function(response){_this._loginCallback(response);});
};

FacebookWrapper.prototype.shareGeneric = function() {
	"use strict";

	if(this.isMobile){
		this.shareCommonMobile("s_facebook_image.png",
				"I Challenge you to game of Harvest Honors!",
				"Come play so that I can beat the pants off you, too!",
				"");
		return;
	}

	this.shareCommon("s_facebook_image.png",
			"I Challenge you to game of Harvest Honors!",
			"Come play so that I can beat the pants off you, too!",
			"");
};

FacebookWrapper.prototype.shareVictory = function() {
	"use strict";

	if(this.isMobile){
		this.shareCommonMobile("s_facebook_image_win.png",
				"I just beat the pants off my opponent in Harvest Honors!",
				"Try and beat me in this Farm style Match 3 multiplayer game. Click to here to  play.",
				"[Legal disclaimer: No pants were harmed during these beatings]");
		return;
	}

	this.shareCommon("s_facebook_image_win.png",
			"I just beat the pants off my opponent in Harvest Honors!",
			"Try and beat me in this Farm style Match 3 multiplayer game. Click to here to  play.",
			"[Legal disclaimer: No pants were harmed during these beatings]");
};

FacebookWrapper.prototype.shareDefeat = function() {
	"use strict";

	if(this.isMobile){
		this.shareCommonMobile("s_facebook_image_win.png",
				"I was beaten in a game of Harvest Honors, but I'm still a worthwhile person!",
				"Try and beat me too in this Farm style Match 3 multiplayer game. Click to here to  play.",
				"[Legal disclaimer: No pants were harmed during these beatings]");
		return;
	}

	this.shareCommon("s_facebook_image_win.png",
			"I was beaten in a game of Harvest Honors, but I'm still a worthwhile person!",
			"Try and beat me too in this Farm style Match 3 multiplayer game. Click to here to  play.",
			"[Legal disclaimer: No pants were harmed during these beatings]");
};

FacebookWrapper.prototype.shareRankUp = function( rankIndex ) {
	"use strict";

	var rankName     = flowController.GetPlayerRankName(rankIndex);
	var rankStarType = flowController.GetPlayerRankStarType(rankIndex);

	var imageName;
	switch(rankStarType)
	{
		default:
		case 1: imageName = "s_facebook_image_level_bronze.png";
			break;
		case 2: imageName = "s_facebook_image_level_silver.png";
			break;
		case 3: imageName = "s_facebook_image_level_gold.png";
			break;
		case 4: imageName = "s_facebook_image_level_platinum.png";
			break;
	}

	if(this.isMobile){
		this.shareCommonMobile(imageName, "Level Up!", "I've achieved the rank of "+rankName+" in Harvest Honors!", "Eat your carrots, and maybe one day you too will be as cool as me.");
		return;
	}
	this.shareCommon(imageName, "Level Up!", "I've achieved the rank of "+rankName+" in Harvest Honors!", "Eat your carrots, and maybe one day you too will be as cool as me.");
};

FacebookWrapper.prototype.shareRoomUnlock = function( roomIndex ) {
	"use strict";

	var roomData = flowController.GetRoomData(roomIndex);
	var roomName = flowController.GetRoomName(roomData);

	var roomImage;

	switch(roomIndex)
	{
		default:
		case 2: roomImage = "s_facebook_image_room_grain"; break;
		case 3: roomImage = "s_facebook_image_room_tomato"; break;
		case 4: roomImage = "s_facebook_image_room_corn"; break;
		case 5: roomImage = "s_facebook_image_room_sweetpotato"; break;
		case 6: roomImage = "s_facebook_image_room_eggplant"; break;
		case 7: roomImage = "s_facebook_image_room_carrot"; break;
		case 8: roomImage = "s_facebook_image_room_apple"; break;
	}

	if(this.isMobile){
		this.shareCommonMobile( roomImage, "New Land Discovered!", "I've just unlocked the "+roomName+" in Harvest Honors!", "Come help me explore some time. =)");
		return;
	}
	this.shareCommon( roomImage, "New Land Discovered!", "I've just unlocked the "+roomName+" in Harvest Honors!", "Come help me explore some time. =)");
};

FacebookWrapper.prototype.shareCommon = function( imagePath, boldTitle, normalText, smallGreyText ) {
	"use strict";

	console.log("Sharing on facebook with image url: http://www.tinglygames.com/hh-facebook-data/" + imagePath);

	this.fb["ui"]({
		"method" : "feed",
		"picture": "http://www.tinglygames.com/hh-facebook-data/" + imagePath,
		"link"   : "http://www.harvesthonors.com",
		"name"   : boldTitle,      // Bold text, immediately under the image.
		"description": normalText, // Normal text, below the name field.
		"caption": smallGreyText   // Grey text, underneath description.
	},
	function(response) { }
	);
};

FacebookWrapper.prototype.shareCommonMobile = function( imagePath, boldTitle, normalText, smallGreyText){
	"use strict";

	console.log("Sharing on mobile facebook with image url: http://www.tinglygames.com/hh-facebook-data/" + imagePath);

	facebookConnectPlugin["showDialog"]({
		method : "feed",
		picture: "http://www.tinglygames.com/hh-facebook-data/" + imagePath,
		link   : "http://www.harvesthonors.com",
		name   : boldTitle,      // Bold text, immediately under the image.
		description: normalText, // Normal text, below the name field.
		caption: smallGreyText   // Grey text, underneath description.
	},function(response) { console.log(response); } , function(error){ console.log(error); });
};

FacebookWrapper.prototype.login = function(onSuccess, onFailure) {
	"use strict";

	// Now that we"ve initialized the JavaScript SDK, we call
	// FB.getLoginStatus(). This function gets the state of the
	// person visiting this page and can return one of three states to
	// the callback you provide. They can be:
	//
	// 1. Logged into your app ("connected")
	// 2. Logged into Facebook, but not your app ("not_authorized")
	// 3. Not logged into Facebook and can"t tell if they are logged into
	// your app or not.
	//
	// These three cases are handled in the callback function.
	var self = this;
	if(this.isMobile){
		facebookConnectPlugin["login"](this.mPermissions, function(success){ self.successLogin(success); }, function(error){ console.log("Mobile error: " + error) });
		return;
	}

	var response = this.loginStatus;
	var _this = this;
	if (response["status"] === "connected") {
		if (onSuccess) {
			onSuccess(response);
		}
		// Logged into your app and Facebook.
	}
	else {
		this.fb["login"](function(response) {
			_this._loginCallback(response);
			if (_this.loggedIn) {
				if (onSuccess) {
					onSuccess(response);
				}
			}
			else {
				if (onFailure) {
					onFailure(response);
				}
			}
		}, {"scope": "user_friends"});
	}

};

FacebookWrapper.prototype.retrieveFriends = function(callback) {
	"use strict";

	if(this.isMobile){
		facebookConnectPlugin["api"]("me/friends?fields=id,name,picture", ["user_friends"] , function(response) {
			callback(response);
		});
		return;
	}

	this.fbApi("/me/friends", "get", {
		"limit": 5000,
		"fields": "id,name,picture"
	}, function(response) {
		callback(response);
	});
};

FacebookWrapper.prototype.retrieveInvitableFriends = function(callback, imageSize) {
	"use strict";

	if (imageSize === undefined) {
		imageSize = FacebookFriendImageSize._80x80;
	}

	if(this.isGuest){
		return;
	}

	if(this.isMobile){
		facebookConnectPlugin["api"]("me/invitable_friends?fields=id,name,picture.type(square).width(" + imageSize + ").height(" + imageSize + ")", ["user_friends"] , function(response) {
			callback(response);
		});
		return;
	}

	this.fbApi("/me/invitable_friends", "get", {
		"limit": 50,
		"fields": "id,name,picture.type(square).width(" + imageSize + ").height(" + imageSize + ")"
	}, function(response) {
		callback(response);
	});
};

FacebookWrapper.prototype.getProfilePicture = function(id, size, callback) {
	"use strict";

	if (size === undefined) {
		size = FacebookFriendImageSize._80x80;
	}

	if(this.isGuest){
		return;
	}

	if(this.isMobile){
		facebookConnectPlugin["api"]("me/?fields=picture.type(square).width(" + size + ").height(" + size + ")", ["public_profile"] , function(response) {
			callback(response);
		});
		return;
	}

	this.fbApi("/" + id + "/picture", "get", {
		"type": "square",
		"height": size,
		"width": size
	}, function(response) {
		callback(response);
	});
};

FacebookWrapper.prototype.isInitialized = function() {
	"use strict";
	return !(!this.loginStatus);
};

FacebookWrapper.prototype.isLoggedIn = function() {
	"use strict";
	return this.loggedIn;
};

FacebookWrapper.prototype._loginCallback = function(response) {
	"use strict";
	console.log(response);

	if (this.loggedIn) {
		return;
	}

	if(this.isMobile){
		if(response["status"] === "unknown" && this.timesChecked < 3){
			console.log("unknown response");
			this.initMobile();
			this.timesChecked++;
			return;
		}

		if(response["authResponse"]){
			this.loggedIn = true;
			facebookConnectPlugin["api"]("me?fields=id,name,picture", ["public_profile"],
				function(success){

			}
			);

			GameSparksWrapper.instance.init(function() {
				GameSparksWrapper.instance.facebookLogin(response["authResponse"]["accessToken"]);
			});
		}

		return;
	}

	this.loginStatus = response;


	if (response["authResponse"]) {
		this.loggedIn = true;
		this.fbApi("/me", function(response) { });

//      GameSparksWrapper.instance.init(function() {
//          GameSparksWrapper.instance.facebookLogin(response["authResponse"]["accessToken"]);
//      });
		tgfFirebase.fbConnect(response["authResponse"]["accessToken"]);
	}
};

// This is called with the results from from FB.getLoginStatus().
FacebookWrapper.prototype._statusChangeCallback = function(response) {
	"use strict";
};

FacebookWrapper.prototype._checkLoginState = function() {
	"use strict";
	console.log("Check Status Mobile");
	var self = this;
	if(this.isMobile){
		facebookConnectPlugin["getLoginStatus"](function(response){ self.statusChangeCallback(response); });
		return;
	}

	var _this = this;
	this.fb["getLoginStatus"](function(response) {
		_this.statusChangeCallback(response);
	});
};

FacebookWrapper.prototype.inviteFriend = function(userId, callback) {
	"use strict";
	if(this.isMobile){

		facebookConnectPlugin["showDialog"]({
			"method" : "apprequests",
			"message": "Come play Harvest Honors with me!",
			"to": [userId]
		}, function(response) {
			if (callback) {
				callback(response);
			}
		}, function(error){ console.log(error); });

		return;
	}

	this.fb["ui"]({
		"method": "apprequests",
		"message": "Come play Harvest Honors with me!",
		"to": [userId]
	}, function(response) {
		if (callback) {
			callback(response);
		}
	});
};

// Here we run a very simple test of the Graph API after login is
// successful. See statusChangeCallback() for when this call is made.
FacebookWrapper.prototype.testAPI = function() {
	"use strict";
	if(this.isMobile){
		console.log("Call API");
		return;
	}
	this.fbApi("/me", function(response) {} );
};

FacebookWrapper.prototype.successLogin = function(userData){
	"use strict";
	console.log("FB Success Test: " + userData);
	console.log("USERDATA: " + userData["authResponse"]);
	this.isGuest = false;
	this._loginCallback(userData);
};

FacebookWrapper.prototype.successGen = function(){
	"use strict";
	console.log("FB Gen Test");
};


FacebookWrapper.instance = new FacebookWrapper();




//******************************************************
//*****    Script Resource: BouncingScroll
//******************************************************

/* global
	tgfSettings,
	tgfComponents
 */

tgfSettings.componentDefaults.bouncingScroll = {
	image: s_tgf_button,
	elementWidth: 500,
	accel: 45,
	outOfBoundsDamp: 1.0,
	damp: 7
};

/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.BouncingScroll = function(properties) {
	"use strict";

	this.initialize(tgfSettings.componentDefaults.bouncingScroll);

	this.index           = 0;
	this.elementWidth    = 500;
	this.elements        = [];
	this.trackingFinger  = -1;
	this.axis            = new tbVector(1,0);
	this.fingerStart     = new tbVector(0,0);
	this.fingerCurrent   = new tbVector(0,0);
	this.speed           = 0;
	this.accel           = 45;
	this.damp            = 7;

	this.applyMask = false;
	this.scrollAreaWidth = tgfScale(470);
	this.scrollAreaHeight = tgfScale(200);
	this.maskAreaX = tgfScale(0);
	this.maskAreaY = tgfScale(0);
	this.maskOffsetX = tgfScale(50);
	this.container = new tgfComponents.Base({});

	this.scrollParam     = 0.0;
	this.scrollParamStart = 0.0;
	this.scrollMax = 1000.0;

	this.postProcessElement = null;

	// Set user properties
	if (properties !== undefined) {
		this.setProperties(properties);
	}
};

tgfComponents.inherit(tgfComponents.BouncingScroll, tgfComponents.Base);

Math.round = Math["round"];

tgfComponents.BouncingScroll.prototype.doPrepare = function(){
	"use strict";
	if(this.applyMask){
		this.surface = new tbSurface(this.scrollAreaWidth, this.scrollAreaHeight);
		this.container.x = this.x;
		this.container.y = this.y;
		this.addComponent(this.container);
		this.surface.context.translate(Math.round(this.maskOffsetX), Math.round(this.scrollAreaHeight / 2));
	}
};

tgfComponents.BouncingScroll.prototype.addElement = function (element) {
	"use strict";
	if(this.applyMask) {
		this.container.addComponent(element);
	} else {
		this.addComponent(element);
	}
	this.elements.push(element);
	this.setElementPosition(element, this.elements.length-1);
};

tgfComponents.BouncingScroll.prototype.addElementAtIndex = function (element, index) {
	"use strict";
	this.addComponent(element);
	this.elements[index] = element;
	this.setElementPosition(element, index);
};

tgfComponents.BouncingScroll.prototype.setElementPosition = function (element, index) {
	"use strict";

	var relativeParam = index - this.scrollParam;

	var pos = this.axis.scale(this.elementWidth * relativeParam);

	element.x = pos.x;
	element.y = pos.y;

	if(this.postProcessElement) {
		this.postProcessElement(element);
	}
};

tgfComponents.BouncingScroll.prototype.snapToIndex = function (index) {
	"use strict";

	this.scrollParam = Math.max(Math.min(this.elements.length-1,index),0);

	for(var i = 0; i < this.elements.length; ++i) {
		this.setElementPosition(this.elements[i], i);
	}
};

tgfComponents.BouncingScroll.prototype.doBeginStep = function(timepassed) {
	"use strict";

	var prevScrollParam = this.scrollParam;

	if(this.trackingFinger >= 0) {

		var fingerX = tbGame.touchX(this.trackingFinger);
		var fingerY = tbGame.touchY(this.trackingFinger);

		var relativeFingerPos = new tbVector(fingerX - this.fingerStart.x, fingerY - this.fingerStart.y);

		relativeFingerPos.scaleDirect(-1.0 / this.elementWidth);

		var fingerDot = relativeFingerPos.dot(this.axis);

		this.scrollParam = fingerDot + this.scrollParamStart;

		if(this.scrollParam < 0.0) {
			this.scrollParam = Math.atan(this.scrollParam * this.outOfBoundsDamp) / this.outOfBoundsDamp;
		}
		else if(this.scrollParam > this.elements.length-1) {
			this.scrollParam = Math.atan(this.outOfBoundsDamp * (this.scrollParam - this.elements.length + 1)) / this.outOfBoundsDamp + this.elements.length - 1;
		}

		var maxSpeed      = 4.0;
		var observedSpeed = (this.scrollParam - prevScrollParam) * 1000 / timepassed;

		this.speed = Math.min(Math.max(observedSpeed, -maxSpeed), maxSpeed);
	}
	else {
		var targetParam = Math.round(this.scrollParam);

		targetParam = Math.max(0, Math.min(this.elements.length-1, targetParam));

		var deltaParam = targetParam - this.scrollParam;

		var accel = deltaParam * this.accel - this.speed * this.damp;

		this.speed += accel * (timepassed/1000);

		this.scrollParam += this.speed * (timepassed/1000);
	}

	if(prevScrollParam !== this.scrollParam) {
		if(this.scrollParam > this.scrollMax - 0.001){
			this.scrollParam = this.scrollMax;
			return;
		}
		for(var i = 0; i < this.elements.length; ++i) {
			this.setElementPosition(this.elements[i], i);
		}
	}
};

tgfComponents.BouncingScroll.prototype.updateElementScales = function() {
	"use strict";
	for(var i = 0; i < this.elements.length; ++i) {

		var diffX  = Math.abs(this.elements[i].x + this.x);
		var interp = Math.min(1, Math.max(0, diffX / this.elementWidth));
		var scale  = tbEase.easeInOutExponential(interp, 1.0, this.offSideScaling - 1.0, 1.0, 2.0);

		this.elements[i].xScale = scale;
		this.elements[i].yScale = scale;
	}
};

tgfComponents.BouncingScroll.prototype.doTouchDown = function(finger, x, y) {
	"use strict";

	if(this.trackingFinger !== -1) {
		return;
	}

	this.trackingFinger = finger;
	this.fingerStart.assignXY(tbGame.touchX(finger), tbGame.touchY(finger));
	this.scrollParamStart = this.scrollParam;
};

tgfComponents.BouncingScroll.prototype.doTouchUp = function(finger, x, y) {
	"use strict";

	if(finger === this.trackingFinger) {
		this.trackingFinger = -1;
	}
};


// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.BouncingScroll.prototype.doDraw = function() {
	"use strict";
	if(this.applyMask){
		var ww = Math.round(this.maskOffsetX), hh = Math.round(this.scrollAreaHeight/2);
		// Draw the sub-components on a surface
		this.surface.setTarget();
		this.surface.context.clearRect(-ww,-hh, this.surface.width, this.surface.height);

		//this.container.handleDraw();
        //
		//this.surface.resetTarget();
		////this.surface.drawSimple(-this.width / 2, -this.height / 2);
		//this.surface.drawSimple(this.maskAreaX, this.maskAreaY);

	}
};

// Called after drawing the sub-components
tgfComponents.BouncingScroll.prototype.doEndDraw = function() {
	"use strict";
	if(this.applyMask) {
		 //Draw the surface with the sub-components on the canvas
		this.surface.resetTarget();
		//this.surface.drawSimple(-this.width / 2, -this.height / 2);
		this.surface.drawSimple(this.maskAreaX, this.maskAreaY);

		this._tempComponents = this._components;
		this._components = this.elements;
	}

};


//******************************************************
//*****    Script Resource: ScrollExt
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.componentDefaults.bouncingExt = {
	titleComponent: undefined,
	titlePicture: undefined
};

/**
 * @constructor
 * @base tgfComponents.BouncingScroll
 */
tgfComponents.BouncingExt = function(properties) {
	"use strict";

	this.initialize(tgfSettings.componentDefaults.bouncingScroll);
	this.setProperties(tgfSettings.componentDefaults.bouncingExt);

	this.index           = 0;
	this.elementWidth    = 500;
	this.elements        = [];
	this.trackingFinger  = -1;
	this.axis            = new tbVector(1,0);
	this.fingerStart     = new tbVector(0,0);
	this.fingerCurrent   = new tbVector(0,0);
	this.speed           = 0;
	this.accel           = 45;
	this.damp            = 7;

	this.scrollParam     = 0.0;
	this.scrollParamStart = 0.0;

	this.postProcessElement = null;

	// Set user properties
	if (properties !== undefined) {
		this.setProperties(properties);
	}
};

tgfComponents.inherit(tgfComponents.BouncingExt, tgfComponents.BouncingScroll);

Math.round = Math["round"];

tgfComponents.BouncingExt.prototype.doPrepare = function(){
	if(this.titlePicture !== undefined){this.addComponent(this.titlePicture)}
	if(this.titleComponent !== undefined){this.addComponent(this.titleComponent);}
};


tgfComponents.BouncingExt.prototype.doBeginStep = function(timepassed) {
	"use strict";
	
	tgfComponents.BouncingExt.uber.doBeginStep.call(this, timepassed);

	if(this.trackingFinger >= 0){
		if(this.titleComponent !== undefined){
			if(this.titleComponent.textArray !== undefined)
			this.titleComponent.text = this.titleComponent.textArray[Math.round(this.scrollParam)];
			this.titleComponent.recreate();
		}
	}
};

tgfComponents.BouncingExt.prototype.handleMouseWheel = function(delta, x, y){
	
	tgfComponents.BouncingExt.uber.handleMouseWheel.call(this, delta, x, y);
	
	console.log("DELTA: " + delta + " X: " + x + " Y: " + y);
	
};
//******************************************************
//*****    Script Resource: MenuScroller
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.componentDefaults.menuScroll = {
    components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.MenuScroll = function(properties) {
    "use strict";
    this.name = "MenuScroll";         // The name of the component
    // Initialize properties
    this.initialize(tgfSettings.componentDefaults.menuScroll);
    // Set user properties
    if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.MenuScroll, tgfComponents.Base);



// ***************************************
// Size information (e.g. for design support)
// TODO: Override these when not default
// ***************************************

/*
// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.MenuScroll.prototype.getWidth = function() {
    "use strict";
    return this.width === undefined ? 0 : this.width;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.MenuScroll.prototype.getHeight = function() {
    "use strict";
    return this.height === undefined ? 0 : this.height;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.MenuScroll.prototype.getLeft = function() {
    "use strict";
    return -this.getWidth() / 2;
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.MenuScroll.prototype.getTop = function() {
    "use strict";
    return -this.getHeight() / 2;
};
*/

// ***************************************
// Specific methods for this component
// ***************************************



// ***************************************
// Internal methods
// ***************************************



// ***************************************
// Preparing, showing and activating
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.MenuScroll.prototype.doPrepare = function() {
    "use strict";
    var i;
    // Add the child components
    if (this.components) {
        for (i = 0; i < this.components.length; i += 1) {
            this.addComponent(this.components[i]);
        }
    }
};

// Processing required when freeing the component from use
tgfComponents.MenuScroll.prototype.doFree = function() {
    "use strict";
};

// Processing required when showing the component
tgfComponents.MenuScroll.prototype.doShow = function() {
    "use strict";
};

// Processing required when hiding the component
tgfComponents.MenuScroll.prototype.doHide = function() {
    "use strict";
};

// Processing required when activating the component
tgfComponents.MenuScroll.prototype.doActivate = function() {
    "use strict";
};

// Processing required when deactivating the component
tgfComponents.MenuScroll.prototype.doDeactivate = function() {
    "use strict";
};


// ***************************************
// Methods called when events must be processed
//      - These can be removed when no processing is required
//      - When they return true, this event is no further processed
//          by other components in the dialog
//      - Never call these methods yourself in other components,
//          Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.MenuScroll.prototype.doBeginStep = function(timePassed) {
    "use strict";
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.MenuScroll.prototype.doTouchDown = function(finger, x, y) {
    "use strict";
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.MenuScroll.prototype.doTouchUp = function(finger, x, y) { 
    "use strict";
};

// Called when the position of the mouse wheel is changed
tgfComponents.MenuScroll.prototype.doMouseWheel = function(delta, x, y) {
    "use strict";
};

// Called immediately when a touch is started or if a mouse button is pressed
tgfComponents.MenuScroll.prototype.doImmediateTouchDown = function(finger, x, y) {
    "use strict";
};

// Called immediately when a touch is ended or if a mouse button is released
tgfComponents.MenuScroll.prototype.doImmediateTouchUp = function(finger, x, y) { 
    "use strict";
};

// Called if the key with the given keyCode is pressed
tgfComponents.MenuScroll.prototype.doKeyDown = function(keyCode) { 
    "use strict";
};

// Called if the key with the given keyCode is released
tgfComponents.MenuScroll.prototype.doKeyUp = function(keyCode) { 
    "use strict";
};

// Called if a global alarm is reached
tgfComponents.MenuScroll.prototype.doAlarm = function(alarm) { 
    "use strict";
};

// Called if a special or user-defined event happens
tgfComponents.MenuScroll.prototype.doSpecial = function(id, args) { 
    "use strict";
};

// Called at the end of each step
tgfComponents.MenuScroll.prototype.doEndStep = function(timePassed) { 
    "use strict";
};

// Called just before drawing (also when not active)
tgfComponents.MenuScroll.prototype.doUpdateVisuals = function(timePassed) { 
    "use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.MenuScroll.prototype.doDraw = function() {
    "use strict";
};

// Called after drawing the sub-components
tgfComponents.MenuScroll.prototype.doEndDraw = function() {
    "use strict";
};



//******************************************************
//*****    Script Resource: ComponentButtonList
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.componentDefaults.buttonList = {
	image: s_tgf_button,					// The image or surface (when two sub-image, first one is for up and second for down)
	createFromSlices: true,					// Create from 3 or 9 slices
	marginLeft: tgfScale(24),				// Margin from the left side of the button
	marginRight: tgfScale(24),				// Margin from the right side of the button
	marginTop: tgfScale(24),				// Margin from the top side of the button
	marginBottom: tgfScale(24),				// Margin from the bottom side of the button
	icon: null,								// The image or surface for the icon (when two sub-image, first one is for up and second for down)
	iconPosition: "left",					// Position of the icon ("left", "right", "center", "top", "bottom")
	iconTextDistance: tgfScale(24),			// Distance between the icon and the text
	text: "",								// The text on the button
	dictionaryKey: "",						// The dictionary key to read the text from (if not empty)
	fontDown: null,							// Font to be used when in down state
	fontUp: f_tgf_button,					// Font to be used when in up state
	splitLines: false,						// Whether to allow for splitting of the lines
	offsetXUp: 0,							// Horizontal offset when the button is up
	offsetYUp: 0,							// Vertical offset when the button is up
	offsetXDown: 0,							// Horizontal offset when the button is down
	offsetYDown: 0,							// Vertical offset when the button is down
	soundDown: a_tgf_button_down,			// Sound to play when pressing down
	soundUp: null,							// Sound to play when going up
	toggleIndex: 0,							// Current toggle index to show
	toggleAutomatic: false,					// Whether toggling happens automatically when clicking
	toggleCount: 0,							// Number of toggles. When 0,determines automatically
	touchMargin: 0,							// Extra margin for the touch events around the image
	shortcutKey: null,						// Shortcut keycode for the button
	anyKey: false,							// Whether it reacts to any key
	reactOnDown: false,						// Whether to react when the button goes down, rather than up
	cancelEvents: true,						// Whether to cancel the touch and key events when treated by the button
	useImmediateInput: false,    			// Should immediate touch function be used to process touches?
	roundPosition: true,					// Whether to round the position when the size is odd
	components: [],							// Components to add as children
	onClick: null							// Called when the player clicks the button
};

// The constructor for the component
/** @constructor
 *  @base tgfComponents.Base
 */
tgfComponents.ButtonList = function(properties) {
	"use strict";
	this.name = "ButtonList";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.button);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ButtonList, tgfComponents.Base);


// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.ButtonList.prototype.getWidth = function() {
	"use strict";
	return this.surfaceDown.width;
};

// Returns the height of the component. Must be overriden if it is not the width property
tgfComponents.ButtonList.prototype.getHeight = function() {
	"use strict";
	return this.surfaceDown.height;
};


// ***************************************
// Methods that are specific for this component
// ***************************************

// Recreate the surfaces, when something has changed
tgfComponents.ButtonList.prototype.recreate = function() {
	"use strict";
	this.createSurfaces();
};


// ***************************************
// Internal methods
// ***************************************

// Returns the actual text
tgfComponents.ButtonList.prototype.findText = function() {
	"use strict";
	var text = this.text, key = this.dictionaryKey;
	// Find the correct value for toggle buttons
	if (Object.prototype.toString.call(this.text) === "[object Array]") {
		text = this.text[this.toggleIndex % this.text.length];
	}
	if (Object.prototype.toString.call(this.dictionaryKey) === "[object Array]") {
		key = this.dictionaryKey[this.toggleIndex % this.dictionaryKey.length];
	}
	// Now determine the actual text
	if (key !== "") {
		text = tgfDictionary.getText(key, "<" + key + ">");
	}
	return text;
};

// Draws the button background
tgfComponents.ButtonList.prototype.drawButton = function(surface, state) {
	"use strict";
	var subImg = state === "up" ? 0 : 1,
		image = this.image;
	if (this.image && Object.prototype.toString.call(this.image) === "[object Array]") {
		image = this.image[this.toggleIndex % this.image.length];
	}
	if (!image) { return; }
	// Draw it in the correct way
	if (image instanceof tbSurface) {
		if (this.createFromSlices) {
			image.drawNineSlice(0, 0, surface.width, surface.height, 1,
				Math.floor(image.width / 2) - 2, Math.floor(image.width / 2) - 2, Math.floor(image.height / 2) - 2, Math.floor(image.height / 2) - 2);
		} else if (surface.width === image.width && surface.height === image.height) {
			image.drawSimple(image.xOrigin, image.yOrigin);
		} else {
			image.drawStretched(0, 0, surface.width, surface.height, 1);
		}
	} else if (image instanceof tbImage) {
		if (this.createFromSlices) {
			image.drawNineSlice(subImg, 0, 0, surface.width, surface.height, 1,
				Math.floor(image.width / 2) - 2, Math.floor(image.width / 2) - 2, Math.floor(image.height / 2) - 2, Math.floor(image.height / 2) - 2);
		} else if (surface.width === image.width && surface.height === image.height) {
			image.drawSimple(subImg, image.xOrigin, image.yOrigin);
		} else {
			image.drawStretched(subImg, 0, 0, surface.width, surface.height, 1);
		}
	}
};

// Draws the icon (if any)
tgfComponents.ButtonList.prototype.drawIcon = function(surface, state) {
	"use strict";
	var subImg = state === "up" ? 0 : 1,
		xx, yy,
		image = this.icon;
	if (this.icon && Object.prototype.toString.call(this.icon) === "[object Array]") {
		image = this.icon[this.toggleIndex % this.icon.length];
	}
	if (!image) { return; }
	// Determine the position
	switch (this.iconPosition) {
		case "left": xx = this.marginLeft; yy = (surface.height - image.height) / 2; break;
		case "center": xx = (surface.width - image.width)/2; yy = (surface.height - image.height) / 2; break;
		case "right": xx = surface.width - image.width - this.marginRight; yy = (surface.height - image.height) / 2; break;
		case "top": xx = (surface.width - image.width)/2; yy = this.marginTop; break;
		case "bottom": xx = (surface.width - image.width)/2; yy = surface.width - image.width - this.marginBottom; break;
	}
	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	// Deal with the offset
	if (state === "down") {
		xx += this.offsetXDown; yy += this.offsetYDown;
	} else {
		xx += this.offsetXUp; yy += this.offsetYUp;
	}
	// Draw it in the correct way
	if (image instanceof tbSurface) {
		image.drawSimple(xx + image.xOrigin, yy + image.yOrigin);
	} else if (image instanceof tbImage) {
		image.drawSimple(subImg, xx + image.xOrigin, yy + image.yOrigin);
	}
};

// Draws the text in the correct way at position x, y
tgfComponents.ButtonList.prototype.drawText = function(surface, state) {
	"use strict";
	var xx, yy, ww, hh, oldSize, newSize, font, fnt,
		text = this.findText(),
		image = this.icon;
	if (this.icon && Object.prototype.toString.call(this.icon) === "[object Array]") {
		image = this.icon[this.toggleIndex % this.icon.length];
	}
	// Create the correct font
	if (state === "down") {
		font = this.fontDown !== null ? this.fontDown : this.fontUp;
	} else {
		font = this.fontUp !== null ? this.fontUp : this.fontDown;
	}
	if (font instanceof tbVectorFont) {
		fnt = font;
	} else {
		fnt = new tbVectorFont();
		fnt.setProperties(font);
	}
	// Determine the box for the text
	xx = this.marginLeft;
	yy = this.marginTop;
	ww = surface.width - this.marginLeft - this.marginRight;
	hh = surface.height - this.marginTop - this.marginBottom;
	if (image) {
		switch (this.iconPosition) {
			case "left": xx += image.width + this.iconTextDistance; ww -= image.width + this.iconTextDistance; break;
			case "center": break;
			case "right": ww -= image.width + this.iconTextDistance; break;
			case "top": yy += image.height + this.iconTextDistance; hh -= image.height + this.iconTextDistance; break;
			case "bottom": hh -= image.height + this.iconTextDistance; break;
		}
	}
	switch (fnt.align) {
		case "left": break;
		case "center": xx += ww/2; break;
		case "right": xx += ww; break;
	}
	switch (fnt.baseline) {
		case "top": break;
		case "middle": yy += hh/2; break;
		case "bottom": yy += hh; break;
	}
	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	// Deal with the offset
	if (state === "down") {
		xx += this.offsetXDown; yy += this.offsetYDown;
	} else {
		xx += this.offsetXUp; yy += this.offsetYUp;
	}
	// Compute the size
	oldSize = fnt.getFontSize();
	newSize = fnt.textFitSize(text, ww, hh, this.splitLines);
	if (newSize < oldSize) { fnt.setFontSize(newSize); }
	// Draw the text
	if (this.splitLines) {
		fnt.drawSimple(text, xx, yy, ww);
	} else {
		fnt.drawSimple(text, xx, yy);
	}
	// Restore the size
	fnt.setFontSize(oldSize);
};

// Create the surfaces for the button
tgfComponents.ButtonList.prototype.createSurfaces = function() {
	"use strict";
	var ww = this.width, hh = this.height,
		image = this.image;
	if (this.image && Object.prototype.toString.call(this.image) === "[object Array]") {
		image = this.image[this.toggleCount % this.image.length];
	}
	if (image && ww === 0) { ww = image.width; }
	if (image && hh === 0) { hh = image.height; }
	this.surfaceDown = new tbSurface(ww, hh);
	this.surfaceDown.setTarget();
	this.drawButton(this.surfaceDown, "down");
	this.drawIcon(this.surfaceDown, "down");
	this.drawText(this.surfaceDown, "down");
	this.surfaceDown.resetTarget();
	this.surfaceUp = new tbSurface(ww, hh);
	this.surfaceUp.setTarget();
	this.drawButton(this.surfaceUp, "up");
	this.drawIcon(this.surfaceUp, "up");
	this.drawText(this.surfaceUp, "up");
	this.surfaceUp.resetTarget();
};

// Set the state of the button to up or down
tgfComponents.ButtonList.prototype._setState = function(state, action) {
	"use strict";
	if (this.state === state) { return; }
	if (state === "down") {
		this.state = "down";
		if (action) {
			if (this.soundDown) { tgfAudio.play(this.soundDown); }
			if (this.reactOnDown) {
				if (this.toggleAutomatic && this.toggleCount > 1) {
					this.toggleIndex = (this.toggleIndex + 1) % this.toggleCount;
					this.createSurfaces();
				}
				if (this.onClick) { this.onClick(this); }
			}
		}
	} else if(state === "up"){
		this.state = "up";
		if (action) {
			if (this.soundUp) { tgfAudio.play(this.soundUp); }
			if (!this.reactOnDown) {
				if (this.toggleAutomatic && this.toggleCount > 1) {
					this.toggleIndex = (this.toggleIndex + 1) % this.toggleCount;
					this.createSurfaces();
				}
				if (this.onClick) { this.onClick(this); }
			}
		}
	} 
};


// ***************************************
// Preparing, showing and activating
// ***************************************

// Prepare the component for use; returns whether already prepared
tgfComponents.ButtonList.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Compute the toggle count
	if (this.toggleCount <= 0) {
		this.toggleCount = 1;
		if (Object.prototype.toString.call(this.image) === "[object Array]") { this.toggleCount = Math.max(this.toggleCount, this.image.length); }
		if (Object.prototype.toString.call(this.icon) === "[object Array]") { this.toggleCount = Math.max(this.toggleCount, this.icon.length); }
		if (Object.prototype.toString.call(this.text) === "[object Array]") { this.toggleCount = Math.max(this.toggleCount, this.text.length); }
		if (Object.prototype.toString.call(this.dictionaryKey) === "[object Array]") { this.toggleCount = Math.max(this.toggleCount, this.dictionaryKey.length); }
	}
	// Create the surfaces
	this.createSurfaces();
	// Initialize the state
	this._setState("up", false);
	this.finger = -1;
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when freeing the component after use
tgfComponents.ButtonList.prototype.doFree = function() {
	"use strict";
	// Free the surface
	this.surfaceDown = undefined;
	this.surfaceUp = undefined;
};


// ***************************************
// Methods called when events must be processed
// ***************************************

//Called when a touch is started or if a mouse button is pressed
tgfComponents.ButtonList.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
//	this.tmpPosX = this.touchX(finger);
//	this.tmpPosY = this.touchY(finger);
	
//	if(this.listButton){this.disableActive();}
	
	if (!this.useImmediateInput) {
		return this.doTouchDownInternal(finger, x, y);
	}
};

//Called when a touch is ended or if a mouse button is released
tgfComponents.ButtonList.prototype.doTouchUp = function(finger, x, y) {
	"use strict";
//	this.tmpPosX = 0;
//	this.tmpPosY = 0;
	
	if (!this.useImmediateInput) {
		return this.doTouchUpInternal(finger, x, y);
	}
};

//Called when a touch is started or if a mouse button is pressed
tgfComponents.ButtonList.prototype.doImmediateTouchDown = function(finger, x, y) {
	"use strict";
	if (this.useImmediateInput) {
		return this.doTouchDownInternal(finger, x, y);
	}
};

//Called when a touch is ended or if a mouse button is released
tgfComponents.ButtonList.prototype.doImmediateTouchUp = function(finger, x, y) {
	"use strict";
	if (this.useImmediateInput) {
		return this.doTouchUpInternal(finger, x, y);
	}
};

// Do the actual work when a touch is started or if a mouse button is pressed
tgfComponents.ButtonList.prototype.doTouchDownInternal = function(finger, x, y) {
	"use strict";
	var ww = this.surfaceDown.width + 2 * this.touchMargin,
		hh = this.surfaceDown.height + 2 * this.touchMargin;
	if (x >= -ww/2 && x <= ww/2 && y >= -hh/2 && y <= hh/2) {
		if (this.state === "up") {
			this._setState("down", true);
			this.finger = finger;
		}
		if (this.cancelEvents) { return true; }
	}
};

//tgfComponents.ButtonList.prototype.disableAfterMovement = function(){
//	if(this.state === "down"){
//		this._setState("up", false);
//	}
//};
//
//tgfComponents.ButtonList.prototype.disableActive = function(){
//	if(this.isActive){
//		this._setState("up", false);
//	}
//};

// Do the actual work when a touch is ended or if a mouse button is released
tgfComponents.ButtonList.prototype.doTouchUpInternal = function(finger, x, y) {
	"use strict";
	var ww = this.surfaceDown.width + 2 * this.touchMargin,
		hh = this.surfaceDown.height + 2 * this.touchMargin;
	if (this.finger !== finger) { return; }
	this.finger = -1;
	
//	if(this.listButton){	
//		this._setState("active");
//		this.isActive = true;
//		return;
//	}
	
	if (x >= -ww/2 && x <= ww/2 && y >= -hh/2 && y <= hh/2) {
		
		
		if (this.state === "down") {
			this._setState("up", true);
		}
		if (this.cancelEvents) { return true; }
	}
	
};

// Called if the key with the given keyCode is pressed
tgfComponents.ButtonList.prototype.doKeyDown = function(keyCode) {
	"use strict";
	if (this.anyKey || (this.shortcutKey && keyCode === this.shortcutKey)) {
		this._setState("down", true);
		if (this.cancelEvents) { return true; }
	}
};

// Called if the key with the given keyCode is released
tgfComponents.ButtonList.prototype.doKeyUp = function(keyCode) {
	"use strict";
	if (this.anyKey || (this.shortcutKey && keyCode === this.shortcutKey)) {
		this._setState("up", true);
		if (this.cancelEvents) { return true; }
	}
};

// Called at the end of each step
tgfComponents.ButtonList.prototype.doEndStep = function(timePassed) {
	"use strict";
	var xx, yy,
		ww = this.surfaceDown.width + 2 * this.touchMargin,
		hh = this.surfaceDown.height + 2 * this.touchMargin;
	// Check whether the finger moves on or off the button
	if (this.finger !== -1) {
		xx = this.touchX(this.finger);
		yy = this.touchY(this.finger);
//		if(this.listButton){
//			if(xx > this.tmpPosX + this.threshold|| xx < this.tmpPosX - this.threshold || yy < this.tmpPosY - this.threshold || yy > this.tmpPosY + this.threshold){
//				this.disableAfterMovement();
//				this.finger = -1;
//				return;
//			}
//		}
		if (xx >= -ww/2 && xx <= ww/2 && yy >= -hh/2 && yy <= hh/2) {
			this._setState("down", false);
		} else {
			this._setState("up", false);
		}
	}
};

// Called if a special or user-defined event happens
tgfComponents.ButtonList.prototype.doSpecial = function(id, args) {
	"use strict";
	if (id === "languageSet") { this.createSurfaces(); }
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.ButtonList.prototype.doDraw = function() {
	"use strict";
	var ww = this.surfaceDown.width, hh = this.surfaceDown.height,
		xx = -ww/2, yy = -hh/2;
	if (this.roundPosition) { xx = Math.floor(xx); yy = Math.floor(yy); }
	if (this.state === "down") {
		this.surfaceDown.drawSimple(xx, yy);
	} else {
		this.surfaceUp.drawSimple(xx, yy);
	}
};

//******************************************************
//*****    Script Resource: OptionButtonBox_Old
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************
tgfSettings.dialogDefaults.optionButtonBox = {
	x: undefined,                                       // X-position. When undefined it is placed in the center
	y: undefined,                                       // Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,                       // The background image
	marginLeft: tgfScale(40),                           // Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),                          // Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),                            // Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),                         // Bottom margin whether there is no text, images, etc.
	titlePercentage: 10,                                // Percentage of the box for the title
	messagePercentage: 0,                               // Percentage of the box for the message (if any)
	buttonPercentage: 90,                               // Percentage of the box for the buttons
	titleText: "",                                      // Text for the title
	titleDictionaryKey: "",                             // Dictionary key for the title
	titleFont: f_tgf_title,                             // Font to be used for the title
	messageText: "",                                    // Text for the message
	messageDictionaryKey: "",                           // Dictionary key for the message
	messageFont: f_tgf_text,                            // Font to be used for the message
	iconImage: null,                                    // Image for the icon
	iconPosition: "right",                              // Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,                              // Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),                     // Width of the close button
	closeButtonHeight: tgfScale(96),                    // Height of the close button
	buttonHorizontal: false,                            // Whether the buttons must be placed horizontally
	buttonHorizontalSize: tgfScale(0),                  // Total horizontal size for the buttons (0 = use maximum)
	buttonHorizontalGap: tgfScale(8),                   // Horizontal gap between the buttons
	buttonVerticalGap: tgfScale(8),                     // Vertical gap between the buttons
	buttonVerticalAlignment: "middle",                  // Vertical alignment for the buttons ("top", "middle", "bottom")
	buttonDefaultHide: false,                           // Whether to hide the dialog on clicking the button
	buttonDefaultImage: s_tgf_button,                   // Default image for the buttons
	buttonDefaultFont: f_tgf_button,                    // Default font to be used for the buttons
	buttonDefaultProperties: null,                      // Default additional properties for the button components
	buttons: [],                                        // Array of (array of) information about the buttons; can contain:
														//      sliced, text, dictionaryKey, image, icon, font, id, properties, hide
	darken: true,                                       // Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 9999999,                                  // How long it will stay visible before disappearing automatically
	disappearOnClick: false,                            // Whether to disappear when the screen is clicked
	components: [],                                     // The additional components to add
	onClick: null,                                      // Function to be called when clicking the button: function(dialog, buttonId)
	onClose: null,                                      // Function to be called when clicking the close button
	
	onTutorial: null,
	onMusic: null,
	onMusicChange: null,
	onSound: null,
	onSoundChange: null,
	onMoreGames: null,
	onAbout: null,
	
	optionSettings: [],
	optionButtonPositions: [{x: tgfScale(0), y: tgfScale(-200)}, {x: tgfScale(0), y: tgfScale(-100)}, {x: tgfScale(0), y: tgfScale(0)}, {x: tgfScale(0), y: tgfScale(100)}, {x: tgfScale(0), y: tgfScale(200)}],
	optionButtonCurX: tgfScale(0),
	optionButtonCurY: tgfScale(0),
	
	buttonTutorialImage: s_tgf_button,
//  buttonTutorialX: tgfScale(0),
//  buttonTutorialY: tgfScale(-200),
	buttonTutorialFont: f_tgf_button,
	buttonTutorialDictionaryKey: "Tutorial",
	buttonTutorialWidth: tgfScale(400),
	buttonTutorialHeight: tgfScale(80),
	buttonTutorialText: "",
	buttonTutorialIcon: null,
	
//  sliderMusicX: tgfScale(0),
//  sliderMusicY: tgfScale(-100),
	sliderMusicImageBack: s_tgf_slider_back,
	sliderMusicImageSlider: s_tgf_slider_slider,
	sliderMusicWidth: tgfScale(400),
	sliderMusicHeight: tgfScale(80),
	sliderMusicIcon: s_tgf_icon_music_on,
	
//  buttonFxX: tgfScale(0),
//  buttonFxY: tgfScale(0),
	sliderSoundImageBack: s_tgf_slider_back,
	sliderSoundImageSlider: s_tgf_slider_slider,
	sliderSoundWidth: tgfScale(400),
	sliderSoundHeight: tgfScale(80),
	sliderSoundIcon: s_tgf_icon_sound_on,
	
	buttonMoreImage: s_tgf_button,
//  buttonMoreX: tgfScale(0),
//  buttonMoreY: tgfScale(100),
	buttonMoreFont: f_tgf_button,
	buttonMoreDictionaryKey: "More Games",
	buttonMoreWidth: tgfScale(400),
	buttonMoreHeight: tgfScale(80),
	buttonMoreText: "",
	buttonMoreIcon: null,
	buttonMoreUrl: "http://www.tinglygames.com/html5-games/",
	
	buttonAboutImage: s_tgf_button,
//  buttonAboutX: tgfScale(0),
//  buttonAboutY: tgfScale(200),
	buttonAboutFont: f_tgf_button,
	buttonAboutDictionaryKey: "About",
	buttonAboutWidth: tgfScale(400),
	buttonAboutHeight: tgfScale(80),
	buttonAboutText: "",
	buttonAboutIcon: null,
	buttonAboutComponents: [],
	//Extra Properties for the about screen
	aboutBackgroundImage: typeof s_overlay_options !== "undefined" ? s_overlay_options : null, aboutTitleDictionaryKey: "Developed by:",
	aboutTitleText: "", aboutTitleFont: f_tgf_title, aboutTitleX: tgfScale(0), aboutTitleY: tgfScale(-250),
	aboutImage: s_logo_tinglygames, aboutImageX: tgfScale(0), aboutImageY: tgfScale(-100), aboutImageUrl: "http://www.tinglygames.com/",
	aboutLabelText: "Tingly Games \n www.tinglygames.com \n  2014 - 2015", aboutLabelTextX: tgfScale(0), aboutLabelTextY: tgfScale(100), aboutLabelUrl: "http://www.tinglygames.com/",
	aboutButtonImage: s_tgf_button, aboutButtonText: "", aboutButtonDictionaryKey: "Back", aboutButtonFont: f_tgf_button, aboutButtonX: tgfScale(0), aboutButtonY: tgfScale(200), aboutButtonWidth: tgfScale(400), aboutButtonHeight: tgfScale(80),
	
	// Additional properties for the components
	darkenerProperties: null,                           // Properties for the darkener component
	backgroundProperties: null,                         // Properties for the background container component
	titleProperties: null,                              // Properties for the title component
	messageProperties: null,                            // Properties for the message component
	iconProperties: null,                               // Properties for the icon component
	closeButtonProperties: null,                            // Properties for the close button component,
	
	tutorialProperties: null,
	musicProperties: null,
	soundProperties: null,
	languageProperties: null,
	moreGamesProperties: null,
	aboutProperties: null
};

// The constructor for the dialog
/** @constructor
 *  @base tgfDialogs.Base
 */
tgfDialogs.OptionButtonBox = function(properties) {
	"use strict";
	this.name = "OptionButtonBox";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.optionButtonBox);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.OptionButtonBox, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.OptionButtonBox.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************

tgfDialogs.OptionButtonBox.prototype.openLanguage = function(){
	var dialog;
	if(tgfSettings.flow.showLanguageDialog){
		if(tgfSettings.flow.languageScreenProperties){
			dialog = new tgfDialogs.LanguageBox(tgfSettings.flow.languageScreenProperties);
			dialog.onClick = function(dialog, buttonId){
				tbGame.resumeTokens();
				dialog.changeLanguage(buttonId);
			};
			tbGame.pauseTokens();
			dialog.show();
		}else{
			console.log("No languageScreenProperties can be found");
		}
	}
};

tgfDialogs.OptionButtonBox.prototype.openTutorial = function(){
	var dialog;
	if(tgfSettings.flow.showTutorialScreen){
		if(tgfSettings.flow.tutorialMenuProperties){
			dialog = new tgfDialogs.Tutorial(tgfSettings.flow.tutorialMenuProperties);
			dialog.onClick = function(dialog){
				tbGame.resumeTokens();
			};
			tbGame.pauseTokens();
			dialog.show();
		}else{
			console.log("No tutorialMenuProperties can be found");
		}
	}
};

// Initialize About Screen
tgfDialogs.OptionButtonBox.prototype.initAbout = function(dialog){
	var self = this;
	
	var tmpLabel = new tgfComponents.Label({
		text: this.aboutTitleText, dictionaryKey: this.aboutTitleDictionaryKey, x: this.aboutTitleX, y: this.aboutTitleY, fontUp: this.aboutTitleFont 
	});
	
	this.buttonAboutComponents.push(tmpLabel);
	
	var tmpPic = new tgfComponents.Picture({image: this.aboutImage, 
		x: this.aboutImageX, y: this.aboutImageY, url: this.aboutImageUrl,
		onClick: function(){
			var link = this.url;
			window.open(link);
		}});
	this.buttonAboutComponents.push(tmpPic);
	
	var tmpLabel = new tgfComponents.Label({
		text: this.aboutLabelText,
		x: this.aboutLabelTextX, y: this.aboutLabelTextY, url: this.aboutLabelUrl,
		onClick: function(){
			var link = this.url;
			window.open(link);
		}});
	this.buttonAboutComponents.push(tmpLabel);
	
	var tmpButton = new tgfComponents.Button({
		image: this.aboutButtonImage,
		x: this.aboutButtonX, y: this.aboutButtonY, width: this.aboutButtonWidth, height: this.aboutButtonHeight,
		text: this.aboutButtonText, dictionaryKey: this.aboutButtonDictionaryKey, fontUp: this.aboutButtonFont,
		onClick: function(){
			if(dialog.onBack){dialog.onBack();}
			else{dialog.disappear();}  
		}});
	this.buttonAboutComponents.push(tmpButton);
	
	return this.buttonAboutComponents;
};

tgfDialogs.OptionButtonBox.prototype.openAbout = function(){
	var dialog;
	dialog = new tgfDialogs.ButtonBox({
		backgroundImage: this.aboutBackgroundImage,
		hasCloseButton: true,
		onBack: null
	});
	dialog.components = this.initAbout(dialog);
	dialog.onHide = function(dialog){
		tbGame.resumeTokens();
	};
	tbGame.pauseTokens();
	dialog.show();
};

tgfDialogs.OptionButtonBox.prototype.arrangeOptionScreen = function(i){
	this.optionButtonCurX = this.optionButtonPositions[i].x;
	this.optionButtonCurY = this.optionButtonPositions[i].y;
};

// Add a component to the dialog and returns it
tgfDialogs.OptionButtonBox.prototype._addComponent = function(parent, Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.addComponent(comp);
	return comp;
};

// Add a button to the dialog and returns it
tgfDialogs.OptionButtonBox.prototype._addButton = function(parent, button, n, x, y, w) {
	"use strict";
	var self = this;
	return this._addComponent(parent, tgfComponents.Button, {
			x: x, y: y, width: button.sliced === undefined ? w : 0, height: 0,
			image: button.image === undefined ? this.buttonDefaultImage : button.image,
			text: button.text === undefined ? "" : button.text,
			dictionaryKey: button.key === undefined ? "" : button.key,
			icon: button.icon, iconPosition: "left",
			font: button.font === undefined ? this.buttonDefaultFont : button.font,
			buttonId: button.id === undefined ? n : button.id,
			buttonHide: button.hide === undefined ? this.buttonDefaultHide : button.hide,
			cancelEvents: true,
			onClick: function (component) {
				if (component.buttonHide) { tgfDialogs.ButtonBox.prototype.disappear.call(self); }
				if (self.onClick) { self.onClick(self, component.buttonId); }
			}
		}, this.buttonDefaultProperties, button.properties);
};

tgfDialogs.OptionButtonBox.prototype.manageVolumeIcon = function(icon, curIcon, curValue, noCall){
	if(icon[0] === curIcon){
		this.setValue(0, noCall);
		icon = icon[1];
	}else{
		this.setValue(curValue, noCall);
		icon = icon[2];
	}
};

// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.OptionButtonBox.prototype.doPrepare = function() {
	"use strict";
	var self = this, i, j, n,
		blockLeft = [], blockTop = [], blockWidth = [], blockHeight = [],
		ww, hh, closeX, closeY,
		buttons, buttonLeft, buttonTop, buttonVDistance, buttonHDistance, buttonWidth, buttonHeight,
		darkener;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Determine the position and sizes of the blocks
	ww = this.width === 0 ? this.backgroundImage.width : this.width;
	hh = this.height === 0 ? this.backgroundImage.height : this.height;
	blockLeft[0] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[0] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[0] = Math.round(-hh/2 + this.marginTop);
	blockHeight[0] = Math.round(this.titlePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	blockLeft[1] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[1] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[1] = Math.round(blockTop[0] + blockHeight[0]);
	blockHeight[1] = Math.round(this.messagePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	if (this.iconImage) {
		blockWidth[2] = this.iconImage.width;
		blockLeft[2] = blockLeft[1] + blockWidth[1] - blockWidth[2];
		blockTop[2] = blockTop[1];
		blockHeight[2] = blockHeight[1];
		blockWidth[1] -= blockWidth[2] + tgfScale(32);
		if (this.iconPosition === "left") {
			blockLeft[2] = blockLeft[1];
			blockLeft[1] += blockWidth[2] + tgfScale(32);
		}
	}
	blockLeft[3] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[3] = Math.round(ww - this.marginLeft - this.marginRight);
	if (this.buttonHorizontalSize > 0) {
		blockLeft[3] = Math.round(-this.buttonHorizontalSize / 2);
		blockWidth[3] = this.buttonHorizontalSize;
	}
	blockTop[3] = Math.round(blockTop[1] + blockHeight[1]);
	blockHeight[3] = Math.round(this.buttonPercentage * (hh - this.marginTop - this.marginBottom) / 100);
	// Create the darkener
	if (this.darken) {
		darkener = this._addComponent(this, tgfComponents.Darkener, {
				width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
			}, this.darkenerProperties);
	}
	// Create the background image container
	this.container = this._addComponent(this, tgfComponents.Picture, {
			image: this.backgroundImage,
			createFromSlices: true,
			width: this.width === 0 ? this.backgroundImage.width : this.width,
			height: this.height === 0 ? this.backgroundImage.height : this.height,
			effects: [ this.appearEffect, { effect: "show", duration: this.lifeTime }, this.disappearEffect ],
			onSubEffectStart: function (component, effect) {
					if (effect === self.disappearEffect && self.darken) {
						darkener.makeLight(darkener.duration, self.container.effects[2].duration-darkener.duration);
					}
				},
			onEffectEnd: function (component) {
					self.hide();
				}
		}, this.backgroundProperties);
	if (this.disappearOnClick) {
		this.container.onTouchDown = function (component) {
				if (self.onClose) { self.onClose(self); }
				tgfDialogs.ButtonBox.prototype.disappear.call(self);
			};
	}
	// Create title
	if (this.titlePercentage) {
		this._addComponent(this.container, tgfComponents.Label, {
				x: Math.round(blockLeft[0] + blockWidth[0]/2), y: Math.round(blockTop[0] + blockHeight[0]/2),
				width: blockWidth[0], height: blockHeight[0],
				text: this.titleText, dictionaryKey: this.titleDictionaryKey,
				font: this.titleFont, fitToBox: true, splitLines: false, surfaceMargin: tgfScale(20)
			}, this.titleProperties);
	}
	// Create message
	if (this.messagePercentage) {
		this._addComponent(this.container, tgfComponents.Label, {
				x: Math.round(blockLeft[1] + blockWidth[1]/2), y: Math.round(blockTop[1] + blockHeight[1]/2),
				width: blockWidth[1], height: blockHeight[1],
				text: this.messageText, dictionaryKey: this.messageDictionaryKey,
				font: this.messageFont, fitToBox: true, splitLines: true, surfaceMargin: tgfScale(20)
			}, this.messageProperties);
	}
	// Create the icon
	if (this.messagePercentage && this.iconImage) {
		this._addComponent(this.container, tgfComponents.Picture, {
				image: this.iconImage,
				x: Math.round(blockLeft[2] + blockWidth[2]/2), y: Math.round(blockTop[2] + blockHeight[2]/2)
			}, this.iconProperties );
	}
	// Create close button
	if (this.hasCloseButton) {
		closeX = Math.round((this.width === 0 ? this.backgroundImage.width : this.width) / 2 - this.closeButtonWidth / 2);
		closeY = Math.round(-(this.height === 0 ? this.backgroundImage.height : this.height) / 2 + this.closeButtonHeight / 2);
		this._addComponent(this.container, tgfComponents.Button, {
				x: closeX, y: closeY, width: this.closeButtonWidth, height: this.closeButtonHeight,
				image: s_tgf_transparent,
				onClick: function(component) {
						if (self.onClose) { self.onClose(self); }
						tgfDialogs.ButtonBox.prototype.disappear.call(self);
					}
			}, this.closeButtonProperties);
	}
	for(var i = 0; i < this.optionSettings.length; i++){
		switch(this.optionSettings[i]){
		case "tutorial":
			this.arrangeOptionScreen(i);
			//Create Tutorial Button
			this.tutorialComponent = new tgfComponents.Button({
				image: this.buttonTutorialImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonTutorialWidth, height: this.buttonTutorialHeight,
				text: this.buttonTutorialText, dictionaryKey: this.buttonTutorialDictionaryKey, fontUp: this.buttonTutorialFont,
				onClick: function(component){
					if (self.onTutorial) { self.onTutorial(self); }
					else{self.openTutorial();}
				}
			});
			this.tutorialComponent.setProperties(this.tutorialProperties);
			this.container.addComponent(this.tutorialComponent);
			break;
		case "music":
			this.arrangeOptionScreen(i);
			//Create Music Slider
			this.musicComponent = new tgfComponents.Slider({
				icon: this.sliderMusicIcon, imageBack: this.sliderMusicImageBack, imageSlider: this.sliderMusicImageSlider,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.sliderMusicWidth, height: this.sliderMusicHeight,
				onChange: function(component, value){
					if (self.onMusicChange) { self.onMusicChange(self); }
					else{
						tgfAudio.setMusicGain(value / 100);
					}
				},
				onIconClick: function(component){
					if (self.onMusic) { self.onMusic(self); }
					else{
					}
				}
			});
			this.musicComponent.setProperties(this.musicProperties);
			this.container.addComponent(this.musicComponent);
			break;
		case "audio":
			this.arrangeOptionScreen(i);
			//Create FX Slider
			this.soundEffectComponent = new tgfComponents.Slider({
				icon: this.sliderSoundIcon, imageBack: this.sliderSoundImageBack, imageSlider: this.sliderSoundImageSlider,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.sliderSoundWidth, height: this.sliderSoundHeight,
				onChange: function(component, value){
					if (self.onSoundChange) { self.onSoundChange(self); }
					else{
						tgfAudio.setEffectsGain(value / 100);
					}
				},
				onIconClick: function(component){
					if (self.onSound) { self.onSound(self); }
					else{}
				}
			});
			this.soundEffectComponent.setProperties(this.soundProperties);
			this.container.addComponent(this.soundEffectComponent);
			break;
		case "moregames":
			this.arrangeOptionScreen(i);
			//Create More Games Button
			this.moreGamesComponent = new tgfComponents.Button({
				image: this.buttonMoreImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonMoreWidth, height: this.buttonMoreHeight,
				text: this.buttonMoreText, link: this.buttonMoreUrl, dictionaryKey: this.buttonMoreDictionaryKey, fontUp: this.buttonMoreFont,
				onClick: function(component){
					if (self.onMoreGames) { self.onMoreGames(self); }
					else{window.open(this.link);}
				}
			});
			this.moreGamesComponent.setProperties(this.moreGamesProperties);
			this.container.addComponent(this.moreGamesComponent);
			break;
		case "about":
			this.arrangeOptionScreen(i);
			//Create About Button
			this.aboutComponent = new tgfComponents.Button({
				image: this.buttonAboutImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonAboutWidth, height: this.buttonAboutHeight,
				text: this.buttonAboutText, dictionaryKey: this.buttonAboutDictionaryKey, fontUp: this.buttonAboutFont,
				onClick: function(component){
					if (self.onAbout) { self.onAbout(self); }
					else{
						self.openAbout();
					}
				}
			});
			this.aboutComponent.setProperties(this.aboutProperties);
			this.container.addComponent(this.aboutComponent);
			break;
		case "close":
			
			break;
		case "exit":
			
			break;
		}
	}
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.OptionButtonBox.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.container = undefined;
	this.tutorialComponent = undefined;
	this.musicComponent = undefined;
	this.soundEffectComponent = undefined;
	this.moreGamesComponent = undefined;
	this.aboutComponent = undefined;
};



//******************************************************
//*****    Script Resource: DialogLanguageBox_OLD
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.dialogDefaults.languageBox = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,						// The background image
	marginLeft: tgfScale(40),							// Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),							// Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),							// Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),							// Bottom margin whether there is no text, images, etc.
	titlePercentage: 10,								// Percentage of the box for the title
	messagePercentage: 0,								// Percentage of the box for the message (if any)
	buttonPercentage: 90,								// Percentage of the box for the buttons
	titleText: "",										// Text for the title
	titleDictionaryKey: "",								// Dictionary key for the title
	titleFont: f_tgf_title,								// Font to be used for the title
	messageText: "",									// Text for the message
	messageDictionaryKey: "",							// Dictionary key for the message
	messageFont: f_tgf_text,							// Font to be used for the message
	iconImage: null,									// Image for the icon
	iconPosition: "right",								// Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,								// Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),						// Width of the close button
	closeButtonHeight: tgfScale(96),					// Height of the close button
	buttonHorizontal: false,							// Whether the buttons must be placed horizontally
	buttonHorizontalSize: tgfScale(0),					// Total horizontal size for the buttons (0 = use maximum)
	buttonHorizontalGap: tgfScale(8),					// Horizontal gap between the buttons
	buttonVerticalGap: tgfScale(8),						// Vertical gap between the buttons
	buttonVerticalAlignment: "middle",					// Vertical alignment for the buttons ("top", "middle", "bottom")
	buttonDefaultHide: false,							// Whether to hide the dialog on clicking the button
	buttonDefaultImage: s_tgf_buttonSelect,				// Default image for the buttons
	buttonDefaultFont: f_tgf_button,					// Default font to be used for the buttons
	buttonDefaultProperties: null,						// Default additional properties for the button components
	buttons: [],										// Array of (array of) information about the buttons; can contain:
														// sliced, text, dictionaryKey, image, icon, font, id, properties, hide
	buttonScrollBoxWidth: tgfScale(500),
	buttonScrollBoxHeight: tgfScale(500),
	buttonsContainer: [],
	buttonTotalHeight: tgfScale(0),
	
	availableLanguagesIcons:[],
	availableLanguagesNames: [],
	availableLanguagesId:[],
	
	darken: true,										// Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 9999999,									// How long it will stay visible before disappearing automatically
	disappearOnClick: false,							// Whether to disappear when the screen is clicked
	components: [],										// The additional components to add
	onClick: null,										// Function to be called when clicking the button: function(dialog, buttonId)
	onClose: null,										// Function to be called when clicking the close button
	
	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	backgroundProperties: null,							// Properties for the background container component
	titleProperties: null,								// Properties for the title component
	messageProperties: null,							// Properties for the message component
	iconProperties: null,								// Properties for the icon component
	closeButtonProperties: null,						// Properties for the close button component,
	scrollBoxProperties: null
};

// The constructor for the dialog
/** @constructor
 *  @base tgfDialogs.Base
 */
tgfDialogs.LanguageBox = function(properties) {
	"use strict";
	this.name = "LanguageBox";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.languageBox);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.LanguageBox, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.LanguageBox.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************

// Add a component to the dialog and returns it
tgfDialogs.LanguageBox.prototype._addComponent = function(parent, Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.addComponent(comp);
	return comp;
};

tgfDialogs.LanguageBox.prototype._addScrollBoxComponent = function(parent, Component, properties, moreProperties, extraProperties){
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	this.buttonsContainer.push(comp);
};

// Add a button to the dialog and returns it
tgfDialogs.LanguageBox.prototype._addButton = function(parent, button, n, x, y, w) {
	"use strict";
	var self = this;
	return this._addScrollBoxComponent(parent, tgfComponents.ExtButton, {
			x: x, y: y, width: w/*button.sliced === undefined ? w : 0*/, height: 0,
			image: button.image === undefined ? this.buttonDefaultImage : button.image,
			text: this.availableLanguagesNames[n],//button.text === undefined ? "" : button.text,
			languageId: this.availableLanguagesId[n],//button.languageId === undefined ? "" : button.languageId, 
			dictionaryKey: button.key === undefined ? "" : button.key,
			icon: this.availableLanguagesIcons[n]/*button.icon*/, iconPosition: "left",
			font: button.font === undefined ? this.buttonDefaultFont : button.font,
			buttonId: button.id === undefined ? n : button.id,
			buttonHide: button.hide === undefined ? this.buttonDefaultHide : button.hide,
			cancelEvents: false,
			offsetYDown: 2,
			threshold: tgfScale(1.5),
			onClick: function (component) {
				if (component.buttonHide) { tgfDialogs.ButtonBox.prototype.disappear.call(self); }
				if (self.onClick) { self.onClick(self, component.buttonId); }
			}
		}, this.buttonDefaultProperties, button.properties);
};

tgfDialogs.LanguageBox.prototype.changeLanguage = function(buttonId){
		var languages = tgfDictionary.getAvailableLanguages();
		tgfDictionary.setLanguage(languages[buttonId]);
		
		this.deactivate();
		this.container.startSubEffect(2);
};

tgfDialogs.LanguageBox.prototype.initLanguages = function(){
	this.availableLanguagesId = tgfDictionary.getAvailableLanguages();
	for(var i = 0; i < this.availableLanguagesId.length; i++){
		this.availableLanguagesIcons.push(tgfDictionary.getLanguageFlag(this.availableLanguagesId[i]));
		this.availableLanguagesNames.push(tgfDictionary.getLanguageName(this.availableLanguagesId[i]));
	}
};

// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.LanguageBox.prototype.doPrepare = function() {
	"use strict";
	var self = this, i, j, n,
		blockLeft = [], blockTop = [], blockWidth = [], blockHeight = [],
		ww, hh, closeX, closeY,
		buttons, buttonLeft, buttonTop, buttonVDistance, buttonHDistance, buttonWidth, buttonHeight,
		darkener;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Determine the position and sizes of the blocks
	ww = this.width === 0 ? this.backgroundImage.width : this.width;
	hh = this.height === 0 ? this.backgroundImage.height : this.height;
	blockLeft[0] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[0] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[0] = Math.round(-hh/2 + this.marginTop);
	blockHeight[0] = Math.round(this.titlePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	blockLeft[1] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[1] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[1] = Math.round(blockTop[0] + blockHeight[0]);
	blockHeight[1] = Math.round(this.messagePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	if (this.iconImage) {
		blockWidth[2] = this.iconImage.width;
		blockLeft[2] = blockLeft[1] + blockWidth[1] - blockWidth[2];
		blockTop[2] = blockTop[1];
		blockHeight[2] = blockHeight[1];
		blockWidth[1] -= blockWidth[2] + tgfScale(32);
		if (this.iconPosition === "left") {
			blockLeft[2] = blockLeft[1];
			blockLeft[1] += blockWidth[2] + tgfScale(32);
		}
	}
	blockLeft[3] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[3] = Math.round(ww - this.marginLeft - this.marginRight);
	if (this.buttonHorizontalSize > 0) {
		blockLeft[3] = Math.round(-this.buttonHorizontalSize / 2);
		blockWidth[3] = this.buttonHorizontalSize;
	}
	blockTop[3] = Math.round(blockTop[1] + blockHeight[1]);
	blockHeight[3] = Math.round(this.buttonPercentage * (hh - this.marginTop - this.marginBottom) / 100);
	// Create the darkener
	if (this.darken) {
		darkener = this._addComponent(this, tgfComponents.Darkener, {
				width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
			}, this.darkenerProperties);
	}
	// Create the background image container
	this.container = this._addComponent(this, tgfComponents.Picture, {
			image: this.backgroundImage,
			createFromSlices: true,
			width: this.width === 0 ? this.backgroundImage.width : this.width,
			height: this.height === 0 ? this.backgroundImage.height : this.height,
			effects: [ this.appearEffect, { effect: "show", duration: this.lifeTime }, this.disappearEffect ],
			onSubEffectStart: function (component, effect) {
					if (effect === self.disappearEffect && self.darken) {
						darkener.makeLight(darkener.duration, self.container.effects[2].duration-darkener.duration);
					}
				},
			onEffectEnd: function (component) {
					self.hide();
				}
		}, this.backgroundProperties);
	if (this.disappearOnClick) {
		this.container.onTouchDown = function (component) {
				if (self.onClose) { self.onClose(self); }
				tgfDialogs.LanguageBox.prototype.disappear.call(self);
			};
	}
	// Create title
	if (this.titlePercentage) {
		this._addComponent(this.container, tgfComponents.Label, {
				x: Math.round(blockLeft[0] + blockWidth[0]/2), y: Math.round(blockTop[0] + blockHeight[0]/2),
				width: blockWidth[0], height: blockHeight[0],
				text: this.titleText, dictionaryKey: this.titleDictionaryKey,
				font: this.titleFont, fitToBox: true, splitLines: false, surfaceMargin: tgfScale(20)
			}, this.titleProperties);
	}
	// Create message
	if (this.messagePercentage) {
		this._addComponent(this.container, tgfComponents.Label, {
				x: Math.round(blockLeft[1] + blockWidth[1]/2), y: Math.round(blockTop[1] + blockHeight[1]/2),
				width: blockWidth[1], height: blockHeight[1],
				text: this.messageText, dictionaryKey: this.messageDictionaryKey,
				font: this.messageFont, fitToBox: true, splitLines: true, surfaceMargin: tgfScale(20)
			}, this.messageProperties);
	}
	// Create the icon
	if (this.messagePercentage && this.iconImage) {
		this._addComponent(this.container, tgfComponents.Picture, {
				image: this.iconImage,
				x: Math.round(blockLeft[2] + blockWidth[2]/2), y: Math.round(blockTop[2] + blockHeight[2]/2)
			}, this.iconProperties );
	}
	// Create close button
	if (this.hasCloseButton) {
		closeX = Math.round((this.width === 0 ? this.backgroundImage.width : this.width) / 2 - this.closeButtonWidth / 2);
		closeY = Math.round(-(this.height === 0 ? this.backgroundImage.height : this.height) / 2 + this.closeButtonHeight / 2);
		this._addComponent(this.container, tgfComponents.Button, {
				x: closeX, y: closeY, width: this.closeButtonWidth, height: this.closeButtonHeight,
				image: s_tgf_transparent,
				onClick: function(component) {
						if (self.onClose) { self.onClose(self); }
						tgfDialogs.ButtonBox.prototype.disappear.call(self);
					}
			}, this.closeButtonProperties);
	}
	
	//Initialize Languages before create Buttons
	this.initLanguages();
	
	// Create the buttons
	if (this.buttonPercentage) {
		if (this.buttonHorizontal) { buttons = [this.buttons]; } else { buttons = this.buttons; }
		buttonHeight = this.buttonDefaultImage.height;
		buttonVDistance = buttonHeight + this.buttonVerticalGap;
		buttonTop = Math.round(blockTop[3] + buttonHeight/2);
		switch (this.buttonVerticalAlignment) {
			case "top": break;
			case "bottom": buttonTop += blockHeight[3] - buttons.length * buttonVDistance - this.buttonVerticalGap; break;
			default: buttonTop += Math.round((blockHeight[3] - buttons.length * buttonVDistance - this.buttonVerticalGap) / 2); break;
		}
		n = 0;
		for (i = 0; i < buttons.length; i += 1) {
			if (Object.prototype.toString.call(buttons[i]) === "[object Array]") {
				buttonWidth = Math.round((blockWidth[3] - this.buttonHorizontalGap * (buttons[i].length - 1)) / buttons[i].length);
				buttonHDistance = buttonWidth + this.buttonHorizontalGap;
				buttonLeft = Math.round(blockLeft[3] + buttonWidth / 2);
				this.buttonTotalHeight += buttonVDistance + this.buttonVerticalGap;
				for (j = 0; j < buttons[i].length; j += 1) {
					this._addButton(this.container, buttons[i][j], n, buttonLeft + j * buttonHDistance, buttonTop + i * buttonVDistance, buttonWidth);
					n += 1;
				}
			} else {
				this._addButton(this.container, buttons[i], n, Math.round(blockLeft[3] + blockWidth[3] / 2), buttonTop + i * buttonVDistance, blockWidth[3]);
				n += 1;
			}
		}
	}
	
	//Create Language Scroll Box
	this._addComponent(this.container, tgfComponents.ScrollBox,{
		scrollHorizontal:false,
		areaX: 0, areaY:0, width: this.buttonScrollBoxWidth, height: this.buttonScrollBoxHeight,
		areaWidth: this.buttonDefaultImage.width,
		areaHeight: this.buttonTotalHeight,
		components: this.buttonsContainer
	}, this.scrollBoxProperties);
	
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.LanguageBox.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.container = undefined;
};
//******************************************************
//*****    Script Resource: DialogGameStart
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.dialogDefaults.gameStart = {
		
	backgroundImage: undefined,
	
	containerX: tgfScale(0),
	containerY: tgfScale(-700),
	didCompleteAnimation: false,
	
	mainLabelText: "",
	mainLabelDictionaryKey: "MAIN",
	mainLabelX: tgfScale(0),
	mainLabelY: tgfScale(-100),
	mainLabelFont: f_tgf_title,
	
	desctiptionLabelText: "",
	desctiptionLabelDictionaryKey: "Second",
	desctiptionLabelX: tgfScale(0),
	desctiptionLabelY: tgfScale(0),
	desctiptionLabelFont: f_tgf_text,
		
	appearEffect: {effect: tgfEffects.transform, duration: 1 , startY: tgfScale(-700), endY: tgfScale(0), ease: tbEase.easeOutOvershoot, easeArgument: 1.2, name: "appear"},
	disappearEffect: {effect: tgfEffects.transform, duration: 1 , startY: tgfScale(0), endY:  tgfScale(-700), ease: tbEase.easeInOvershoot, easeArgument: 1.2, name: "disappear"},
	
	components: [],					// The additional components to add
	container: [],
	
	onFinish: null
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.GameStart = function(properties) {
	"use strict";
	this.name = "GameStart";			// The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.gameStart);
	this.setProperties(tgfSettings.startPlayDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.GameStart, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************


// ***************************************
// Internal methods
// ***************************************
tgfDialogs.GameStart.prototype.disappear = function(){
	this.deactivate();
	this.containerComponent.startSubEffect(2);
};

// ***************************************
// Preparing and showing
//		- These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.GameStart.prototype.doPrepare = function() {
	"use strict";
	var i, self = this;
	this.x = tgfGraphics.mainCanvas.width/2;
	this.y = tgfGraphics.mainCanvas.height/2;
	
	this.containerComponent = new tgfComponents.Container({
		y: this.containerY,
		effects: [this.appearEffect, {effect: "show", duration: 4}, this.disappearEffect, {effect: "show", duration: 9999999999}],
		onSubEffectStart: function(components, effect){
			if(effect.name === "disappear"){
				self.didCompleteAnimation = false;
			}
		},
		onSubEffectEnd: function(components, effect){
			if(effect.name === "appear"){
				self.didCompleteAnimation = true;
			}
			if(effect.name === "disappear"){
				if(self.onFinish){ self.onFinish(self); }
			}
		}
	});
	
	this.backgroundComponent = new tgfComponents.Picture({
		image: this.backgroundImage, x: this.backgroundX, y: this.backgroundY
	});
	
	this.container.push(this.backgroundComponent);
	
	this.mainLabelComponent = new tgfComponents.Label({
		text: this.mainLabelText, dictionaryKey: this.mainLabelDictionaryKey, x: this.mainLabelX,
		y: this.mainLabelY, font_up: this.mainLabelFont
	});
	
	this.container.push(this.mainLabelComponent);
	
	this.desctiptionLabelComponent = new tgfComponents.Label({
		text: this.desctiptionLabelText, dictionaryKey: this.desctiptionLabelDictionaryKey, x: this.desctiptionLabelX,
		y: this.desctiptionLabelY, font_up: this.desctiptionLabelFont
	});
	
	this.container.push(this.desctiptionLabelComponent);
	
	for(var i = 0; i < this.container.length; i++){
		this.containerComponent.addComponent(this.container[i]);
	}
	
	this.addComponent(this.containerComponent);
	
	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.GameStart.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.backgroundComponent = undefined;
	this.mainLabelComponent = undefined;
	this.desctiptionLabelComponent = undefined;
	this.containerComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.GameStart.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the dialog
tgfDialogs.GameStart.prototype.doHide = function() {
	"use strict";
};

tgfDialogs.GameStart.prototype.handleImmediateTouchUp = function(){
	"use strict";
	if(this.didCompleteAnimation){
		this.disappear();
	}
};

//******************************************************
//*****    Script Resource: ChatDialog
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.chatDefault = {
//		tmpDiv: null,
//		viewport: null
		
};

var ChatDialog = function(){
	this.initialize();
};

ChatDialog.prototype._setProperties = function(properties) {
	"use strict";
	var property;
	if (typeof properties !== "object") { return; }
	for (property in properties) {
		if (properties.hasOwnProperty(property)) { this[property] = tgfFunctions.copyValue(properties[property]); }
	}
};

ChatDialog.prototype.initialize = function(settings){
	"use strict";
	this._setProperties(tgfSettings.chatDefault);
	this._setProperties(settings);
};

ChatDialog.prototype.makeWindow = function(){
	"use strict";
	this.tmpDiv = document.createElement("div");
	this.viewport = tgfGraphics.container;
	this.tmpDiv.id = "chatSend";
	this.viewport.appendChild(this.tmpDiv);
	
	this.tmpDiv["style"]["z-index"] = 440;
	this.tmpDiv["style"]["position"] = "absolute";
	this.tmpDiv["style"]["display"] = "block";
	this.tmpDiv["style"]["top"] = "0px";
	this.tmpDiv["style"]["left"] = "0px";
	this.tmpDiv["style"]["width"] = "300px";
	this.tmpDiv["style"]["height"] = "360px";
//	
	this.footer = document.createElement("div");
	
	this.tmpDiv.appendChild(this.footer);
	
	this.footer["class"] = "chatmain";
	
	this.footer["style"]["z-index"] = 560;
	this.footer["style"]["display"] = "block";
	
	this.textInput = document.createElement("input");
	this.textInput["class"] = "messageInput";
	this.textInput["type"] = 'text';
//	this.textInput["id"] = 'messageInput';
	this.textInput["style"]["display"] = "block";
	this.textInput["style"]["z-index"] = 570;
	this.textInput["placeholder"] = 'Type a message...';
	
	this.footer.appendChild(this.textInput);
	
	this.viewport.appendChild(this.footer);
};

//var chatDialog = new ChatDialog();
//******************************************************
//*****    Script Resource: PolyFillsExt
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

(function(){
    if(Math.sign === undefined){
        Math.sign = Math.sign || function(x) {
                x = +x; // convert to a number
                if (x === 0 || isNaN(x)) {
                    return Number(x);
                }
                return x > 0 ? 1 : -1;
            };
    }

    if (!String.format) 
    {
        String.format = function(format) 
        {
            var args = Array.prototype.slice.call(arguments, 1);

            return format.replace(/{(\d+)}/g, function(match, number) 
            { 
                return typeof args[number] != 'undefined' ? args[number] : match;
            });
        };
    }

    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function(searchString, position){
            return this.substr(position || 0, searchString.length) === searchString;
        };
    }

    if (!Array.prototype.find) 
    {
        Array.prototype.find = function(predicate) {
            if (this === null) 
            {
                throw new TypeError('Array.prototype.find called on null or undefined');
            }
            if (typeof predicate !== 'function') 
            {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(this);
            var length = list.length >>> 0;
            var thisArg = arguments[1];
            var value;

            for (var i = 0; i < length; i++) 
            {
                value = list[i];
                if (predicate.call(thisArg, value, i, list)) 
                {
                    return value;
                }
            }
            return undefined;
        };
    }   

    //implementation by MDN.
    // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex?v=example#Polyfill
    if (!Array.prototype.findIndex) {
        Array.prototype.findIndex = function(predicate) {
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }

            var o = Object(this);
            var len = o.length >>> 0;

            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }

            var thisArg = arguments[1];
            var k = 0;

            while (k < len) {
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                return k;
                }
                k++;
            }

            return -1;
        };
    }
}());


//******************************************************
//*****    Script Resource: DialogLevelMap
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.dialogDefaults.levelMap = {
	backgroundImage:  typeof s_background !== "undefined" ? s_background : undefined,
	
	levelPlacement: "manual",           // Direction of the placement of the levels  // grid: grid levels placement // manual: manual levels placement
	levelScrollDirection: "vertical",         // Scroll Direction // Available: "horizontal", "vertical"
	mode: tgfSettings.game.currentMode,
	levels: 20,
	pages: 20,
	curPage: tgfScale(0),
	pageWidth: tgfScale(0),
	hasTitle: false,
	hasTitleFixed: false,
	topMaxScroll: 0,
	maxScroll:  2.8,
	singleWorldSize: 2,
	isLocked: true,
	maxLevelPlayed: 0,
	_playSettings: null,
	hasClouds: true,
	backgroundGradient: true,
	
	// True only for test
	testLock: false,
	
	hasIndicator: true,
	indicatorImage: s_tgf_button,
	indicatorX: tgfScale(0),
	indicatorY: tgfScale(0),
	indicatorScaleUp: {effect: tgfEffects.scale, duration: 0.5, startScale: tgfScale(1), endScale: tgfScale(1.2), ease: tbEase.easeOutElastic, easeArgument: 1 },
	indicatorScaleDown: {effect: tgfEffects.scale, duration: 0.5, startScale: tgfScale(1.2), endScale: tgfScale(1), ease: tbEase.easeOutElastic, easeArgument: 1 },
	
	levelTitleImage: s_tgf_button,
	levelTitleText: ["Page 01", "Page 02", "Page 03"],
	levelTitleDictionaryKey: "",
	levelTitleX: undefined,
	levelTitleY: undefined,
	levelTitleWidth: tgfScale(300),
	levelTitleHeight: tgfScale(100),
	
	comingsoonText: "",
	comingsoonDictionaryKey: "ComingSoonText",
	comingsoonFont: f_tgf_text,
	comingsoonX: tgfScale(576),
	comingsoonY: tgfScale(-335),
	
	levelRows: tgfScale(3),
	levelCols: tgfScale(3),
	levelsPerPage: 10,
	levelOffsetX: undefined,
	levelOffsetY: undefined,
	levelButtonIcons: undefined,
	levelHasIcon: false,
	levelButtonFont: f_tgf_button,
	levelButtonFontLocked: f_tgf_button,
	levelButtonImage: [s_level2_0, s_level2_1, s_level2_2, s_level2_3, s_level2_lock],
	levelButtonHeight: tgfScale(73),
	levelButtonWidth: tgfScale(64),
	levelButtonSpacingX: tgfScale(75),
	levelButtonSpacingY: tgfScale(50),
	levelSelectedLast: tgfScale(0),
	levelLockPosition: tgfScale(4),
	levelManual: false,
	// Positions for manual level placement
	levelManualPotisions: [{x: tgfScale(-79), y: tgfScale(232)}, {x: tgfScale(-168), y: tgfScale(92)}, {x: tgfScale(-26), y: tgfScale(90)}, {x: tgfScale(96), y: tgfScale(128)},{x: tgfScale(224), y: tgfScale(130)},
							{x: tgfScale(178), y: tgfScale(-82)}, {x: tgfScale(-62), y: tgfScale(-86)}, {x: tgfScale(-275), y: tgfScale(-134)}, {x: tgfScale(-138), y: tgfScale(-244)}],
	pointerPositions:[],
	titleManualPositions: [{x: tgfScale(345), y:tgfScale(356)},{x: tgfScale(345), y:tgfScale(356)},{x: tgfScale(345), y:tgfScale(356)}],
	
	menuButtonImage: s_tgf_button,                      // Image for the menu button
	menuButtonIcon: s_tgf_icon_options,                 // Icon for the menu button
	menuButtonX: tgfScale(-300),                        // Horizontal position of the menu button
	menuButtonY: tgfScale(100),                         // Vertical position of the menu button
	menuButtonWidth: tgfScale(0),                       // Width of the menu button
	menuButtonHeight: tgfScale(0),                      // Height of the menu button
	
	//LevelMaps
	mapBackgroundImage: [s_tgf_button, s_tgf_button],
	mapBackgroundWidth: undefined,
	mapBackgroundHeight: undefined, 
	
	levelIcons:[[s_tgf_button, s_tgf_button],[s_tgf_button]],
	levelIconDepth: -1000,
	levelIconPositions: [[{x: tgfScale(500), y: tgfScale(100)},{x: tgfScale(560), y: tgfScale(100)}], [{x: tgfScale(559), y: tgfScale(100)}]],
	
	gatesComponents: [],
	gateNames: ["SPRINGFIELD", "CLAY VALLEY", "PALM BEACH", "TUNDRA TOWN"],
	gatePositions: [{x:3, y:-23},{x:17, y:-25},{x:0, y:-28},{x:10, y:-26}],
	gateFonts: [],
	
	onClick: null,
	onOptions: null,
	totalPages: [],
	components: [],                 // The additional components to add
	
	cloudComponents: [],
	
	levelMapProperties: null,
	bouncyProperties: null
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.LevelMap = function(properties) {
	"use strict";
	this.name = "LevelMap";         // The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.levelMap);
	this.setProperties(tgfSettings.levelMapProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.LevelMap, tgfDialogs.Base);


tgfDialogs.LevelMap.prototype.disappear = function(){
	"use strict";
	this.hide();
};

// ***************************************
// Specific methods for this dialog
// ***************************************
tgfDialogs.LevelMap.prototype._createImageArray = function(imageObj){
	
	var tmpImage = new tgfComponents.Picture({
		x: imageObj.x, y: imageObj.y, image: imageObj.image, layer: imageObj.layer
	});
	
	this.imageObjReady.push(tmpImage);
};

tgfDialogs.LevelMap.prototype._sortImageLayer = function(imageArray){
	
	imageArray.sort(function(a,b){ return a.layer - b.layer;});
	return imageArray;
};

tgfDialogs.LevelMap.prototype._drawImageArray = function(imageArray){
	//console.log(imageArray);
	for(var i = 0; i < imageArray.length; i++){
		this.components.push(imageArray[i]);
	}
};

tgfDialogs.LevelMap.prototype.changeMaxScroll = function(id){
	var tmpMax = this.maxScroll;
	id *= this.singleWorldSize;
	//console.log(id);
	for(var i = 0; i < id; i++){
		tmpMax += 1;
	}
	
	if(this.topMaxScroll > 0 && tmpMax > this.topMaxScroll){
		tmpMax = this.topMaxScroll;
	}
	
	if(this.manualLevelComponents){
		this.manualLevelComponents.setScrollMax(tmpMax);
	}
};

tgfDialogs.LevelMap.prototype.handleKeyDown = function(keyCode) { 
	"use strict";
	if(this.testLock){
		if(tbGame.keyboardKeyDown(tbKeyCodes.vkZ)){
			//console.log("PRESS");
			if(keyCode == tbKeyCodes.vk1){
				for(var i = 0; i < this.cloudComponents.length; i++){                   
					//this.cloudComponents[i].setMove(1);
					if(this.cloudComponents[i].id === 1){
						this.cloudComponents[i].setMove(1);
						this.gatesComponents[i].unlockGate(1);
						//this.cloudComponents[i].hide();
					}
				}
			} 
			if(keyCode == tbKeyCodes.vk2){
				for(var i = 0; i < this.cloudComponents.length; i++){                   
					//this.cloudComponents[i].setMove(1);
					if(this.cloudComponents[i].id === 2){
						this.cloudComponents[i].setMove(2);
						this.gatesComponents[i].unlockGate(2);
					}
				}
			} 
			if(keyCode == tbKeyCodes.vk3){
				for(var i = 0; i < this.cloudComponents.length; i++){
					if(this.cloudComponents[i].id === 3){
						this.cloudComponents[i].setMove(3);
					}
				}
			} 
		}
	}
};

tgfDialogs.LevelMap.prototype.cloudEvent = function(){
	"use strict";
	
	this.cloudComponents.reverse();
	var worldMaxLevels = 0, worldsUnlock = 0;
	if(this._playSettings.world){
		worldMaxLevels = this._playSettings.world.maxWorldLevel;
		for(var i = 0; i < worldMaxLevels.length; i++){
			var tmpWorldMax = worldMaxLevels[i];
			var nextLevelData = tgfStatus.getPlayData( this.mode, tmpWorldMax + 1);
			
			if(tmpWorldMax + 1 < this.maxLevelPlayed && this.maxLevelPlayed > 0){
				if(this.cloudComponents[i]){
					//this.cloudComponents[i].isShowingCloud = false;//hide();
					this.cloudComponents[i].autoHide(i + 1);
					if(this.gatesComponents[i]){
						this.gatesComponents[i].autoUnlock = true;
					}
				}
			} else {
				if(tmpWorldMax <= this.maxLevelPlayed && nextLevelData.totalPlayed > 0){
					if(this.cloudComponents[i]){
						if(nextLevelData.totalPlayed > 0){
							//this.cloudComponents[i].isShowingCloud = false;//hide();
							this.cloudComponents[i].autoHide(i + 1);
							if(this.gatesComponents[i]){
								this.gatesComponents[i].autoUnlock = true;
							}
						}
					}
				} else if(tmpWorldMax === this.maxLevelPlayed) {
					if(this.cloudComponents[i]){
						this.cloudComponents[i].setMove(i + 1);
						if(this.gatesComponents[i]){
							this.gatesComponents[i].unlockGate(i + 1);
						}
					}
				}
			}
		}
	}
};

// ***************************************
// Internal methods
// ***************************************
tgfDialogs.LevelMap.prototype._addComponent = function(parent, Component, properties, moreProperties, extraProperties){
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.components.push(comp);
};

// Add a button to the dialog and returns it
tgfDialogs.LevelMap.prototype._addButton = function(parent, Component, image, lock, n, t, x, y, w, h) {
	"use strict";
	var self = this;
	return this._addComponent(parent, tgfComponents.ExtButton, {
			x: x, y: y, width: w, height: h,
			image: image,//this.levelButtonImage[n],
			text: this.levelHasIcon ? "" : t.toString(),
			marginTop: tgfScale(-5),
			icon: this.levelButtonIcons === undefined ? null : this.levelButtonIcons[n], iconPosition: "top",
			fontUp: lock ? this.levelButtonFontLocked : this.levelButtonFont,//button.font === undefined ? this.buttonDefaultFont : button.font,
			buttonId: n,
			levelState: lock,//this.levelLockPosition === this.levels[n] ? "locked" : "",
			cancelEvents: false,
			threshold: tgfScale(1.5),
			onClick: function (component) {
				if(!this.levelState){
					if (self.onClick) { self.onClick(self, component.buttonId); }
				}
			}
		}, this.levelMapProperties);
};

tgfDialogs.LevelMap.prototype.initLevels = function(){
	var self = this, levelMapSettings = new levelSettings();
	var gateCounter = 0;
	var gateNameCounter = 0;
	var levelWorlds = levelMapSettings.levelmap.order;
	this._playSettings = playSettings();
	this.levels = this._playSettings.levels.length;
	var lastLevelPlayed = 1, curImage,
	globalStatus, curLevelStatus;
	
	globalStatus = tgfStatus.getGlobalData();
	
	lastLevelPlayed = globalStatus.lastLevelPlayed;
	this.maxLevelPlayed = globalStatus.maxLevelWon;
	
	if(this.levelTitleX === undefined){ this.levelTitleX = tbGraphics.width / 2;}
	if(this.levelTitleY === undefined){ this.levelTitleY = tbGraphics.height / 8;}
	if(this.mapBackgroundWidth == undefined){ this.mapBackgroundWidth = tbGraphics.width; }
	if(this.mapBackgroundHeight == undefined){ this.mapBackgroundHeight = tbGraphics.height; }
	
	switch(this.levelPlacement){
	case "grid":
		this.pages = Math.ceil(this.levels / (this.levelRows * this.levelCols));
		var levelLength = this.levelButtonWidth * this.levelCols + this.levelButtonSpacingX * (this.levelCols -2);
		var levelHeight = this.levelButtonWidth * this.levelRows + this.levelButtonSpacingY * (this.levelRows -1);
		
		for(var p = 0; p < this.pages; p++){
			var curPage = new tgfComponents.Container({});
			
			if(this.hasTitle && !this.hasTitleFixed){
				
				var curTitle = new tgfComponents.Container({});
				
				var levelTitleComponents = new tgfComponents.Picture({
					image: this.levelTitleImage, x: this.levelTitleX , y: this.levelTitleY, width: this.levelTitleWidth, height: this.levelTitleHeight
				});
				
				var levelTitleImageComponents = new tgfComponents.Label({
					text: this.levelTitleText[p], x: this.levelTitleX, y:  this.levelTitleY, width: this.levelTitleWidth, height: this.levelTitleHeight
				});
				
				curTitle.components.push(levelTitleComponents);
				curTitle.components.push(levelTitleImageComponents);
				
				curPage.components.push(curTitle);
			}
			
			var offsetX = this.levelOffsetX === undefined ? (tbGraphics.width - levelLength) / 2 : this.levelOffsetX;
			var offsetY = this.levelOffsetY === undefined ?  200 : this.OffsetY;
			
			for(var i = 0; i < this.levelRows; i++){
				for(var j = 0; j < this.levelCols; j++){
					
					var levelNumber = i * this.levelCols + j + p * (this.levelRows * this.levelCols);   // Level refering to
					
					curLevelStatus = tgfStatus.getPlayData(this.mode, levelNumber);
					this.levelSelected = lastLevelPlayed;
					
					if((levelNumber + 1) === lastLevelPlayed){this.curPage = p;}                 // Page of last selected level
					
					if(levelNumber === this.levels){                                                    // If levels are uneven, the remaining ones will be passed to the last page
						this.totalPages.push(curPage);
						return;
					}
					
					var x = offsetX + j * (this.levelButtonWidth + this.levelButtonSpacingX);
					var y = offsetY + i * (this.levelButtonHeight + this.levelButtonSpacingY);
					
					var levelText = levelNumber + 1;
					if(!curLevelStatus.isUnlocked){
						curImage = this.levelButtonImage[4];
						levelText = "";
					} else {
						curImage = this.levelButtonImage[curLevelStatus.maxStars];
					}
					
					this._addButton(curPage ,this.levelMapComponents, curImage, curLevelStatus.isUnlocked, levelNumber, levelText, x, y, this.levelButtonWidth, this.levelButtonHeight);
				}
			}
			this.totalPages.push(curPage);
		}
		
		break;
	case "manual":
		var levelLength = this.levelButtonWidth * this.levelCols + this.levelButtonSpacingX * (this.levelCols -1);
		var levelHeight = this.levelButtonWidth * this.levelRows + this.levelButtonSpacingY * (this.levelRows-1);
		var pageIndicator = false;
		var backgroundOffsetX = tbGraphics.width / 2;
		var backgroundOffsetY = tbGraphics.height / 2;
		
		this.pages = levelWorlds.length;
		
		var _levelMapExtra = new levelMapExtra();
		var totalWorlds = this.pages / this.singleWorldSize;
		//this.pointerPositions = _levelMapExtra.levelmap["page"].test;
		this.pointerPositions = _levelMapExtra.levelmap["page"].coordinatesAnimation;
		this.yInterps         = _levelMapExtra.levelmap["page"].yInterps;
		if(_levelMapExtra){
			this.levelManualPotisions = [];
			for(var i = 0; i < totalWorlds; i++){
				for(var j = 0; j < _levelMapExtra.levelmap["page"].coordinates.length; j++){
					this.levelManualPotisions.push(_levelMapExtra.levelmap["page"].coordinates[j]);
				}
			}
		}
		
		var pageContainer = [];
		
		for(var i = 0; i < this.pages; i++){
			var curPage = new tgfComponents.Container({});
			var _levelArray = levelMapSettings.levelmap[levelWorlds[i]].items;
			for(var j = 0; j < _levelArray.length; j++){
				if(_levelArray[j].id === "background"){
					if(this.backgroundGradient){
						var decall = new tgfComponents.Picture({
							image: _levelArray[j].image, x: backgroundOffsetX, y: backgroundOffsetY,
							createFromSlices: true, combineSubImages: true, width: this.mapBackgroundWidth, height: this.mapBackgroundHeight
						});
						curPage.components.push(decall);
					} else {
						var decall = new tgfComponents.Picture({
							image: _levelArray[j].image, x: backgroundOffsetX, y: backgroundOffsetY,
							createFromSlices: false, combineSubImages: true, width: this.mapBackgroundWidth, height: this.mapBackgroundHeight
						});
						curPage.components.push(decall);
					}
				}
			}
			
			pageContainer[i] = curPage;
		}
		
		for(var p = 0; p < pageContainer.length; p++){          
			
			var levelArray = levelMapSettings.levelmap[levelWorlds[p]].items;
			
			levelArray = this._sortImageLayer(levelArray);
			
			var decallTest = new tgfComponents.Decalls({
				id: p,
				decallList: levelArray
			});
			
			pageContainer[p].components.push(decallTest);
			
			
			//Place Decalls
			for(var i = 0; i < levelArray.length; i++){
				if(levelArray[i].id !== "background"){
//                  var decall = new tgfComponents.Picture({
//                      image: levelArray[i].image, x: levelArray[i].x, y: levelArray[i].y
//                  });
//                  pageContainer[p].components.push(decall);
					
					if(levelArray[i].id === "gate"){
//                      var curPosX = this.gatePositions[gateNameCounter].x + (tgfGraphics.width / 2);
//                      var curPosY = this.gatePositions[gateNameCounter].y + (tgfGraphics.height / 2);
//                      var gateText = new tgfComponents.Label({
//                          x: curPosX,
//                          y: curPosY,
//                          text: this.gateNames[gateNameCounter],
//                          font: this.gateFonts[gateNameCounter]
//                      });
//                      gateText.activate();
//                      //decall.components.push(gateText);
//                      decallTest.components.push(gateText);
						gateNameCounter++;
						if(gateCounter !== 0){
							var tmpContainer = new tgfComponents.Container({});
							var tmpGate = new tgfComponents.ComponentGate({
								id: gateCounter,
								position:{x: 577 , y: 540}
							});
							this.gatesComponents.push(tmpGate);
							tmpContainer.addComponent(tmpGate);
							pageContainer[p].components.push(tmpContainer);
						}
						gateCounter++;
					}
				}
			}
			
			
			if(this.hasTitle){
				var curTitle = new tgfComponents.Container({});
				
				var levelTitleComponents = new tgfComponents.Picture({
					image: this.levelTitleImage, x: this.titleManualPositions[p].x , y: this.titleManualPositions[p].y, width: this.levelTitleWidth, height: this.levelTitleHeight
				});
				
				var levelTitleImageComponents = new tgfComponents.Label({
					text: this.levelTitleText[p], x: this.titleManualPositions[p].x , y: this.titleManualPositions[p].y, width: this.levelTitleWidth, height: this.levelTitleHeight
				});
				
				curTitle.components.push(levelTitleComponents);
				curTitle.components.push(levelTitleImageComponents);
				
				pageContainer[p].components.push(curTitle);
			}
			
			var specialContainer = new tgfComponents.Container({
				x: backgroundOffsetX, y: backgroundOffsetY
			});
			
			
			
			for(var i = 0; i < this.levelsPerPage; i++){
				
				var levelNumber = i + p * this.levelsPerPage;                                       // Level refering to
				
				curLevelStatus = tgfStatus.getPlayData( this.mode, levelNumber + 1);
				
				 // Page of last selected level
				if(levelNumber + 1 === 2 && !curLevelStatus.unlocked){
//                  this.curPage = p;
					this.indicatorX = this.levelManualPotisions[levelNumber - 1].x;
					this.indicatorY = this.levelManualPotisions[levelNumber - 1].y;
//                  if(this.indicatorY < -100){ this.curPage += 0.4; }
					pageIndicator = true;
				}
				
				if(curLevelStatus.unlocked && curLevelStatus.maxScore < 1){
					this.curPage = p;
					this.indicatorX = this.levelManualPotisions[levelNumber].x;
					this.indicatorY = this.levelManualPotisions[levelNumber].y;
					if(this.indicatorY < -100){ this.curPage += 0.2; }
					pageIndicator = true;
				}
				
				
				var x = this.levelManualPotisions[levelNumber].x;
				var y = this.levelManualPotisions[levelNumber].y;
				
				if(this._playSettings.levels[levelNumber]){
					if(_levelMapExtra.buttons[this._playSettings.levels[levelNumber].general.mode].images !== undefined){
						this.levelButtonImage = _levelMapExtra.buttons[this._playSettings.levels[levelNumber].general.mode].images;
					}
					//console.log(this.levelButtonImage);
				}
				
				var levelText = levelNumber + 1;
				
				if(!this.testLock){
					if(!curLevelStatus.unlocked && levelNumber > 0){
						curImage = this.levelButtonImage[4];
						this.isLocked = true;
						this.levelButtonWidth = curImage.width;
						this.levelButtonHeight = curImage.height;
						//levelText = "";
					} else {
						this.isLocked = false;
						curImage = this.levelButtonImage[curLevelStatus.maxStars];
						this.levelButtonWidth = curImage.width;
						this.levelButtonHeight = curImage.height;
					}
				} else {
					this.isLocked = false;
					curImage = this.levelButtonImage[curLevelStatus.maxStars];
					this.levelButtonWidth = curImage.width;
					this.levelButtonHeight = curImage.height;
				}
				levelNumber += 1;
				
				this._addButton(specialContainer, this.levelMapComponents, curImage, this.isLocked, levelNumber, levelText, x, y, this.levelButtonWidth, this.levelButtonHeight);
			}
			
			if(this.hasIndicator && pageIndicator){
//              var path = new pathfinding.Pathfinding(s_animation_icecreamtruck, this.pointerPositions, this.yInterps);
//              specialContainer.components.push(path);
				
				var indicator = new tgfComponents.Picture({
					image: this.indicatorImage, x: this.indicatorX - 4, y: this.indicatorY - 117
					//effects: [this.indicatorScaleUp, this.indicatorScaleDown]
				});
				specialContainer.components.push(indicator);
		
				
				pageIndicator = false;
			}
		
			pageContainer[p].components.push(specialContainer);
			
			this.totalPages.push(pageContainer[p]);
		}
		break;
	}
};

// ***************************************
// Preparing and showing
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.LevelMap.prototype.doPrepare = function() {
	"use strict";
	var self = this, i, counter = 0;
	
	//Initializing the levels
	this.initLevels();
	
	switch(this.levelPlacement){
		case "grid":
			if(this.levelScrollDirection === "horizontal"){
				
				if(this.hasTitle && this.hasTitleFixed){
					this.levelTitleComponents = new tgfComponents.Picture({
						image: this.levelTitleImage, x: this.levelTitleX , y: this.levelTitleY, width: this.levelTitleWidth, height: this.levelTitleHeight
					});
					
					this.levelTitleImageComponents = new tgfComponents.Label({
						text: this.levelTitleText[0], x: this.levelTitleX, y: this.levelTitleY, width: this.levelTitleWidth, height: this.levelTitleHeight,
						textArray: this.levelTitleText
					});
				}
				
				this.bouncyComponents = new tgfComponents.BouncingExt({
					y:0,
					outOfBoundsDamp: 2.0,
					elementWidth: tgfScale(tbGraphics.width),
					accel: 25,
					damp:  4,
					axis: new tbVector(1,0),
					titlePicture: this.levelTitleComponents,
					titleComponent: this.levelTitleImageComponents
				});
			}else if(this.levelScrollDirection === "vertical"){
				this.bouncyComponents = new tgfComponents.BouncingExt({
					y:0,
					outOfBoundsDamp: 2.0,
					elementWidth: tgfScale(tbGraphics.height),
					accel: 25,
					damp:  4,
					axis: new tbVector(0,1)
				});
			}
			
			for(var i = 0; i < this.totalPages.length; i++){
				this.bouncyComponents.addElement(this.totalPages[i]);
			}
			this.bouncyComponents.snapToIndex(this.curPage);
			this.addComponent(this.bouncyComponents);
			
			break;
		case "manual":
			if(this.levelScrollDirection === "horizontal"){
				this.manualLevelComponents = new tgfComponents.MapScroll({
					y:0,
					outOfBoundsDamp: 10000.0,
					elementWidth: this.mapBackgroundWidth,
					accel: 25,
					damp:  4,
					axis: new tbVector(1,0)
				});
				for(var i = this.totalPages.length -1; i > -1; i--){
					this.manualLevelComponents.addElement(this.totalPages[i]);
				}
			} else if(this.levelScrollDirection === "vertical"){
				this.manualLevelComponents = new tgfComponents.MapScroll({
					y:0,
					outOfBoundsDamp: 10000.0,
					elementWidth: tgfScale(tbGraphics.height),
					accel: 25,
					damp:  4,
					axis: new tbVector(0,-1)
				});
				if(this.hasClouds){
					for(var i = this.totalPages.length - 1; i > -1; i--){
						var cloudComponent = new tgfComponents.ComponentCloud({
							onMoveUpComplete: function(id){
								self.changeMaxScroll(id);
								//self.gatesComponents[id - 1].unlockGate(id);
							}
						});
						
						if(counter == this.singleWorldSize){
							cloudComponent.id = (i + 1) / this.singleWorldSize;
							this.cloudComponents.push(cloudComponent);
							this.totalPages[i].components.push(cloudComponent);
							
							if(i === this._playSettings.world.maxWorldLevel.length + this.singleWorldSize){
								var comingSoon = new tgfComponents.Label({
									text: this.comingsoonText,
									dictionaryKey: this.comingsoonDictionaryKey, font: this.comingsoonFont,
									x: this.comingsoonX, y: this.comingsoonY
								});
								this.totalPages[i].components.push(comingSoon);
							}
							
							counter = 0;
						}
						counter ++;
						
						this.manualLevelComponents.addElementAtIndex(this.totalPages[i], i);
					}
				}
			}
			this.topMaxScroll = this.totalPages.length;
			this.manualLevelComponents.snapToIndex(this.curPage);
			this.manualLevelComponents.setScrollMax(this.maxScroll);
			//console.log(this.manualLevelComponents);
			this.addComponent(this.manualLevelComponents);
			
			break;
	}
	
var tmpAnchor = new tgfComponents.AnchorComponent({ });
	
	// Create the menu button
	this.optionButtonComponents = new tgfComponents.Button( {
			image: this.menuButtonImage,
			x: this.menuButtonX, y: this.menuButtonY, width: this.menuButtonWidth, height: this.menuButtonHeight,
			touchMargin: tgfScale(30),
			onClick: function (component) {
					if (self.onOptions) { self.onOptions(self); }
					else{}
			}
		} );
	this.optionButtonComponents.setProperties(this.optionButtonComponents);
	tmpAnchor.addComponent(this.optionButtonComponents)
	
	this.addComponent(tmpAnchor);
	//////
//  this.optionButtonComponents = new tgfComponents.Button({
//      image: s_tgf_button , //icon: s_tgf_icon_options, iconPosition: "center",
//      x: tgfScale(76), y: tgfScale(576), width: tgfScale(100), height: tgfScale(100),
//      onClick: function(component){
//          if(self.onOptions){self.onOptions(self);}
//          else{
//          }
//      }
//  });
//  
//  this.addComponent(this.optionButtonComponents);
	//////
	
	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.LevelMap.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.levelMapComponents = undefined;
	this.bouncyComponents = undefined;
	this.manualLevelComponents = undefined;
	this.levelTitleComponents = undefined;
	this.levelTitleImageComponents = undefined;
	this.optionButtonComponents = undefined;
	this.gateProperties = undefined;
};

// Processing required when showing the dialog
tgfDialogs.LevelMap.prototype.doShow = function() {
	"use strict";
	this.cloudEvent();
	if (this.backgroundImage) {
		tbGraphics.setCanvas(tgfGraphics.backgroundCanvas);
		this.backgroundImage.drawCombinedSimple(0, 0);
		tbGraphics.setCanvas(tgfGraphics.mainCanvas);
	}
	
//  if(this.hasClouds){
//      this.cloudEvent();
//  }
};

tgfDialogs.LevelMap.prototype.onActivate = function(){
	"use strict";
	this.cloudEvent();
};

// Processing required when hiding the dialog
tgfDialogs.LevelMap.prototype.doHide = function() {
	"use strict";
};



//******************************************************
//*****    Script Resource: AdDialogStage
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.dialogDefaults.adDialogStage = {
	backgroundImage: null,
	depth: -5,

	rewardCount: 0,
	
	frameLabelFont: f_tgf_button,

	frameImage: s_dialog_load_frame,
	frameX: tgfScale(0),
	frameY: tgfScale(0),
	frameWidth: tgfScale(480),
	frameHeight: tgfScale(480),
	frameScaleUp: {effect: tgfEffects.scaleXY, duration: 0.4, startScaleX: 1, endScaleX: 1.8, startScaleY: 1, endScaleY: 1.3, ease: tbEase.easeLinear, name: "frameScale"},
	frameAppear: {effect: tgfEffects.move, duration: 1, startY: tgfScale(-1500), endY: tgfScale(0), ease: tbEase.easeLinear, easeArgument: 1.2, name: "frameAppear"},
	frameDisappear: {effect: tgfEffects.move, duration: 1, startY: tgfScale(0), endY: tgfScale(-1500), ease: tbEase.easeLinear, easeArgument: 1.2},
	
	blackFrameImage: blackAdFrame,
	blackFrameX: tgfScale(0),
	blackFrameY: tgfScale(-61),
	blackFrameWidth: tgfScale(470),
	blackFrameHeight: tgfScale(450),

	playButtonImage: s_dialog_load_btn_load,
	playButtonX: tgfScale(0),
	playButtonY: tgfScale(138),
	playButtonWidth: tgfScale(96),
	playButtonHeight: tgfScale(96),
	playButtonElastic: {effect: tgfEffects.popElastic, duration: 4, startScaleX: 1, endScaleX: 1.25, startScaleY: 1, endScaleY: 0.9, easeArgument: 1, name: "elastic"},
	playButtonAppear: {effect: tgfEffects.scale, duration: 0.5, startScale: tgfScale(0), endScale: tgfScale(1), ease: tbEase.easeOutElastic, easeArgument: 1 },
	playButtonDisappear: {effect: tgfEffects.alpha, startAlpha: tgfScale(1), endAlpha: tgfScale(0), duration: 10, ease: tbEase.easeLinear, name: "hide"},

	gameLogoImage: typeof s_title_gamelogo !== "undefined" ? s_title_gamelogo : undefined,
	gameLogoX: tgfScale(-320),
	gameLogoY: tgfScale(220),
	gameLogoWidth: tgfScale(280),
	gameLogoHeight: tgfScale(160),
	gameLogoReposition: {effect: tgfEffects.transform, duration: 0.4, startX: this.gameLogoX, startY: this.gameLogoY, endX: tgfScale(-300), endY: tgfScale(230), startScale: 1, endScale: 0.6},

	progressBarDisappear: {effect: tgfEffects.alpha, duration: 0.2, startAlpha: 1, endAlpha: 0, name: "endBar"},

	onClick: null,
	onPlay: null,
	onAdFinish: null,
	onAdFail: null,

	playButtonProperties:null,
	gameLogoProperties:null,
	frameProperties: null,
	blackFrameProperties: null,
	progressBarProperties: null,

	//Ads props
	viewport: undefined,

	adWindowX: 0,
	adWindowY: 150,
	adSizeWidth: undefined,
	adSizeHeight: undefined,
	haveAd: false,
	doPlay: true,
	getTimer: false,
	provider: "none",				//Ad provider "none","google", "poki", "woobi"
	hasFrame: false,
	isMobile: false,
	//onClick: null,
	onNext: null,

    components: []                  // The additional components to add
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.AdDialogStage = function(properties) {
    "use strict";
    this.name = "AdDialogStage";         // The name of the dialog
    // Initialize properties
    this.initialize(tgfSettings.dialogDefaults.adDialogStage);
    // Set user properties
    if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.AdDialogStage, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************


// ***************************************
// Internal methods
// ***************************************
//tgfDialogs.AdDialog.prototype.disappear = function() {
//
//};

tgfDialogs.AdDialogStage.prototype.create = function(){
	"use strict";
	tgfAds._createContainer(this.provider, this.getDisplayLeft(), this.getDisplayTop(), this.getDisplayWidth(), this.getDisplayHeight());
	tgfAds._onResize(this.onResize, this);
};

tgfDialogs.AdDialogStage.prototype.onResize = function(base){
	"use strict";
	var scale = base.viewport.clientWidth / tgfGraphics.visibleWidth;

	var ww = base.getDisplayWidth();
	var hh = base.getDisplayHeight();
	var width = Math.round(ww * scale);
	var height = Math.round(hh * scale);

	var ll = base.getDisplayLeft();
	var tt = base.getDisplayTop();

	var top = Math.round((tt  - tgfGraphics.visibleTop) * scale) + "px";
	var left = Math.round((ll - tgfGraphics.visibleLeft) * scale) + "px";

	tgfAds.doResize(base.provider, left, top, width, height);
};

tgfDialogs.AdDialogStage.prototype.getDisplayWidth = function(){
	"use strict";
	return this.adSizeWidth - tgfScale(32) - tgfScale(32);
};

tgfDialogs.AdDialogStage.prototype.getDisplayHeight = function(){
	"use strict";
	return this.adSizeHeight - tgfScale(32) - tgfScale(96 + 60);
};

tgfDialogs.AdDialogStage.prototype.getDisplayLeft = function(){
	"use strict";
	return this.adWindowY + tgfScale(32);
};

tgfDialogs.AdDialogStage.prototype.getDisplayTop = function(){
	"use strict";
	return this.adWindowX + tgfScale(32);
};

tgfDialogs.AdDialogStage.prototype.adPrepare = function(){
	"use strict";
	if(this.playButtonComponent) {
		this.playButtonComponent.startSubEffect(3);
	}
};

tgfDialogs.AdDialogStage.prototype.adShow = function(){
	"use strict";
	if(this.frameComponent) {
		this.containerComponent.startSubEffect(1);
		this.gameLogoComponent.startSubEffect(1);
	} else {
		console.log("adDialogStage " + this.provider);
		tgfAds.showAds(this.provider);
	}
};

tgfDialogs.AdDialogStage.prototype.adCompleted = function(){
	"use strict";
	this.deactivate();
	if(this.frameComponent) {
		this.containerComponent.startSubEffect(2);
	} else {
		this.hide();
	}
	if(this.provider !== "none"){
		//this.progressBarComponent.startSubEffect(1);
	}

	if(this.onComplete) {
		this.onComplete(this.rewardCount);
	}
};

tgfDialogs.AdDialogStage.prototype.noAds = function(){
	"use strict";
	if(this.frameComponent) {
		this.containerComponent.startSubEffect(2);
	}
	if(this.playButtonComponent) {
		this.playButtonComponent.startSubEffect(3);
	}
};

tgfDialogs.AdDialogStage.prototype.adFailed = function(){
	"use strict";
	this.deactivate();
	if(this.frameComponent) {
		this.containerComponent.startSubEffect(2);
	} else {
		this.hide();
	}
	if(this.provider !== "none"){
		//this.progressBarComponent.startSubEffect(1);
	}
};

tgfDialogs.AdDialogStage.prototype.createProgress = function() {
	"use strict";
	var self = this;

//	var ad = new tgfComponents.Ad({baseDialog: self});
//	this.addComponent(ad);
//	ad.activate();
//	ad.show();

//	this.progressBarComponent = new tgfComponents.ProgressBar({
//		x: tgfScale(200), y: tgfScale(300), width: tgfScale(500),
//		effects: [{effect:"show", duration: 99999999}, this.progressBarDisappear],
//		onSubEffectEnd: function(component, effect){
//			if(effect.name === "endBar"){
//				self.progressBarComponent.hide();
//			}
//		}
//	});
//
//	this.progressBarComponent.setProperties(this.progressBarProperties);
//	this.addComponent(this.progressBarComponent);
//	this.progressBarComponent.activate();
//	this.progressBarComponent.show();
};

tgfDialogs.AdDialogStage.prototype.renewProgressBar = function(prog){
	"use strict";
	if(this.progressBarComponent !== undefined){
		this.progressBarComponent.setProgress(prog, false);
	}
};

tgfDialogs.AdDialogStage.prototype.completeProgressBar = function(){
	"use strict";
	if(this.progressBarComponent !== undefined){
		this.progressBarComponent.setProgress(100, true);
	}
};

// ***************************************
// Preparing and showing
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.AdDialogStage.prototype.doPrepare = function() {
    "use strict";
    var i, self = this;
    this.x = tgfGraphics.mainCanvas.width/2;
	this.y = tgfGraphics.mainCanvas.height/2;
	
	//if(!tgfAds.adsAvailable(this.provider)){
	//	tgfAds.adCompleted();
	//	this.hide();
	//	return;
	//}

	if(this.adSizeWidth === undefined){ this.adSizeWidth = tgfGraphics.safeZoneWidth; }
    if(this.adSizeHeight === undefined){ this.adSizeHeight = tgfGraphics.visibleHeight; }
    this.viewport = tgfGraphics.container;
	//this.create();
	//this.hasFrame = tgfAds.hasFrame;
	this.isMobile  = tgfAds.isMobile;

	this.containerComponent = new tgfComponents.Container({});
	if(this.isMobile){
		switch(this.provider){
		case "admob":
			tgfAds.makeAdMobContainer();
			break;
		case "chartboost":
			tgfAds.makeChartboostContainer();
			break;
		}
	}

	if(this.hasFrame){

		var darkener = new tgfComponents.Darkener({
			width: this.width,
			height: this.height
		});

		this.addComponent(darkener);
		
		this.containerComponent = new tgfComponents.Container({
			y: tgfScale(0),x: tgfScale(0),
			effects: [self.frameAppear, {effect: "show", duration: 99999999}, {effect: "show", duration: 1},  self.frameDisappear],
			onSubEffectEnd: function(components, effect){
				if(effect.name === "frameAppear"){
					tgfAds.showAds(self.provider);
				}
			},
			onEffectEnd: function(components){
				self.hide();
			}
		});

		this.frameComponent = new tgfComponents.Picture({
			image: this.frameImage, x: this.frameX, y: this.frameY, width: this.frameWidth, height: this.frameHeight,
			createFromSlices: true,
			xScale: 1.8, yScale: 1.3
//			effects: [this.frameAppear, {effect: "show", duration: 99999999}, this.frameDisappear],
//			onSubEffectEnd: function(components, effect){
//				if(effect.name === "frameAppear"){
//					tgfAds.showAds(self.provider);
//				}
//			},
//			onEffectEnd: function(components){
//				self.hide();
//			}
		});

		this.frameComponent.setProperties(this.frameProperties);
		this.containerComponent.addComponent(this.frameComponent);
		
		var blackFrame = new tgfComponents.Picture({
			image: this.blackFrameImage, x: this.blackFrameX, y:this.blackFrameY, height: this.blackFrameHeight,
			width: this.blackFrameWidth, xScale: 1.74, yScale: 1
		});
		
		this.containerComponent.addComponent(blackFrame);

		this.gameLogoComponent = new tgfComponents.Picture({
			image: this.gameLogoImage, x: this.gameLogoX, y: this.gameLogoY,
			width: this.gameLogoWidth, height: this.gameLogoHeight,
			xScale: 0.6, yScale: 0.6
			//effects: [{effect: "show", duration: 99999999}, this.gameLogoReposition,{effect: "show", duration: 99999999}]
		});
		this.gameLogoComponent.setProperties(this.gameLogoProperties);
		this.containerComponent.addComponent(this.gameLogoComponent);
		
		var loadingLabel = new tgfComponents.Label({
			dictionaryKey: ""/*"is continuing in"*/, x: tgfScale(-137), y: tgfScale(232),
			fontUp: this.frameLabelFont, width: tgfScale(200), height: tgfScale(100)
		});
		
		this.containerComponent.addComponent(loadingLabel);

		this.progressBarComponent = new tgfComponents.ProgressBar({
			x: tgfScale(200), y: tgfScale(230), width: tgfScale(400),
			effects: [{effect:"show", duration: 99999999}, this.progressBarDisappear],
			onSubEffectEnd: function(component, effect){
				if(effect.name === "endBar"){
					self.progressBarComponent.hide();
				}
			}
		});

		this.progressBarComponent.setProperties(this.progressBarProperties);
		this.containerComponent.addComponent(this.progressBarComponent);

		this.playButtonComponent = new tgfComponents.Button({
			image: this.playButtonImage, x: this.playButtonX, y: this.playButtonY,
			width: this.playButtonWidth, height: this.playButtonHeight,
			effects: [this.playButtonAppear ,this.playButtonElastic, {effect: "show", duration: 99999999}, this.playButtonDisappear],
			onClick: function(components){
				self.doPlay = true;

				if(!self.isMobile && self.provider === "none"){
					self.noAds();
				} else if(!self.isMobile || self.provider !== "none"){
					if(self.onPlay){ self.onPlay(self);}
					else{
						self.adPrepare();
					}
				} else {
					self.adCompleted();
					tgfAds.showAds(self.provider);
				}
			},
			onSubEffectEnd: function(components, effect){
				if(effect.name === "elastic"){self.playButtonComponent.startSubEffect(1);}
				if(effect.name === "hide"){
					self.playButtonComponent.hide();
				}
			}
		});
//		this.playButtonComponent.setProperties(this.playButtonProperties);
//		container.addComponent(this.playButtonComponent);
		this.addComponent(this.containerComponent);
	}else{
		var darkener = new tgfComponents.Darkener({
			width: this.width,
			height: this.height
		});

		this.addComponent(darkener);
	}

	if (this.components) {
        for (i = 0; i < this.components.length; i += 1) {
            this.addComponent(this.components[i]);
        }
    }
	
	tgfAds.setAdTimer();
};

// Processing required when freeing the dialog from use
tgfDialogs.AdDialogStage.prototype.doFree = function() {
    "use strict";
    this.removeAllComponents();
    this.playButtonComponent = undefined;
    this.frameComponent = undefined;
    this.gameLogoComponent = undefined;
    this.blackFrameComponent = undefined;
    this.progressBarComponent = undefined;

    this.containerComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.AdDialogStage.prototype.onShow = function() {
	"use strict";
	// Draw the background on the background canvas
	if (this.backgroundImage) {
		tbGraphics.setCanvas(tgfGraphics.backgroundCanvas);
		this.backgroundImage.drawCombinedSimple(0, 0);
		tbGraphics.setCanvas(tgfGraphics.mainCanvas);
	}
	tgfAds.userTouch = false;
	tgfAds.pokiAdsReady = false;
	tgfAds.initContainer();
};

tgfDialogs.AdDialogStage.prototype.handleSpecial = function(id, args){
	"use strict";
	if(id === "Ad Failed"){
		if(this.doPlay){this.adFailed();}
		console.log(args.error);
	} else if(id === "Ad Completed"){
		if(this.doPlay){this.adCompleted();}
		console.log("Did Complete");
	} else if(id === "Ad Reward"){
		console.log(args._reward);
		this.rewardCount++;
		if(testMode) { console.log("Did Reward"); }
	}
};

tgfDialogs.AdDialogStage.prototype.handleEndStep = function(timePassed) {
	"use strict";
	tgfDialogs.AdDialog.uber.handleEndStep.call(this, timePassed);
	if(!this.haveAd && this.doPlay){
		if(tgfAds.adsAvailable(this.provider)){
			this.adShow();
			//this.createProgress();
			this.getTimer = true;
			this.haveAd = true;
		}
	}

	if(this.getTimer){
			if(this.progressBarComponent !== undefined && tgfAds.getTimer(this.provider, timePassed) > 0){
				this.progressBarComponent.setProgress(tgfAds.getTimer(this.provider, timePassed), false);
			}
//		console.log(tgfAds.getTimer(this.provider));
	}
};

// Processing required when hiding the dialog
tgfDialogs.AdDialogStage.prototype.doHide = function() {
    "use strict";

};

// Events shall not pass.
tgfDialogs.AdDialogStage.prototype.handleTouchDown = function(touch,x,y) {
	"use strict";
	tgfDialogs.AdDialog.uber.handleTouchDown.call(this, touch, x, y);
	return true;
};

tgfDialogs.AdDialogStage.prototype.handleImmediateTouchUp = function(){
	"use strict";
	//tgfAds.initContainer();
};
//******************************************************
//*****    Script Resource: AdDialog
//******************************************************

/* global
	tgfAds,
	audioController
*/

tgfSettings.dialogDefaults.adDialog = {
	backgroundImage: null,
	depth: -5,

	rewardCount: 0,

	frameImage: s_dialog_load_frame,
	frameX: tgfScale(0),
	frameY: tgfScale(0),
	frameWidth: tgfScale(480),
	frameHeight: tgfScale(480),
	frameScaleUp: {effect: tgfEffects.scaleXY, duration: 0.6, startScaleX: 1, endScaleX: 1.8, startScaleY: 1, endScaleY: 1.3, ease: tbEase.easeLinear, name: "frameScale"},
	frameDisappear: {effect: tgfEffects.move, duration: 1, startY: tgfScale(-100), endY: tgfScale(-1500), ease: tbEase.easeLinear, easeArgument: 1.2},
	
	blackFrameImage: blackAdFrame,
	blackFrameX: tgfScale(0),
	blackFrameY: tgfScale(-50),
	blackFrameWidth: tgfScale(250),
	blackFrameHeight: tgfScale(550),
	
	playButtonImage: s_dialog_load_btn_load,
	playButtonX: tgfScale(0),
	playButtonY: tgfScale(80),
	playButtonWidth: tgfScale(154),
	playButtonHeight: tgfScale(152),
	playButtonElastic: {effect: tgfEffects.popElastic, duration: 4, startScaleX: 1, endScaleX: 1.25, startScaleY: 1, endScaleY: 0.9, easeArgument: 1, name: "elastic"},
	playButtonAppear: {effect: tgfEffects.scale, duration: 0.5, startScale: tgfScale(0), endScale: tgfScale(1), ease: tbEase.easeOutElastic, easeArgument: 1 },
	playButtonDisappear: {effect: tgfEffects.alpha, startAlpha: tgfScale(1), endAlpha: tgfScale(0), duration: 10, ease: tbEase.easeLinear, name: "hide"},

	gameLogoImage: typeof s_title_gamelogo !== "undefined" ? s_title_gamelogo : undefined,
	gameLogoX: tgfScale(0),
	gameLogoY: tgfScale(-115),
//	gameLogoWidth: tgfScale(250),
//	gameLogoHeight: tgfScale(250),
	gameLogoWidth: tgfScale(417),
	gameLogoHeight: tgfScale(219),
	gameLogoReposition: {effect: tgfEffects.transform, duration: 0.6, startX: this.gameLogoX, startY: this.gameLogoY, endX: tgfScale(-300), endY: tgfScale(230), startScale: 1, endScale: 0.6},
	
	frameLabelText: "",
	frameLabelDictionaryKey: "",//"Click To Play",
	frameLabelX: tgfScale(0),
	frameLabelY: tgfScale(195),
	frameLabelFont: f_tgf_button,
	
	progressBarDisappear: {effect: tgfEffects.alpha, duration: 0.2, startAlpha: 1, endAlpha: 0, name: "endBar"},
	
	onClick: null,
	onPlay: null,
	onAdFinish: null,
	onAdFail: null,

	playButtonProperties:null,
	gameLogoProperties:null,
	frameProperties: null,
	blackFrameProperties: null,
	progressBarProperties: null,

	frameContainer: null,
	
	//Ads props
	viewport: undefined,
	
	fillImage: s_logo_tinglygames_background,//null,									// The pattern image to fill the screen
	fillTime: 60,										// Time for a single rotation of the fill
	fillDistance: tgfScale(200),						// Distance the fill Image should move

	adWindowX: 0,
	adWindowY: 150,
	adSizeWidth: undefined,
	adSizeHeight: undefined,
	haveAd: false,
	doPlay: false,
	getTimer: false,
	provider: "none",				//Ad provider "none","google", "poki", "woobi"
	hasFrame: false,
	isMobile: false,
	//onClick: null,
	onNext: null,

    components: []                  // The additional components to add
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.AdDialog = function(properties) {
    "use strict";
    this.name = "AdDialog";         // The name of the dialog
    // Initialize properties
    this.initialize(tgfSettings.dialogDefaults.adDialog);
    // Set user properties
    if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.AdDialog, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************


// ***************************************
// Internal methods
// ***************************************
//tgfDialogs.AdDialog.prototype.disappear = function() {
//
//};

tgfDialogs.AdDialog.prototype.create = function(){
	"use strict";
	tgfAds._createContainer(this.provider, this.getDisplayLeft(), this.getDisplayTop(), this.getDisplayWidth(), this.getDisplayHeight());
	tgfAds._onResize(this.onResize, this);
};

tgfDialogs.AdDialog.prototype.onResize = function(base){
	"use strict";
	var scale = base.viewport.clientWidth / tgfGraphics.visibleWidth;

	var ww = base.getDisplayWidth();
	var hh = base.getDisplayHeight();
	var width = Math.round(ww * scale);
	var height = Math.round(hh * scale);

	var ll = base.getDisplayLeft();
	var tt = base.getDisplayTop();

	var top = Math.round((tt  - tgfGraphics.visibleTop) * scale) + "px";
	var left = Math.round((ll - tgfGraphics.visibleLeft) * scale) + "px";

	tgfAds.doResize(base.provider, left, top, width, height);
};

tgfDialogs.AdDialog.prototype.getDisplayWidth = function(){
	return this.adSizeWidth - tgfScale(32) - tgfScale(32);
};

tgfDialogs.AdDialog.prototype.getDisplayHeight = function(){
	return this.adSizeHeight - tgfScale(32) - tgfScale(96 + 60);
};

tgfDialogs.AdDialog.prototype.getDisplayLeft = function(){
	return this.adWindowY + tgfScale(32);
};

tgfDialogs.AdDialog.prototype.getDisplayTop = function(){
	return this.adWindowX + tgfScale(32);
};

tgfDialogs.AdDialog.prototype.adPrepare = function(){
	"use strict";
	if(this.playButtonComponent) {
		this.playButtonComponent.startSubEffect(3);
	}
};

tgfDialogs.AdDialog.prototype.adShow = function(){
	"use strict";
	if(this.frameComponent) {
		this.blackFrameComponent.show();
		this.frameComponent.startSubEffect(1);
		this.gameLogoComponent.startSubEffect(1);
	} else {
		tgfAds.showAds(this.provider);
	}
};

tgfDialogs.AdDialog.prototype.addBlackFrame = function(){
	"use strict";
	var blackFrame = new tgfComponents.Picture({
		image: this.blackFrameImage, x: this.blackFrameX, y:this.blackFrameY, height: this.blackFrameHeight,
		width: this.blackFrameWidth, xScale: 1.74, yScale: 1
	});
	
//	this.containerComponent.addComponent(blackFrame);
	this.frameComponent.components.push(blackFrame);
	blackFrame.activate();
};

tgfDialogs.AdDialog.prototype.adCompleted = function(){
	"use strict";
	this.deactivate();
	if(this.frameComponent) {
		this.frameComponent.startSubEffect(3);
		this.gameLogoComponent.startSubEffect(3);
	} else {
		this.hide();
	}
	if(this.provider !== "none" && this.progressBarComponent){
		this.progressBarComponent.startSubEffect(1);
		this.lastLable();
	}

	if(this.onComplete) {
		this.onComplete(this.rewardCount);
	}
	
	if(tgfAds.hasAdBlock){
		 this.playButtonComponent.hide();
		 this.frameLabelComponent.hide();
	}
};

tgfDialogs.AdDialog.prototype.lastLable = function(){
//	this.lastFrameComponent.show();
//	this.lastFrameComponent.startSubEffect(2);
};

tgfDialogs.AdDialog.prototype.noAds = function(){
	"use strict";
	if(this.frameComponent) {
		this.frameComponent.startSubEffect(3);
		this.gameLogoComponent.startSubEffect(3);
	}
	if(this.playButtonComponent) {
		this.playButtonComponent.startSubEffect(3);
	}
};

tgfDialogs.AdDialog.prototype.adFailed = function(){
	"use strict";
	this.deactivate();
	if(!this.haveAd){
		this.hide();
		return;
	}
	if(this.frameComponent) {
		this.frameComponent.startSubEffect(3);
		this.gameLogoComponent.startSubEffect(3);
	} else {
		this.hide();
	}
	if(this.provider !== "none"){
		this.progressBarComponent.startSubEffect(1);
	}
};

tgfDialogs.AdDialog.prototype.createProgress = function() {
	"use strict";
	var self = this;

//	var ad = new tgfComponents.Ad({baseDialog: self});
//	this.addComponent(ad);
//	ad.activate();
//	ad.show();
	
	var loadingLabel = new tgfComponents.Label({
		dictionaryKey: ""/*"is loading now"*/, x: tgfScale(-310), y: tgfScale(5),
		fontUp: this.frameLabelFont, width: tgfScale(200), height: tgfScale(100)
	});
	
	//this.addComponent(loadingLabel);

	this.progressBarComponent = new tgfComponents.ProgressBar({
		x: tgfScale(200), y: tgfScale(230), width: tgfScale(400),
		effects: [{effect:"show", duration: 99999999}, this.progressBarDisappear],
		onSubEffectEnd: function(component, effect){
			if(effect.name === "endBar"){
				self.progressBarComponent.hide();
				loadingLabel.hide();
			}
		}
	});

	this.progressBarComponent.setProperties(this.progressBarProperties);
	
	this.progressBarComponent.components.push(loadingLabel);
	
	
	this.addComponent(this.progressBarComponent);

	if(this.provider !== "woobi") {
		this.progressBarComponent.activate();
		this.progressBarComponent.show();
	}
};

tgfDialogs.AdDialog.prototype.renewProgressBar = function(prog){
	"use strict";
	if(this.progressBarComponent !== undefined){
		this.progressBarComponent.setProgress(prog, false);
	}
};

tgfDialogs.AdDialog.prototype.completeProgressBar = function(){
	"use strict";
	if(this.progressBarComponent !== undefined){
		this.progressBarComponent.setProgress(100, true);
	}
};

// ***************************************
// Preparing and showing
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.AdDialog.prototype.doPrepare = function() {
    "use strict";
    var i, self = this, fillEffect;
    this.x = tgfGraphics.mainCanvas.width/2;
	this.y = tgfGraphics.mainCanvas.height/2;

	if(this.adSizeWidth === undefined){ this.adSizeWidth = tgfGraphics.safeZoneWidth; }
    if(this.adSizeHeight === undefined){ this.adSizeHeight = tgfGraphics.visibleHeight; }
    this.viewport = tgfGraphics.container;
	this.create();
	//this.hasFrame = tgfAds.hasFrame;
	this.isMobile  = tgfAds.isMobile;

	this.frameContainer = new tgfComponents.Container({});
	if(this.isMobile){
		switch(this.provider){
		case "admob":
			tgfAds.makeAdMobContainer();
			break;
		case "chartboost":
			tgfAds.makeChartboostContainer();
			break;
		}
	}
	
	// Do the background fill
	if (this.fillImage !== null) {
		fillEffect = function(component, effect, time) {
				component.x = self.fillDistance/2 * Math.sin(2 * Math.PI * time / self.fillTime);
				component.y = self.fillDistance/2 * - Math.cos(2 * Math.PI * time / self.fillTime);
			};
		this.fillerComponent = new tgfComponents.Base( {
				effects: { effect: fillEffect, duration: 9999999 }
			} );
		this.fillerComponent.onDraw = function (component) {
				self.fillImage.drawTiled(0, -self.x - self.fillDistance/2, -self.y - self.fillDistance/2, tbGraphics.width + self.fillDistance, tbGraphics.height + self.fillDistance, 1);
			};
		this.addComponent(this.fillerComponent);
	}

	if(this.hasFrame){

		this.frameComponent = new tgfComponents.Picture({
			image: this.frameImage, x: this.frameX, y: this.frameY, width: this.frameWidth, height: this.frameHeight,
			createFromSlices: true,
			effects: [{effect: "show", duration: 99999999}, self.frameScaleUp, {effect: "show", duration: 99999999},{effect: "show", duration: 1}, self.frameDisappear],
			onSubEffectEnd: function(components, effect){
				if(effect.name === "frameScale"){
					tgfAds.showAds(self.provider);
				}
			},
			onEffectEnd: function(components){
				self.hide();
			}
		});

		this.frameComponent.setProperties(this.frameProperties);
		
		this.blackFrameComponent = new tgfComponents.Picture({
			image: this.blackFrameImage, x: this.blackFrameX, y:this.blackFrameY, height: this.blackFrameHeight,
			width: this.blackFrameWidth, xScale: 1.74, yScale: 1.37
		});
		
		this.frameComponent.components.push(this.blackFrameComponent);
		
		this.frameContainer.addComponent(this.frameComponent);
		
		

		this.gameLogoComponent = new tgfComponents.Picture({
			image: this.gameLogoImage, x: this.gameLogoX, y: this.gameLogoY,
			width: this.gameLogoWidth, height: this.gameLogoHeight,
			effects: [{effect: "show", duration: 99999999}, this.gameLogoReposition,{effect: "show", duration: 99999999}, {effect: "show", duration: 1}, this.frameDisappear]
		});
		this.gameLogoComponent.setProperties(this.gameLogoProperties);
		this.frameContainer.addComponent(this.gameLogoComponent);

		this.playButtonComponent = new tgfComponents.Button({
			image: this.playButtonImage, x: this.playButtonX, y: this.playButtonY,
			width: this.playButtonWidth, height: this.playButtonHeight,
			effects: [this.playButtonAppear ,this.playButtonElastic, {effect: "show", duration: 99999999}, this.playButtonDisappear],
			onClick: function(components){
				self.doPlay = true;

				if(!tgfAds.hasAdBlock){
					if(!self.isMobile && self.provider === "none"){
						self.noAds();
					} else if(!self.isMobile || self.provider !== "none"){
						if(self.onPlay){ self.onPlay(self);}
						else{
							self.adPrepare();
						}
					} else {
						self.adCompleted();
						tgfAds.showAds(self.provider);
					}
				} else {
					self.adCompleted();
				}
			},
			onSubEffectEnd: function(components, effect){
				if(effect.name === "elastic"){self.playButtonComponent.startSubEffect(1);}
				if(effect.name === "hide"){
					self.playButtonComponent.hide();
					self.frameLabelComponent.hide();
				}
			}
		});
		this.playButtonComponent.setProperties(this.playButtonProperties);
		this.frameContainer.addComponent(this.playButtonComponent);
		
		
		
//		this.lastFrameComponent = new tgfComponents.Label({
//			dictionaryKey: "Thank you", x: tgfScale(0), y: tgfScale(0), fontUp: this.frameLabelFont,
//			effect: [{effect: "show", duration: 99999999},{effect: "show", duration: 1}, this.frameDisappear]
//		});
//		
//		this.addComponent(this.lastFrameComponent);
		
		this.addComponent(this.frameContainer);

		
		this.frameLabelComponent = new tgfComponents.Label({
			text: this.frameLabelText, x: this.frameLabelX, y: this.frameLabelY,
			dictionaryKey: this.frameLabelDictionaryKey, fontUp:this.frameLabelFont
		});
		
		this.addComponent(this.frameLabelComponent);
	}else{
		var darkener = new tgfComponents.Darkener({
			width: this.width,
			height: this.height
		});

		this.addComponent(darkener);
	}

	if (this.components) {
        for (i = 0; i < this.components.length; i += 1) {
            this.addComponent(this.components[i]);
        }
    }
};

// Processing required when freeing the dialog from use
tgfDialogs.AdDialog.prototype.doFree = function() {
    "use strict";
    this.removeAllComponents();
    this.playButtonComponent = undefined;
    this.frameComponent = undefined;
    this.lastFrameComponent = undefined;
    this.gameLogoComponent = undefined;
    this.frameLabelComponent = undefined;
    this.blackFrameComponent = undefined;
    this.progressBarComponent = undefined;
    this.fillerComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.AdDialog.prototype.doShow = function() {
	"use strict";
	if(this.blackFrameComponent){
		this.blackFrameComponent.hide();
	}
//	if(this.lastFrameComponent){
//		this.lastFrameComponent.hide();
//	}
	// Draw the background on the background canvas
	if (this.backgroundImage) {
		tbGraphics.setCanvas(tgfGraphics.backgroundCanvas);
		this.backgroundImage.drawCombinedSimple(0, 0);
		tbGraphics.setCanvas(tgfGraphics.mainCanvas);
	}
};

tgfDialogs.AdDialog.prototype.handleSpecial = function(id, args){
	"use strict";
	if(id === "Ad Failed"){
		this.adFailed();
		console.log(args.error);
	} else if(id === "Ad Completed"){
		if(this.doPlay){this.adCompleted();}
		console.log("Did Complete");
		tgfAds.removeContainer();
	} else if(id === "Ad Reward"){
		console.log(args._reward);
		this.rewardCount++;
		if(testMode) { console.log("Did Reward"); }
	}
};

tgfDialogs.AdDialog.prototype.handleEndStep = function(timePassed) {
	"use strict";
	tgfDialogs.AdDialog.uber.handleEndStep.call(this, timePassed);
	if(!this.haveAd && this.doPlay){
		if(tgfAds.adsAvailable(this.provider)){
			this.adShow();
			this.createProgress();
			this.getTimer = true;
			this.haveAd = true;
		}
	}

	if(this.getTimer){
			if(this.progressBarComponent !== undefined && tgfAds.getTimer(this.provider, timePassed) > 0){
				this.progressBarComponent.setProgress(tgfAds.getTimer(this.provider, timePassed), false);
			}
//		console.log(tgfAds.getTimer(this.provider));
	}
};

// Processing required when hiding the dialog
tgfDialogs.AdDialog.prototype.doHide = function() {
    "use strict";

};

// Events shall not pass.
tgfDialogs.AdDialog.prototype.handleTouchDown = function(touch,x,y) {
	"use strict";
	tgfDialogs.AdDialog.uber.handleTouchDown.call(this, touch, x, y);
	return true;
};

tgfDialogs.AdDialog.prototype.handleImmediateTouchUp = function(){
	"use strict";
	tgfAds.initContainer();
};


//******************************************************
//*****    Script Resource: ComponentGate
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.componentDefaults.componentGate = {
	imageLocked:   typeof(s_gate_closed) !== 'undefined' ? s_gate_closed : null,
	imageUnlocked: typeof(s_gate_open)   !== 'undefined' ? s_gate_open   : null,
	imageDoorLock: typeof(s_gate_lock)   !== 'undefined' ? s_gate_lock   : null,
	effectImage:   typeof(s_glitter)     !== 'undefined' ? s_glitter     : null,
	effectCount: tgfScale(0),
	showEffect: false,
	doorLockAlpha: 1,
	lockAlpha: 1,
	unlockAlpha: 0,
	position : [],
	id: 0,
	lifetime: 0,
	unlock: false,
	autoUnlock : false,
	timer: 5000,
	base: null,
	unlockAnimTime: 3000,
	effectTime: 1000,
	
	
	components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.ComponentGate = function(properties) {
	"use strict";
	this.name = "ComponentGate";            // The name of the component
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.componentGate);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
	
	this.animator = new tbAnimator(this);
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ComponentGate, tgfComponents.Base);



// ***************************************
// Size information (e.g. for design support)
// TODO: Override these when not default
// ***************************************

/*
// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.ComponentGate.prototype.getWidth = function() {
	"use strict";
	return this.width === undefined ? 0 : this.width;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.ComponentGate.prototype.getHeight = function() {
	"use strict";
	return this.height === undefined ? 0 : this.height;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.ComponentGate.prototype.getLeft = function() {
	"use strict";
	return -this.getWidth() / 2;
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.ComponentGate.prototype.getTop = function() {
	"use strict";
	return -this.getHeight() / 2;
};
*/

// ***************************************
// Specific methods for this component
// ***************************************



// ***************************************
// Internal methods
// ***************************************
tgfComponents.ComponentGate.prototype.setMove = function(id){
	"use strict";
	if(id === this.id){
		this.unlock = true;
	}
	
	console.log("ID: " + id + "THIS ID: " + this.id);
};


// ***************************************
// Preparing, showing and activating
//      - These can be removed if no processing is required
// ***************************************

tgfComponents.ComponentGate.prototype.unlockGate = function(id){
	var tr, self = this;
	
	if(id === this.id){
		this.animator.removeAllTracks();
		this.animator.events = [];
		this.animator.setTime(0);
		
		tr = this.animator.addTrack("function", this, function(value){ self.doorLockAlpha = value;  });
		this.animator.addKeys(tr, [{time: 0, value: 1}, {time: 1000, value: 0}]);
		tr = this.animator.addTrack("function", this, function(value){ self.lockAlpha = value;  });
		this.animator.addKeys(tr, [{time: 1000, value: 1}, {time: 2000, value: 0}]);
		this.animator.addEvent(this, 1000, self.setEffect);
		tr = this.animator.addTrack("function", this, function(value){ self.effectCount = Math.floor(value);  });
		this.animator.addKeys(tr, [{time: 1000, value: 0}, {time: 2000, value: 6}]);
		
		tr = this.animator.addTrack("function", this, function(value){ self.unlockAlpha = value;  });
		this.animator.addKeys(tr, [{time: 1500, value: 0}, {time: 2200, value: 1}]);
		
		this.animator.addEvent(this, 2200, self.setEffect);
	}
};

tgfComponents.ComponentGate.prototype.setEffect = function(){
	
	if(!this.showEffect){
		this.showEffect = true;
	}else {
		this.showEffect = false;
	}
};

// Processing required when preparing the component for use
tgfComponents.ComponentGate.prototype.doPrepare = function() {
	"use strict";
	var i;
	
	// Add the child components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

// Processing required when freeing the component from use
tgfComponents.ComponentGate.prototype.doFree = function() {
	"use strict";
};

// Processing required when showing the component
tgfComponents.ComponentGate.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the component
tgfComponents.ComponentGate.prototype.doHide = function() {
	"use strict";
	
};

// Processing required when activating the component
tgfComponents.ComponentGate.prototype.doActivate = function() {
	"use strict";
};

// Processing required when deactivating the component
tgfComponents.ComponentGate.prototype.doDeactivate = function() {
	"use strict";
};


// ***************************************
// Methods called when events must be processed
//      - These can be removed when no processing is required
//      - When they return true, this event is no further processed
//          by other components in the dialog
//      - Never call these methods yourself in other components,
//          Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.ComponentGate.prototype.doBeginStep = function(timePassed) {
	"use strict";
	this.animator.updateTime(timePassed);
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.ComponentGate.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.ComponentGate.prototype.doTouchUp = function(finger, x, y) { 
	"use strict";
};

// Called when the position of the mouse wheel is changed
tgfComponents.ComponentGate.prototype.doMouseWheel = function(delta, x, y) {
	"use strict";
};

// Called immediately when a touch is started or if a mouse button is pressed
tgfComponents.ComponentGate.prototype.doImmediateTouchDown = function(finger, x, y) {
	"use strict";
};

// Called immediately when a touch is ended or if a mouse button is released
tgfComponents.ComponentGate.prototype.doImmediateTouchUp = function(finger, x, y) { 
	"use strict";
};

// Called if the key with the given keyCode is pressed
tgfComponents.ComponentGate.prototype.doKeyDown = function(keyCode) { 
	"use strict";
//  if(tbGame.keyboardKeyDown(tbKeyCodes.vkA)){
//      if(keyCode == tbKeyCodes.vk1){
//          if(this.id === 1){
//              this.unlockGate(this.id);
//          }
//      } 
//      if(keyCode == tbKeyCodes.vk2){
//          if(this.id === 2){
//              this.unlockGate(this.id);
//          }
//      } 
//      if(keyCode == tbKeyCodes.vk3){
//          if(this.id === 3){
//              this.unlockGate(this.id);
//          }
//      } 
//  }
};

// Called if the key with the given keyCode is released
tgfComponents.ComponentGate.prototype.doKeyUp = function(keyCode) { 
	"use strict";
};

// Called if a global alarm is reached
tgfComponents.ComponentGate.prototype.doAlarm = function(alarm) { 
	"use strict";
};

// Called if a special or user-defined event happens
tgfComponents.ComponentGate.prototype.doSpecial = function(id, args) { 
	"use strict";
};

// Called at the end of each step
tgfComponents.ComponentGate.prototype.doEndStep = function(timePassed) { 
	"use strict";
	if(timePassed === 0){ return; }
	
//  if(this.unlock){
//      this.lifetime += timePassed;
//      this.y -= 30 / timePassed;
//      if(this.lifetime > this.timer){
//          this.unlock = false;
//      }
//  }
	
};

// Called just before drawing (also when not active)
tgfComponents.ComponentGate.prototype.doUpdateVisuals = function(timePassed) { 
	"use strict";
	
	
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.ComponentGate.prototype.doDraw = function() {
	"use strict";
	if(!this.autoUnlock){
		if(!this.unlock){
			this.imageLocked.drawExt(0, this.position.x, this.position.y, 1, 1, 0, this.lockAlpha);
			this.imageUnlocked.drawExt(0, this.position.x, this.position.y, 1, 1, 0, this.unlockAlpha);
			this.imageDoorLock.drawExt(0, this.position.x, this.position.y, 1, 1, 0, this.doorLockAlpha);
		}
		
		if(this.showEffect){
			this.effectImage.drawExt(this.effectCount, this.position.x, this.position.y, 1, 1, 0, 1)
		}
	}
	if(this.autoUnlock) {
		this.imageUnlocked.drawExt(0, this.position.x, this.position.y, 1, 1, 0, 1);
	}
};

// Called after drawing the sub-components
tgfComponents.ComponentGate.prototype.doEndDraw = function() {
	"use strict";
};



//******************************************************
//*****    Script Resource: ComponentStar
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.componentDefaults.star = {
	
	imageEmpty: null,
	imageFill: null,                     // The imageEmpty or surface resource to display
	animationImage: null,
	animationSpeed: 0,                      // The animation speed, in frames per second (can be negative, or 0 for static)
	startSubImage: 0,                       // The sub-imageEmpty at which the animation starts
	loopAnimation: false,                    // Whether to loop when the animation is completed
	roundSubImage: true,                    // Whether to round the sub-imageFills or floor them
	combineSubImages: false,                // Whether to combine the sub-imageFills in one big imageEmpty
	createFromSlices: false,                // Create from 3 or 9 slices (overwrites combineSubImages)
	onAnimationComplete: null,              // Called when the animation is complete
	roundPosition: true,                    // Whether to round the position when the size is odd
	maintainAspectRatio: true,              // Whether to maintain the aspect ratio of the imageEmpty
	components: [],                         // Components to add as children
	id: 0,
	stars: 0,
	timeWaitAnimation: 0.2,
	didCompleteAnimation: false,
	showStar: false,
	startAnimation: false,
	sound: undefined,
	onFinish: null
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Star = function(properties) {
	"use strict";
	this.name = "Star";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.star);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Star, tgfComponents.Base);

// Overriden to return the correct width
tgfComponents.Star.prototype.getWidth = function() {
	"use strict";
	if (this.width > 0) {
		return this.width;
	} else if (!this.imageEmpty) {
		return 0;
	} else if (this.combineSubImages) {
		return this.imageEmpty.combinedWidth;
	} else {
		return this.imageEmpty.width;
	}
};

// Overriden to return the correct width
tgfComponents.Star.prototype.getHeight = function() {
	"use strict";
	if (this.height > 0) {
		return this.height;
	} else if (!this.imageEmpty) {
		return 0;
	} else if (this.combineSubImages) {
		return this.imageEmpty.combinedHeight;
	} else {
		return this.imageEmpty.height;
	}
};

// ***************************************
// Preparing, showing and activating
// ***************************************

tgfComponents.Star.prototype.initSound = function(id){
	"use strict";
	if(id === this.id){
		tgfAudio.play(this.sound, 730 * (this.id + 1));
	}
};

// Processing required when preparing the component for use
tgfComponents.Star.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when showing the component
tgfComponents.Star.prototype.doShow = function() {
	"use strict";
	if(this.id === 0){
		this.startAnimation = true;
	}
	this.subImage = this.startSubImage;
	this.timeWaitAnimation *= 1000;
};


// ***************************************
// Methods called when events must be processed
// ***************************************

// Called just before drawing (also when not active)
tgfComponents.Star.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
	var newSubImage;
	
	if(this.timeWaitAnimation > 0 && this.startAnimation){
		this.timeWaitAnimation -= 1000 * timePassed /1000;
		return;
	} else if(this.timeWaitAnimation < 1) {this.timeWaitAnimation = 0;}
	
	if (this.animationImage !== null && this.animationImage instanceof tbImage && !this.didCompleteAnimation && this.startAnimation) {
		newSubImage = this.subImage + this.animationSpeed * timePassed/1000;
		if (this.subImage < this.animationImage.number && newSubImage >= this.animationImage.number) {
			if (this.loopAnimation) {
				this.subImage = newSubImage - this.animationImage.number;
			} else {
				this.subImage = this.animationImage.number;
			}
			if (this.onAnimationComplete) { this.onAnimationComplete(this, this.id); this.didCompleteAnimation = true;}
		} else if (this.subImage > 0 && newSubImage < 0) {
			if (this.loopAnimation) {
				this.subImage = this.animationImage.number + newSubImage;
			} else {
				this.subImage = 0;
			}
			if (this.onAnimationComplete) {
				this.onAnimationComplete(this, this.id); 
				this.didCompleteAnimation = true;
			}
		} else {
			this.subImage = newSubImage;
		}
	}
	
	
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Star.prototype.doDraw = function() {
	"use strict";
	var subImg, ww, hh, xx, yy, screenAspectRatio, imageFillAspectRatio;
	if (this.imageEmpty !== null){
		ww = this.imageEmpty.width;
		hh = this.imageEmpty.height;
		xx = -ww / 2;
		yy = -hh / 2;
		
		this.imageEmpty.drawSimple(0, xx + this.imageEmpty.xOrigin, yy + this.imageEmpty.yOrigin);
	}
	
	if(this.id < this.stars && this.timeWaitAnimation === 0){
		if (this.animationImage !== null && !this.didCompleteAnimation){
			ww = this.animationImage.width;
			hh = this.animationImage.height;
			xx = -ww / 2;
			yy = -hh / 2;
			subImg = this.roundSubImage ? this.subImage : Math.min(this.image.number-1, Math.floor(this.subImage));
			this.animationImage.drawSimple(subImg, xx + this.animationImage.xOrigin, yy + this.animationImage.yOrigin);
		}
		
		if (this.imageFill !== null){
			ww = this.imageFill.width;
			hh = this.imageFill.height;
			xx = -ww / 2;
			yy = -hh / 2;
			
			this.imageFill.drawSimple(0, xx + this.imageFill.xOrigin, yy + this.imageFill.yOrigin);
		}
	}
};

//******************************************************
//*****    Script Resource: ComponentCloud
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.componentDefaults.componentCloud = {
	image:           typeof(s_fogofwar_cloud_transparent) !== 'undefined' ? s_fogofwar_cloud_transparent : null,
	backgroundImage: typeof(s_fogofwar_gradient)          !== 'undefined' ? s_fogofwar_gradient          : null,
	positions : [{x:100, y: -150},{x:50, y: -400}, {x:70, y: -270}, {x: 200, y:-300}, {x: 300, y:-200}, {x: 300, y:-350}, {x: 450, y:-250},{x: 530, y:-300}, {x: 600, y:-250}, {x: 700, y:-300}, {x: 800, y:-200}, {x: 950, y:-300}, {x: 1100, y:-150}, {x: 1100, y:-250}],
	id: 0,
	lifetime: 0,
	moveUp: false,
	timer: 5000,
	base: null,
	onMoveUpComplete: null,
	isShowingCloud: true,
	
	components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.ComponentCloud = function(properties) {
	"use strict";
	this.name = "ComponentCloud";           // The name of the component
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.componentCloud);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
	
	var rand = new tbRandom();
	
	for(var i = 0; i < this.positions.length; i++) {
		this.positions[i].angleX = rand.randomRange(0.0, 6.0);
		this.positions[i].angleY = rand.randomRange(0.0, 6.0);
	}
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ComponentCloud, tgfComponents.Base);



// ***************************************
// Size information (e.g. for design support)
// TODO: Override these when not default
// ***************************************

/*
// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.ComponentCloud.prototype.getWidth = function() {
	"use strict";
	return this.width === undefined ? 0 : this.width;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.ComponentCloud.prototype.getHeight = function() {
	"use strict";
	return this.height === undefined ? 0 : this.height;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.ComponentCloud.prototype.getLeft = function() {
	"use strict";
	return -this.getWidth() / 2;
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.ComponentCloud.prototype.getTop = function() {
	"use strict";
	return -this.getHeight() / 2;
};
*/

// ***************************************
// Specific methods for this component
// ***************************************



// ***************************************
// Internal methods
// ***************************************
tgfComponents.ComponentCloud.prototype.setMove = function(id){
	"use strict";
	if(id === this.id){
		this.moveUp = true;
	}
	
//  console.log("ID: " + id + "THIS ID: " + this.id);
};

tgfComponents.ComponentCloud.prototype.autoHide = function(_id){
	"use strict";
	if(this.onMoveUpComplete && _id === this.id){
		this.onMoveUpComplete(this.id);
		this.isShowingCloud = false;
	}
};


// ***************************************
// Preparing, showing and activating
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.ComponentCloud.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Add the child components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

// Processing required when freeing the component from use
tgfComponents.ComponentCloud.prototype.doFree = function() {
	"use strict";
};

// Processing required when showing the component
tgfComponents.ComponentCloud.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the component
tgfComponents.ComponentCloud.prototype.doHide = function() {
	"use strict";
//  if(this.onMoveUpComplete){
//      this.onMoveUpComplete(this.id);
//  }
};

// Processing required when activating the component
tgfComponents.ComponentCloud.prototype.doActivate = function() {
	"use strict";
};

// Processing required when deactivating the component
tgfComponents.ComponentCloud.prototype.doDeactivate = function() {
	"use strict";
};


// ***************************************
// Methods called when events must be processed
//      - These can be removed when no processing is required
//      - When they return true, this event is no further processed
//          by other components in the dialog
//      - Never call these methods yourself in other components,
//          Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.ComponentCloud.prototype.doBeginStep = function(timePassed) {
	"use strict";
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.ComponentCloud.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.ComponentCloud.prototype.doTouchUp = function(finger, x, y) { 
	"use strict";
};

// Called when the position of the mouse wheel is changed
tgfComponents.ComponentCloud.prototype.doMouseWheel = function(delta, x, y) {
	"use strict";
};

// Called immediately when a touch is started or if a mouse button is pressed
tgfComponents.ComponentCloud.prototype.doImmediateTouchDown = function(finger, x, y) {
	"use strict";
};

// Called immediately when a touch is ended or if a mouse button is released
tgfComponents.ComponentCloud.prototype.doImmediateTouchUp = function(finger, x, y) { 
	"use strict";
};

// Called if the key with the given keyCode is pressed
//tgfComponents.ComponentCloud.prototype.doKeyDown = function(keyCode) { 
//  "use strict";
//  if(tbGame.keyboardKeyDown(tbKeyCodes.vkZ)){
//      if(keyCode == tbKeyCodes.vk1){
//          if(this.id === 1){
//              this.moveUp = true;
//              console.log("MOVE UP:  id = " + this.id);
//          }
//      } 
//      if(keyCode == tbKeyCodes.vk2){
//          if(this.id === 2){
//              this.moveUp = true;
//              console.log("MOVE UP:  id = " + this.id);
//          }
//      } 
//      if(keyCode == tbKeyCodes.vk3){
//          if(this.id === 3){
//              this.moveUp = true;
//              console.log("MOVE UP:  id = " + this.id);
//          }
//      } 
//  }
//};

// Called if the key with the given keyCode is released
tgfComponents.ComponentCloud.prototype.doKeyUp = function(keyCode) { 
	"use strict";
};

// Called if a global alarm is reached
tgfComponents.ComponentCloud.prototype.doAlarm = function(alarm) { 
	"use strict";
};

// Called if a special or user-defined event happens
tgfComponents.ComponentCloud.prototype.doSpecial = function(id, args) { 
	"use strict";
};

// Called at the end of each step
tgfComponents.ComponentCloud.prototype.doEndStep = function(timePassed) { 
	"use strict";
	
	if(this.moveUp){
		this.lifetime += timePassed;
		this.y -= 80 / timePassed;
		if(this.lifetime > this.timer){
			this.moveUp = false;
			this.autoHide(this.id);
//          if(this.onMoveUpComplete){
//              this.onMoveUpComplete(this.id);
//          }
		}
	}
	
	if(timePassed === 0){ return; }
	
	for(var i = 0; i < this.positions.length; i++) {    

		var angleX = this.positions[i].angleX;
		var angleY = this.positions[i].angleY;      
		
		angleX += 0.0600 / timePassed;
		angleY += 0.0833 / timePassed;
		
		var twoPi = 3.1415926 * 2.0;
		
		if(angleX > twoPi) {
			angleX = angleX % twoPi;
		}

		if(angleY > twoPi) {
			angleY = angleY % twoPi;
		}
		
		this.positions[i].angleX = angleX;
		this.positions[i].angleY = angleY;      
	}   
};

// Called just before drawing (also when not active)
tgfComponents.ComponentCloud.prototype.doUpdateVisuals = function(timePassed) { 
	"use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.ComponentCloud.prototype.doDraw = function() {
	"use strict";
	//console.log("SHOWING: " + this.isShowingCloud + "  ID: " + this.id + " moveUP: " + this.moveUp);
	
	if(this.isShowingCloud){
		this.backgroundImage.drawCombinedExt(0, -730, 1,1,0,1);
		
		var radiusX = 20.0;
		var radiusY =  5.0;
		
		for(var i = 0; i < this.positions.length; i++) {    
	
			var angleX = this.positions[i].angleX;
			var angleY = this.positions[i].angleY;      
					
			var x = this.positions[i].x + Math.sin(angleX) * radiusX;
			var y = this.positions[i].y + Math.sin(angleY) * radiusY;
			
			this.image.drawExt(0, x, y, 1,1,0,1);
		}
	}
};

// Called after drawing the sub-components
tgfComponents.ComponentCloud.prototype.doEndDraw = function() {
	"use strict";
};




//******************************************************
//*****    Script Resource: AdComponent
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.componentDefaults.adComponent = {
	
	baseDialog: null,
	
	viewport: undefined,
	
	adWindowX: 0,
	adWindowY: 150,
	adSizeWidth: undefined,
	adSizeHeight: undefined,
	
	provider: "google",				//Ad provider "none","google", "poki"
	
	onClick: null,
	onNext: null,
		
    components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Ad = function(properties) {
    "use strict";
    this.name = "Ad";         // The name of the component
    // Initialize properties
    this.initialize(tgfSettings.componentDefaults.adComponent);
    // Set user properties
    if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Ad, tgfComponents.Base);



// ***************************************
// Size information (e.g. for design support)
// TODO: Override these when not default
// ***************************************

/*
// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.Ad.prototype.getWidth = function() {
    "use strict";
    return this.width === undefined ? 0 : this.width;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.Ad.prototype.getHeight = function() {
    "use strict";
    return this.height === undefined ? 0 : this.height;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.Ad.prototype.getLeft = function() {
    "use strict";
    return -this.getWidth() / 2;
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.Ad.prototype.getTop = function() {
    "use strict";
    return -this.getHeight() / 2;
};
*/

// ***************************************
// Specific methods for this component
// ***************************************



// ***************************************
// Internal methods
// ***************************************
tgfComponents.Ad.prototype.create = function(){
	tgfAds._createContainer(this.provider, this.getDisplayLeft(), this.getDisplayTop(), this.getDisplayWidth(), this.getDisplayHeight());
	tgfAds._onResize(this.onResize, this);
};

tgfComponents.Ad.prototype.onResize = function(base){
	
	var scale = base.viewport.clientWidth / tgfGraphics.visibleWidth;

	var ww = base.getDisplayWidth();
	var hh = base.getDisplayHeight();
	var width = Math.round(ww * scale);
	var height = Math.round(hh * scale);
	
	var ll = base.getDisplayLeft();
	var tt = base.getDisplayTop();
	
	var top = Math.round((tt  - tgfGraphics.visibleTop) * scale) + "px";
	var left = Math.round((ll - tgfGraphics.visibleLeft) * scale) + "px";

//	base.adContainer.style["top"] = top;
//	base.adContainer.style["left"] = left;
	
	tgfAds.doResize(base.provider, left, top, width, height);
};

tgfComponents.Ad.prototype.getDisplayWidth = function(){
	return this.adSizeWidth - tgfScale(32) - tgfScale(32);
};

tgfComponents.Ad.prototype.getDisplayHeight = function(){
	return this.adSizeHeight - tgfScale(32) - tgfScale(96 + 60);
};

tgfComponents.Ad.prototype.getDisplayLeft = function(){
	return this.adWindowY + tgfScale(32);
};

tgfComponents.Ad.prototype.getDisplayTop = function(){
	return this.adWindowX + tgfScale(32);
};

// ***************************************
// Preparing, showing and activating
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.Ad.prototype.doPrepare = function() {
    "use strict";
    var i, self = this;
    
    if(this.adSizeWidth === undefined){ this.adSizeWidth = tgfGraphics.safeZoneWidth; }
    if(this.adSizeHeight === undefined){ this.adSizeHeight = tgfGraphics.visibleHeight; }
    this.viewport = tgfGraphics.container;
    this.create();
    
    // Add the child components
    if (this.components) {
        for (i = 0; i < this.components.length; i += 1) {
            this.addComponent(this.components[i]);
        }
    }
};

// ***************************************
// Methods called when events must be processed
//      - These can be removed when no processing is required
//      - When they return true, this event is no further processed
//          by other components in the dialog
//      - Never call these methods yourself in other components,
//          Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.Ad.prototype.doBeginStep = function(timePassed) {
    "use strict";
    
    if(this.startTimer && this.adTime > -1 && !this.userSkip){

    	this.adTime = this.adManager.getRemainingTime() * 1000;
    	
//    	this.adTime -= timePassed;
    	
    	var reverseTime = this.adStartTime - this.adTime;
    	
    	var prog = Math.round((reverseTime / this.adStartTime) * 100);
    
    	
    	if(this.baseDialog !== null){
    		this.baseDialog.renewProgressBar(prog);
    	}
    	if(this.adTime < 0){
    		this.startTimer = false;
    	}
    } else if(this.userSkip){
    	if(this.baseDialog !== null){
    		this.baseDialog.completeProgressBar();
    	}
    }
};
//******************************************************
//*****    Script Resource: ComponentMapScroll
//******************************************************

/* global
	tgfSettings,
	tgfComponents
 */

tgfSettings.componentDefaults.mapScroll = {
	image: s_tgf_button,
	elementWidth: 500,
	accel: 45,
	outOfBoundsDamp: 1.0,
	damp: 7,
	index: 0
};

/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.MapScroll = function(properties) {
	"use strict";

	this.initialize(tgfSettings.componentDefaults.mapScroll);

	this.index           = 0;
	this.elementWidth    = 500;
	this.elements        = [];
	this.trackingFinger  = -1;
	this.axis            = new tbVector(1,0);
	this.fingerStart     = new tbVector(0,0);
	this.fingerCurrent   = new tbVector(0,0);
	this.speed           = 0;
	this.accel           = 45;
	this.damp            = 7;
	this.maxScroll       = -1;
	this.scrollParam     = 0.0;
	this.scrollParamStart = 0.0;
	this.mouseWheel      = false;
	this.postProcessElement = null;
	this.mouseWheelSpeed = 0.10;
	this.isMap             = true;

	// Set user properties
	if (properties !== undefined) {
		this.setProperties(properties);
	}
};

tgfComponents.inherit(tgfComponents.MapScroll, tgfComponents.Base);

Math.round = Math["round"];

tgfComponents.MapScroll.prototype.addElement = function (element) {
	"use strict";
	this.addComponent(element);
	this.elements.push(element);
	this.setElementPosition(element, this.elements.length-1);
};


tgfComponents.MapScroll.prototype.addElementAtIndex = function (element, index) {
	"use strict";
	this.addComponent(element);
	this.elements[index] = element;
	this.setElementPosition(element, index);
};

tgfComponents.MapScroll.prototype.setElementPosition = function (element, index) {
	"use strict";

	var relativeParam = index - this.scrollParam;

	var pos = this.axis.scale(this.elementWidth * relativeParam);

	element.x = Math.round(pos.x);
	element.y = Math.round(pos.y);

	if(this.postProcessElement) {
		this.postProcessElement(element);
	}
};

tgfComponents.MapScroll.prototype.getIndex = function (){
	return this.index;
}

tgfComponents.MapScroll.prototype.snapToIndex = function (index) {
	"use strict";

	this.scrollParam = Math.max(Math.min(this.elements.length-1,index),0);

	for(var i = 0; i < this.elements.length; ++i) {
		this.setElementPosition(this.elements[i], i);
	}
};

tgfComponents.MapScroll.prototype.setScrollMax = function(max){
	if(max){
		this.maxScroll = max;
	}
};

tgfComponents.MapScroll.prototype.doBeginStep = function(timepassed) {
	"use strict";

	if(this.isMap){
		if(Math.round(this.scrollParam) !== 0){
			this.elements[Math.round(this.scrollParam)].show();
			this.elements[Math.round(this.scrollParam)].activate();
			this.elements[Math.round(this.scrollParam)+1].show();
			this.elements[Math.round(this.scrollParam)+1].activate();
			this.elements[Math.round(this.scrollParam)-1].show();
			this.elements[Math.round(this.scrollParam)-1].activate();

			if(Math.round(this.scrollParam) > 1){
				this.elements[0].hide();
			}

			for(var i = Math.round(this.scrollParam) - 2; i > 0; i--){
				if(this.elements[i]){
					this.elements[i].hide();
				}
			}
			for(var i = Math.round(this.scrollParam) + 2; i < this.elements.length; i++){
				if(this.elements[i]){
					this.elements[i].hide();
				}
			}
		}else if(Math.round(this.scrollParam) <= 0){
			this.elements[Math.round(this.scrollParam)].show();
			this.elements[Math.round(this.scrollParam)].activate();
			for(var i = 2; i < this.elements.length; i++){
				this.elements[i].hide();
			}
		}
		var prevScrollParam = this.scrollParam;
	}


	if(this.trackingFinger >= 0) {

		var fingerX = tbGame.touchX(this.trackingFinger);
		var fingerY = tbGame.touchY(this.trackingFinger);

		var relativeFingerPos = new tbVector(fingerX - this.fingerStart.x, fingerY - this.fingerStart.y);

		relativeFingerPos.scaleDirect(-1.0 / this.elementWidth);

		var fingerDot = relativeFingerPos.dot(this.axis);

		this.scrollParam = fingerDot + this.scrollParamStart;

		if(this.maxScroll < 0){
			if(this.scrollParam < 0.0) {
				this.scrollParam = Math.atan(this.scrollParam * this.outOfBoundsDamp) / this.outOfBoundsDamp;
			}
			else if(this.scrollParam > this.elements.length-1) {
				this.scrollParam = Math.atan(this.outOfBoundsDamp * (this.scrollParam - this.elements.length + 1)) / this.outOfBoundsDamp + this.elements.length - 1;
			}
		} else {
			if(this.scrollParam < 0.0) {
				this.scrollParam = Math.atan(this.scrollParam * this.outOfBoundsDamp) / this.outOfBoundsDamp;
			}
			else if(this.scrollParam > this.maxScroll-1) {
				this.scrollParam = Math.atan(this.outOfBoundsDamp * (this.scrollParam - this.maxScroll + 1)) / this.outOfBoundsDamp + this.maxScroll - 1;
			}
		}
		var maxSpeed      = 4.0;
		var observedSpeed = (this.scrollParam - prevScrollParam) * 1000 / timepassed;

		this.speed = Math.min(Math.max(observedSpeed, -maxSpeed), maxSpeed);
	}
	else{
		if(this.scrollParam < 0.0) {
			this.scrollParam = Math.atan(this.scrollParam * this.outOfBoundsDamp) / this.outOfBoundsDamp;
			
			var targetParam = Math.round(this.scrollParam);
			
			targetParam = Math.max(0, Math.min(this.elements.length-1, targetParam));
	
			var deltaParam = targetParam - this.scrollParam;
	
			var accel = deltaParam * this.accel - this.speed * this.damp;
	
			this.speed += accel * (timepassed/1000);
	
			this.scrollParam += this.speed * (timepassed/1000);
		}
		else if(this.scrollParam > this.elements.length-1) {
			this.scrollParam = Math.atan(this.outOfBoundsDamp * (this.scrollParam - this.elements.length + 1)) / this.outOfBoundsDamp + this.elements.length - 1;
			
			var targetParam = Math.round(this.scrollParam);
			
			targetParam = Math.max(0, Math.min(this.elements.length-1, targetParam));
	
			var deltaParam = targetParam - this.scrollParam;
	
			var accel = deltaParam * this.accel - this.speed * this.damp;
	
			this.speed += accel * (timepassed/1000);
	
			this.scrollParam += this.speed * (timepassed/1000);
		}       
	}
	if(prevScrollParam !== this.scrollParam) {
		for(var i = 0; i < this.elements.length; ++i) {
			this.setElementPosition(this.elements[i], i);
		}
	}
	
	//this.trackingFinger = -1;
};

tgfComponents.MapScroll.prototype.updateElementScales = function() {
	"use strict";
	for(var i = 0; i < this.elements.length; ++i) {

		var diffX  = Math.abs(this.elements[i].x + this.x);
		var interp = Math.min(1, Math.max(0, diffX / this.elementWidth));
		var scale  = tbEase.easeInOutExponential(interp, 1.0, this.offSideScaling - 1.0, 1.0, 2.0);

		this.elements[i].xScale = scale;
		this.elements[i].yScale = scale;
	}
};

tgfComponents.MapScroll.prototype.doTouchDown = function(finger, x, y) {
	"use strict";

	if(this.trackingFinger !== -1) {
		return;
	}

	this.trackingFinger = finger;
	this.fingerStart.assignXY(tbGame.touchX(finger), tbGame.touchY(finger));
	this.scrollParamStart = this.scrollParam;
};

tgfComponents.MapScroll.prototype.doTouchUp = function(finger, x, y) {
	"use strict";

	if(finger === this.trackingFinger) {
		this.trackingFinger = -1;
	}
};

tgfComponents.MapScroll.prototype.handleMouseWheel = function(delta, x, y){
	
	if(this.elements.length < 2){ return; }
	
	this.scrollParam += delta * this.mouseWheelSpeed;
	
	this.applyClamp(0.2);
	
	for(var i = 0; i < this.elements.length; ++i) {
		this.setElementPosition(this.elements[i], i);
	}   
	
	this.mouseWheel = true;
};

tgfComponents.MapScroll.prototype.applyClamp = function(timepassed) {
	"use strict";
	
	var maxScroll = this.maxScroll;
	
	if(maxScroll < 0.0) {
		maxScroll = this.elements.length-1;
	}
	
	if(this.scrollParam < 0.0) {
		this.scrollParam = Math.atan(this.scrollParam * this.outOfBoundsDamp) / this.outOfBoundsDamp;
		
		var targetParam = Math.round(this.scrollParam);
		
		targetParam = Math.max(0, Math.min(this.elements.length-1, targetParam));

		var deltaParam = targetParam - this.scrollParam;

		var accel = deltaParam * this.accel - this.speed * this.damp;

		this.speed += accel * (timepassed/1000);

		this.scrollParam += this.speed * (timepassed/1000);
	}
	else if(this.scrollParam > maxScroll-1) {
				
		this.scrollParam = Math.atan(this.outOfBoundsDamp * (this.scrollParam - maxScroll + 1)) / this.outOfBoundsDamp + maxScroll - 1;
		
		var targetParam = Math.round(this.scrollParam);
		
		targetParam = Math.max(0, Math.min(this.elements.length-1, targetParam));

		var deltaParam = targetParam - this.scrollParam;

		var accel = deltaParam * this.accel - this.speed * this.damp;

		this.speed += accel * (timepassed/1000);

		this.scrollParam += this.speed * (timepassed/1000);
	}   
};



//******************************************************
//*****    Script Resource: ExtButton
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

//tgfComponents.ExtButton.uber.doTouchDown.call(this,finger,x,y);


tgfSettings.componentDefaults.extButton = {
		isActive: false,
		threshold: tgfScale(0),
		tmpPosX : 0,
		tmpPosY : 0,
		toggleCounter : tgfScale(3),
		languageId: ""
};

// The constructor for the component
/** @constructor
 *  @base tgfComponents.Button
 *  
 */
tgfComponents.ExtButton = function(properties) {
	"use strict";
	this.name = "ExtButton";
	
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.button);
	// Add additional properties
	this.setProperties(tgfSettings.componentDefaults.extButton);
	
	this.touchStart = new tbVector(0,0);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

//Inherit the base component
tgfComponents.inherit(tgfComponents.ExtButton, tgfComponents.Button);

//Set the state of the button to up or down
tgfComponents.ExtButton.prototype._setState = function(state, action) {
	"use strict";
	if(state === "active"){
		if (this.onClick) { this.onClick(this); }
		return;
	}
	tgfComponents.ExtButton.uber._setState.call(this, state, action);
};


//Called when a touch is started or if a mouse button is pressed
tgfComponents.ExtButton.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
	this.tmpPosX = this.touchX(finger);
	this.tmpPosY = this.touchY(finger);
	this.threshold = this.threshold === undefined ? 0 : this.threshold;
	if (!this.useImmediateInput) {
		return this.doTouchDownInternal(finger, x, y);
	}
};

//Called when a touch is ended or if a mouse button is released
tgfComponents.ExtButton.prototype.doTouchUp = function(finger, x, y) {
	"use strict";
	this.tmpPosX = 0;
	this.tmpPosY = 0;
	if (!this.useImmediateInput) {
		return this.doTouchUpInternal(finger, x, y);
	}
};

//Do the actual work when a touch is started or if a mouse button is pressed
tgfComponents.ExtButton.prototype.doTouchDownInternal = function(finger, x, y) {
	"use strict";
	var ww = this.surfaceDown.width + 2 * this.touchMargin,
		hh = this.surfaceDown.height + 2 * this.touchMargin;
	if (x >= -ww/2 && x <= ww/2 && y >= -hh/2 && y <= hh/2) {
		if (this.state === "up" || this.state === "active") {
			this._setState("down", true);
			this.finger = finger;
			this.touchStart = this.componentToScreenVector(x, y);
		}
		else{
			this.finger = finger;
		}
		if (this.cancelEvents) { return true; }
	}
};

//Do the actual work when a touch is ended or if a mouse button is released
tgfComponents.ExtButton.prototype.doTouchUpInternal = function(finger, x, y) {
	"use strict";
	var ww = this.surfaceDown.width + 2 * this.touchMargin,
	hh = this.surfaceDown.height + 2 * this.touchMargin;
	if (this.finger !== finger) { return; }
	this.finger = -1;
	this._setState("active");
	this.isActive = true;
	this.toggleIndex = this.toggleCounter;
	this.createSurfaces();
};

tgfComponents.ExtButton.prototype.disableAfterMovement = function(){
	if(this.state === "down"){
		this._setState("up", false);
	}
};

tgfComponents.ExtButton.prototype.disableActive = function(){
	if(this.isActive){
		this._setState("up", false);
	}
};

tgfComponents.ExtButton.prototype.doPrepare = function(){
	tgfComponents.ExtButton.uber.doPrepare.call(this);
	if(this.languageId !== ""){
		if(tgfDictionary.getLanguage() === this.languageId){
			this.isActive = true;
			this._setState("down", false);
			this.toggleIndex = this.toggleCounter;
			this.createSurfaces();
		}
	}
};

//Called at the end of each step
tgfComponents.ExtButton.prototype.doEndStep = function(timePassed) {
	"use strict";
	var xx, yy,
		ww = this.surfaceDown.width + 2 * this.touchMargin,
		hh = this.surfaceDown.height + 2 * this.touchMargin;
	// Check whether the finger moves on or off the button
	if (this.finger !== -1) {
		xx = this.touchX(this.finger);
		yy = this.touchY(this.finger);
		
		if(xx > this.tmpPosX + this.threshold|| xx < this.tmpPosX - this.threshold || yy < this.tmpPosY - this.threshold || yy > this.tmpPosY + this.threshold){
			this.disableAfterMovement();
			this.finger = -1;
			return;
		}
		tgfComponents.ExtButton.uber.doEndStep.call(this, timePassed);
	}
};


//******************************************************
//*****    Script Resource: ExtEffect
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

//TODO Documentation
//Play Button effect
tgfEffects.popElastic = function(component, effect, time){
	var elasticEase = function(time, begin, change, duration, oscillations, stiffness){
		return tbEase.easeOutElastic(time, begin, change, duration, 3, 2);
	};
	var newEase = tbEase.easeCreateCombined([tbEase.easeOutOvershoot, elasticEase, tbEase.easeConstant], [true, false, false], [0.02, 0.1, 0.88]);
	var ease = newEase,//effect.ease === undefined ? tbEase.easeLinear : effect.ease,
		easeArgument = effect.easeArgument === undefined ? undefined : effect.easeArgument,
		easeScale = effect.easeScale === undefined ? ease : effect.easeScale,
		easeScaleArgument = effect.easeScaleArgument === undefined ? easeArgument : effect.easeScaleArgument,
		startScaleX = effect.startScaleX === undefined ? 1 : effect.startScaleX,
		endScaleX = effect.endScaleX === undefined ? 1 : effect.endScaleX,
		startScaleY = effect.startScaleY === undefined ? 1 : effect.startScaleY,
		endScaleY = effect.endScaleY === undefined ? 1 : effect.endScaleY;
	var scaleRepeat = tbEase.easeCreateRepeat(newEase, tbEase.repeatRepeat);
	
	component.xScale = easeScale(time, startScaleX, endScaleX-startScaleX, effect.duration, easeScaleArgument);
	component.yScale = easeScale(time, startScaleY, endScaleY-startScaleY, effect.duration, easeScaleArgument);
};

tgfEffects.scaleXY = function(component, effect, time){
	var ease = effect.ease === undefined ? tbEase.easeLinear : effect.ease,
		easeArgument = effect.easeArgument === undefined ? undefined : effect.easeArgument,
		easeScale = effect.easeScale === undefined ? ease : effect.easeScale,
		easeScaleArgument = effect.easeScaleArgument === undefined ? easeArgument : effect.easeScaleArgument,
		startScaleX = effect.startScaleX === undefined ? 1 : effect.startScaleX,
		endScaleX = effect.endScaleX === undefined ? 1 : effect.endScaleX,
		startScaleY = effect.startScaleY === undefined ? 1 : effect.startScaleY,
		endScaleY = effect.endScaleY === undefined ? 1 : effect.endScaleY;
	component.xScale = easeScale(time, startScaleX, endScaleX-startScaleX, effect.duration, easeScaleArgument);
	component.yScale = easeScale(time, startScaleY, endScaleY-startScaleY, effect.duration, easeScaleArgument);
};

//******************************************************
//*****    Script Resource: ComponentDecal
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************


tgfSettings.componentDefaults.decalls = {
	id: 0,
	decallList: [],
	components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Decalls = function(properties) {
	"use strict";
	this.name = "Decalls";			// The name of the component
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.decalls);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
	
	this.startRender = false;
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Decalls, tgfComponents.Base);

// ***************************************
// Internal methods
// ***************************************



// ***************************************
// Preparing, showing and activating
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.Decalls.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Add the child components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

// Processing required when freeing the component from use
tgfComponents.Decalls.prototype.doFree = function() {
	"use strict";
};

// Processing required when showing the component
tgfComponents.Decalls.prototype.doShow = function() {
	"use strict";
	this.startRender = true;
};

// Processing required when hiding the component
tgfComponents.Decalls.prototype.doHide = function() {
	"use strict";
};

// Processing required when activating the component
tgfComponents.Decalls.prototype.doActivate = function() {
	"use strict";
};

// Processing required when deactivating the component
tgfComponents.Template.prototype.doDeactivate = function() {
	"use strict";
};


// ***************************************
// Methods called when events must be processed
//      - These can be removed when no processing is required
//      - When they return true, this event is no further processed
//          by other components in the dialog
//      - Never call these methods yourself in other components,
//          Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.Decalls.prototype.doBeginStep = function(timePassed) {
	"use strict";
};

// Called at the end of each step
tgfComponents.Decalls.prototype.doEndStep = function(timePassed) { 
	"use strict";
};

// Called just before drawing (also when not active)
tgfComponents.Decalls.prototype.doUpdateVisuals = function(timePassed) { 
	"use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Decalls.prototype.doDraw = function() {
	"use strict";
	if(this.startRender){
		for(var i = 0; i < this.decallList.length; i++){
			if(this.decallList[i].id !== "background"){
				this.decallList[i].image.drawExt(0, this.decallList[i].x, this.decallList[i].y, 1,1,0,1);
			}
		}
	}
};

// Called after drawing the sub-components
tgfComponents.Decalls.prototype.doEndDraw = function() {
	"use strict";
};


//******************************************************
//*****    Script Resource: TextBox
//******************************************************


var gameui = gameui || {};

/**
 * @constructor
 * @base gameui.Component
 */
gameui.TextBox = function(parent, x, y, width, height, font) {
	"use strict";
	tgfComponents.Base.call(this, parent, x, y);
	this.width = width;
	this.height = height;
	this.surfaceMargin = 4;
	this.alpha = 1;
	this.text = "";
	this.font = font ? font : fonts.game.f_default;
	this.surface = new tbSurface(width + this.surfaceMargin * 2, height + this.surfaceMargin * 2);
	this.setText("LOREM IPSUM");
};

tgfComponents.inherit(gameui.TextBox, tgfComponents.Base);

gameui.TextBox.prototype.setText = function (text) {
	"use strict";
	if (this.text === text) {
		return;
	}
	this.dirty = true;
	this.text = text;
	this.surface.clear();
	this.surface.setTarget();
	var fontScale = 1;
	var textWidth = this.font.textWidth(this.text) + (this.font.getStroke() ? this.font.getStrokeWidth() : 0);
	var textHeight = this.font.textHeight(this.text) + (this.font.getStroke() ? this.font.getStrokeWidth() : 0);
	var oldFontSize = this.font.getFontSize();
	if (textWidth > this.width) {
		fontScale = this.width / textWidth;
	}
	if (textHeight > this.height) {
		fontScale = Math.min(fontScale, this.height / textHeight);
	}
	this.font.setFontSize(Math.floor(oldFontSize * fontScale));
	switch (this.font.getAlign()) {
		case alignLeft:
			this.font.drawSimple(this.text, this.surfaceMargin, this.surface.height / 2 + this.surface.height * 0.085);
			break;
		case alignCenter:
			this.font.drawSimple(this.text, this.surface.width / 2, this.surface.height / 2 + this.surface.height * 0.085);
			break;
		case alignRight:
			this.font.drawSimple(this.text, this.surface.width - this.surfaceMargin, this.surface.height / 2 + this.surface.height * 0.085);
			break;
	}
	this.font.setFontSize(oldFontSize);
	this.surface.resetTarget();
};

gameui.TextBox.prototype.draw = function () {
	"use strict";
	if (tgfComponents.drawDebug) {
		tbGraphics.drawRectangle(this.x, this.y, this.width, this.height, "red", true);
	}
	if (this.alpha !== 1) {
		tbGraphics.context.save();
		tbGraphics.context.globalAlpha *= this.alpha;
	}
	this.surface.drawSimple(this.x - this.surfaceMargin, this.y - this.surfaceMargin);
	if (this.alpha !== 1) {
		tbGraphics.context.restore();
	}
};

/**
 * @constructor
 * @base gameui.TextBox
 */
 gameui.TextBoxToken = function(x, y, width, height, font, depth, layer, callback, canvas) {
	"use strict";
	gameui.TextBox.call(this, null, x, y, width, height, font);
	 this.canvas = canvas;
	this.depth = depth ? depth : -900;
	this.layer = layer ? layer : -901;
	this.active = true;
	this.visible = true;
	 this.onClose = callback;
	tbGame.addToken(this);
};

tgfComponents.inherit(gameui.TextBoxToken, gameui.TextBox);

gameui.TextBoxToken.prototype.handleDraw = function() {
	"use strict";
	this.draw();
};




//******************************************************
//*****    Script Resource: Floater
//******************************************************

/* global
	gameui
 */

var floaters = floaters || {};

/**
 * @constructor
 */
floaters.Floater = function(text, x, y, delay, font, scaleFactor, fillColor, strokeColor, depth , layer, callback, canvas) {
	"use strict";
	if (delay === void 0) {
		delay = 0;
	}
	if (font === void 0) {
		font = OpenSansBold;
	}
	/*
	if (fillColor === void 0) {
		fillColor = "#FFF3C1";
	}
	if (strokeColor === void 0) {
		strokeColor = "#421700";
	}
	if (scaleFactor === void 0) {
		scaleFactor = 1;
	}
	*/
	var workingFont = font.clone();
	
	if (fillColor !== void 0) {
		workingFont.setFillColor(fillColor);
	}
	if (strokeColor !== void 0) {
		workingFont.setStrokeColor(strokeColor);
	}
	if (scaleFactor !== void 0) {
		workingFont.setFontSize(workingFont.getFontSize() * scaleFactor);
	}

	
	
	
	workingFont.setBaseline("middle");

	gameui.TextBoxToken.call(this, x, y, workingFont.textWidth(text) + (workingFont.getStroke() ? workingFont.getStrokeWidth() : 0), workingFont.textHeight(text) + 50
			+ (workingFont.getStroke() ? workingFont.getStrokeWidth() : 0), workingFont, depth, layer, callback, canvas);

	this.timer = 0;
	this.duration = 2200;
	this.easeY = tbEase.easeCreateCombined([tbEase.easeConstant, tbEase.easeConstant, tbEase.easeInCubic], [false, false, false], [0.2, 0.0, 1.3]);
	this.easeAlpha = tbEase.easeCreateCombined([tbEase.easeConstant, tbEase.easeConstant, tbEase.easeInOutCubic], [false, false, false], [0.2, 0.4, 0.9]);
	this.easeScale = tbEase.easeCreateCombined([tbEase.easeOutOvershoot, tbEase.easeConstant, tbEase.easeConstant], [false, false, false], [0.2, 0.4, 0.9]);
	this.x = x;
	this.y = y;
	this.timer = -delay;
	this.setText(text);
	this.from_y = y;
	this.to_y = y - tgfScale(50);
	this.active = true;
	this.scale = 0;
	this.alpha = 1;
};

tgfComponents.inherit(floaters.Floater, gameui.TextBoxToken);

floaters.Floater.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	this.timer += timePassed;
	if (this.timer > 0) {
		if (this.timer >= this.duration) {
			tbGame.removeToken(this);
		}
		else {
			this.y = this.easeY(this.timer, this.from_y, this.to_y - this.from_y, this.duration);
			this.alpha = this.easeAlpha(this.timer, 1, -1, this.duration);
			this.scale = this.easeScale(this.timer, 0, 1, this.duration);
		}
	}
};

floaters.Floater.prototype.draw = function() {
	"use strict";
	if (this.timer > 0) {
		this.surface
				.drawExt(this.x - this.surface.width / 2 * this.scale, this.y - this.surface.height / 2 * this.scale, this.scale, this.scale, 0, this.alpha);
	}
};

floaters.Floater.prototype.handleRemove = function(){
	"use strict";
	if(this.onClose){
		this.onClose();
	}
};




//******************************************************
//*****    Script Resource: Pathfinding
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

var pathfinding = pathfinding || {};

tgfSettings.componentDefaults.pathfinding = {
	onTargetReach: undefined,
	components: []                  // Components to add as children	
};

pathfinding.Pathfinding = function(_image, _positions, _yInterps){
	"use strict";
	this.image = _image;
	this.positions = _positions;
	this.yInterps = _yInterps;
	this.curPosVec;
	this.fps = 60;
	this.percent = 0;
	this.maxPercent = _positions.length * 10;
	this.direction = 0.1;
	this.name = "Pathfinding";         // The name of the component
    // Initialize properties
    this.initialize(tgfSettings.componentDefaults.pathfinding);
    this.animator = new tbAnimator(this);
    this.animFrame = 0;
    this.curPosVec = _positions[0];
    
    this.setMovement();
};



tgfComponents.inherit(pathfinding.Pathfinding, tgfComponents.Base);

//INNER FUNCTIONS//

//line: percent is 0-1
pathfinding.Pathfinding.prototype.getLineXYatPercent = function(startPt, endPt, percent) {
	"use strict";
    var dx = endPt.x - startPt.x;
    var dy = endPt.y - startPt.y;
    var X = startPt.x + dx * percent;
    var Y = startPt.y + dy * percent;
    return ({
        x: X,
        y: Y
    });
};

// quadratic bezier: percent is 0-1
pathfinding.Pathfinding.prototype.getQuadraticBezierXYatPercent = function(startPt, controlPt, endPt, percent) {
	"use strict";
    var x = Math.pow(1 - percent, 2) * startPt.x + 2 * (1 - percent) * percent * controlPt.x + Math.pow(percent, 2) * endPt.x;
    var y = Math.pow(1 - percent, 2) * startPt.y + 2 * (1 - percent) * percent * controlPt.y + Math.pow(percent, 2) * endPt.y;
    return ({
        x: x,
        y: y
    });
};

// cubic bezier percent is 0-1
pathfinding.Pathfinding.prototype.getCubicBezierXYatPercent = function(startPt, controlPt1, controlPt2, endPt, percent) {
	"use strict";
    var x = this.CubicN(percent, startPt.x, controlPt1.x, controlPt2.x, endPt.x);
    var y = this.CubicN(percent, startPt.y, controlPt1.y, controlPt2.y, endPt.y);
    return ({
        x: x,
        y: y
    });
};

// cubic helper formula at percent distance
pathfinding.Pathfinding.prototype.CubicN = function(pct, a, b, c, d) {
	"use strict";
    var t2 = pct * pct;
    var t3 = t2 * pct;
    return a + (-a * 3 + pct * (3 * a - a * pct)) * pct + (3 * b + pct * (-6 * b + b * 3 * pct)) * pct + (c * 3 - c * 3 * pct) * t2 + d * t3;
};

pathfinding.Pathfinding.prototype.setMovement = function(from, to){
	"use strict";
	var tr, track, time = 1000, self = this;
	from = 0;
	to = 19;
	this.animator.removeAllTracks();
	this.animator.events = [];
	var curTime = 0;
	
	tr = this.animator.addTrack("function",this, function(value){
		
		var startPoint = Math.floor(value);
		var endPoint   = Math.ceil(value);		
		var percentage = value - startPoint;
		
		var interpolatedPosition = {
			x: 	(this.positions[startPoint].x + this.positions[endPoint].x) * 0.5,
			y: 	(this.positions[startPoint].y + this.positions[endPoint].y) * 0.5			
		};
		
		interpolatedPosition.y += self.yInterps[startPoint];
		
		var newPosVec = self.getQuadraticBezierXYatPercent(this.positions[startPoint], interpolatedPosition, this.positions[endPoint], percentage);
		
		var dx = newPosVec.x - self.curPosVec.x;
			
		var dy = newPosVec.y - self.curPosVec.y;
		
		var angle = Math.atan2(-dx, dy);
		
		if(angle < 0) { angle += 2.0 * Math.PI; }
		
		self.animFrame = Math.round( angle / (2.0 * Math.PI) * 8);		
		
		self.curPosVec = newPosVec;
	});
	
	this.animator.addKeys(tr, [{time: 0, value:from }, {time: Math.abs(to-from)*1500, value:to}]);	
};


pathfinding.Pathfinding.prototype.handleBeginStep = function(timePassed){
	"use strict";
	this.animator.updateTime(timePassed);
};

pathfinding.Pathfinding.prototype.handleDraw = function() {
	"use strict";
	 if(this.curPosVec){
		 this.image.drawExt(this.animFrame, this.curPosVec.x, this.curPosVec.y, 1, 1, 0, 1);
	 }
};

pathfinding.Pathfinding.prototype.doPrepare = function() {
    "use strict";
    var i;
    // Add the child components
    if (this.components) {
        for (i = 0; i < this.components.length; i += 1) {
            this.addComponent(this.components[i]);
        }
    }
};


//******************************************************
//*****    Script Resource: ComponentAnimation
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.componentDefaults.animation = {
	
	imageEmpty: null,
	imageFill: null,                     // The imageEmpty or surface resource to display
	animationImage: null,
	animationSpeed: 0,                      // The animation speed, in frames per second (can be negative, or 0 for static)
	startSubImage: 0,                       // The sub-imageEmpty at which the animation starts
	loopAnimation: false,                    // Whether to loop when the animation is completed
	roundSubImage: true,                    // Whether to round the sub-imageFills or floor them
	combineSubImages: false,                // Whether to combine the sub-imageFills in one big imageEmpty
	createFromSlices: false,                // Create from 3 or 9 slices (overwrites combineSubImages)
	onAnimationComplete: null,              // Called when the animation is complete
	roundPosition: true,                    // Whether to round the position when the size is odd
	maintainAspectRatio: true,              // Whether to maintain the aspect ratio of the imageEmpty
	components: [],                         // Components to add as children
	id: 0,
	stars: 0,
	timeWaitAnimation: 0.2,
	didCompleteAnimation: false,
	showStar: false,
	startAnimation: false,
	sound: undefined,
	onFinish: null,
	onClick: null,
	onFrameChange: null,
	lastSub: -1
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.Animation = function(properties) {
	"use strict";
	this.name = "Animation";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.animation);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.Animation, tgfComponents.Base);

// Overriden to return the correct width
tgfComponents.Animation.prototype.getWidth = function() {
	"use strict";
	if (this.width > 0) {
		return this.width;
	} else if (!this.imageEmpty) {
		return 0;
	} else if (this.combineSubImages) {
		return this.imageEmpty.combinedWidth;
	} else {
		return this.imageEmpty.width;
	}
};

tgfComponents.Animation.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
	var ww, hh;
	if (!this.onClick) { return; }
	if (this.animationImage === null) { return; }
	if (this.combineSubImages && this.animationImage instanceof tbImage) {
		ww = this.width > 0 ? this.width : this.animationImage.combinedWidth;
		hh = this.height > 0 ? this.height : this.animationImage.combinedHeight;
	} else {
		ww = this.width > 0 ? this.width : this.animationImage.width;
		hh = this.height > 0 ? this.height : this.animationImage.height;
	}
	if (x >= -ww/2 && x <= ww && y >= -hh/2 && y <= hh/2) {
		this.onClick(this);
	}
};

// Overriden to return the correct width
tgfComponents.Animation.prototype.getHeight = function() {
	"use strict";
	if (this.height > 0) {
		return this.height;
	} else if (!this.imageEmpty) {
		return 0;
	} else if (this.combineSubImages) {
		return this.imageEmpty.combinedHeight;
	} else {
		return this.imageEmpty.height;
	}
};

// ***************************************
// Preparing, showing and activating
// ***************************************

tgfComponents.Animation.prototype.initSound = function(id){
	"use strict";
	if(id === this.id){
		tgfAudio.play(this.sound, 730 * (this.id + 1));
	}
};

// Processing required when preparing the component for use
tgfComponents.Animation.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Add the child components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when showing the component
tgfComponents.Animation.prototype.doShow = function() {
	"use strict";
	if(this.id === 0){
		this.startAnimation = true;
	}
	this.subImage = this.startSubImage;
	this.timeWaitAnimation *= 1000;
};


// ***************************************
// Methods called when events must be processed
// ***************************************

// Called just before drawing (also when not active)
tgfComponents.Animation.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
	var newSubImage;
	
	if(this.timeWaitAnimation > 0 && this.startAnimation){
		this.timeWaitAnimation -= 1000 * timePassed /1000;
		return;
	} else if(this.timeWaitAnimation < 1) {this.timeWaitAnimation = 0;}
	
	if (this.animationImage !== null && this.animationImage instanceof tbImage && !this.didCompleteAnimation && this.startAnimation) {
		newSubImage = this.subImage + this.animationSpeed * timePassed/1000;
		if (this.subImage < this.animationImage.number && newSubImage >= this.animationImage.number) {
			if (this.loopAnimation) {
				this.subImage = newSubImage - this.animationImage.number;
			} else {
				this.subImage = this.animationImage.number;
			}
			if (this.onAnimationComplete) { this.onAnimationComplete(this, this.id); this.didCompleteAnimation = true;}
		} else if (this.subImage > 0 && newSubImage < 0) {
			if (this.loopAnimation) {
				this.subImage = this.animationImage.number + newSubImage;
			} else {
				this.subImage = 0;
			}
			if (this.onAnimationComplete) {
				this.onAnimationComplete(this, this.id); 
				this.didCompleteAnimation = true;
			}
		} else {
			this.subImage = newSubImage;

			if(this.lastSub < 0){
				this.lastSub = Math.floor(this.subImage);
				if(this.onFrameChange){
					this.onFrameChange(this.lastSub);
				}
			}else if(this.lastSub < Math.floor(this.subImage)) {
				this.lastSub = Math.floor(this.subImage);
				if(this.onFrameChange){
					this.onFrameChange(this.lastSub);
				}
			}
		}
	}
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.Animation.prototype.doDraw = function() {
	"use strict";
	var subImg, ww, hh, xx, yy, screenAspectRatio, imageFillAspectRatio;
	if (this.imageEmpty !== null){
		ww = this.imageEmpty.width;
		hh = this.imageEmpty.height;
		xx = -ww / 2;
		yy = -hh / 2;
		
		this.imageEmpty.drawSimple(0, xx + this.imageEmpty.xOrigin, yy + this.imageEmpty.yOrigin);
	}
	
	if(this.id < this.stars && this.timeWaitAnimation === 0){
		if (this.animationImage !== null && !this.didCompleteAnimation){
			ww = this.animationImage.width;
			hh = this.animationImage.height;
			xx = -ww / 2;
			yy = -hh / 2;
			subImg = this.roundSubImage ? this.subImage : Math.min(this.image.number-1, Math.floor(this.subImage));
			this.animationImage.drawSimple(subImg, xx + this.animationImage.xOrigin, yy + this.animationImage.yOrigin);
		}
		
		if (this.imageFill !== null){
			ww = this.imageFill.width;
			hh = this.imageFill.height;
			xx = -ww / 2;
			yy = -hh / 2;
			
			this.imageFill.drawSimple(0, xx + this.imageFill.xOrigin, yy + this.imageFill.yOrigin);
		}
	}

	if(this.id === -1 && this.timeWaitAnimation === 0)
	{	
		if (this.animationImage !== null)
		{
			ww = this.animationImage.width;
			hh = this.animationImage.height;
			xx = -ww / 2;
			yy = -hh / 2;
			if (this.didCompleteAnimation)
			{
				subImg = this.animationImage.number - 1;
			} else subImg = this.roundSubImage ? this.subImage : Math.min(this.animationImage.number-1, Math.floor(this.subImage));
			
			this.animationImage.drawSimple(subImg, xx + this.animationImage.xOrigin, yy + this.animationImage.yOrigin);
		}
	}
};


//******************************************************
//*****    Script Resource: ComponentParticleEmitter
//******************************************************

// ***************************************
// tgfComponents.ParticleEmitter
//
// This component displays an animated picture
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 6/4/2017
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */
tgfSettings.componentDefaults.particleEmitter = 
{
    images: [s_tgf_frame],             // The (randomly selected) images of the particles

    position: new tbVector(0, 0),    // Component's position
    
    minDuration: 800,           // The minimum duration of a particles lifetime
    maxDuration: 1000,          // The maxmimum duration of a particles lifetime
    emissionRate: 10,           // The amount of particles that are emmited per second
    maxParticles: 50,           // The max amount of particles allowed to spawn (Match with maxDuration * emissionRate)
    emiting: true,              // Enables particle emitting
    
    particleScaleStart: 0.5,    // At what scale the particle starts off at
    particleScaleEnd: 1,        // At what scale the particle ends at
    
    particleAlphaStart: 1,      // At what alpha the particle starts off at
    particleAlphaEnd: 0.2,      // At what alpha the particle ends at
    
    spawnMinRadius: 0,      // Min random spray radius
    spawnMaxRadius: 50,     // Max random spray radius
    
    targetMinRadius: 0,     // Min random spray radius
    targetMaxRadius: 10,    // Max random spray radius
    
    rotationSpeedMin: 0,    // Min random rotation speed
    rotationSpeedMax: 10,   // Max random rotation speed
    
    particleMinScale: 0.5,  // Min random spray radius
    particleMaxScale: 1,    // Max random spray radius
    
    sprayOrder: [/*new tbVector(0,400)*/],  // (keep empty to spray around the center of the component) Sprays the particles in the following order towards the positions (tbVectors)
    currentSprayOrder: 0,                   // Where to start in the sprayOrder
    randomSprayOrder: false,                // Set to true for a random spray order
    
    movementEaseType: tbEase.easeInOvershoot,   // The ease type for the movement
    alphaEaseType: tbEase.easeLinear,      // The ease type for the alpha
    sizeEaseType: tbEase.easeLinear,       // The ease type for the size

    onParticleSpawned: undefined,           // Callbacks (when a particle has spawned)
    onParticleReachedTarget : undefined,    // Callbacks (when a particle has despawned)
    

    particles: []
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.ParticleEmitter = function(properties)
{
    "use strict";

    this.name = "ParticleEmitter";

    // Initialize properties
    this.initialize(tgfSettings.componentDefaults.particleEmitter);

    // Set user properties
    if (properties !== undefined) 
    { 
        this.setProperties(properties); 
    }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ParticleEmitter, tgfComponents.Base);

tgfComponents.ParticleEmitter.prototype.getActiveParticles = function()
{
    "use strict";

    return this.particles.filter(function(particle)
    {
        return particle.active === true;
    });
};

tgfComponents.ParticleEmitter.prototype.doPrepare = function()
{
    "use strict";
    var self = this;

    for (var i = 0; i < this.maxParticles; ++i)
    {
        this.particles.push
        ({
            image: this.images[ Math.floor(Math.random() * this.images.length) ],   // The particle, represented as an image.
            
            // Particle properties
            position: new tbVector(0,0),
            active: false,
            speed: 15,
            startScale: 1,
            size: 1,
            rotation: 0,
            timeAlive: 0,
            startAlpha: 1,
            alpha: 1,
            duration: Math.random() * (this.maxDuration - this.minDuration) + this.minDuration,
        });
    }

    this._timeSinceLastSpawned  = 0;
    this._spawnRate = 1000 / this.emissionRate;
};

// Called just before drawing (also when not active)
tgfComponents.ParticleEmitter.prototype.handleEndStep = function(timePassed) 
{
	"use strict";

    if (this.emiting)
    {
        this._timeSinceLastSpawned += timePassed;
        if (this._timeSinceLastSpawned > this._spawnRate)
        {       
            this._spawnParticle();

            this._timeSinceLastSpawned = 0;
        }
    }    

    //if (this.emiting)
    for (var i = 0; i < this.maxParticles; ++i)
    {
        var particle = this.particles[i];

        if (particle.active)
        {
            particle.angle += particle.rotation;
            particle.timeAlive += timePassed;
            
            var movementEase = this.movementEaseType(particle.timeAlive, 0, 1, particle.duration, 1, 1);
            var alphaEase = this.alphaEaseType(particle.timeAlive, 0, 1, particle.duration, 1, 1);
            var sizeEase = this.sizeEaseType(particle.timeAlive, 0, 1, particle.duration, 1, 1);
            
            particle.alpha = alphaEase * (this.particleAlphaEnd - this.particleAlphaStart) + this.particleAlphaStart;
            particle.size = particle.startScale * (sizeEase * (this.particleScaleEnd - this.particleScaleStart) + this.particleScaleStart);
            
            particle.position = particle.startPosition.add(
                particle.target.subtract( this.position ).scale( movementEase )
            );
            
            // Despawn if dead
            if (particle.timeAlive > particle.duration)
            {
                particle.active = false;
                if (this.onParticleReachedTarget)
                {
                    this.onParticleReachedTarget(particle);
                }
            }
        }
    }

    //TODO: if the _spawnRate is smaller than timePassed, spawn multiple particles.
};

tgfComponents.ParticleEmitter.prototype.addTarget = function(position)
{
    'use strict';
    
    this.sprayOrder.push(position);
};

tgfComponents.ParticleEmitter.prototype.setTargets = function(arrayOfPositions)
{
    'use strict';
    
    this.clearTargets();
    
    for (var i = 0; i < arrayOfPositions.length; i++) {
        this.sprayOrder.push( arrayOfPositions[i] );
    }
};

tgfComponents.ParticleEmitter.prototype.clearTargets = function()
{
    'use strict';
    
    for (var i = 0; i < this.sprayOrder.length; i++) {
        delete this.sprayOrder[i];
    }
    this.sprayOrder.push();
};

tgfComponents.ParticleEmitter.prototype._spawnParticle = function(properties)
{
    'use strict';

    var self = this;

    for (var i = 0; i < this.maxParticles; ++i)
    {
        var particle = this.particles[i];

        if (!particle.active)
        {
            // Get spawn location
            var startPosition = this.position.clone();
            
            // Add randomness
            var randomDirection = new tbVector(Math.random()-0.5, Math.random()-0.5).normal(); // Get random direction
            
            randomDirection.scaleDirect( Math.random() * (this.spawnMaxRadius - this.spawnMinRadius) + this.spawnMinRadius ); // Set random distance
            
            startPosition.addDirect( randomDirection );
            
            particle.active = true;
            particle.startPosition = startPosition;
            particle.target = self.getNextTarget();
            particle.startScale = Math.random() * (self.particleMaxScale - self.particleMinScale) + self.particleMinScale;
            particle.size = particle.startScale;
            particle.startAlpha = this.particleAlphaStart;
            particle.alpha = 1;
            particle.angle = 0;
            particle.rotation = (Math.random() * this.rotationSpeedMax) + this.rotationSpeedMin;
            particle.timeAlive = 0;
            particle.movementEaseType = this.movementEaseType;
            particle.alphaEaseType = this.alphaEaseType;
            particle.sizeEaseType = this.sizeEaseType;
            particle.duration = Math.random() * (this.maxDuration - this.minDuration) + this.minDuration;

            if (this.onParticleSpawned)
            {
                this.onParticleSpawned(particle);
            }
            if (properties !== undefined) 
            { 
                particle.setProperties(properties); 
            }

            break;
        }
    } 
};

tgfComponents.ParticleEmitter.prototype.getNextTarget = function()
{
    'use strict';
    
    if (this.randomSprayOrder)
    {
        this.currentSprayOrder = Math.floor(Math.random() * this.sprayOrder.length);
    } else {
        this.currentSprayOrder = (this.currentSprayOrder + 1) % this.sprayOrder.length;
    }
    
    // Get target destination
    var sprayPos = this.sprayOrder[ this.currentSprayOrder ];
    var endPosition = sprayPos !== undefined ? sprayPos.clone() : this.position.clone();
    
    // Add randomness
    var randomDirection = new tbVector(Math.random()-0.5, Math.random()-0.5).normal(); // Get random direction
    
    randomDirection.scaleDirect( Math.random() * (this.targetMaxRadius - this.targetMinRadius) + this.targetMinRadius ); // Set random distance
    
    // Apply randomness
    endPosition.addDirect( randomDirection );
    

    return endPosition;
};

tgfComponents.ParticleEmitter.prototype.startEmitting = function()
{
    'use strict';

    this.emiting = true;
};

tgfComponents.ParticleEmitter.prototype.stopEmitting = function()
{
    'use strict';

    this.emiting = false;
};

tgfComponents.ParticleEmitter.prototype.doDraw = function()
{
    "use strict";
    for (var i = 0; i < this.particles.length; ++i)
    {
        var particle = this.particles[i];

        if (particle.active)
        {
            particle.image.drawExt(0, particle.position.x, particle.position.y, particle.size, particle.size, particle.angle, particle.alpha);                    
        }
    }
};

//******************************************************
//*****    Script Resource: ComponentAvatar
//******************************************************

// ***************************************
// tgfComponents.ComponentAvatar
//
// ***************************************
tgfSettings.componentDefaults.componentAvatar = 
{   
    rank: null,  // rank object as found in rankData
    rankId: 1,   // id of the rank, this is the fallback if rank is not defined
    alphaMask: s_dest_in,
    baseWidth: tgfScale(100),
    baseHeight: tgfScale(100),
    width: tgfScale(100),
    height: tgfScale(100),
    profilePictureProperties: {
        x: tgfScale(-4),
        y: tgfScale(0),
        width: tgfScale(100),
        height: tgfScale(100),
    },
    rankPictureProperties: {},
    rankLabelProperties: {
        display: true,
        x: tgfScale(42),
        y: tgfScale(32),
        font: {fontFace: f_tgf_text.fontFace, fontSize: 30, fillColor: "#666666", baseline: "middle", align: "center"},
        width: tgfScale(24),
        height: tgfScale(24),
    },
    rankData: undefined,
    components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.ComponentAvatar = function(properties) 
{
    "use strict";
    this.name = "Avatar";         // The name of the component
    
    //if getProfileImage is defined, use that. Otherwise fall back to Mitch.
    this.profileImage = tgfHooks.getProfileImage ? tgfHooks.getProfileImage() : null;

    // Initialize properties
    this.initialize(tgfSettings.componentDefaults.componentAvatar);
    // Set user properties
    if (properties !== undefined) { this.setProperties(properties); }

    if (typeof TG !== 'undefined') {
        this.rankData = TG.settings.game.ranks;
    } else if(tgfSettings.game && tgfSettings.game.ranks){
        this.rankData = tgfSettings.game.ranks;
    }
    if (!this.rankData){
        console.error("[ComponentAvatar] No rankData found. Can not construct ComponentAvatar.");   
    }

    this.rankImage = null;
    this.profileSurface = null;
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ComponentAvatar, tgfComponents.Base);

// Processing required when preparing the component for use
tgfComponents.ComponentAvatar.prototype.doPrepare = function()
{
    "use strict";
    var i;
    var self = this;

    // scaling
    this.xScale = this.width / this.baseWidth;
    this.yScale = this.height / this.baseHeight;
    this.width = this.width / this.xScale; // width and height corrected for scale
    this.height = this.height / this.yScale;


    // take the rank if provided, otherwise search for the correct one
    var currentRank;
    if (!this.rank) 
    {
        this.rank = this.getRankDataFor(this.rankId); 
    } else 
    {
        this.rankId = this.rank.rankId;
    }

    this.rankImage = this.rank.rankImage;
    
    // profile picture
    this.profileSurface = new tbSurface(this.alphaMask.width, this.alphaMask.height);
    this.profileSurface.clear();
    this.profileSurface.context.translate(this.alphaMask.xOrigin, this.alphaMask.yOrigin);
    this.profileSurface.xOrigin = this.alphaMask.xOrigin;
    this.profileSurface.yOrigin = this.alphaMask.yOrigin;

    this.profileSurface.setTarget();

    if (this.profileImage)
    {
        this.profileImage.drawStretched(0, -this.alphaMask.xOrigin, -this.alphaMask.yOrigin, this.alphaMask.width, this.alphaMask.height, 1);        
    }

    tbGraphics.context.globalCompositeOperation = "destination-in";
    this.alphaMask.drawSimple(0, 0, 0);
    tbGraphics.context.globalCompositeOperation = "source-over";
    this.profileSurface.resetTarget();

    this.profilePicture = new tgfComponents.Picture
    ({
        image: this.profileSurface
    });

    this.profilePicture.setProperties(this.profilePictureProperties);
    
    this.addComponent(this.profilePicture);

    // frame + deco
    for(i = 0; i < this.rankImage.length; i++) 
    {
        var rankImageProps = this.rankImage[i];
        var pictureComp = new tgfComponents.Picture(this.rankPictureProperties);
        pictureComp.image = rankImageProps.image;
        pictureComp.x += rankImageProps.x;
        pictureComp.y += rankImageProps.y;
        
        this.addComponent(pictureComp);
    }

    // rank number
    if (this.rankLabelProperties.display)
    {
        this.rankLabel = new tgfComponents.Label(this.rankLabelProperties);
        this.addComponent(this.rankLabel);
        this.rankLabel.text = "" + this.rankId;
    }
    // Add the child components
    if (this.components) 
    {
        for (i = 0; i < this.components.length; i += 1) 
        {
            this.addComponent(this.components[i]);
        }
    }
};

tgfComponents.ComponentAvatar.prototype.getRankDataFor = function (rankId) 
{
    "use strict";
    return this.rankData.find(function (element) 
    {
        return element.rankId === rankId;
    });
};


//******************************************************
//*****    Script Resource: Tween
//******************************************************

function Tween(node, attributes, duration, easing, callback) {
	"use strict";
	var i=0;

	this.active = false;
	this.visible = false;
	this.group = 0;

	this.node = node;
	this.attributes = attributes;
	this.duration = duration;
	this.callback = callback;
	this.easing = easing;

	this.deltaTime = 0;
	this.begin = {};
	for (i in this.attributes) {
		if (this.attributes.hasOwnProperty(i)){
			this.begin[i] = node[i];
		}
	}

	this.delta = {};
	for (i in this.attributes) {
		if (this.attributes.hasOwnProperty(i)){
			this.delta[i] = this.attributes[i] - this.begin[i];
		}
	}

	tbGame.addToken(this);
}

Tween.prototype.finish = function( timePassed ) {

	this.active = false;
	tbGame.removeToken(this);
	for (i in this.attributes) {
		if (this.attributes.hasOwnProperty(i)){
			this.node[i] = this.attributes[i];
		}
	}

	if(typeof(this.callback) !== "undefined") {
		this.callback();
	}

};

Tween.prototype.handleBeginStep = function( timePassed ) {
	"use strict";
	var i=0, c, dt, b, d;

	this.deltaTime += timePassed;

	if (this.deltaTime < this.duration) {

		for (i in this.attributes) {
			if (this.attributes.hasOwnProperty(i)){
				c = this.delta[i];
				dt = this.deltaTime;
				b = this.begin[i];
				d = this.duration;

				 this.node[i] = this.easing(dt, b, c, d);
			}
		}
	}
	else {
		this.finish();
	}
};

Tween.prototype.start = function() {
	this.active = true;
};

Tween.prototype.pause = function() {
	this.active = false;
};
//******************************************************
//*****    Script Resource: Easer
//******************************************************

/**
 * @constructor Easer
 */
var Easer = function(initial, defaultDuration, easeFunction, clampFunction) {
	"use strict";
	this.from = initial;
	this.to = initial;
	this.defaultDuration = defaultDuration;
	this.duration = 1;
	this.clampFunction = clampFunction;
	this.easeFunction = easeFunction;
	this.callBackFunction = null;
	this.totalTimePassed = 0;
};

Easer.prototype.addTime = function(timePassed) {
	"use strict";
	this.totalTimePassed += timePassed;
	if (this.totalTimePassed > this.duration) {
		if (this.callBackFunction) {
			this.callBackFunction();
			this.callBackFunction = null;
		}
	}
};

Easer.prototype.getValue = function() {
	"use strict";

	if (this.totalTimePassed >= this.duration) {
		return this.easeFunction(this.duration, this.from, this.to - this.from, this.duration);
	}

	var result = this.easeFunction(this.totalTimePassed, this.from, this.to - this.from, this.duration);

	if (this.clampFunction) {
		result = this.clampFunction(result);
	}
	return result;
};

Easer.prototype.easeTo = function(to, duration, callBackFunction) {
	"use strict";
	this.from = this.getValue();
	this.to = to;
	this.duration = duration || this.defaultDuration;
	this.callBackFunction = callBackFunction;
	this.totalTimePassed = 0;
};

Easer.prototype.isDone = function() {
	"use strict";
	return this.totalTimePassed > this.duration;
};
//******************************************************
//*****    Script Resource: framework3_dictionary
//******************************************************

// **********************************************
// Localization file for game: frameworkdictionary
//
// created on 8/9/2018 4:34:03 PM
// **********************************************

/*exported dictionaryVar*/
var dictionaryVar = dictionaryVar || {};
dictionaryVar["nl-nl"] = dictionaryVar["nl-nl"] || {};
dictionaryVar["nl-nl"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["nl-nl"]["challengeForfeitMessage_winnings"] = "<NAME> heeft <AMOUNT> Fairplay munten gewonnen!";
dictionaryVar["nl-nl"]["challengeEndScreenChallengeSend_submessage_stranger"] = "Als niemand binnen 72 uur je uitdaging accepteert, worden je inzet en uitdagingskosten teruggestort.";
dictionaryVar["nl-nl"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> heeft 72 uur om de uitdaging aan te nemen of te weigeren. Als <NAME> je uitdaging weigert of niet accepteert binnen 72 uur worden je inzet en uitdagingskosten teruggestort.";
dictionaryVar["nl-nl"]["levelEndScreenHighScore_number"] = "Topscore:";
dictionaryVar["nl-nl"]["levelEndScreenTotalScore_number"] = "Totale score:";
dictionaryVar["nl-nl"]["optionsExit"] = "Stoppen";
dictionaryVar["nl-nl"]["optionsLang_ru-ru"] = "Russisch";
dictionaryVar["nl-nl"]["optionsLang_pt-br"] = "Braziliaans-Portugees";
dictionaryVar["nl-nl"]["optionsLang_es-es"] = "Spaans";
dictionaryVar["nl-nl"]["optionsLang_ar-eg"] = "Arabisch";
dictionaryVar["nl-nl"]["optionsLang_ko-kr"] = "Koreaans";
dictionaryVar["nl-nl"]["optionsLang_fr-fr"] = "Frans";
dictionaryVar["nl-nl"]["levelEndScreenTotalScore_time"] = "Totale tijd:";
dictionaryVar["nl-nl"]["levelEndScreenHighScore_time"] = "Beste tijd:";
dictionaryVar["nl-nl"]["challengeLoadingError_notStarted"] = "Kan de server niet bereiken. Probeer het later nog een keer.";
dictionaryVar["nl-nl"]["challengeLoadingError_notValid"] = "Sorry, deze uitdaging kan niet meer gespeeld worden.";
dictionaryVar["nl-nl"]["optionsChallengeCancel"] = "Stop";
dictionaryVar["nl-nl"]["optionsChallengeForfeit"] = "Geef op";
dictionaryVar["nl-nl"]["challengeForfeitMessage_error"] = "Er is een fout opgetreden tijdens het opgeven van de uitdaging. Probeer het later nog een keer.";
dictionaryVar["nl-nl"]["challengeForfeitMessage_success"] = "Je hebt de uitdaging opgegeven.";
dictionaryVar["nl-nl"]["challengeForfeitConfirmBtn_no"] = "Nee";
dictionaryVar["nl-nl"]["challengeForfeitConfirmBtn_yes"] = "Ja";
dictionaryVar["nl-nl"]["challengeForfeitConfirmText"] = "Je staat op het punt de uitdaging op te geven. Weet je zeker dat je dit wilt doen?";
dictionaryVar["nl-nl"]["challengeStartTextScore_challenger"] = "Speel het spel en zet een score neer.";
dictionaryVar["nl-nl"]["challengeStartTextTime_challenger"] = "Speel het spel en zet een tijd neer.";
dictionaryVar["nl-nl"]["challengeStartScreenTitle_challenger_stranger"] = "Je zet een uitdaging voor:";
dictionaryVar["nl-nl"]["challengeStartScreenTitle_challenger_friend"] = "Jouw tegenstander:";
dictionaryVar["nl-nl"]["challengeStartScreenTitle_challengee_stranger"] = "Jouw tegenstander:";
dictionaryVar["nl-nl"]["challengeEndScreenScoreSend_error"] = "Er is een fout opgetreden tijdens de communicatie met de server. Probeer het later nog een keer.";
dictionaryVar["nl-nl"]["challengeCancelMessage_success"] = "De uitdaging is geannuleerd.";
dictionaryVar["nl-nl"]["challengeCancelMessage_error"] = "Er is een fout opgetreden bij het annuleren van de uitdaging. Probeer het later nog een keer.";
dictionaryVar["nl-nl"]["challengeEndScreenChallengeSend_success"] = "Je uitdaging is verstuurd!";
dictionaryVar["nl-nl"]["challengeEndScreenChallengeSend_error"] = "Er is een fout opgetreden bij het versturen van de uitdaging. Probeer het later nog een keer.";
dictionaryVar["nl-nl"]["challengeEndScreenName_you"] = "Jij";
dictionaryVar["nl-nl"]["challengeEndScreenBtn_cancel"] = "Annuleer uitdaging";
dictionaryVar["nl-nl"]["challengeEndScreensBtn_submit"] = "Verstuur uitdaging";
dictionaryVar["nl-nl"]["challengeCancelConfirmBtn_no"] = "Nee";
dictionaryVar["nl-nl"]["challengeCancelConfirmBtn_yes"] = "Ja";
dictionaryVar["nl-nl"]["challengeCancelConfirmText"] = "Je staat op het punt de uitdaging te annuleren. Je inzet wordt teruggestort minus de uitdagingskosten. Weet je zeker dat je de uitdaging wilt annuleren? ";
dictionaryVar["nl-nl"]["challengeEndScreenOutcomeMessage_TIED"] = "Jullie hebben gelijk gespeeld.";
dictionaryVar["nl-nl"]["challengeEndScreenOutcomeMessage_LOST"] = "Je hebt de uitdaging verloren.";
dictionaryVar["nl-nl"]["challengeEndScreenOutcomeMessage_WON"] = "Je hebt de uitdaging gewonnen!";
dictionaryVar["nl-nl"]["challengeEndScreenWinnings"] = "Je hebt <AMOUNT> Fairplay munten gewonnen!";
dictionaryVar["nl-nl"]["challengeStartScreenToWin"] = "Te winnen aantal Fairplay munten:";
dictionaryVar["nl-nl"]["challengeStartTextTime"] = "Tijd van <NAME>:";
dictionaryVar["nl-nl"]["challengeStartTextScore"] = "Punten van <NAME>:";
dictionaryVar["nl-nl"]["challengeStartScreenTitle_challengee_friend"] = "Je bent uitgedaagd door:";
dictionaryVar["nl-nl"]["levelEndScreenSubmitHighscoreBtn"] = "Score verzenden";
dictionaryVar["nl-nl"]["levelEndScreenViewHighscoreBtn"] = "Scores bekijken";
dictionaryVar["nl-nl"]["optionsAbout_header"] = "Ontwikkeld door:";
dictionaryVar["nl-nl"]["optionsLang_tr-tr"] = "Turks";
dictionaryVar["nl-nl"]["optionsLang_de-de"] = "Duits";
dictionaryVar["nl-nl"]["startScreenByTinglyGames"] = "door: CoolGames";
dictionaryVar["nl-nl"]["levelMapScreenWorld_0"] = "Kies een level";
dictionaryVar["nl-nl"]["startScreenQuestionaire"] = "Wat vind jij?";
dictionaryVar["nl-nl"]["levelEndScreenMedal"] = "VERBETERD!";
dictionaryVar["nl-nl"]["optionsAbout"] = "Over ons";
dictionaryVar["nl-nl"]["optionsAbout_version"] = "versie:";
dictionaryVar["nl-nl"]["optionsAbout_backBtn"] = "Terug";
dictionaryVar["nl-nl"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\nCopyright  2018";
dictionaryVar["nl-nl"]["optionsAbout_title"] = "Over ons";
dictionaryVar["nl-nl"]["optionsSFXBig_off"] = "Geluid uit";
dictionaryVar["nl-nl"]["optionsSFXBig_on"] = "Geluid aan";
dictionaryVar["nl-nl"]["optionsRestart"] = "Herstart";
dictionaryVar["nl-nl"]["optionsRestartConfirmationText"] = "Pas op!\n\nAls je nu herstart verlies je alle voortgang in dit level. Weet je zeker dat je wilt herstarten?";
dictionaryVar["nl-nl"]["levelMapScreenTitle"] = "Kies een level";
dictionaryVar["nl-nl"]["optionsQuitConfirmBtn_Yes"] = "Ja, ik weet het zeker";
dictionaryVar["nl-nl"]["optionsQuitConfirmBtn_No"] = "Nee";
dictionaryVar["nl-nl"]["optionsQuitConfirmationText"] = "Pas op!\n\nAls je nu stopt verlies je alle voortgang in dit level. Weet je zeker dat je wilt stoppen?";
dictionaryVar["nl-nl"]["optionsTitle"] = "Instellingen";
dictionaryVar["nl-nl"]["gameEndScreenBtnText"] = "Ga verder";
dictionaryVar["nl-nl"]["gameEndScreenTitle"] = "Gefeliciteerd!\nJe hebt gewonnen.";
dictionaryVar["nl-nl"]["optionsLang_nl-nl"] = "Nederlands";
dictionaryVar["nl-nl"]["optionsLang_en-gb"] = "Engels (GB)";
dictionaryVar["nl-nl"]["optionsLang_en-us"] = "Engels (US)";
dictionaryVar["nl-nl"]["optionsSFX_off"] = "Uit";
dictionaryVar["nl-nl"]["optionsSFX_on"] = "Aan";
dictionaryVar["nl-nl"]["optionsMusic_off"] = "Uit";
dictionaryVar["nl-nl"]["optionsMusic_on"] = "Aan";
dictionaryVar["nl-nl"]["optionsDifficulty_hard"] = "Moeilijk";
dictionaryVar["nl-nl"]["optionsDifficulty_medium"] = "Gemiddeld";
dictionaryVar["nl-nl"]["optionsDifficulty_easy"] = "Makkelijk";
dictionaryVar["nl-nl"]["optionsMoreGames"] = "Meer Spellen";
dictionaryVar["nl-nl"]["optionsHighScore"] = "High scores";
dictionaryVar["nl-nl"]["optionsTutorial"] = "Speluitleg";
dictionaryVar["nl-nl"]["optionsResume"] = "Terug naar spel";
dictionaryVar["nl-nl"]["optionsQuit"] = "Stop";
dictionaryVar["nl-nl"]["optionsStartScreen"] = "Hoofdmenu";
dictionaryVar["nl-nl"]["levelEndScreenHighScore"] = "High score";
dictionaryVar["nl-nl"]["levelEndScreenTimeBonus"] = "Tijdbonus";
dictionaryVar["nl-nl"]["levelEndScreenTimeLeft"] = "Tijd over";
dictionaryVar["nl-nl"]["levelEndScreenSubTitle_levelFailed"] = "Level niet gehaald";
dictionaryVar["nl-nl"]["levelEndScreenTotalScore"] = "Totale score";
dictionaryVar["nl-nl"]["levelEndScreenTitle_endless"] = "Level <VALUE>";
dictionaryVar["nl-nl"]["levelEndScreenTitle_difficulty"] = "Goed Gedaan!";
dictionaryVar["nl-nl"]["levelEndScreenTitle_level"] = "Level <VALUE>";
dictionaryVar["nl-nl"]["levelMapScreenTotalScore"] = "Totale score";
dictionaryVar["nl-nl"]["startScreenPlay"] = "SPELEN";
dictionaryVar["nl-nl"]["loadingScreenLoading"] = "Laden...";
dictionaryVar["nl-nl"]["RewardAd_button"] = "video";
dictionaryVar["nl-nl"]["RewardAd_header"] = "coins";
dictionaryVar["nl-nl"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["nl-nl"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["en-us"] = dictionaryVar["en-us"] || {};
dictionaryVar["en-us"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["en-us"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["en-us"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["en-us"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["en-us"]["levelEndScreenHighScore_number"] = "High score:";
dictionaryVar["en-us"]["levelEndScreenTotalScore_number"] = "Total score:";
dictionaryVar["en-us"]["optionsExit"] = "Exit";
dictionaryVar["en-us"]["optionsLang_ru-ru"] = "Russian";
dictionaryVar["en-us"]["optionsLang_pt-br"] = "Brazilian-Portuguese";
dictionaryVar["en-us"]["optionsLang_es-es"] = "Spanish";
dictionaryVar["en-us"]["optionsLang_ar-eg"] = "Arabic";
dictionaryVar["en-us"]["optionsLang_ko-kr"] = "Korean";
dictionaryVar["en-us"]["optionsLang_fr-fr"] = "French";
dictionaryVar["en-us"]["levelEndScreenTotalScore_time"] = "Total time:";
dictionaryVar["en-us"]["levelEndScreenHighScore_time"] = "Best time:";
dictionaryVar["en-us"]["challengeLoadingError_notStarted"] = "Unable to connect to the server. Please try again later.";
dictionaryVar["en-us"]["challengeLoadingError_notValid"] = "Sorry, this challenge is no longer valid.";
dictionaryVar["en-us"]["optionsChallengeCancel"] = "Quit";
dictionaryVar["en-us"]["optionsChallengeForfeit"] = "Forfeit";
dictionaryVar["en-us"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["en-us"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["en-us"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["en-us"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["en-us"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["en-us"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["en-us"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["en-us"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["en-us"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["en-us"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["en-us"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["en-us"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["en-us"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["en-us"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["en-us"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["en-us"]["challengeEndScreenName_you"] = "You";
dictionaryVar["en-us"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["en-us"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["en-us"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["en-us"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["en-us"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["en-us"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["en-us"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["en-us"]["challengeEndScreenOutcomeMessage_WON"] = "You have won the challenge!";
dictionaryVar["en-us"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["en-us"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["en-us"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["en-us"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["en-us"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["en-us"]["levelEndScreenSubmitHighscoreBtn"] = "Submit score";
dictionaryVar["en-us"]["levelEndScreenViewHighscoreBtn"] = "View scores";
dictionaryVar["en-us"]["optionsAbout_header"] = "Developed by:";
dictionaryVar["en-us"]["optionsLang_tr-tr"] = "Turkish";
dictionaryVar["en-us"]["optionsLang_de-de"] = "German";
dictionaryVar["en-us"]["startScreenByTinglyGames"] = "by: CoolGames";
dictionaryVar["en-us"]["levelMapScreenWorld_0"] = "Select a level";
dictionaryVar["en-us"]["startScreenQuestionaire"] = "What do you think?";
dictionaryVar["en-us"]["levelEndScreenMedal"] = "IMPROVED!";
dictionaryVar["en-us"]["optionsAbout"] = "About";
dictionaryVar["en-us"]["optionsAbout_version"] = "version:";
dictionaryVar["en-us"]["optionsAbout_backBtn"] = "Back";
dictionaryVar["en-us"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["en-us"]["optionsAbout_title"] = "About";
dictionaryVar["en-us"]["optionsSFXBig_off"] = "Sound off";
dictionaryVar["en-us"]["optionsSFXBig_on"] = "Sound on";
dictionaryVar["en-us"]["optionsRestart"] = "Restart";
dictionaryVar["en-us"]["optionsRestartConfirmationText"] = "Attention!\n\nIf you restart now you will lose all progress made during this level. Are you sure you want to restart?";
dictionaryVar["en-us"]["levelMapScreenTitle"] = "Select a level";
dictionaryVar["en-us"]["optionsQuitConfirmBtn_Yes"] = "Yes, I'm sure";
dictionaryVar["en-us"]["optionsQuitConfirmBtn_No"] = "No";
dictionaryVar["en-us"]["optionsQuitConfirmationText"] = "Attention!\n\nIf you quit now you will lose all progress made during this level. Are you sure you want to quit?";
dictionaryVar["en-us"]["optionsTitle"] = "Settings";
dictionaryVar["en-us"]["gameEndScreenBtnText"] = "Continue";
dictionaryVar["en-us"]["gameEndScreenTitle"] = "Congratulations!\nYou have completed the game.";
dictionaryVar["en-us"]["optionsLang_nl-nl"] = "Dutch";
dictionaryVar["en-us"]["optionsLang_en-gb"] = "English (GB)";
dictionaryVar["en-us"]["optionsLang_en-us"] = "English (US)";
dictionaryVar["en-us"]["optionsSFX_off"] = "Off";
dictionaryVar["en-us"]["optionsSFX_on"] = "On";
dictionaryVar["en-us"]["optionsMusic_off"] = "Off";
dictionaryVar["en-us"]["optionsMusic_on"] = "On";
dictionaryVar["en-us"]["optionsDifficulty_hard"] = "Difficult";
dictionaryVar["en-us"]["optionsDifficulty_medium"] = "Medium";
dictionaryVar["en-us"]["optionsDifficulty_easy"] = "Easy";
dictionaryVar["en-us"]["optionsMoreGames"] = "More Games";
dictionaryVar["en-us"]["optionsHighScore"] = "High scores";
dictionaryVar["en-us"]["optionsTutorial"] = "How to play";
dictionaryVar["en-us"]["optionsResume"] = "Resume";
dictionaryVar["en-us"]["optionsQuit"] = "Quit";
dictionaryVar["en-us"]["optionsStartScreen"] = "Main menu";
dictionaryVar["en-us"]["levelEndScreenHighScore"] = "High score";
dictionaryVar["en-us"]["levelEndScreenTimeBonus"] = "Time bonus";
dictionaryVar["en-us"]["levelEndScreenTimeLeft"] = "Time remaining";
dictionaryVar["en-us"]["levelEndScreenSubTitle_levelFailed"] = "Level failed";
dictionaryVar["en-us"]["levelEndScreenTotalScore"] = "Total score";
dictionaryVar["en-us"]["levelEndScreenTitle_endless"] = "Stage <VALUE>";
dictionaryVar["en-us"]["levelEndScreenTitle_difficulty"] = "Well done!";
dictionaryVar["en-us"]["levelEndScreenTitle_level"] = "Level <VALUE>";
dictionaryVar["en-us"]["levelMapScreenTotalScore"] = "Total score";
dictionaryVar["en-us"]["startScreenPlay"] = "PLAY";
dictionaryVar["en-us"]["loadingScreenLoading"] = "Loading...";
dictionaryVar["en-us"]["RewardAd_button"] = "video";
dictionaryVar["en-us"]["RewardAd_header"] = "coins";
dictionaryVar["en-us"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["en-us"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["en-gb"] = dictionaryVar["en-gb"] || {};
dictionaryVar["en-gb"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["en-gb"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["en-gb"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["en-gb"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["en-gb"]["levelEndScreenHighScore_number"] = "High score:";
dictionaryVar["en-gb"]["levelEndScreenTotalScore_number"] = "Total score:";
dictionaryVar["en-gb"]["optionsExit"] = "Exit";
dictionaryVar["en-gb"]["optionsLang_ru-ru"] = "Russian";
dictionaryVar["en-gb"]["optionsLang_pt-br"] = "Brazilian-Portuguese";
dictionaryVar["en-gb"]["optionsLang_es-es"] = "Spanish";
dictionaryVar["en-gb"]["optionsLang_ar-eg"] = "Arabic";
dictionaryVar["en-gb"]["optionsLang_ko-kr"] = "Korean";
dictionaryVar["en-gb"]["optionsLang_fr-fr"] = "French";
dictionaryVar["en-gb"]["levelEndScreenTotalScore_time"] = "Total time:";
dictionaryVar["en-gb"]["levelEndScreenHighScore_time"] = "Best time:";
dictionaryVar["en-gb"]["challengeLoadingError_notStarted"] = "Unable to connect to the server. Please try again later.";
dictionaryVar["en-gb"]["challengeLoadingError_notValid"] = "Sorry, this challenge is no longer valid.";
dictionaryVar["en-gb"]["optionsChallengeCancel"] = "Quit";
dictionaryVar["en-gb"]["optionsChallengeForfeit"] = "Forfeit";
dictionaryVar["en-gb"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["en-gb"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["en-gb"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["en-gb"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["en-gb"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you wish to proceed?";
dictionaryVar["en-gb"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["en-gb"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["en-gb"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["en-gb"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["en-gb"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["en-gb"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["en-gb"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["en-gb"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["en-gb"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["en-gb"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["en-gb"]["challengeEndScreenName_you"] = "You";
dictionaryVar["en-gb"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["en-gb"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["en-gb"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["en-gb"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["en-gb"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["en-gb"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["en-gb"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["en-gb"]["challengeEndScreenOutcomeMessage_WON"] = "You have won the challenge!";
dictionaryVar["en-gb"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["en-gb"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["en-gb"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["en-gb"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["en-gb"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["en-gb"]["levelEndScreenSubmitHighscoreBtn"] = "Submit score";
dictionaryVar["en-gb"]["levelEndScreenViewHighscoreBtn"] = "View scores";
dictionaryVar["en-gb"]["optionsAbout_header"] = "Developed by:";
dictionaryVar["en-gb"]["optionsLang_tr-tr"] = "Turkish";
dictionaryVar["en-gb"]["optionsLang_de-de"] = "German";
dictionaryVar["en-gb"]["startScreenByTinglyGames"] = "by: CoolGames";
dictionaryVar["en-gb"]["levelMapScreenWorld_0"] = "Select a level";
dictionaryVar["en-gb"]["startScreenQuestionaire"] = "What do you think?";
dictionaryVar["en-gb"]["levelEndScreenMedal"] = "IMPROVED!";
dictionaryVar["en-gb"]["optionsAbout"] = "About";
dictionaryVar["en-gb"]["optionsAbout_version"] = "version:";
dictionaryVar["en-gb"]["optionsAbout_backBtn"] = "Back";
dictionaryVar["en-gb"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["en-gb"]["optionsAbout_title"] = "About";
dictionaryVar["en-gb"]["optionsSFXBig_off"] = "Sound off";
dictionaryVar["en-gb"]["optionsSFXBig_on"] = "Sound on";
dictionaryVar["en-gb"]["optionsRestart"] = "Restart";
dictionaryVar["en-gb"]["optionsRestartConfirmationText"] = "Attention!\n\nIf you restart now you will lose all progress made during this level. Are you sure you want to restart?";
dictionaryVar["en-gb"]["levelMapScreenTitle"] = "Select a level";
dictionaryVar["en-gb"]["optionsQuitConfirmBtn_Yes"] = "Yes, I'm sure";
dictionaryVar["en-gb"]["optionsQuitConfirmBtn_No"] = "No";
dictionaryVar["en-gb"]["optionsQuitConfirmationText"] = "Attention!\n\nIf you quit now you will lose all progress made during this level. Are you sure you want to quit?";
dictionaryVar["en-gb"]["optionsTitle"] = "Settings";
dictionaryVar["en-gb"]["gameEndScreenBtnText"] = "Continue";
dictionaryVar["en-gb"]["gameEndScreenTitle"] = "Congratulations!\nYou have completed the game.";
dictionaryVar["en-gb"]["optionsLang_nl-nl"] = "Dutch";
dictionaryVar["en-gb"]["optionsLang_en-gb"] = "English (GB)";
dictionaryVar["en-gb"]["optionsLang_en-us"] = "English (US)";
dictionaryVar["en-gb"]["optionsSFX_off"] = "Off";
dictionaryVar["en-gb"]["optionsSFX_on"] = "On";
dictionaryVar["en-gb"]["optionsMusic_off"] = "Off";
dictionaryVar["en-gb"]["optionsMusic_on"] = "On";
dictionaryVar["en-gb"]["optionsDifficulty_hard"] = "Difficult";
dictionaryVar["en-gb"]["optionsDifficulty_medium"] = "Medium";
dictionaryVar["en-gb"]["optionsDifficulty_easy"] = "Easy";
dictionaryVar["en-gb"]["optionsMoreGames"] = "More Games";
dictionaryVar["en-gb"]["optionsHighScore"] = "High scores";
dictionaryVar["en-gb"]["optionsTutorial"] = "How to play";
dictionaryVar["en-gb"]["optionsResume"] = "Resume";
dictionaryVar["en-gb"]["optionsQuit"] = "Quit";
dictionaryVar["en-gb"]["optionsStartScreen"] = "Main menu";
dictionaryVar["en-gb"]["levelEndScreenHighScore"] = "High score";
dictionaryVar["en-gb"]["levelEndScreenTimeBonus"] = "Time bonus";
dictionaryVar["en-gb"]["levelEndScreenTimeLeft"] = "Time remaining";
dictionaryVar["en-gb"]["levelEndScreenSubTitle_levelFailed"] = "Level failed";
dictionaryVar["en-gb"]["levelEndScreenTotalScore"] = "Total score";
dictionaryVar["en-gb"]["levelEndScreenTitle_endless"] = "Stage <VALUE>";
dictionaryVar["en-gb"]["levelEndScreenTitle_difficulty"] = "Well done!";
dictionaryVar["en-gb"]["levelEndScreenTitle_level"] = "Level <VALUE>";
dictionaryVar["en-gb"]["levelMapScreenTotalScore"] = "Total score";
dictionaryVar["en-gb"]["startScreenPlay"] = "PLAY";
dictionaryVar["en-gb"]["loadingScreenLoading"] = "Loading...";
dictionaryVar["en-gb"]["RewardAd_button"] = "video";
dictionaryVar["en-gb"]["RewardAd_header"] = "coins";
dictionaryVar["en-gb"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["en-gb"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["de-de"] = dictionaryVar["de-de"] || {};
dictionaryVar["de-de"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["de-de"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["de-de"]["challengeEndScreenChallengeSend_submessage_stranger"] = "Als niemanden Deine Herausforderung innerhalb von 72 Stunden annimmt, werden Dir Deinen Wetteinsatz Einsatzgebhr zurckerstattet.";
dictionaryVar["de-de"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> hat 72 Stunden um die Wette anzunehmen oder abzulehnen. Sollte <NAME> nicht reagieren oder ablehnen werden Dir Dein Wetteinsatz und die Gebhr zurckerstattet.";
dictionaryVar["de-de"]["levelEndScreenHighScore_number"] = "Highscore:";
dictionaryVar["de-de"]["levelEndScreenTotalScore_number"] = "Gesamtpunktzahl:";
dictionaryVar["de-de"]["optionsExit"] = "Verlassen";
dictionaryVar["de-de"]["optionsLang_ru-ru"] = "Russisch";
dictionaryVar["de-de"]["optionsLang_pt-br"] = "Portugiesisch (Brasilien)";
dictionaryVar["de-de"]["optionsLang_es-es"] = "Spanisch";
dictionaryVar["de-de"]["optionsLang_ar-eg"] = "Arabisch";
dictionaryVar["de-de"]["optionsLang_ko-kr"] = "Koreanisch";
dictionaryVar["de-de"]["optionsLang_fr-fr"] = "Franzsisch";
dictionaryVar["de-de"]["levelEndScreenTotalScore_time"] = "Gesamtzeit:";
dictionaryVar["de-de"]["levelEndScreenHighScore_time"] = "Bestzeit:";
dictionaryVar["de-de"]["challengeLoadingError_notStarted"] = "Leider ist ein Fehleraufgetreten. Es konnte keiner Verbindung zum Server hergestellt werden. Versuche es bitte nochmal spter.";
dictionaryVar["de-de"]["challengeLoadingError_notValid"] = "Leider ist diese Partie nicht mehr aktuel.";
dictionaryVar["de-de"]["optionsChallengeCancel"] = "Zurckziehen";
dictionaryVar["de-de"]["optionsChallengeForfeit"] = "Aufgeben";
dictionaryVar["de-de"]["challengeForfeitMessage_error"] = "Leider ist ein Fehler aufgetreten. Probiere es bitte nochmal spter.";
dictionaryVar["de-de"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["de-de"]["challengeForfeitConfirmBtn_no"] = "Nein";
dictionaryVar["de-de"]["challengeForfeitConfirmBtn_yes"] = "Ja";
dictionaryVar["de-de"]["challengeForfeitConfirmText"] = "Willst du Die Partie wirklich aufgeben?";
dictionaryVar["de-de"]["challengeStartTextScore_challenger"] = "Spiel um die hochste Punktzahl!";
dictionaryVar["de-de"]["challengeStartTextTime_challenger"] = "Spiel um die niedrigste Zeit!";
dictionaryVar["de-de"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["de-de"]["challengeStartScreenTitle_challenger_friend"] = "Du hast den folgenden Spieler herausgefordert:";
dictionaryVar["de-de"]["challengeStartScreenTitle_challengee_stranger"] = "Dein Gegner wird:";
dictionaryVar["de-de"]["challengeEndScreenScoreSend_error"] = "Leider ist ein Fehler aufgetreten. Probiere es bitte nochmal spter.";
dictionaryVar["de-de"]["challengeCancelMessage_success"] = "Du hast die Wette erfolgreich zurckgezogen.";
dictionaryVar["de-de"]["challengeCancelMessage_error"] = "Leider ist ein Fehler aufgetreten. Probiere es bitte nochmal spter.";
dictionaryVar["de-de"]["challengeEndScreenChallengeSend_success"] = "Herausforderung verschickt!";
dictionaryVar["de-de"]["challengeEndScreenChallengeSend_error"] = "Leider ist ein Fehler aufgetreten. Probiere es bitte nochmal spter.";
dictionaryVar["de-de"]["challengeEndScreenName_you"] = "Du";
dictionaryVar["de-de"]["challengeEndScreenBtn_cancel"] = "Zurckziehen";
dictionaryVar["de-de"]["challengeEndScreensBtn_submit"] = "Herausfordern";
dictionaryVar["de-de"]["challengeCancelConfirmBtn_no"] = "Nein";
dictionaryVar["de-de"]["challengeCancelConfirmBtn_yes"] = "Ja";
dictionaryVar["de-de"]["challengeCancelConfirmText"] = "Willst Du Deine Wette wirklich zurckziehen? Dein Wetteinsatz wird Dir zurckgegeben minus die Einsatzgebhr.";
dictionaryVar["de-de"]["challengeEndScreenOutcomeMessage_TIED"] = "Gleichstand!";
dictionaryVar["de-de"]["challengeEndScreenOutcomeMessage_LOST"] = "Leider hat Dein Gegner die Partie gewonnen.";
dictionaryVar["de-de"]["challengeEndScreenOutcomeMessage_WON"] = "Du hast die Partie gewonnen!";
dictionaryVar["de-de"]["challengeEndScreenWinnings"] = "Du hast <AMOUNT> Fairmnzen gewonnen!";
dictionaryVar["de-de"]["challengeStartScreenToWin"] = "Einsatz:";
dictionaryVar["de-de"]["challengeStartTextTime"] = "Zeit von <NAME>:";
dictionaryVar["de-de"]["challengeStartTextScore"] = "Punktzahl von <NAME>:";
dictionaryVar["de-de"]["challengeStartScreenTitle_challengee_friend"] = "Dein Gegner:";
dictionaryVar["de-de"]["levelEndScreenSubmitHighscoreBtn"] = "Punktzahl senden";
dictionaryVar["de-de"]["levelEndScreenViewHighscoreBtn"] = "Punktzahlen ansehen";
dictionaryVar["de-de"]["optionsAbout_header"] = "Entwickelt von:";
dictionaryVar["de-de"]["optionsLang_tr-tr"] = "Trkisch";
dictionaryVar["de-de"]["optionsLang_de-de"] = "Deutsch";
dictionaryVar["de-de"]["startScreenByTinglyGames"] = "von: CoolGames";
dictionaryVar["de-de"]["levelMapScreenWorld_0"] = "Whle ein Level";
dictionaryVar["de-de"]["startScreenQuestionaire"] = "Deine Meinung zhlt!";
dictionaryVar["de-de"]["levelEndScreenMedal"] = "VERBESSERT!";
dictionaryVar["de-de"]["optionsAbout"] = "ber";
dictionaryVar["de-de"]["optionsAbout_version"] = "Version:";
dictionaryVar["de-de"]["optionsAbout_backBtn"] = "Zurck";
dictionaryVar["de-de"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["de-de"]["optionsAbout_title"] = "ber";
dictionaryVar["de-de"]["optionsSFXBig_off"] = "Sound AUS";
dictionaryVar["de-de"]["optionsSFXBig_on"] = "Sound EIN";
dictionaryVar["de-de"]["optionsRestart"] = "Neustart";
dictionaryVar["de-de"]["optionsRestartConfirmationText"] = "Achtung!\n\nWenn du jetzt neu startest, verlierst du alle in diesem Level gemachten Fortschritte. Willst du wirklich neu starten?";
dictionaryVar["de-de"]["levelMapScreenTitle"] = "Whle ein Level";
dictionaryVar["de-de"]["optionsQuitConfirmBtn_Yes"] = "Ja, ich bin mir sicher";
dictionaryVar["de-de"]["optionsQuitConfirmBtn_No"] = "NEIN";
dictionaryVar["de-de"]["optionsQuitConfirmationText"] = "Achtung!\n\nWenn du jetzt aufhrst, verlierst du alle in diesem Level gemachten Fortschritte. Willst du wirklich aufhren?";
dictionaryVar["de-de"]["optionsTitle"] = "Einstellungen";
dictionaryVar["de-de"]["gameEndScreenBtnText"] = "Weiter";
dictionaryVar["de-de"]["gameEndScreenTitle"] = "Glckwunsch!\nDu hast das Spiel abgeschlossen.";
dictionaryVar["de-de"]["optionsLang_nl-nl"] = "Hollndisch";
dictionaryVar["de-de"]["optionsLang_en-gb"] = "Englisch (GB)";
dictionaryVar["de-de"]["optionsLang_en-us"] = "Englisch (US)";
dictionaryVar["de-de"]["optionsSFX_off"] = "AUS";
dictionaryVar["de-de"]["optionsSFX_on"] = "EIN";
dictionaryVar["de-de"]["optionsMusic_off"] = "AUS";
dictionaryVar["de-de"]["optionsMusic_on"] = "EIN";
dictionaryVar["de-de"]["optionsDifficulty_hard"] = "Schwer";
dictionaryVar["de-de"]["optionsDifficulty_medium"] = "Mittel";
dictionaryVar["de-de"]["optionsDifficulty_easy"] = "Einfach";
dictionaryVar["de-de"]["optionsMoreGames"] = "Weitere Spiele";
dictionaryVar["de-de"]["optionsHighScore"] = "Highscores";
dictionaryVar["de-de"]["optionsTutorial"] = "So wird gespielt";
dictionaryVar["de-de"]["optionsResume"] = "Weiterspielen";
dictionaryVar["de-de"]["optionsQuit"] = "Beenden";
dictionaryVar["de-de"]["optionsStartScreen"] = "Hauptmen";
dictionaryVar["de-de"]["levelEndScreenHighScore"] = "Highscore";
dictionaryVar["de-de"]["levelEndScreenTimeBonus"] = "Zeitbonus";
dictionaryVar["de-de"]["levelEndScreenTimeLeft"] = "Restzeit";
dictionaryVar["de-de"]["levelEndScreenSubTitle_levelFailed"] = "Level nicht geschafft";
dictionaryVar["de-de"]["levelEndScreenTotalScore"] = "Gesamtpunkte";
dictionaryVar["de-de"]["levelEndScreenTitle_endless"] = "Stufe <VALUE>";
dictionaryVar["de-de"]["levelEndScreenTitle_difficulty"] = "Sehr gut!";
dictionaryVar["de-de"]["levelEndScreenTitle_level"] = "Level <VALUE>";
dictionaryVar["de-de"]["levelMapScreenTotalScore"] = "Gesamtpunkte";
dictionaryVar["de-de"]["startScreenPlay"] = "SPIELEN";
dictionaryVar["de-de"]["loadingScreenLoading"] = "Laden ...";
dictionaryVar["de-de"]["RewardAd_button"] = "video";
dictionaryVar["de-de"]["RewardAd_header"] = "coins";
dictionaryVar["de-de"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["de-de"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["fr-fr"] = dictionaryVar["fr-fr"] || {};
dictionaryVar["fr-fr"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["fr-fr"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["fr-fr"]["challengeEndScreenChallengeSend_submessage_stranger"] = "Si personne naccepte votre pari dici 72 heures, on vous remboursera le montant du pari y compris les frais.";
dictionaryVar["fr-fr"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> a 72 heures pour accepter votre dfi. Si <NAME> refuse ou naccepte pas dans ce dlai vous serez rembours le montant de votre pari et les frais de pari.";
dictionaryVar["fr-fr"]["levelEndScreenHighScore_number"] = "Meilleur score :";
dictionaryVar["fr-fr"]["levelEndScreenTotalScore_number"] = "Score total :";
dictionaryVar["fr-fr"]["optionsExit"] = "Quitter";
dictionaryVar["fr-fr"]["optionsLang_ru-ru"] = "Russe";
dictionaryVar["fr-fr"]["optionsLang_pt-br"] = "Portugais - Brsilien";
dictionaryVar["fr-fr"]["optionsLang_es-es"] = "Espagnol";
dictionaryVar["fr-fr"]["optionsLang_ar-eg"] = "Arabe";
dictionaryVar["fr-fr"]["optionsLang_ko-kr"] = "Coren";
dictionaryVar["fr-fr"]["optionsLang_fr-fr"] = "Franais";
dictionaryVar["fr-fr"]["levelEndScreenTotalScore_time"] = "Temps total :";
dictionaryVar["fr-fr"]["levelEndScreenHighScore_time"] = "Meilleur temps :";
dictionaryVar["fr-fr"]["challengeLoadingError_notStarted"] = "Une erreur de connexion est survenue. Veuillez ressayer ultrieurement.";
dictionaryVar["fr-fr"]["challengeLoadingError_notValid"] = "Dsol, cette partie n'existe plus.";
dictionaryVar["fr-fr"]["optionsChallengeCancel"] = "Annuler";
dictionaryVar["fr-fr"]["optionsChallengeForfeit"] = "Abandonner";
dictionaryVar["fr-fr"]["challengeForfeitMessage_error"] = "Une erreur est survenue. Veuillez ressayer ultrieurement.";
dictionaryVar["fr-fr"]["challengeForfeitMessage_success"] = "Vous avez abandonn.";
dictionaryVar["fr-fr"]["challengeForfeitConfirmBtn_no"] = "Non";
dictionaryVar["fr-fr"]["challengeForfeitConfirmBtn_yes"] = "Oui";
dictionaryVar["fr-fr"]["challengeForfeitConfirmText"] = "Voulez-vous vraiment abandonner la partie ?";
dictionaryVar["fr-fr"]["challengeStartTextScore_challenger"] = "Essayez datteindre le plus haut score !";
dictionaryVar["fr-fr"]["challengeStartTextTime_challenger"] = "Finissez le plus vite possible !";
dictionaryVar["fr-fr"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["fr-fr"]["challengeStartScreenTitle_challenger_friend"] = "Votre adversaire:";
dictionaryVar["fr-fr"]["challengeStartScreenTitle_challengee_stranger"] = "Votre adversaire:";
dictionaryVar["fr-fr"]["challengeEndScreenScoreSend_error"] = "Une erreur est survenue. Veuillez ressayer ultrieurement.";
dictionaryVar["fr-fr"]["challengeCancelMessage_success"] = "Dfi annul.";
dictionaryVar["fr-fr"]["challengeCancelMessage_error"] = "Une erreur est survenue. Veuillez ressayer ultrieurement.";
dictionaryVar["fr-fr"]["challengeEndScreenChallengeSend_success"] = "Dfi lanc.";
dictionaryVar["fr-fr"]["challengeEndScreenChallengeSend_error"] = "Une erreur est survenue. Veuillez ressayer ultrieurement.";
dictionaryVar["fr-fr"]["challengeEndScreenName_you"] = "Moi";
dictionaryVar["fr-fr"]["challengeEndScreenBtn_cancel"] = "Annuler le dfi";
dictionaryVar["fr-fr"]["challengeEndScreensBtn_submit"] = "Lancer le dfi";
dictionaryVar["fr-fr"]["challengeCancelConfirmBtn_no"] = "Non";
dictionaryVar["fr-fr"]["challengeCancelConfirmBtn_yes"] = "Oui";
dictionaryVar["fr-fr"]["challengeCancelConfirmText"] = "Si vous annulez, on vous remboursera le montant du pari moins les frais de pari. Voulez-vous continuer? ";
dictionaryVar["fr-fr"]["challengeEndScreenOutcomeMessage_TIED"] = "Ex-aequo!";
dictionaryVar["fr-fr"]["challengeEndScreenOutcomeMessage_LOST"] = "Zut!";
dictionaryVar["fr-fr"]["challengeEndScreenOutcomeMessage_WON"] = "Vainqueur!";
dictionaryVar["fr-fr"]["challengeEndScreenWinnings"] = "Vous avez gagn <AMOUNT> fairpoints.";
dictionaryVar["fr-fr"]["challengeStartScreenToWin"] = " gagner:";
dictionaryVar["fr-fr"]["challengeStartTextTime"] = "Son temps:";
dictionaryVar["fr-fr"]["challengeStartTextScore"] = "Son score :";
dictionaryVar["fr-fr"]["challengeStartScreenTitle_challengee_friend"] = "Votre adversaire:";
dictionaryVar["fr-fr"]["levelEndScreenSubmitHighscoreBtn"] = "Publier un score";
dictionaryVar["fr-fr"]["levelEndScreenViewHighscoreBtn"] = "Voir les scores";
dictionaryVar["fr-fr"]["optionsAbout_header"] = "Dvelopp par :";
dictionaryVar["fr-fr"]["optionsLang_tr-tr"] = "Turc";
dictionaryVar["fr-fr"]["optionsLang_de-de"] = "Allemand";
dictionaryVar["fr-fr"]["startScreenByTinglyGames"] = "Un jeu CoolGames";
dictionaryVar["fr-fr"]["levelMapScreenWorld_0"] = "Choisir un niveau";
dictionaryVar["fr-fr"]["startScreenQuestionaire"] = "Un avis sur le jeu ?";
dictionaryVar["fr-fr"]["levelEndScreenMedal"] = "RECORD BATTU !";
dictionaryVar["fr-fr"]["optionsAbout"] = " propos";
dictionaryVar["fr-fr"]["optionsAbout_version"] = "Version :";
dictionaryVar["fr-fr"]["optionsAbout_backBtn"] = "Retour";
dictionaryVar["fr-fr"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["fr-fr"]["optionsAbout_title"] = " propos";
dictionaryVar["fr-fr"]["optionsSFXBig_off"] = "Sans son";
dictionaryVar["fr-fr"]["optionsSFXBig_on"] = "Avec son";
dictionaryVar["fr-fr"]["optionsRestart"] = "Recommencer";
dictionaryVar["fr-fr"]["optionsRestartConfirmationText"] = "Attention !\n\nEn recommenant maintenant, vous perdrez votre progression pour le niveau en cours. Recommencer quand mme ?";
dictionaryVar["fr-fr"]["levelMapScreenTitle"] = "Choisir un niveau";
dictionaryVar["fr-fr"]["optionsQuitConfirmBtn_Yes"] = "Oui";
dictionaryVar["fr-fr"]["optionsQuitConfirmBtn_No"] = "Non";
dictionaryVar["fr-fr"]["optionsQuitConfirmationText"] = "Attention !\n\nEn quittant maintenant, vous perdrez votre progression pour le niveau en cours. Quitter quand mme ?";
dictionaryVar["fr-fr"]["optionsTitle"] = "Paramtres";
dictionaryVar["fr-fr"]["gameEndScreenBtnText"] = "Continuer";
dictionaryVar["fr-fr"]["gameEndScreenTitle"] = "Flicitations !\nVous avez termin le jeu.";
dictionaryVar["fr-fr"]["optionsLang_nl-nl"] = "Nerlandais";
dictionaryVar["fr-fr"]["optionsLang_en-gb"] = "Anglais (UK)";
dictionaryVar["fr-fr"]["optionsLang_en-us"] = "Anglais (US)";
dictionaryVar["fr-fr"]["optionsSFX_off"] = "Sans";
dictionaryVar["fr-fr"]["optionsSFX_on"] = "Avec";
dictionaryVar["fr-fr"]["optionsMusic_off"] = "Sans";
dictionaryVar["fr-fr"]["optionsMusic_on"] = "Avec";
dictionaryVar["fr-fr"]["optionsDifficulty_hard"] = "Difficile";
dictionaryVar["fr-fr"]["optionsDifficulty_medium"] = "Moyen";
dictionaryVar["fr-fr"]["optionsDifficulty_easy"] = "Facile";
dictionaryVar["fr-fr"]["optionsMoreGames"] = "Plus de jeux";
dictionaryVar["fr-fr"]["optionsHighScore"] = "Meilleurs scores";
dictionaryVar["fr-fr"]["optionsTutorial"] = "Comment jouer";
dictionaryVar["fr-fr"]["optionsResume"] = "Reprendre";
dictionaryVar["fr-fr"]["optionsQuit"] = "Quitter";
dictionaryVar["fr-fr"]["optionsStartScreen"] = "Menu principal";
dictionaryVar["fr-fr"]["levelEndScreenHighScore"] = "Meilleur score";
dictionaryVar["fr-fr"]["levelEndScreenTimeBonus"] = "Bonus de temps";
dictionaryVar["fr-fr"]["levelEndScreenTimeLeft"] = "Temps restant";
dictionaryVar["fr-fr"]["levelEndScreenSubTitle_levelFailed"] = "chec du niveau";
dictionaryVar["fr-fr"]["levelEndScreenTotalScore"] = "Score total";
dictionaryVar["fr-fr"]["levelEndScreenTitle_endless"] = "Scne <VALUE>";
dictionaryVar["fr-fr"]["levelEndScreenTitle_difficulty"] = "Bien jou !";
dictionaryVar["fr-fr"]["levelEndScreenTitle_level"] = "Niveau <VALUE>";
dictionaryVar["fr-fr"]["levelMapScreenTotalScore"] = "Score total";
dictionaryVar["fr-fr"]["startScreenPlay"] = "JOUER";
dictionaryVar["fr-fr"]["loadingScreenLoading"] = "Chargement...";
dictionaryVar["fr-fr"]["RewardAd_button"] = "video";
dictionaryVar["fr-fr"]["RewardAd_header"] = "coins";
dictionaryVar["fr-fr"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["fr-fr"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["pt-br"] = dictionaryVar["pt-br"] || {};
dictionaryVar["pt-br"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["pt-br"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["pt-br"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["pt-br"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["pt-br"]["levelEndScreenHighScore_number"] = "Pontuao mxima:";
dictionaryVar["pt-br"]["levelEndScreenTotalScore_number"] = "Pontuao total:";
dictionaryVar["pt-br"]["optionsExit"] = "Sada";
dictionaryVar["pt-br"]["optionsLang_ru-ru"] = "Russo";
dictionaryVar["pt-br"]["optionsLang_pt-br"] = "Portugus do Brasil";
dictionaryVar["pt-br"]["optionsLang_es-es"] = "Espanhol";
dictionaryVar["pt-br"]["optionsLang_ar-eg"] = "rabe";
dictionaryVar["pt-br"]["optionsLang_ko-kr"] = "Coreano";
dictionaryVar["pt-br"]["optionsLang_fr-fr"] = "Francs";
dictionaryVar["pt-br"]["levelEndScreenTotalScore_time"] = "Tempo total:";
dictionaryVar["pt-br"]["levelEndScreenHighScore_time"] = "Tempo recorde:";
dictionaryVar["pt-br"]["challengeLoadingError_notStarted"] = "Impossvel conectar ao servidor. Por favor, tente novamente mais tarde.";
dictionaryVar["pt-br"]["challengeLoadingError_notValid"] = "Desculpe, este desafio no  mais vlido.";
dictionaryVar["pt-br"]["optionsChallengeCancel"] = "Sair do Jogo";
dictionaryVar["pt-br"]["optionsChallengeForfeit"] = "Desistir";
dictionaryVar["pt-br"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["pt-br"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["pt-br"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["pt-br"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["pt-br"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["pt-br"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["pt-br"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["pt-br"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["pt-br"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["pt-br"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["pt-br"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["pt-br"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["pt-br"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["pt-br"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["pt-br"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["pt-br"]["challengeEndScreenName_you"] = "You";
dictionaryVar["pt-br"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["pt-br"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["pt-br"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["pt-br"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["pt-br"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["pt-br"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["pt-br"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["pt-br"]["challengeEndScreenOutcomeMessage_WON"] = "You have won the challenge!";
dictionaryVar["pt-br"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["pt-br"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["pt-br"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["pt-br"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["pt-br"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["pt-br"]["levelEndScreenSubmitHighscoreBtn"] = "Enviar recorde";
dictionaryVar["pt-br"]["levelEndScreenViewHighscoreBtn"] = "Ver pontuaes";
dictionaryVar["pt-br"]["optionsAbout_header"] = "Desenvolvido por:";
dictionaryVar["pt-br"]["optionsLang_tr-tr"] = "Turco";
dictionaryVar["pt-br"]["optionsLang_de-de"] = "Alemo";
dictionaryVar["pt-br"]["startScreenByTinglyGames"] = "da: CoolGames";
dictionaryVar["pt-br"]["levelMapScreenWorld_0"] = "Selecione um nvel";
dictionaryVar["pt-br"]["startScreenQuestionaire"] = "O que voc achou?";
dictionaryVar["pt-br"]["levelEndScreenMedal"] = "MELHOROU!";
dictionaryVar["pt-br"]["optionsAbout"] = "Sobre";
dictionaryVar["pt-br"]["optionsAbout_version"] = "verso:";
dictionaryVar["pt-br"]["optionsAbout_backBtn"] = "Voltar";
dictionaryVar["pt-br"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["pt-br"]["optionsAbout_title"] = "Sobre";
dictionaryVar["pt-br"]["optionsSFXBig_off"] = "Sem som";
dictionaryVar["pt-br"]["optionsSFXBig_on"] = "Com som";
dictionaryVar["pt-br"]["optionsRestart"] = "Reiniciar";
dictionaryVar["pt-br"]["optionsRestartConfirmationText"] = "Ateno!\n\nSe voc reiniciar agora, perder todo progresso realizado neste nvel. Deseja mesmo reiniciar?";
dictionaryVar["pt-br"]["levelMapScreenTitle"] = "Selecione um nvel";
dictionaryVar["pt-br"]["optionsQuitConfirmBtn_Yes"] = "Sim, tenho certeza.";
dictionaryVar["pt-br"]["optionsQuitConfirmBtn_No"] = "No";
dictionaryVar["pt-br"]["optionsQuitConfirmationText"] = "Ateno!\n\nSe voc sair agora, perder todo progresso realizado neste nvel. Deseja mesmo sair?";
dictionaryVar["pt-br"]["optionsTitle"] = "Configuraes";
dictionaryVar["pt-br"]["gameEndScreenBtnText"] = "Continuar";
dictionaryVar["pt-br"]["gameEndScreenTitle"] = "Parabns!\nVoc concluiu o jogo.";
dictionaryVar["pt-br"]["optionsLang_nl-nl"] = "Holands";
dictionaryVar["pt-br"]["optionsLang_en-gb"] = "Ingls (GB)";
dictionaryVar["pt-br"]["optionsLang_en-us"] = "Ingls (EUA)";
dictionaryVar["pt-br"]["optionsSFX_off"] = "No";
dictionaryVar["pt-br"]["optionsSFX_on"] = "Sim";
dictionaryVar["pt-br"]["optionsMusic_off"] = "No";
dictionaryVar["pt-br"]["optionsMusic_on"] = "Sim";
dictionaryVar["pt-br"]["optionsDifficulty_hard"] = "Difcil";
dictionaryVar["pt-br"]["optionsDifficulty_medium"] = "Mdio";
dictionaryVar["pt-br"]["optionsDifficulty_easy"] = "Fcil";
dictionaryVar["pt-br"]["optionsMoreGames"] = "Mais jogos";
dictionaryVar["pt-br"]["optionsHighScore"] = "Recordes";
dictionaryVar["pt-br"]["optionsTutorial"] = "Como jogar";
dictionaryVar["pt-br"]["optionsResume"] = "Continuar";
dictionaryVar["pt-br"]["optionsQuit"] = "Sair";
dictionaryVar["pt-br"]["optionsStartScreen"] = "Menu principal";
dictionaryVar["pt-br"]["levelEndScreenHighScore"] = "Recorde";
dictionaryVar["pt-br"]["levelEndScreenTimeBonus"] = "Bnus de tempo";
dictionaryVar["pt-br"]["levelEndScreenTimeLeft"] = "Tempo restante";
dictionaryVar["pt-br"]["levelEndScreenSubTitle_levelFailed"] = "Tente novamente";
dictionaryVar["pt-br"]["levelEndScreenTotalScore"] = "Pontuao";
dictionaryVar["pt-br"]["levelEndScreenTitle_endless"] = "Fase <VALUE>";
dictionaryVar["pt-br"]["levelEndScreenTitle_difficulty"] = "Muito bem!";
dictionaryVar["pt-br"]["levelEndScreenTitle_level"] = "Nvel <VALUE>";
dictionaryVar["pt-br"]["levelMapScreenTotalScore"] = "Pontuao";
dictionaryVar["pt-br"]["startScreenPlay"] = "JOGAR";
dictionaryVar["pt-br"]["loadingScreenLoading"] = "Carregando...";
dictionaryVar["pt-br"]["RewardAd_button"] = "video";
dictionaryVar["pt-br"]["RewardAd_header"] = "coins";
dictionaryVar["pt-br"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["pt-br"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["es-es"] = dictionaryVar["es-es"] || {};
dictionaryVar["es-es"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["es-es"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["es-es"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["es-es"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["es-es"]["levelEndScreenHighScore_number"] = "Mejor puntuacin:";
dictionaryVar["es-es"]["levelEndScreenTotalScore_number"] = "Puntos totales:";
dictionaryVar["es-es"]["optionsExit"] = "Salir";
dictionaryVar["es-es"]["optionsLang_ru-ru"] = "Ruso";
dictionaryVar["es-es"]["optionsLang_pt-br"] = "Portugus brasileo";
dictionaryVar["es-es"]["optionsLang_es-es"] = "Espaol";
dictionaryVar["es-es"]["optionsLang_ar-eg"] = "rabe";
dictionaryVar["es-es"]["optionsLang_ko-kr"] = "Coreano";
dictionaryVar["es-es"]["optionsLang_fr-fr"] = "Francs";
dictionaryVar["es-es"]["levelEndScreenTotalScore_time"] = "Tiempo total:";
dictionaryVar["es-es"]["levelEndScreenHighScore_time"] = "Mejor tiempo:";
dictionaryVar["es-es"]["challengeLoadingError_notStarted"] = "Imposible conectar con el servidor. Intntalo ms tarde.";
dictionaryVar["es-es"]["challengeLoadingError_notValid"] = "Lo sentimos, este reto ya no es vlido.";
dictionaryVar["es-es"]["optionsChallengeCancel"] = "Abandonar";
dictionaryVar["es-es"]["optionsChallengeForfeit"] = "Rendirse";
dictionaryVar["es-es"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["es-es"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["es-es"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["es-es"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["es-es"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["es-es"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["es-es"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["es-es"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["es-es"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["es-es"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["es-es"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["es-es"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["es-es"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["es-es"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["es-es"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["es-es"]["challengeEndScreenName_you"] = "You";
dictionaryVar["es-es"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["es-es"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["es-es"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["es-es"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["es-es"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["es-es"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["es-es"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["es-es"]["challengeEndScreenOutcomeMessage_WON"] = "You have won the challenge!";
dictionaryVar["es-es"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["es-es"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["es-es"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["es-es"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["es-es"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["es-es"]["levelEndScreenSubmitHighscoreBtn"] = "Enviar puntuacin";
dictionaryVar["es-es"]["levelEndScreenViewHighscoreBtn"] = "Ver puntuaciones";
dictionaryVar["es-es"]["optionsAbout_header"] = "Desarrollado por:";
dictionaryVar["es-es"]["optionsLang_tr-tr"] = "Turco";
dictionaryVar["es-es"]["optionsLang_de-de"] = "Alemn";
dictionaryVar["es-es"]["startScreenByTinglyGames"] = "de: CoolGames";
dictionaryVar["es-es"]["levelMapScreenWorld_0"] = "Elige un nivel";
dictionaryVar["es-es"]["startScreenQuestionaire"] = "Qu te parece?";
dictionaryVar["es-es"]["levelEndScreenMedal"] = "SUPERADO!";
dictionaryVar["es-es"]["optionsAbout"] = "Acerca de";
dictionaryVar["es-es"]["optionsAbout_version"] = "versin:";
dictionaryVar["es-es"]["optionsAbout_backBtn"] = "Atrs";
dictionaryVar["es-es"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["es-es"]["optionsAbout_title"] = "Acerca de";
dictionaryVar["es-es"]["optionsSFXBig_off"] = "Sonido no";
dictionaryVar["es-es"]["optionsSFXBig_on"] = "Sonido s";
dictionaryVar["es-es"]["optionsRestart"] = "Reiniciar";
dictionaryVar["es-es"]["optionsRestartConfirmationText"] = "Aviso!\n\nSi reinicias ahora, perders el progreso que hayas realizado en el nivel. Seguro que quieres reiniciar?";
dictionaryVar["es-es"]["levelMapScreenTitle"] = "Elige un nivel";
dictionaryVar["es-es"]["optionsQuitConfirmBtn_Yes"] = "S, seguro";
dictionaryVar["es-es"]["optionsQuitConfirmBtn_No"] = "No";
dictionaryVar["es-es"]["optionsQuitConfirmationText"] = "Aviso!\n\nSi sales ahora, perders el progreso que hayas realizado en el nivel. Seguro que quieres salir?";
dictionaryVar["es-es"]["optionsTitle"] = "Ajustes";
dictionaryVar["es-es"]["gameEndScreenBtnText"] = "Continuar";
dictionaryVar["es-es"]["gameEndScreenTitle"] = "Enhorabuena!\nHas terminado el juego.";
dictionaryVar["es-es"]["optionsLang_nl-nl"] = "Neerlands";
dictionaryVar["es-es"]["optionsLang_en-gb"] = "Ingls (GB)";
dictionaryVar["es-es"]["optionsLang_en-us"] = "Ingls (EE.UU.)";
dictionaryVar["es-es"]["optionsSFX_off"] = "No";
dictionaryVar["es-es"]["optionsSFX_on"] = "S";
dictionaryVar["es-es"]["optionsMusic_off"] = "No";
dictionaryVar["es-es"]["optionsMusic_on"] = "S";
dictionaryVar["es-es"]["optionsDifficulty_hard"] = "Difcil";
dictionaryVar["es-es"]["optionsDifficulty_medium"] = "Normal";
dictionaryVar["es-es"]["optionsDifficulty_easy"] = "Fcil";
dictionaryVar["es-es"]["optionsMoreGames"] = "Ms juegos";
dictionaryVar["es-es"]["optionsHighScore"] = "Rcords";
dictionaryVar["es-es"]["optionsTutorial"] = "Cmo jugar";
dictionaryVar["es-es"]["optionsResume"] = "Seguir";
dictionaryVar["es-es"]["optionsQuit"] = "Salir";
dictionaryVar["es-es"]["optionsStartScreen"] = "Men principal";
dictionaryVar["es-es"]["levelEndScreenHighScore"] = "Rcord";
dictionaryVar["es-es"]["levelEndScreenTimeBonus"] = "Bonif. tiempo";
dictionaryVar["es-es"]["levelEndScreenTimeLeft"] = "Tiempo restante";
dictionaryVar["es-es"]["levelEndScreenSubTitle_levelFailed"] = "Nivel fallido";
dictionaryVar["es-es"]["levelEndScreenTotalScore"] = "Punt. total";
dictionaryVar["es-es"]["levelEndScreenTitle_endless"] = "Fase <VALUE>";
dictionaryVar["es-es"]["levelEndScreenTitle_difficulty"] = "Muy bien!";
dictionaryVar["es-es"]["levelEndScreenTitle_level"] = "Nivel <VALUE>";
dictionaryVar["es-es"]["levelMapScreenTotalScore"] = "Punt. total";
dictionaryVar["es-es"]["startScreenPlay"] = "JUGAR";
dictionaryVar["es-es"]["loadingScreenLoading"] = "Cargando...";
dictionaryVar["es-es"]["RewardAd_button"] = "video";
dictionaryVar["es-es"]["RewardAd_header"] = "coins";
dictionaryVar["es-es"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["es-es"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["tr-tr"] = dictionaryVar["tr-tr"] || {};
dictionaryVar["tr-tr"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["tr-tr"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["tr-tr"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["tr-tr"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["tr-tr"]["levelEndScreenHighScore_number"] = "Yksek Puan:";
dictionaryVar["tr-tr"]["levelEndScreenTotalScore_number"] = "Toplam Puan:";
dictionaryVar["tr-tr"]["optionsExit"] = "k";
dictionaryVar["tr-tr"]["optionsLang_ru-ru"] = "Rusa";
dictionaryVar["tr-tr"]["optionsLang_pt-br"] = "Brezilya Portekizcesi";
dictionaryVar["tr-tr"]["optionsLang_es-es"] = "spanyolca";
dictionaryVar["tr-tr"]["optionsLang_ar-eg"] = "Arapa";
dictionaryVar["tr-tr"]["optionsLang_ko-kr"] = "Korece";
dictionaryVar["tr-tr"]["optionsLang_fr-fr"] = "Franszca";
dictionaryVar["tr-tr"]["levelEndScreenTotalScore_time"] = "Toplam Zaman:";
dictionaryVar["tr-tr"]["levelEndScreenHighScore_time"] = "En yi Zaman:";
dictionaryVar["tr-tr"]["challengeLoadingError_notStarted"] = "Sunucuya balanlamyor. Ltfen daha sonra tekrar deneyin.";
dictionaryVar["tr-tr"]["challengeLoadingError_notValid"] = "zgnz, bu zorluk artk geerli deil.";
dictionaryVar["tr-tr"]["optionsChallengeCancel"] = "k";
dictionaryVar["tr-tr"]["optionsChallengeForfeit"] = "Vazge";
dictionaryVar["tr-tr"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["tr-tr"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["tr-tr"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["tr-tr"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["tr-tr"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["tr-tr"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["tr-tr"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["tr-tr"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["tr-tr"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["tr-tr"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["tr-tr"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["tr-tr"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["tr-tr"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["tr-tr"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["tr-tr"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["tr-tr"]["challengeEndScreenName_you"] = "You";
dictionaryVar["tr-tr"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["tr-tr"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["tr-tr"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["tr-tr"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["tr-tr"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["tr-tr"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["tr-tr"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["tr-tr"]["challengeEndScreenOutcomeMessage_WON"] = "You have won the challenge!";
dictionaryVar["tr-tr"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["tr-tr"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["tr-tr"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["tr-tr"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["tr-tr"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["tr-tr"]["levelEndScreenSubmitHighscoreBtn"] = "Puan gnder";
dictionaryVar["tr-tr"]["levelEndScreenViewHighscoreBtn"] = "Puanlar gster:";
dictionaryVar["tr-tr"]["optionsAbout_header"] = "Hazrlayan:";
dictionaryVar["tr-tr"]["optionsLang_tr-tr"] = "Trke";
dictionaryVar["tr-tr"]["optionsLang_de-de"] = "Almanca";
dictionaryVar["tr-tr"]["startScreenByTinglyGames"] = "tarafndan: CoolGames";
dictionaryVar["tr-tr"]["levelMapScreenWorld_0"] = "Bir seviye se";
dictionaryVar["tr-tr"]["startScreenQuestionaire"] = "Ne dersin?";
dictionaryVar["tr-tr"]["levelEndScreenMedal"] = "YLET!";
dictionaryVar["tr-tr"]["optionsAbout"] = "Hakknda";
dictionaryVar["tr-tr"]["optionsAbout_version"] = "srm:";
dictionaryVar["tr-tr"]["optionsAbout_backBtn"] = "Geri";
dictionaryVar["tr-tr"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["tr-tr"]["optionsAbout_title"] = "Hakknda";
dictionaryVar["tr-tr"]["optionsSFXBig_off"] = "Ses kapal";
dictionaryVar["tr-tr"]["optionsSFXBig_on"] = "Ses ak";
dictionaryVar["tr-tr"]["optionsRestart"] = "Tekrar balat";
dictionaryVar["tr-tr"]["optionsRestartConfirmationText"] = "Dikkat!\nimdi tekrar balarsan bu seviyede yaplan tm ilerleme kaybedilecek. Batan balamak istediinden emin misin?";
dictionaryVar["tr-tr"]["levelMapScreenTitle"] = "Bir seviye se";
dictionaryVar["tr-tr"]["optionsQuitConfirmBtn_Yes"] = "Evet, eminim";
dictionaryVar["tr-tr"]["optionsQuitConfirmBtn_No"] = "Hayr";
dictionaryVar["tr-tr"]["optionsQuitConfirmationText"] = "Dikkat!\nimdi karsan bu seviyede yaplan tm ilerleme kaybedilecek. kmak istediinizden emin misiniz?";
dictionaryVar["tr-tr"]["optionsTitle"] = "Ayarlar";
dictionaryVar["tr-tr"]["gameEndScreenBtnText"] = "Devam";
dictionaryVar["tr-tr"]["gameEndScreenTitle"] = "Tebrikler!\nOyunu tamamladn.";
dictionaryVar["tr-tr"]["optionsLang_nl-nl"] = "Hollandaca";
dictionaryVar["tr-tr"]["optionsLang_en-gb"] = "ngilizce (GB)";
dictionaryVar["tr-tr"]["optionsLang_en-us"] = "ngilizce (US)";
dictionaryVar["tr-tr"]["optionsSFX_off"] = "Kapal";
dictionaryVar["tr-tr"]["optionsSFX_on"] = "Ak";
dictionaryVar["tr-tr"]["optionsMusic_off"] = "Kapal";
dictionaryVar["tr-tr"]["optionsMusic_on"] = "Ak";
dictionaryVar["tr-tr"]["optionsDifficulty_hard"] = "Zorluk";
dictionaryVar["tr-tr"]["optionsDifficulty_medium"] = "Orta";
dictionaryVar["tr-tr"]["optionsDifficulty_easy"] = "Kolay";
dictionaryVar["tr-tr"]["optionsMoreGames"] = "Daha Fazla Oyun";
dictionaryVar["tr-tr"]["optionsHighScore"] = "Yksek skorlar";
dictionaryVar["tr-tr"]["optionsTutorial"] = "Nasl oynanr";
dictionaryVar["tr-tr"]["optionsResume"] = "Devam et";
dictionaryVar["tr-tr"]["optionsQuit"] = "k";
dictionaryVar["tr-tr"]["optionsStartScreen"] = "Ana men";
dictionaryVar["tr-tr"]["levelEndScreenHighScore"] = "Yksek skor";
dictionaryVar["tr-tr"]["levelEndScreenTimeBonus"] = "Sre Bonusu";
dictionaryVar["tr-tr"]["levelEndScreenTimeLeft"] = "Kalan Sre";
dictionaryVar["tr-tr"]["levelEndScreenSubTitle_levelFailed"] = "Seviye baarsz";
dictionaryVar["tr-tr"]["levelEndScreenTotalScore"] = "Toplam skor";
dictionaryVar["tr-tr"]["levelEndScreenTitle_endless"] = "Blm <VALUE>";
dictionaryVar["tr-tr"]["levelEndScreenTitle_difficulty"] = "Bravo!";
dictionaryVar["tr-tr"]["levelEndScreenTitle_level"] = "Seviye <VALUE>";
dictionaryVar["tr-tr"]["levelMapScreenTotalScore"] = "Toplam skor";
dictionaryVar["tr-tr"]["startScreenPlay"] = "OYNA";
dictionaryVar["tr-tr"]["loadingScreenLoading"] = "Ykleniyor...";
dictionaryVar["tr-tr"]["RewardAd_button"] = "video";
dictionaryVar["tr-tr"]["RewardAd_header"] = "coins";
dictionaryVar["tr-tr"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["tr-tr"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["ru-ru"] = dictionaryVar["ru-ru"] || {};
dictionaryVar["ru-ru"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["ru-ru"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["ru-ru"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["ru-ru"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["ru-ru"]["levelEndScreenHighScore_number"] = "High score:";
dictionaryVar["ru-ru"]["levelEndScreenTotalScore_number"] = "Total score:";
dictionaryVar["ru-ru"]["optionsExit"] = "Exit";
dictionaryVar["ru-ru"]["optionsLang_ru-ru"] = "";
dictionaryVar["ru-ru"]["optionsLang_pt-br"] = " ";
dictionaryVar["ru-ru"]["optionsLang_es-es"] = "";
dictionaryVar["ru-ru"]["optionsLang_ar-eg"] = "";
dictionaryVar["ru-ru"]["optionsLang_ko-kr"] = "";
dictionaryVar["ru-ru"]["optionsLang_fr-fr"] = "";
dictionaryVar["ru-ru"]["levelEndScreenTotalScore_time"] = "Total time:";
dictionaryVar["ru-ru"]["levelEndScreenHighScore_time"] = "Best time:";
dictionaryVar["ru-ru"]["challengeLoadingError_notStarted"] = "Unable to connect to the server. Please try again later.";
dictionaryVar["ru-ru"]["challengeLoadingError_notValid"] = "Sorry, this challenge is no longer valid.";
dictionaryVar["ru-ru"]["optionsChallengeCancel"] = "Quit";
dictionaryVar["ru-ru"]["optionsChallengeForfeit"] = "Forfeit";
dictionaryVar["ru-ru"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["ru-ru"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["ru-ru"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["ru-ru"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["ru-ru"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["ru-ru"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["ru-ru"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["ru-ru"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["ru-ru"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["ru-ru"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["ru-ru"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["ru-ru"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["ru-ru"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["ru-ru"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["ru-ru"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["ru-ru"]["challengeEndScreenName_you"] = "You";
dictionaryVar["ru-ru"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["ru-ru"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["ru-ru"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["ru-ru"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["ru-ru"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["ru-ru"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["ru-ru"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["ru-ru"]["challengeEndScreenOutcomeMessage_WON"] = "You have won the challenge!";
dictionaryVar["ru-ru"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["ru-ru"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["ru-ru"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["ru-ru"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["ru-ru"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["ru-ru"]["levelEndScreenSubmitHighscoreBtn"] = "Submit score";
dictionaryVar["ru-ru"]["levelEndScreenViewHighscoreBtn"] = "View scores";
dictionaryVar["ru-ru"]["optionsAbout_header"] = "Developed by:";
dictionaryVar["ru-ru"]["optionsLang_tr-tr"] = "";
dictionaryVar["ru-ru"]["optionsLang_de-de"] = "";
dictionaryVar["ru-ru"]["startScreenByTinglyGames"] = ": CoolGames";
dictionaryVar["ru-ru"]["levelMapScreenWorld_0"] = " ";
dictionaryVar["ru-ru"]["startScreenQuestionaire"] = "  ?";
dictionaryVar["ru-ru"]["levelEndScreenMedal"] = " !";
dictionaryVar["ru-ru"]["optionsAbout"] = " ";
dictionaryVar["ru-ru"]["optionsAbout_version"] = ":";
dictionaryVar["ru-ru"]["optionsAbout_backBtn"] = "";
dictionaryVar["ru-ru"]["optionsAbout_text"] = " CoolGames\nwww.coolgames.com\n2018";
dictionaryVar["ru-ru"]["optionsAbout_title"] = " ";
dictionaryVar["ru-ru"]["optionsSFXBig_off"] = " .";
dictionaryVar["ru-ru"]["optionsSFXBig_on"] = " .";
dictionaryVar["ru-ru"]["optionsRestart"] = "";
dictionaryVar["ru-ru"]["optionsRestartConfirmationText"] = "!\n\n     ,    .  ,    ?";
dictionaryVar["ru-ru"]["levelMapScreenTitle"] = " ";
dictionaryVar["ru-ru"]["optionsQuitConfirmBtn_Yes"] = ", ";
dictionaryVar["ru-ru"]["optionsQuitConfirmBtn_No"] = "";
dictionaryVar["ru-ru"]["optionsQuitConfirmationText"] = "!\n\n   ,    .  ,   ?";
dictionaryVar["ru-ru"]["optionsTitle"] = "";
dictionaryVar["ru-ru"]["gameEndScreenBtnText"] = "";
dictionaryVar["ru-ru"]["gameEndScreenTitle"] = "!\n  .";
dictionaryVar["ru-ru"]["optionsLang_nl-nl"] = "";
dictionaryVar["ru-ru"]["optionsLang_en-gb"] = " ()";
dictionaryVar["ru-ru"]["optionsLang_en-us"] = " ()";
dictionaryVar["ru-ru"]["optionsSFX_off"] = ".";
dictionaryVar["ru-ru"]["optionsSFX_on"] = ".";
dictionaryVar["ru-ru"]["optionsMusic_off"] = ".";
dictionaryVar["ru-ru"]["optionsMusic_on"] = ".";
dictionaryVar["ru-ru"]["optionsDifficulty_hard"] = "";
dictionaryVar["ru-ru"]["optionsDifficulty_medium"] = "";
dictionaryVar["ru-ru"]["optionsDifficulty_easy"] = "";
dictionaryVar["ru-ru"]["optionsMoreGames"] = " ";
dictionaryVar["ru-ru"]["optionsHighScore"] = "";
dictionaryVar["ru-ru"]["optionsTutorial"] = " ";
dictionaryVar["ru-ru"]["optionsResume"] = "";
dictionaryVar["ru-ru"]["optionsQuit"] = "";
dictionaryVar["ru-ru"]["optionsStartScreen"] = " ";
dictionaryVar["ru-ru"]["levelEndScreenHighScore"] = "";
dictionaryVar["ru-ru"]["levelEndScreenTimeBonus"] = " ";
dictionaryVar["ru-ru"]["levelEndScreenTimeLeft"] = " ";
dictionaryVar["ru-ru"]["levelEndScreenSubTitle_levelFailed"] = "  ";
dictionaryVar["ru-ru"]["levelEndScreenTotalScore"] = " ";
dictionaryVar["ru-ru"]["levelEndScreenTitle_endless"] = " <VALUE>";
dictionaryVar["ru-ru"]["levelEndScreenTitle_difficulty"] = " !";
dictionaryVar["ru-ru"]["levelEndScreenTitle_level"] = " <VALUE>";
dictionaryVar["ru-ru"]["levelMapScreenTotalScore"] = " ";
dictionaryVar["ru-ru"]["startScreenPlay"] = "";
dictionaryVar["ru-ru"]["loadingScreenLoading"] = "...";
dictionaryVar["ru-ru"]["RewardAd_button"] = "video";
dictionaryVar["ru-ru"]["RewardAd_header"] = "coins";
dictionaryVar["ru-ru"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["ru-ru"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["ar-eg"] = dictionaryVar["ar-eg"] || {};
dictionaryVar["ar-eg"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["ar-eg"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["ar-eg"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["ar-eg"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["ar-eg"]["levelEndScreenHighScore_number"] = "High score:";
dictionaryVar["ar-eg"]["levelEndScreenTotalScore_number"] = "Total score:";
dictionaryVar["ar-eg"]["optionsExit"] = "Exit";
dictionaryVar["ar-eg"]["optionsLang_ru-ru"] = "";
dictionaryVar["ar-eg"]["optionsLang_pt-br"] = " - ";
dictionaryVar["ar-eg"]["optionsLang_es-es"] = "";
dictionaryVar["ar-eg"]["optionsLang_ar-eg"] = "";
dictionaryVar["ar-eg"]["optionsLang_ko-kr"] = "";
dictionaryVar["ar-eg"]["optionsLang_fr-fr"] = "";
dictionaryVar["ar-eg"]["levelEndScreenTotalScore_time"] = "Total time:";
dictionaryVar["ar-eg"]["levelEndScreenHighScore_time"] = "Best time:";
dictionaryVar["ar-eg"]["challengeLoadingError_notStarted"] = "Unable to connect to the server. Please try again later.";
dictionaryVar["ar-eg"]["challengeLoadingError_notValid"] = "Sorry, this challenge is no longer valid.";
dictionaryVar["ar-eg"]["optionsChallengeCancel"] = "Quit";
dictionaryVar["ar-eg"]["optionsChallengeForfeit"] = "Forfeit";
dictionaryVar["ar-eg"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["ar-eg"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["ar-eg"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["ar-eg"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["ar-eg"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["ar-eg"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["ar-eg"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["ar-eg"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["ar-eg"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["ar-eg"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["ar-eg"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["ar-eg"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["ar-eg"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["ar-eg"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["ar-eg"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["ar-eg"]["challengeEndScreenName_you"] = "You";
dictionaryVar["ar-eg"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["ar-eg"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["ar-eg"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["ar-eg"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["ar-eg"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["ar-eg"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["ar-eg"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["ar-eg"]["challengeEndScreenOutcomeMessage_WON"] = "You have won the challenge!";
dictionaryVar["ar-eg"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["ar-eg"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["ar-eg"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["ar-eg"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["ar-eg"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["ar-eg"]["levelEndScreenSubmitHighscoreBtn"] = "Submit score";
dictionaryVar["ar-eg"]["levelEndScreenViewHighscoreBtn"] = "View scores";
dictionaryVar["ar-eg"]["optionsAbout_header"] = "Developed by:";
dictionaryVar["ar-eg"]["optionsLang_tr-tr"] = "";
dictionaryVar["ar-eg"]["optionsLang_de-de"] = "";
dictionaryVar["ar-eg"]["startScreenByTinglyGames"] = ": CoolGames";
dictionaryVar["ar-eg"]["levelMapScreenWorld_0"] = " ";
dictionaryVar["ar-eg"]["startScreenQuestionaire"] = " ";
dictionaryVar["ar-eg"]["levelEndScreenMedal"] = " !";
dictionaryVar["ar-eg"]["optionsAbout"] = "";
dictionaryVar["ar-eg"]["optionsAbout_version"] = ":";
dictionaryVar["ar-eg"]["optionsAbout_backBtn"] = "";
dictionaryVar["ar-eg"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["ar-eg"]["optionsAbout_title"] = "";
dictionaryVar["ar-eg"]["optionsSFXBig_off"] = " ";
dictionaryVar["ar-eg"]["optionsSFXBig_on"] = " ";
dictionaryVar["ar-eg"]["optionsRestart"] = " ";
dictionaryVar["ar-eg"]["optionsRestartConfirmationText"] = "!\n\n            .        ";
dictionaryVar["ar-eg"]["levelMapScreenTitle"] = " ";
dictionaryVar["ar-eg"]["optionsQuitConfirmBtn_Yes"] = " ";
dictionaryVar["ar-eg"]["optionsQuitConfirmBtn_No"] = "";
dictionaryVar["ar-eg"]["optionsQuitConfirmationText"] = "!n\n\            .         ";
dictionaryVar["ar-eg"]["optionsTitle"] = "";
dictionaryVar["ar-eg"]["gameEndScreenBtnText"] = "";
dictionaryVar["ar-eg"]["gameEndScreenTitle"] = "!\n  .";
dictionaryVar["ar-eg"]["optionsLang_nl-nl"] = "";
dictionaryVar["ar-eg"]["optionsLang_en-gb"] = " ( )";
dictionaryVar["ar-eg"]["optionsLang_en-us"] = " ( )";
dictionaryVar["ar-eg"]["optionsSFX_off"] = "  ";
dictionaryVar["ar-eg"]["optionsSFX_on"] = "  ";
dictionaryVar["ar-eg"]["optionsMusic_off"] = " ";
dictionaryVar["ar-eg"]["optionsMusic_on"] = " ";
dictionaryVar["ar-eg"]["optionsDifficulty_hard"] = "";
dictionaryVar["ar-eg"]["optionsDifficulty_medium"] = "";
dictionaryVar["ar-eg"]["optionsDifficulty_easy"] = "";
dictionaryVar["ar-eg"]["optionsMoreGames"] = "  ";
dictionaryVar["ar-eg"]["optionsHighScore"] = " ";
dictionaryVar["ar-eg"]["optionsTutorial"] = " ";
dictionaryVar["ar-eg"]["optionsResume"] = "";
dictionaryVar["ar-eg"]["optionsQuit"] = "  ";
dictionaryVar["ar-eg"]["optionsStartScreen"] = " ";
dictionaryVar["ar-eg"]["levelEndScreenHighScore"] = " ";
dictionaryVar["ar-eg"]["levelEndScreenTimeBonus"] = " ";
dictionaryVar["ar-eg"]["levelEndScreenTimeLeft"] = " ";
dictionaryVar["ar-eg"]["levelEndScreenSubTitle_levelFailed"] = "     ";
dictionaryVar["ar-eg"]["levelEndScreenTotalScore"] = " ";
dictionaryVar["ar-eg"]["levelEndScreenTitle_endless"] = " <VALUE>";
dictionaryVar["ar-eg"]["levelEndScreenTitle_difficulty"] = "!";
dictionaryVar["ar-eg"]["levelEndScreenTitle_level"] = " <VALUE>";
dictionaryVar["ar-eg"]["levelMapScreenTotalScore"] = " ";
dictionaryVar["ar-eg"]["startScreenPlay"] = "";
dictionaryVar["ar-eg"]["loadingScreenLoading"] = "  ...";
dictionaryVar["ar-eg"]["RewardAd_button"] = "video";
dictionaryVar["ar-eg"]["RewardAd_header"] = "coins";
dictionaryVar["ar-eg"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["ar-eg"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["ko-kr"] = dictionaryVar["ko-kr"] || {};
dictionaryVar["ko-kr"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["ko-kr"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["ko-kr"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["ko-kr"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["ko-kr"]["levelEndScreenHighScore_number"] = "High score:";
dictionaryVar["ko-kr"]["levelEndScreenTotalScore_number"] = "Total score:";
dictionaryVar["ko-kr"]["optionsExit"] = "Exit";
dictionaryVar["ko-kr"]["optionsLang_ru-ru"] = "";
dictionaryVar["ko-kr"]["optionsLang_pt-br"] = "()";
dictionaryVar["ko-kr"]["optionsLang_es-es"] = "";
dictionaryVar["ko-kr"]["optionsLang_ar-eg"] = "";
dictionaryVar["ko-kr"]["optionsLang_ko-kr"] = "";
dictionaryVar["ko-kr"]["optionsLang_fr-fr"] = "";
dictionaryVar["ko-kr"]["levelEndScreenTotalScore_time"] = "Total time:";
dictionaryVar["ko-kr"]["levelEndScreenHighScore_time"] = "Best time:";
dictionaryVar["ko-kr"]["challengeLoadingError_notStarted"] = "Unable to connect to the server. Please try again later.";
dictionaryVar["ko-kr"]["challengeLoadingError_notValid"] = "Sorry, this challenge is no longer valid.";
dictionaryVar["ko-kr"]["optionsChallengeCancel"] = "Quit";
dictionaryVar["ko-kr"]["optionsChallengeForfeit"] = "Forfeit";
dictionaryVar["ko-kr"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["ko-kr"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["ko-kr"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["ko-kr"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["ko-kr"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["ko-kr"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["ko-kr"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["ko-kr"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["ko-kr"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["ko-kr"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["ko-kr"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["ko-kr"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["ko-kr"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["ko-kr"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["ko-kr"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["ko-kr"]["challengeEndScreenName_you"] = "You";
dictionaryVar["ko-kr"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["ko-kr"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["ko-kr"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["ko-kr"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["ko-kr"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["ko-kr"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["ko-kr"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["ko-kr"]["challengeEndScreenOutcomeMessage_WON"] = "You have won the challenge!";
dictionaryVar["ko-kr"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["ko-kr"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["ko-kr"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["ko-kr"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["ko-kr"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["ko-kr"]["levelEndScreenSubmitHighscoreBtn"] = "Submit score";
dictionaryVar["ko-kr"]["levelEndScreenViewHighscoreBtn"] = "View scores";
dictionaryVar["ko-kr"]["optionsAbout_header"] = "Developed by:";
dictionaryVar["ko-kr"]["optionsLang_tr-tr"] = "";
dictionaryVar["ko-kr"]["optionsLang_de-de"] = "";
dictionaryVar["ko-kr"]["startScreenByTinglyGames"] = ": CoolGames";
dictionaryVar["ko-kr"]["levelMapScreenWorld_0"] = " ";
dictionaryVar["ko-kr"]["startScreenQuestionaire"] = " ?";
dictionaryVar["ko-kr"]["levelEndScreenMedal"] = "!";
dictionaryVar["ko-kr"]["optionsAbout"] = " ";
dictionaryVar["ko-kr"]["optionsAbout_version"] = ":";
dictionaryVar["ko-kr"]["optionsAbout_backBtn"] = "";
dictionaryVar["ko-kr"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["ko-kr"]["optionsAbout_title"] = " ";
dictionaryVar["ko-kr"]["optionsSFXBig_off"] = " ";
dictionaryVar["ko-kr"]["optionsSFXBig_on"] = " ";
dictionaryVar["ko-kr"]["optionsRestart"] = " ";
dictionaryVar["ko-kr"]["optionsRestartConfirmationText"] = "!\n\n        .   ?";
dictionaryVar["ko-kr"]["levelMapScreenTitle"] = " ";
dictionaryVar["ko-kr"]["optionsQuitConfirmBtn_Yes"] = ", ";
dictionaryVar["ko-kr"]["optionsQuitConfirmBtn_No"] = "";
dictionaryVar["ko-kr"]["optionsQuitConfirmationText"] = "!\n\n       .  ?";
dictionaryVar["ko-kr"]["optionsTitle"] = "";
dictionaryVar["ko-kr"]["gameEndScreenBtnText"] = "";
dictionaryVar["ko-kr"]["gameEndScreenTitle"] = "!\n .";
dictionaryVar["ko-kr"]["optionsLang_nl-nl"] = "";
dictionaryVar["ko-kr"]["optionsLang_en-gb"] = "(GB)";
dictionaryVar["ko-kr"]["optionsLang_en-us"] = "(US)";
dictionaryVar["ko-kr"]["optionsSFX_off"] = "";
dictionaryVar["ko-kr"]["optionsSFX_on"] = "";
dictionaryVar["ko-kr"]["optionsMusic_off"] = "";
dictionaryVar["ko-kr"]["optionsMusic_on"] = "";
dictionaryVar["ko-kr"]["optionsDifficulty_hard"] = "";
dictionaryVar["ko-kr"]["optionsDifficulty_medium"] = "";
dictionaryVar["ko-kr"]["optionsDifficulty_easy"] = "";
dictionaryVar["ko-kr"]["optionsMoreGames"] = "  ";
dictionaryVar["ko-kr"]["optionsHighScore"] = " ";
dictionaryVar["ko-kr"]["optionsTutorial"] = " ";
dictionaryVar["ko-kr"]["optionsResume"] = "";
dictionaryVar["ko-kr"]["optionsQuit"] = "";
dictionaryVar["ko-kr"]["optionsStartScreen"] = " ";
dictionaryVar["ko-kr"]["levelEndScreenHighScore"] = " ";
dictionaryVar["ko-kr"]["levelEndScreenTimeBonus"] = " ";
dictionaryVar["ko-kr"]["levelEndScreenTimeLeft"] = " ";
dictionaryVar["ko-kr"]["levelEndScreenSubTitle_levelFailed"] = " ";
dictionaryVar["ko-kr"]["levelEndScreenTotalScore"] = " ";
dictionaryVar["ko-kr"]["levelEndScreenTitle_endless"] = " <VALUE>";
dictionaryVar["ko-kr"]["levelEndScreenTitle_difficulty"] = " !";
dictionaryVar["ko-kr"]["levelEndScreenTitle_level"] = " <VALUE>";
dictionaryVar["ko-kr"]["levelMapScreenTotalScore"] = " ";
dictionaryVar["ko-kr"]["startScreenPlay"] = "PLAY";
dictionaryVar["ko-kr"]["loadingScreenLoading"] = " ...";
dictionaryVar["ko-kr"]["RewardAd_button"] = "video";
dictionaryVar["ko-kr"]["RewardAd_header"] = "coins";
dictionaryVar["ko-kr"]["RewardAd_text_1"] = "watch a video and get <COINS> coins!";
dictionaryVar["ko-kr"]["RewardAd_text_2"] = "new video is available soon";
dictionaryVar["jp-jp"] = dictionaryVar["jp-jp"] || {};
dictionaryVar["jp-jp"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["jp-jp"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["jp-jp"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["jp-jp"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["jp-jp"]["levelEndScreenHighScore_number"] = "";
dictionaryVar["jp-jp"]["levelEndScreenTotalScore_number"] = "";
dictionaryVar["jp-jp"]["optionsExit"] = "";
dictionaryVar["jp-jp"]["optionsLang_ru-ru"] = "";
dictionaryVar["jp-jp"]["optionsLang_pt-br"] = "";
dictionaryVar["jp-jp"]["optionsLang_es-es"] = "";
dictionaryVar["jp-jp"]["optionsLang_ar-eg"] = "";
dictionaryVar["jp-jp"]["optionsLang_ko-kr"] = "";
dictionaryVar["jp-jp"]["optionsLang_fr-fr"] = "";
dictionaryVar["jp-jp"]["levelEndScreenTotalScore_time"] = "";
dictionaryVar["jp-jp"]["levelEndScreenHighScore_time"] = "";
dictionaryVar["jp-jp"]["challengeLoadingError_notStarted"] = "Unable to connect to the server. Please try again later.";
dictionaryVar["jp-jp"]["challengeLoadingError_notValid"] = "Sorry, this challenge is no longer valid.";
dictionaryVar["jp-jp"]["optionsChallengeCancel"] = "";
dictionaryVar["jp-jp"]["optionsChallengeForfeit"] = "";
dictionaryVar["jp-jp"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["jp-jp"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["jp-jp"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["jp-jp"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["jp-jp"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["jp-jp"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["jp-jp"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["jp-jp"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["jp-jp"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["jp-jp"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["jp-jp"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["jp-jp"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["jp-jp"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["jp-jp"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["jp-jp"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["jp-jp"]["challengeEndScreenName_you"] = "You";
dictionaryVar["jp-jp"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["jp-jp"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["jp-jp"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["jp-jp"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["jp-jp"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["jp-jp"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["jp-jp"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["jp-jp"]["challengeEndScreenOutcomeMessage_WON"] = "";
dictionaryVar["jp-jp"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["jp-jp"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["jp-jp"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["jp-jp"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["jp-jp"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["jp-jp"]["levelEndScreenSubmitHighscoreBtn"] = "";
dictionaryVar["jp-jp"]["levelEndScreenViewHighscoreBtn"] = "";
dictionaryVar["jp-jp"]["optionsAbout_header"] = "Developed by:";
dictionaryVar["jp-jp"]["optionsLang_tr-tr"] = "";
dictionaryVar["jp-jp"]["optionsLang_de-de"] = "";
dictionaryVar["jp-jp"]["startScreenByTinglyGames"] = "by: CoolGames";
dictionaryVar["jp-jp"]["levelMapScreenWorld_0"] = "";
dictionaryVar["jp-jp"]["startScreenQuestionaire"] = "";
dictionaryVar["jp-jp"]["levelEndScreenMedal"] = "";
dictionaryVar["jp-jp"]["optionsAbout"] = "About";
dictionaryVar["jp-jp"]["optionsAbout_version"] = "version:";
dictionaryVar["jp-jp"]["optionsAbout_backBtn"] = "";
dictionaryVar["jp-jp"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["jp-jp"]["optionsAbout_title"] = "About";
dictionaryVar["jp-jp"]["optionsSFXBig_off"] = " ";
dictionaryVar["jp-jp"]["optionsSFXBig_on"] = " ";
dictionaryVar["jp-jp"]["optionsRestart"] = "";
dictionaryVar["jp-jp"]["optionsRestartConfirmationText"] = "\n\n\n\n";
dictionaryVar["jp-jp"]["levelMapScreenTitle"] = "";
dictionaryVar["jp-jp"]["optionsQuitConfirmBtn_Yes"] = "";
dictionaryVar["jp-jp"]["optionsQuitConfirmBtn_No"] = "";
dictionaryVar["jp-jp"]["optionsQuitConfirmationText"] = "\n\n\n\n";
dictionaryVar["jp-jp"]["optionsTitle"] = "";
dictionaryVar["jp-jp"]["gameEndScreenBtnText"] = "";
dictionaryVar["jp-jp"]["gameEndScreenTitle"] = "\n";
dictionaryVar["jp-jp"]["optionsLang_nl-nl"] = "";
dictionaryVar["jp-jp"]["optionsLang_en-gb"] = "";
dictionaryVar["jp-jp"]["optionsLang_en-us"] = "";
dictionaryVar["jp-jp"]["optionsSFX_off"] = "";
dictionaryVar["jp-jp"]["optionsSFX_on"] = "";
dictionaryVar["jp-jp"]["optionsMusic_off"] = "";
dictionaryVar["jp-jp"]["optionsMusic_on"] = "";
dictionaryVar["jp-jp"]["optionsDifficulty_hard"] = "";
dictionaryVar["jp-jp"]["optionsDifficulty_medium"] = "";
dictionaryVar["jp-jp"]["optionsDifficulty_easy"] = "";
dictionaryVar["jp-jp"]["optionsMoreGames"] = "";
dictionaryVar["jp-jp"]["optionsHighScore"] = "";
dictionaryVar["jp-jp"]["optionsTutorial"] = "";
dictionaryVar["jp-jp"]["optionsResume"] = "";
dictionaryVar["jp-jp"]["optionsQuit"] = "";
dictionaryVar["jp-jp"]["optionsStartScreen"] = "";
dictionaryVar["jp-jp"]["levelEndScreenHighScore"] = "";
dictionaryVar["jp-jp"]["levelEndScreenTimeBonus"] = "";
dictionaryVar["jp-jp"]["levelEndScreenTimeLeft"] = "";
dictionaryVar["jp-jp"]["levelEndScreenSubTitle_levelFailed"] = "";
dictionaryVar["jp-jp"]["levelEndScreenTotalScore"] = "";
dictionaryVar["jp-jp"]["levelEndScreenTitle_endless"] = " <VALUE>";
dictionaryVar["jp-jp"]["levelEndScreenTitle_difficulty"] = "";
dictionaryVar["jp-jp"]["levelEndScreenTitle_level"] = " <VALUE>";
dictionaryVar["jp-jp"]["levelMapScreenTotalScore"] = "";
dictionaryVar["jp-jp"]["startScreenPlay"] = "";
dictionaryVar["jp-jp"]["loadingScreenLoading"] = "";
dictionaryVar["jp-jp"]["RewardAd_button"] = "";
dictionaryVar["jp-jp"]["RewardAd_header"] = "";
dictionaryVar["jp-jp"]["RewardAd_text_1"] = "\n<COINS>";
dictionaryVar["jp-jp"]["RewardAd_text_2"] = "";

// Chrome japanese
dictionaryVar["ja"] = dictionaryVar["ja"] || {};
dictionaryVar["ja"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["ja"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["ja"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["ja"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["ja"]["levelEndScreenHighScore_number"] = "";
dictionaryVar["ja"]["levelEndScreenTotalScore_number"] = "";
dictionaryVar["ja"]["optionsExit"] = "";
dictionaryVar["ja"]["optionsLang_ru-ru"] = "";
dictionaryVar["ja"]["optionsLang_pt-br"] = "";
dictionaryVar["ja"]["optionsLang_es-es"] = "";
dictionaryVar["ja"]["optionsLang_ar-eg"] = "";
dictionaryVar["ja"]["optionsLang_ko-kr"] = "";
dictionaryVar["ja"]["optionsLang_fr-fr"] = "";
dictionaryVar["ja"]["levelEndScreenTotalScore_time"] = "";
dictionaryVar["ja"]["levelEndScreenHighScore_time"] = "";
dictionaryVar["ja"]["challengeLoadingError_notStarted"] = "Unable to connect to the server. Please try again later.";
dictionaryVar["ja"]["challengeLoadingError_notValid"] = "Sorry, this challenge is no longer valid.";
dictionaryVar["ja"]["optionsChallengeCancel"] = "";
dictionaryVar["ja"]["optionsChallengeForfeit"] = "";
dictionaryVar["ja"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["ja"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["ja"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["ja"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["ja"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["ja"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["ja"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["ja"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["ja"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["ja"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["ja"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["ja"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["ja"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["ja"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["ja"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["ja"]["challengeEndScreenName_you"] = "You";
dictionaryVar["ja"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["ja"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["ja"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["ja"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["ja"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["ja"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["ja"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["ja"]["challengeEndScreenOutcomeMessage_WON"] = "";
dictionaryVar["ja"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["ja"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["ja"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["ja"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["ja"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["ja"]["levelEndScreenSubmitHighscoreBtn"] = "";
dictionaryVar["ja"]["levelEndScreenViewHighscoreBtn"] = "";
dictionaryVar["ja"]["optionsAbout_header"] = "Developed by:";
dictionaryVar["ja"]["optionsLang_tr-tr"] = "";
dictionaryVar["ja"]["optionsLang_de-de"] = "";
dictionaryVar["ja"]["startScreenByTinglyGames"] = "by: CoolGames";
dictionaryVar["ja"]["levelMapScreenWorld_0"] = "";
dictionaryVar["ja"]["startScreenQuestionaire"] = "";
dictionaryVar["ja"]["levelEndScreenMedal"] = "";
dictionaryVar["ja"]["optionsAbout"] = "About";
dictionaryVar["ja"]["optionsAbout_version"] = "version:";
dictionaryVar["ja"]["optionsAbout_backBtn"] = "";
dictionaryVar["ja"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["ja"]["optionsAbout_title"] = "About";
dictionaryVar["ja"]["optionsSFXBig_off"] = " ";
dictionaryVar["ja"]["optionsSFXBig_on"] = " ";
dictionaryVar["ja"]["optionsRestart"] = "";
dictionaryVar["ja"]["optionsRestartConfirmationText"] = "\n\n\n\n";
dictionaryVar["ja"]["levelMapScreenTitle"] = "";
dictionaryVar["ja"]["optionsQuitConfirmBtn_Yes"] = "";
dictionaryVar["ja"]["optionsQuitConfirmBtn_No"] = "";
dictionaryVar["ja"]["optionsQuitConfirmationText"] = "\n\n\n\n";
dictionaryVar["ja"]["optionsTitle"] = "";
dictionaryVar["ja"]["gameEndScreenBtnText"] = "";
dictionaryVar["ja"]["gameEndScreenTitle"] = "\n";
dictionaryVar["ja"]["optionsLang_nl-nl"] = "";
dictionaryVar["ja"]["optionsLang_en-gb"] = "";
dictionaryVar["ja"]["optionsLang_en-us"] = "";
dictionaryVar["ja"]["optionsSFX_off"] = "";
dictionaryVar["ja"]["optionsSFX_on"] = "";
dictionaryVar["ja"]["optionsMusic_off"] = "";
dictionaryVar["ja"]["optionsMusic_on"] = "";
dictionaryVar["ja"]["optionsDifficulty_hard"] = "";
dictionaryVar["ja"]["optionsDifficulty_medium"] = "";
dictionaryVar["ja"]["optionsDifficulty_easy"] = "";
dictionaryVar["ja"]["optionsMoreGames"] = "";
dictionaryVar["ja"]["optionsHighScore"] = "";
dictionaryVar["ja"]["optionsTutorial"] = "";
dictionaryVar["ja"]["optionsResume"] = "";
dictionaryVar["ja"]["optionsQuit"] = "";
dictionaryVar["ja"]["optionsStartScreen"] = "";
dictionaryVar["ja"]["levelEndScreenHighScore"] = "";
dictionaryVar["ja"]["levelEndScreenTimeBonus"] = "";
dictionaryVar["ja"]["levelEndScreenTimeLeft"] = "";
dictionaryVar["ja"]["levelEndScreenSubTitle_levelFailed"] = "";
dictionaryVar["ja"]["levelEndScreenTotalScore"] = "";
dictionaryVar["ja"]["levelEndScreenTitle_endless"] = " <VALUE>";
dictionaryVar["ja"]["levelEndScreenTitle_difficulty"] = "";
dictionaryVar["ja"]["levelEndScreenTitle_level"] = " <VALUE>";
dictionaryVar["ja"]["levelMapScreenTotalScore"] = "";
dictionaryVar["ja"]["startScreenPlay"] = "";
dictionaryVar["ja"]["loadingScreenLoading"] = "";
dictionaryVar["ja"]["RewardAd_button"] = "";
dictionaryVar["ja"]["RewardAd_header"] = "";
dictionaryVar["ja"]["RewardAd_text_1"] = "\n<COINS>";
dictionaryVar["ja"]["RewardAd_text_2"] = "";

// iOS japanese
dictionaryVar["ja-jp"] = dictionaryVar["ja-jp"] || {};
dictionaryVar["ja-jp"]["optionsAbout_header_publisher"] = "Published by:";
dictionaryVar["ja-jp"]["challengeForfeitMessage_winnings"] = "<NAME> has won <AMOUNT> fairpoints!";
dictionaryVar["ja-jp"]["challengeEndScreenChallengeSend_submessage_stranger"] = "If no one accepts your challenge within 72 hours, the amount of your wager and the challenge fee will be returned to you.";
dictionaryVar["ja-jp"]["challengeEndScreenChallengeSend_submessage"] = "<NAME> has 72 hours to accept or decline your challenge. If <NAME> declines or doesnt accept within 72 hours your wager and challenge fee will be reimbursed.";
dictionaryVar["ja-jp"]["levelEndScreenHighScore_number"] = "";
dictionaryVar["ja-jp"]["levelEndScreenTotalScore_number"] = "";
dictionaryVar["ja-jp"]["optionsExit"] = "";
dictionaryVar["ja-jp"]["optionsLang_ru-ru"] = "";
dictionaryVar["ja-jp"]["optionsLang_pt-br"] = "";
dictionaryVar["ja-jp"]["optionsLang_es-es"] = "";
dictionaryVar["ja-jp"]["optionsLang_ar-eg"] = "";
dictionaryVar["ja-jp"]["optionsLang_ko-kr"] = "";
dictionaryVar["ja-jp"]["optionsLang_fr-fr"] = "";
dictionaryVar["ja-jp"]["levelEndScreenTotalScore_time"] = "";
dictionaryVar["ja-jp"]["levelEndScreenHighScore_time"] = "";
dictionaryVar["ja-jp"]["challengeLoadingError_notStarted"] = "Unable to connect to the server. Please try again later.";
dictionaryVar["ja-jp"]["challengeLoadingError_notValid"] = "Sorry, this challenge is no longer valid.";
dictionaryVar["ja-jp"]["optionsChallengeCancel"] = "";
dictionaryVar["ja-jp"]["optionsChallengeForfeit"] = "";
dictionaryVar["ja-jp"]["challengeForfeitMessage_error"] = "An error occured while forfeiting the challenge. Please try again later.";
dictionaryVar["ja-jp"]["challengeForfeitMessage_success"] = "You have forfeited the challenge.";
dictionaryVar["ja-jp"]["challengeForfeitConfirmBtn_no"] = "No";
dictionaryVar["ja-jp"]["challengeForfeitConfirmBtn_yes"] = "Yes";
dictionaryVar["ja-jp"]["challengeForfeitConfirmText"] = "You are about to forfeit the challenge. Are you sure you want to proceed?";
dictionaryVar["ja-jp"]["challengeStartTextScore_challenger"] = "Play the game and set a score.";
dictionaryVar["ja-jp"]["challengeStartTextTime_challenger"] = "Play the game and set a time.";
dictionaryVar["ja-jp"]["challengeStartScreenTitle_challenger_stranger"] = "You are setting a score for:";
dictionaryVar["ja-jp"]["challengeStartScreenTitle_challenger_friend"] = "You are challenging:";
dictionaryVar["ja-jp"]["challengeStartScreenTitle_challengee_stranger"] = "You have been matched with:";
dictionaryVar["ja-jp"]["challengeEndScreenScoreSend_error"] = "An error occured while communicating with the server. Please try again later.";
dictionaryVar["ja-jp"]["challengeCancelMessage_success"] = "Your challenge has been cancelled.";
dictionaryVar["ja-jp"]["challengeCancelMessage_error"] = "An error occured while cancelling your challenge. Please try again later.";
dictionaryVar["ja-jp"]["challengeEndScreenChallengeSend_success"] = "Your challenge has been sent!";
dictionaryVar["ja-jp"]["challengeEndScreenChallengeSend_error"] = "An error occured while submitting the challenge. Please try again later.";
dictionaryVar["ja-jp"]["challengeEndScreenName_you"] = "You";
dictionaryVar["ja-jp"]["challengeEndScreenBtn_cancel"] = "Cancel challenge";
dictionaryVar["ja-jp"]["challengeEndScreensBtn_submit"] = "Submit challenge";
dictionaryVar["ja-jp"]["challengeCancelConfirmBtn_no"] = "No";
dictionaryVar["ja-jp"]["challengeCancelConfirmBtn_yes"] = "Yes";
dictionaryVar["ja-jp"]["challengeCancelConfirmText"] = "You are about to cancel the challenge. Your wager will be returned minus the challenge fee. Are you sure you want to cancel the challenge?";
dictionaryVar["ja-jp"]["challengeEndScreenOutcomeMessage_TIED"] = "You tied.";
dictionaryVar["ja-jp"]["challengeEndScreenOutcomeMessage_LOST"] = "You have lost the challenge.";
dictionaryVar["ja-jp"]["challengeEndScreenOutcomeMessage_WON"] = "";
dictionaryVar["ja-jp"]["challengeEndScreenWinnings"] = "You have won <AMOUNT> fairpoints";
dictionaryVar["ja-jp"]["challengeStartScreenToWin"] = "Amount to win:";
dictionaryVar["ja-jp"]["challengeStartTextTime"] = "<NAME>'s time:";
dictionaryVar["ja-jp"]["challengeStartTextScore"] = "<NAME>'s score:";
dictionaryVar["ja-jp"]["challengeStartScreenTitle_challengee_friend"] = "You have been challenged by:";
dictionaryVar["ja-jp"]["levelEndScreenSubmitHighscoreBtn"] = "";
dictionaryVar["ja-jp"]["levelEndScreenViewHighscoreBtn"] = "";
dictionaryVar["ja-jp"]["optionsAbout_header"] = "Developed by:";
dictionaryVar["ja-jp"]["optionsLang_tr-tr"] = "";
dictionaryVar["ja-jp"]["optionsLang_de-de"] = "";
dictionaryVar["ja-jp"]["startScreenByTinglyGames"] = "by: CoolGames";
dictionaryVar["ja-jp"]["levelMapScreenWorld_0"] = "";
dictionaryVar["ja-jp"]["startScreenQuestionaire"] = "";
dictionaryVar["ja-jp"]["levelEndScreenMedal"] = "";
dictionaryVar["ja-jp"]["optionsAbout"] = "About";
dictionaryVar["ja-jp"]["optionsAbout_version"] = "version:";
dictionaryVar["ja-jp"]["optionsAbout_backBtn"] = "";
dictionaryVar["ja-jp"]["optionsAbout_text"] = "CoolGames\nwww.coolgames.com\n 2018";
dictionaryVar["ja-jp"]["optionsAbout_title"] = "About";
dictionaryVar["ja-jp"]["optionsSFXBig_off"] = " ";
dictionaryVar["ja-jp"]["optionsSFXBig_on"] = " ";
dictionaryVar["ja-jp"]["optionsRestart"] = "";
dictionaryVar["ja-jp"]["optionsRestartConfirmationText"] = "\n\n\n\n";
dictionaryVar["ja-jp"]["levelMapScreenTitle"] = "";
dictionaryVar["ja-jp"]["optionsQuitConfirmBtn_Yes"] = "";
dictionaryVar["ja-jp"]["optionsQuitConfirmBtn_No"] = "";
dictionaryVar["ja-jp"]["optionsQuitConfirmationText"] = "\n\n\n\n";
dictionaryVar["ja-jp"]["optionsTitle"] = "";
dictionaryVar["ja-jp"]["gameEndScreenBtnText"] = "";
dictionaryVar["ja-jp"]["gameEndScreenTitle"] = "\n";
dictionaryVar["ja-jp"]["optionsLang_nl-nl"] = "";
dictionaryVar["ja-jp"]["optionsLang_en-gb"] = "";
dictionaryVar["ja-jp"]["optionsLang_en-us"] = "";
dictionaryVar["ja-jp"]["optionsSFX_off"] = "";
dictionaryVar["ja-jp"]["optionsSFX_on"] = "";
dictionaryVar["ja-jp"]["optionsMusic_off"] = "";
dictionaryVar["ja-jp"]["optionsMusic_on"] = "";
dictionaryVar["ja-jp"]["optionsDifficulty_hard"] = "";
dictionaryVar["ja-jp"]["optionsDifficulty_medium"] = "";
dictionaryVar["ja-jp"]["optionsDifficulty_easy"] = "";
dictionaryVar["ja-jp"]["optionsMoreGames"] = "";
dictionaryVar["ja-jp"]["optionsHighScore"] = "";
dictionaryVar["ja-jp"]["optionsTutorial"] = "";
dictionaryVar["ja-jp"]["optionsResume"] = "";
dictionaryVar["ja-jp"]["optionsQuit"] = "";
dictionaryVar["ja-jp"]["optionsStartScreen"] = "";
dictionaryVar["ja-jp"]["levelEndScreenHighScore"] = "";
dictionaryVar["ja-jp"]["levelEndScreenTimeBonus"] = "";
dictionaryVar["ja-jp"]["levelEndScreenTimeLeft"] = "";
dictionaryVar["ja-jp"]["levelEndScreenSubTitle_levelFailed"] = "";
dictionaryVar["ja-jp"]["levelEndScreenTotalScore"] = "";
dictionaryVar["ja-jp"]["levelEndScreenTitle_endless"] = " <VALUE>";
dictionaryVar["ja-jp"]["levelEndScreenTitle_difficulty"] = "";
dictionaryVar["ja-jp"]["levelEndScreenTitle_level"] = " <VALUE>";
dictionaryVar["ja-jp"]["levelMapScreenTotalScore"] = "";
dictionaryVar["ja-jp"]["startScreenPlay"] = "";
dictionaryVar["ja-jp"]["loadingScreenLoading"] = "";
dictionaryVar["ja-jp"]["RewardAd_button"] = "";
dictionaryVar["ja-jp"]["RewardAd_header"] = "";
dictionaryVar["ja-jp"]["RewardAd_text_1"] = "\n<COINS>";
dictionaryVar["ja-jp"]["RewardAd_text_2"] = "";

//******************************************************
//*****    Script Resource: DialogStartPlay
//******************************************************

// ***************************************
// tgfDialogs.StartPlay
//
// This dialog displays the start message when the game starts.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 18-10-2015
// ***************************************

// TODO: Make this into a much nicer dialog, now it is just a message box

// Directives for jslint
/*global tbEase */
/*global tgfDialogs, tgfSettings, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.startPlay = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,						// The background image
	marginLeft: tgfScale(40),							// Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),							// Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),							// Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),							// Bottom margin whether there is no text, images, etc.
	titlePercentage: 25,								// Percentage of the box for the title
	messagePercentage: 75,								// Percentage of the box for the message (if any)
	titleText: "",										// Text for the title
	titleDictionaryKey: "",								// Dictionary key for the title
	titleFont: f_tgf_title,								// Font to be used for the title
	messageText: "",									// Text for the message
	messageDictionaryKey: "",							// Dictionary key for the message
	messageFont: f_tgf_text,							// Font to be used for the message
	iconImage: null,									// Image for the icon
	iconPosition: "right",								// Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,								// Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),						// Width of the close button
	closeButtonHeight: tgfScale(96),					// Height of the close button
	darken: true,										// Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 4,										// How long it will stay visible before disappearing
	disappearOnClick: true,								// Whether to disappear when the screen is clicked
	components: [],										// The additional components to add
	onClose: null,										// Function to be called when clicking the close button

	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	backgroundProperties: null,							// Properties for the background container component
	titleProperties: null,								// Properties for the title component
	messageProperties: null,							// Properties for the message component
	iconProperties: null,								// Properties for the icon component
	closeButtonProperties: null							// Properties for the close button component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.MessageBox
 */
tgfDialogs.StartPlay = function(properties) {
	"use strict";
	this.name = "StartPlay";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.startPlay);
	this.setProperties(tgfSettings.startPlayDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the message box dialog
tgfDialogs.inherit(tgfDialogs.StartPlay, tgfDialogs.MessageBox);

//******************************************************
//*****    Script Resource: DialogEndPlayWon
//******************************************************

// ***************************************
// tgfDialogs.EndPlayWon
//
// This dialog displays the game won message when the play ends
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 18-10-2015
// ***************************************

// TODO: Make this into a much nicer dialog, now it is just a question box

// Directives for jslint
/*global tbEase */
/*global tgfDialogs, tgfSettings, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.endPlayWon = {

	backgroundImage: s_tgf_frame,                       // The background image
	backgroundX: tgfScale(0),
	backgroundY: tgfScale(0),

	x: undefined,                                       // X-position. When undefined it is placed in the center
	y: undefined,                                       // Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,                       // The background image
	marginLeft: tgfScale(40),                           // Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),                          // Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),                            // Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),                         // Bottom margin whether there is no text, images, etc.
	titlePercentage: 10,                                // Percentage of the box for the title
	messagePercentage: 60,                              // Percentage of the box for the message (if any)
	buttonPercentage: 30,                               // Percentage of the box for the buttons
	titleText: "",                                      // Text for the title
	titleDictionaryKey: "",                             // Dictionary key for the title
	titleDict:"",
	titleFont: f_tgf_title,                             // Font to be used for the title
	messageText: "",                                    // Text for the message
	messageDictionaryKey: "",                           // Dictionary key for the message
	messageFont: f_tgf_text,                            // Font to be used for the message
	iconImage: null,                                    // Image for the icon
	iconPosition: "right",                              // Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,                              // Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),                     // Width of the close button
	closeButtonHeight: tgfScale(96),                    // Height of the close button
	buttonHorizontal: true,                             // Whether the buttons must be placed horizontally
	buttonHorizontalSize: tgfScale(0),                  // Total horizontal size for the buttons (0 = use maximum)
	buttonHorizontalGap: tgfScale(8),                   // Horizontal gap between the buttons
	buttonVerticalGap: tgfScale(8),                     // Vertical gap between the buttons
	buttonVerticalAlignment: "middle",                  // Vertical alignment for the buttons ("top", "middle", "bottom")
	buttonDefaultHide: true,                            // Whether to hide the dialog on clicking the button
	buttonDefaultImage: s_tgf_button,                   // Default image for the buttons
	buttonDefaultFont: f_tgf_button,                    // Default font to be used for the buttons
	buttonDefaultProperties: null,                      // Default additional properties for the button components
	buttons: [],                                        // Array of (array of) information about the buttons; can contain:
														//      sliced, text, dictionaryKey, image, icon, font, id, properties, hide
	darken: true,                                       // Whether to darken the background
	appearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-500), endY: tgfScale(0), ease: tbEase.easeOutOvershoot, easeArgument: 1.2},//{effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 9999999,                                  // How long it will stay visible before disappearing automatically
	disappearOnClick: false,                            // Whether to disappear when the screen is clicked
	components: [],                                     // The additional components to add
	onClick: null,                                      // Function to be called when clicking the button: function(dialog, buttonId)   
	onClose: null,                                      // Function to be called when clicking the close button
	
	// Additional properties for the components
	darkenerProperties: null,                           // Properties for the darkener component
	backgroundProperties: null,                         // Properties for the background container component
	titleProperties: null,                              // Properties for the title component
	messageProperties: null,                            // Properties for the message component
	iconProperties: null,                               // Properties for the icon component
	closeButtonProperties: null,                        // Properties for the close button component
	
	//Extra Properties
	levelName: "",
	level: undefined,
	score: 0,
	time: 0,
	stars: 0,
	moves: 0,
	highscore: 0,
	coins: 0,
	
	improved: false,
	
	showSettings: [],                                   // Which information to show USED: "score", "time", "stars", "moves"
	
	starImageEmpty: [s_star01_empty,  s_star02_empty, s_star03_empty],
	starImageFill: [s_star01_fill, s_star02_fill, s_star03_fill],
	starEffect:  s_sfx_star,
	starImageX: [tgfScale(-177), tgfScale(0), tgfScale(177)],
	starImageY: [tgfScale(-117), tgfScale(-140), tgfScale(-117)],
	starImageWidth: [tgfScale(0), tgfScale(0), tgfScale(0)],
	starImageHeight: [tgfScale(0), tgfScale(0), tgfScale(0)],
	starsComponents: [],
	
	starSounds: [a_levelend_star_01, a_levelend_star_02, a_levelend_star_03],

	emphasizedStatsHeaderText: "",
	emphasizedStatsHeaderDictionaryKey: "",
	emphasizedStatsHeaderX: tgfScale(0),
	emphasizedStatsHeaderY: tgfScale(15),
	emphasizedStatsHeaderFont: f_tgf_title,
	
	emphasizedStatsText: "",
	emphasizedStatsDictionaryKey: "",
	emphasizedStatsX: tgfScale(0),
	emphasizedStatsY: tgfScale(50),
	emphasizedStatsFont: f_tgf_title,
	
	primaryStatsHeaderText: "",
	primaryStatsHeaderDictionaryKey: "TOTAL SCORE:",
	primaryStatsHeaderX: tgfScale(0),
	primaryStatsHeaderY: tgfScale(15),
	primaryStatsHeaderFont: f_tgf_text,
	
	primaryStatsText: "",
	primaryStatsDictionaryKey: "",
	primaryStatsX: tgfScale(0),
	primaryStatsY: tgfScale(50),
	primaryStatsFont: f_tgf_text,
	
	secondaryStatsHeaderText: "",
	secondaryStatsHeaderDictionaryKey: "HIGH SCORE:",
	secondaryStatsHeaderX: tgfScale(0),
	secondaryStatsHeaderY: tgfScale(85),
	secondaryStatsHeaderFont: f_tgf_text,
	
	secondaryStatsText: "",
	secondaryStatsDictionaryKey: "",
	secondaryStatsX: tgfScale(0),
	secondaryStatsY: tgfScale(120),
	secondaryStatsFont: f_tgf_text,

	coinsLabelFont: f_tgf_text,
	coinsLabelX: tgfScale(0),
	coinsLabelY: tgfScale(0),
	
	failLabelText: "",
	failLabelDictionaryKey: "Level Failed",
	failLabelX: tgfScale(0),
	failLabelY: tgfScale(-15),
	failLabelFont: f_tgf_text,
	
	hasNextButton: true,
	nextButtonImage: s_btn_big_start,
	nextButtonX: tgfScale(162),
	nextButtonY: tgfScale(184),
	nextButtonId: "next",
	
	hasRestartButton: true,
	restartButtonImage: s_btn_small_retry,
	restartButtonX: tgfScale(12),
	restartButtonY: tgfScale(214),
	restartButtonId: "restart",
	
	hasEmphasizedStats: false,
	hasPrimaryStats: false,
	hasSecondaryStats: false,
	
	hasFailedLabel: false,
		
	components: [],                 // The additional components to add
	
	onFinish: null
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.QuestionBox
 */
tgfDialogs.EndPlayWon = function(properties) {
	"use strict";
	this.name = "EndPlayWon";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.questionBox);
	this.setProperties(tgfSettings.dialogDefaults.endPlayWon);
	this.setProperties(tgfSettings.endPlayWonDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the message box dialog
tgfDialogs.inherit(tgfDialogs.EndPlayWon, tgfDialogs.Base);


//***************************************
//Internal methods
//***************************************
tgfDialogs.EndPlayWon.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};

tgfDialogs.EndPlayWon.prototype.createStars = function(parent, component, ii){
	"use strict";
	var self = this;
	var properties = {imageEmpty: this.starImageEmpty[ii], imageFill: this.starImageFill[ii], animationImage: this.starEffect, loopAnimation: false, animationSpeed: 10, x: this.starImageX[ii],
			y: this.starImageY[ii], width: this.starImageWidth[ii], height: this.starImageHeight[ii], id: ii, stars: this.stars, sound: this.starSounds[ii],
			onAnimationComplete: function(component, id){
				self.frequenceAnimationTrigger(id);
			}
	};
	
	var comp = new component(properties);
	this.starsComponents.push(comp);
	parent.addComponent(comp);
};

tgfDialogs.EndPlayWon.prototype._addComponent = function(parent, Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.addComponent(comp);
	return comp;
};

tgfDialogs.EndPlayWon.prototype.frequenceAnimationTrigger = function(id){
	if(this.stars === undefined) {return;}
	if(id < this.stars - 1){
		this.starsComponents[id + 1].startAnimation = true;
	} else {
//		console.log("SIGN");
	}
};

tgfDialogs.EndPlayWon.prototype.createText = function(textType){
	"use strict";
	
	switch(textType){
	case "emphasized":
		if(this.hasEmphasizedStats){
			this.emphasizedStatsHeaderComponent = new tgfComponents.Label({
				text: this.emphasizedStatsHeaderText, dictionaryKey: this.emphasizedStatsHeaderDictionaryKey, x: this.emphasizedStatsHeaderX,
				y: this.emphasizedStatsHeaderY, font: this.emphasizedStatsHeaderFont
			});
			
			this.container.addComponent(this.emphasizedStatsHeaderComponent);
			
			this.emphasizedStatsComponent = new tgfComponents.Label({
				text: this.emphasizedStatsText, dictionaryKey: this.emphasizedStatsDictionaryKey, x: this.emphasizedStatsX,
				y: this.emphasizedStatsY, font: this.emphasizedStatsFont
			});
			
			this.container.addComponent(this.emphasizedStatsComponent);
			this.hasEmphasizedStats = false;
		}
		break;
	case "primary":
		if(this.hasPrimaryStats){
			this.primaryStatsHeaderComponent = new tgfComponents.Label({
				text: this.primaryStatsHeaderText, dictionaryKey: this.primaryStatsHeaderDictionaryKey, x: this.primaryStatsHeaderX,
				y: this.primaryStatsHeaderY, font: this.primaryStatsHeaderFont
			});
			
			this.container.addComponent(this.primaryStatsHeaderComponent);
			
			this.primaryStatsComponent = new tgfComponents.Label({
				text: this.primaryStatsText, dictionaryKey: this.primaryStatsDictionaryKey, x: this.primaryStatsX,
				y: this.primaryStatsY, font: this.primaryStatsFont
			});
			
			this.container.addComponent(this.primaryStatsComponent);
			this.hasPrimaryStats = false;
		}
			break;
	case "secondary":
		if(this.hasSecondaryStats){
			this.secondaryStatsHeaderComponent = new tgfComponents.Label({
				text: this.secondaryStatsHeaderText, dictionaryKey: this.secondaryStatsHeaderDictionaryKey, x: this.secondaryStatsHeaderX,
				y: this.secondaryStatsHeaderY, font: this.secondaryStatsHeaderFont
			});
			
			this.container.addComponent(this.secondaryStatsHeaderComponent);
			
			this.secondaryStatsComponent = new tgfComponents.Label({
				text: this.secondaryStatsText, dictionaryKey: this.secondaryStatsDictionaryKey, x: this.secondaryStatsX,
				y: this.secondaryStatsY, font: this.secondaryStatsFont
			});
			
			this.container.addComponent(this.secondaryStatsComponent);
			this.hasSecondaryStats = false;
		}
		break;
	}
	
};

//***************************************
//Preparing and showing
//      - These can be removed if no processing is required
//***************************************

//Processing required when preparing the dialog for use
tgfDialogs.EndPlayWon.prototype.doPrepare = function() {
	"use strict";
	
	this.titleText = tgfDictionary.getText(this.titleDict).replace("<VALUE>", tgfSettings.game.currentLevel.toString());
	
	//tgfDialogs.EndPlayWon.uber.doPrepare.call(this);
	//var i, self = this, closeX, closeY;
	
//	this.level = " " + tgfSettings.game.currentLevel;

	var self = this, i, j, n,
		blockLeft = [], blockTop = [], blockWidth = [], blockHeight = [],
		ww, hh, closeX, closeY,
		buttons, buttonLeft, buttonTop, buttonVDistance, buttonHDistance, buttonWidth, buttonHeight,
		darkener;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Determine the position and sizes of the blocks
	ww = this.width === 0 ? this.backgroundImage.width : this.width;
	hh = this.height === 0 ? this.backgroundImage.height : this.height;
	blockLeft[0] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[0] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[0] = Math.round(-hh/2 + this.marginTop);
	blockHeight[0] = Math.round(this.titlePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	blockLeft[1] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[1] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[1] = Math.round(blockTop[0] + blockHeight[0]);
	blockHeight[1] = Math.round(this.messagePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	if (this.iconImage) {
		blockWidth[2] = this.iconImage.width;
		blockLeft[2] = blockLeft[1] + blockWidth[1] - blockWidth[2];
		blockTop[2] = blockTop[1];
		blockHeight[2] = blockHeight[1];
		blockWidth[1] -= blockWidth[2] + tgfScale(32);
		if (this.iconPosition === "left") {
			blockLeft[2] = blockLeft[1];
			blockLeft[1] += blockWidth[2] + tgfScale(32);
		}
	}
	blockLeft[3] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[3] = Math.round(ww - this.marginLeft - this.marginRight);
	if (this.buttonHorizontalSize > 0) {
		blockLeft[3] = Math.round(-this.buttonHorizontalSize / 2);
		blockWidth[3] = this.buttonHorizontalSize;
	}
	blockTop[3] = Math.round(blockTop[1] + blockHeight[1]);
	blockHeight[3] = Math.round(this.buttonPercentage * (hh - this.marginTop - this.marginBottom) / 100);
	// Create the darkener
	if (this.darken) {
		darkener = this._addComponent(this, tgfComponents.Darkener, {
			width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
		}, this.darkenerProperties);
	}

	this.container = this._addComponent(this, tgfComponents.Picture, {
		x: this.backgroundX,
		y: this.backgroundY,
		image: this.backgroundImage,
		createFromSlices: true,
		width: this.width === 0 ? this.backgroundImage.width : this.width,
		height: this.height === 0 ? this.backgroundImage.height : this.height,
		effects: [ this.appearEffect, { effect: "show", duration: this.lifeTime }, this.disappearEffect ],
		onSubEffectStart: function (component, effect) {
			if (effect === self.disappearEffect && self.darken) {
				darkener.makeLight(darkener.duration, self.container.effects[2].duration-darkener.duration);
			}
		},
		onSubEffectEnd: function(component, effect){
			if(self.onArrive){
				self.onArrive();
			}
		},
		onEffectEnd: function (component) {
			self.hide();
		}
	}, this.backgroundProperties);
	
	this.containerComponent = new tgfComponents.Container({
		y: this.containerY,
		effects: [this.appearEffect, {effect: "show", duration: 99999999}, this.disappearEffect, {effect: "show", duration: 9999999999}]
	});

	if (this.hasCloseButton) {
		closeX = Math.round((this.width === 0 ? this.backgroundImage.width : this.width) / 2 - this.closeButtonWidth / 2);
		closeY = Math.round(-(this.height === 0 ? this.backgroundImage.height : this.height) / 2 + this.closeButtonHeight / 2);
		this._addComponent(this.container, tgfComponents.Button, {
			x: closeX, y: closeY, width: this.closeButtonWidth, height: this.closeButtonHeight,
			image: s_tgf_transparent, buttonId: this.closeButtonId,
			onClick: function(component) {
				if (self.onClose) { self.onClose(self); }
				if(self.onClick){ self.onClick(self, component.buttonId); }
				tgfDialogs.ButtonBox.prototype.disappear.call(self);
			}
		}, this.closeButtonProperties);
	}
	
	for(var ii = 0; ii < this.showSettings.length; ii++){
		switch(this.showSettings[ii]) {
			case "stars":
				for (var i = 0; i < 3; i++) {
					this.createStars(this.container, tgfComponents.Star, i);
				}
				this.hasEmphasizedStats = false;
				break;
			case "score":
				if (this.hasEmphasizedStats) {
					this.emphasizedStatsText = this.score.toString();
					this.createText("emphasized");
				}
				else if (this.hasPrimaryStats) {
					this.primaryStatsText = this.score.toString();
					this.createText("primary");
				}
				else if (this.hasSecondaryStats) {
					this.secondaryStatsText = this.score.toString();
					this.createText("secondary");
				}
				break;
			case "time":
				if (this.hasEmphasizedStats) {
					this.emphasizedStatsText = this.time.toString();
					this.createText("emphasized");
				}
				else if (this.hasPrimaryStats) {
					this.primaryStatsText = this.time.toString();
					this.createText("primary");
				}
				else if (this.hasSecondaryStats) {
					this.secondaryStatsText = this.time.toString();
					this.createText("secondary");
				}
				break;
			case "moves":
				if (this.hasEmphasizedStats) {
					this.emphasizedStatsText = this.moves.toString();
					this.createText("emphasized");
				}
				else if (this.hasPrimaryStats) {
					this.primaryStatsText = this.moves.toString();
					this.createText("primary");
				}
				else if (this.hasSecondaryStats) {
					this.secondaryStatsText = this.moves.toString();
					this.createText("secondary");
				}
				break;
			case "highscore":
				if (this.hasEmphasizedStats) {
					this.emphasizedStatsText = this.highscore.toString();
					this.createText("emphasized");
				}
				else if (this.hasPrimaryStats) {
					this.primaryStatsText = this.highscore.toString();
					this.createText("primary");
				}
				else if (this.hasSecondaryStats) {
					this.secondaryStatsText = this.highscore.toString();
					this.createText("secondary");
				}
				break;
			case "coins":
				var coinComponent = new tgfComponents.Label({
					text: this.coins.toString(), font: this.coinsLabelFont,
					x: this.coinsLabelX, y: this.coinsLabelY
				});

				this.container.addComponent(coinComponent);
				break;
		}
	}
	
	if(this.hasNextButton){
		var nextButton = new tgfComponents.Button({
			image: this.nextButtonImage, x: this.nextButtonX, y: this.nextButtonY,
			buttonId: this.nextButtonId,
			onClick: function(component){
				if(self.onClick){ self.onClick(self, component.buttonId); }
			}
		});
		
		this.container.addComponent(nextButton);
	}
	
	if(this.hasRestartButton){
		var restartButton = new tgfComponents.Button({
			image: this.restartButtonImage, x: this.restartButtonX, y: this.restartButtonY,
			buttonId: this.restartButtonId,
			onClick: function(component){
				if(self.onClick){ self.onClick(self, component.buttonId); }
			}
		});
		
		this.container.addComponent(restartButton);
	}
	
	if(this.hasFailedLabel){
		this.failLabelComponent = new tgfComponents.Label({
			text: this.failLabelText, dictionaryKey: this.failLabelDictionaryKey, x: this.failLabelX, y: this.failLabelY, font: this.failLabelFont 
		});
		
		this.container.addComponent(this.failLabelComponent);
	}
	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.container.addComponent(this.components[i]);
		}
	}
	
	
};

//Processing required when freeing the dialog from use
tgfDialogs.EndPlayWon.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.backgroundComponent = undefined;
	this.emphasizedStatsHeaderComponent = undefined;
	this.emphasizedStatsComponent = undefined;
	this.primaryStatsHeaderComponent = undefined;
	this.primaryStatsComponent = undefined;
	this.secondaryStatsHeaderComponent = undefined;
	this.secondaryStatsComponent = undefined;
	this.failLabelComponent = undefined;
	this.containerComponent = undefined;
};

//Processing required when showing the dialog
tgfDialogs.EndPlayWon.prototype.doShow = function() {
	"use strict";
	if(this.starsComponents){
		for(var i = 0; i < this.stars; i++){
			this.starsComponents[i].initSound(i);
		}
	}
};

//Processing required when hiding the dialog
tgfDialogs.EndPlayWon.prototype.doHide = function() {
	"use strict";
};


//******************************************************
//*****    Script Resource: DialogEndPlayLost
//******************************************************

// ***************************************
// tgfDialogs.EndPlayLost
//
// This dialog displays the game lost message when the play ends
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 18-10-2015
// ***************************************

// TODO: Make this into a much nicer dialog, now it is just a question box

// Directives for jslint
/*global tbEase */
/*global tgfDialogs, tgfSettings, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.endPlayLost = {

	backgroundImage: s_tgf_frame,                       // The background image
	backgroundX: tgfScale(0),
	backgroundY: tgfScale(0),

	x: undefined,                                       // X-position. When undefined it is placed in the center
	y: undefined,                                       // Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,                       // The background image
	marginLeft: tgfScale(40),                           // Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),                          // Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),                            // Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),                         // Bottom margin whether there is no text, images, etc.
	titlePercentage: 10,                                // Percentage of the box for the title
	messagePercentage: 60,                              // Percentage of the box for the message (if any)
	buttonPercentage: 30,                               // Percentage of the box for the buttons
	titleText: "",                                      // Text for the title
	titleDictionaryKey: "",                             // Dictionary key for the title
	titleDict:"",
	titleFont: f_tgf_title,                             // Font to be used for the title
	messageText: "",                                    // Text for the message
	messageDictionaryKey: "",                           // Dictionary key for the message
	messageFont: f_tgf_text,                            // Font to be used for the message
	iconImage: null,                                    // Image for the icon
	iconPosition: "right",                              // Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,                              // Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),                     // Width of the close button
	closeButtonHeight: tgfScale(96),                    // Height of the close button
	buttonHorizontal: true,                             // Whether the buttons must be placed horizontally
	buttonHorizontalSize: tgfScale(0),                  // Total horizontal size for the buttons (0 = use maximum)
	buttonHorizontalGap: tgfScale(8),                   // Horizontal gap between the buttons
	buttonVerticalGap: tgfScale(8),                     // Vertical gap between the buttons
	buttonVerticalAlignment: "middle",                  // Vertical alignment for the buttons ("top", "middle", "bottom")
	buttonDefaultHide: true,                            // Whether to hide the dialog on clicking the button
	buttonDefaultImage: s_tgf_button,                   // Default image for the buttons
	buttonDefaultFont: f_tgf_button,                    // Default font to be used for the buttons
	buttonDefaultProperties: null,                      // Default additional properties for the button components
	buttons: [],                                        // Array of (array of) information about the buttons; can contain:
														//      sliced, text, dictionaryKey, image, icon, font, id, properties, hide
	darken: true,                                       // Whether to darken the background
	appearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-500), endY: tgfScale(0), ease: tbEase.easeOutOvershoot, easeArgument: 1.2},// {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 9999999,                                  // How long it will stay visible before disappearing automatically
	disappearOnClick: false,                            // Whether to disappear when the screen is clicked
	components: [],                                     // The additional components to add
	onClick: null,                                      // Function to be called when clicking the button: function(dialog, buttonId)   
	onClose: null,                                      // Function to be called when clicking the close button
	
	// Additional properties for the components
	darkenerProperties: null,                           // Properties for the darkener component
	backgroundProperties: null,                         // Properties for the background container component
	titleProperties: null,                              // Properties for the title component
	messageProperties: null,                            // Properties for the message component
	iconProperties: null,                               // Properties for the icon component
	closeButtonProperties: null,                            // Properties for the close button component
	
	containerX: tgfScale(0),
	containerY: tgfScale(-700),
	didCompleteAnimation: false,
	
	//Extra Properties
	levelName: "",
	level: undefined,
	score: 0,
	time:  0,
	stars: 0,
	moves: 0,
	highscore: 0,
	
	improved: false,
	
	showSettings: [],                                   // Which information to show USED: "score", "time", "stars", "moves"
	
	starImageEmpty: [s_star01_empty,  s_star02_empty, s_star03_empty],
	starImageFill: [s_star01_fill, s_star02_fill, s_star03_fill],
	starEffect: s_sfx_star,
	starImageX: [tgfScale(-165), tgfScale(0), tgfScale(165)],
	starImageY: [tgfScale(-90), tgfScale(-160), tgfScale(-90)],
	starImageWidth: [tgfScale(0), tgfScale(0), tgfScale(0)],
	starImageHeight: [tgfScale(0), tgfScale(0), tgfScale(0)],
	starsComponents: [],

	emphasizedStatsHeaderText: "",
	emphasizedStatsHeaderDictionaryKey: "",
	emphasizedStatsHeaderX: tgfScale(0),
	emphasizedStatsHeaderY: tgfScale(15),
	emphasizedStatsHeaderFont: f_tgf_title,
	
	emphasizedStatsText: "",
	emphasizedStatsDictionaryKey: "",
	emphasizedStatsX: tgfScale(0),
	emphasizedStatsY: tgfScale(50),
	emphasizedStatsFont: f_tgf_title,
	
	primaryStatsHeaderText: "",
	primaryStatsHeaderDictionaryKey: "TOTAL SCORE:",
	primaryStatsHeaderX: tgfScale(0),
	primaryStatsHeaderY: tgfScale(-65),
	primaryStatsHeaderFont: f_tgf_text,
	
	primaryStatsText: "",
	primaryStatsDictionaryKey: "",
	primaryStatsX: tgfScale(0),
	primaryStatsY: tgfScale(-30),
	primaryStatsFont: f_tgf_text,
	
	secondaryStatsHeaderText: "",
	secondaryStatsHeaderDictionaryKey: "HIGH SCORE:",
	secondaryStatsHeaderX: tgfScale(0),
	secondaryStatsHeaderY: tgfScale(5),
	secondaryStatsHeaderFont: f_tgf_text,
	
	secondaryStatsText: "",
	secondaryStatsDictionaryKey: "",
	secondaryStatsX: tgfScale(0),
	secondaryStatsY: tgfScale(40),
	secondaryStatsFont: f_tgf_text,
	
	failLabelText: "",
	failLabelDictionaryKey: "Level Failed",
	failLabelX: tgfScale(0),
	failLabelY: tgfScale(-135),
	failLabelFont: f_tgf_text,
	
//	hasNextButton: true,
//	nextButtonImage: s_btn_big_start,
//	nextButtonX: tgfScale(162),
//	nextButtonY: tgfScale(184),
//	nextButtonId: "next",
	
	hasRestartButton: true,
	restartButtonImage: s_btn_big_restart,
	restartButtonX: tgfScale(162),
	restartButtonY: tgfScale(184),
	restartButtonId: "restart",
	
	
	hasEmphasizedStats: false,
	hasPrimaryStats: false,
	hasSecondaryStats: false,
	
	hasFailedLabel: false,
	components: [],                 // The additional components to add
	
	onClick: null,
	onFinish: null
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.QuestionBox
 */
tgfDialogs.EndPlayLost = function(properties) {
	"use strict";
	this.name = "EndPlayLost";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.questionBox);
	this.setProperties(tgfSettings.dialogDefaults.endPlayLost);
	this.setProperties(tgfSettings.endPlayLostDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the message box dialog
tgfDialogs.inherit(tgfDialogs.EndPlayLost, tgfDialogs.Base);


//***************************************
//Internal methods
//***************************************
tgfDialogs.EndPlayLost.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};

tgfDialogs.EndPlayLost.prototype._addComponent = function(parent, Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.addComponent(comp);
	return comp;
};

tgfDialogs.EndPlayLost.prototype.createStars = function(parent, component, ii){
	"use strict";
	var self = this;
	var properties = {imageEmpty: this.starImageEmpty[ii], imageFill: this.starImageFill[ii], animationImage: this.starEffect, loopAnimation: false, animationSpeed: 10, x: this.starImageX[ii],
			y: this.starImageY[ii], width: this.starImageWidth[ii], height: this.starImageHeight[ii], id: ii, stars: this.stars,
			onAnimationComplete: function(component, id){
				self.frequenceAnimationTrigger(id);
			}
	};
	
	var comp = new component(properties);
	this.starsComponents.push(comp);
	parent.addComponent(comp);
};

tgfDialogs.EndPlayLost.prototype.frequenceAnimationTrigger = function(id){
	if(this.stars === undefined) {return;}
	if(id < this.stars - 1){
		this.starsComponents[id + 1].startAnimation = true;
	}
};

tgfDialogs.EndPlayLost.prototype.createText = function(textType){
	"use strict";
	
	switch(textType){
	case "emphasized":
		if(this.hasEmphasizedStats){
			this.emphasizedStatsHeaderComponent = new tgfComponents.Label({
				text: this.emphasizedStatsHeaderText, dictionaryKey: this.emphasizedStatsHeaderDictionaryKey, x: this.emphasizedStatsHeaderX,
				y: this.emphasizedStatsHeaderY, font: this.emphasizedStatsHeaderFont
			});
			
			this.container.addComponent(this.emphasizedStatsHeaderComponent);
			
			this.emphasizedStatsComponent = new tgfComponents.Label({
				text: this.emphasizedStatsText, dictionaryKey: this.emphasizedStatsDictionaryKey, x: this.emphasizedStatsX,
				y: this.emphasizedStatsY, font: this.emphasizedStatsFont
			});
			
			this.container.addComponent(this.emphasizedStatsComponent);
			this.hasEmphasizedStats = false;
		}
		break;
	case "primary":
		if(this.hasPrimaryStats){
			this.primaryStatsHeaderComponent = new tgfComponents.Label({
				text: this.primaryStatsHeaderText, dictionaryKey: this.primaryStatsHeaderDictionaryKey, x: this.primaryStatsHeaderX,
				y: this.primaryStatsHeaderY, font: this.primaryStatsHeaderFont
			});
			
			this.container.addComponent(this.primaryStatsHeaderComponent);
			
			this.primaryStatsComponent = new tgfComponents.Label({
				text: this.primaryStatsText, dictionaryKey: this.primaryStatsDictionaryKey, x: this.primaryStatsX,
				y: this.primaryStatsY, font: this.primaryStatsFont
			});
			
			this.container.addComponent(this.primaryStatsComponent);
			this.hasPrimaryStats = false;
		}
			break;
	case "secondary":
		if(this.hasSecondaryStats){
			this.secondaryStatsHeaderComponent = new tgfComponents.Label({
				text: this.secondaryStatsHeaderText, dictionaryKey: this.secondaryStatsHeaderDictionaryKey, x: this.secondaryStatsHeaderX,
				y: this.secondaryStatsHeaderY, font: this.secondaryStatsHeaderFont
			});
			
			this.container.addComponent(this.secondaryStatsHeaderComponent);
			
			this.secondaryStatsComponent = new tgfComponents.Label({
				text: this.secondaryStatsText, dictionaryKey: this.secondaryStatsDictionaryKey, x: this.secondaryStatsX,
				y: this.secondaryStatsY, font: this.secondaryStatsFont
			});
			
			this.container.addComponent(this.secondaryStatsComponent);
			this.hasSecondaryStats = false;
		}
		break;
	}
	
};

//***************************************
//Preparing and showing
//      - These can be removed if no processing is required
//***************************************

//Processing required when preparing the dialog for use
tgfDialogs.EndPlayLost.prototype.doPrepare = function() {
	"use strict";

	var self = this, i, j, n,
		blockLeft = [], blockTop = [], blockWidth = [], blockHeight = [],
		ww, hh, closeX, closeY,
		buttons, buttonLeft, buttonTop, buttonVDistance, buttonHDistance, buttonWidth, buttonHeight,
		darkener;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Determine the position and sizes of the blocks
	ww = this.width === 0 ? this.backgroundImage.width : this.width;
	hh = this.height === 0 ? this.backgroundImage.height : this.height;
	blockLeft[0] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[0] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[0] = Math.round(-hh/2 + this.marginTop);
	blockHeight[0] = Math.round(this.titlePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	blockLeft[1] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[1] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[1] = Math.round(blockTop[0] + blockHeight[0]);
	blockHeight[1] = Math.round(this.messagePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	if (this.iconImage) {
		blockWidth[2] = this.iconImage.width;
		blockLeft[2] = blockLeft[1] + blockWidth[1] - blockWidth[2];
		blockTop[2] = blockTop[1];
		blockHeight[2] = blockHeight[1];
		blockWidth[1] -= blockWidth[2] + tgfScale(32);
		if (this.iconPosition === "left") {
			blockLeft[2] = blockLeft[1];
			blockLeft[1] += blockWidth[2] + tgfScale(32);
		}
	}
	blockLeft[3] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[3] = Math.round(ww - this.marginLeft - this.marginRight);
	if (this.buttonHorizontalSize > 0) {
		blockLeft[3] = Math.round(-this.buttonHorizontalSize / 2);
		blockWidth[3] = this.buttonHorizontalSize;
	}
	blockTop[3] = Math.round(blockTop[1] + blockHeight[1]);
	blockHeight[3] = Math.round(this.buttonPercentage * (hh - this.marginTop - this.marginBottom) / 100);
	// Create the darkener
	if (this.darken) {
		darkener = this._addComponent(this, tgfComponents.Darkener, {
			width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
		}, this.darkenerProperties);
	}

	this.container = this._addComponent(this, tgfComponents.Picture, {
		x: this.backgroundX,
		y: this.backgroundY,
		image: this.backgroundImage,
		createFromSlices: true,
		width: this.width === 0 ? this.backgroundImage.width : this.width,
		height: this.height === 0 ? this.backgroundImage.height : this.height,
		effects: [ this.appearEffect, { effect: "show", duration: this.lifeTime }, this.disappearEffect ],
		onSubEffectStart: function (component, effect) {
			if (effect === self.disappearEffect && self.darken) {
				darkener.makeLight(darkener.duration, self.container.effects[2].duration-darkener.duration);
			}
		},
		onSubEffectEnd: function(component, effect){
			if(self.onArrive){
				self.onArrive();
			}
		},
		onEffectEnd: function (component) {
			self.hide();
		}
	}, this.backgroundProperties);
	
	this.containerComponent = new tgfComponents.Container({
		y: this.containerY,
		effects: [this.appearEffect, {effect: "show", duration: 99999999}, this.disappearEffect, {effect: "show", duration: 9999999999}]
	});

	if (this.hasCloseButton) {
		closeX = Math.round((this.width === 0 ? this.backgroundImage.width : this.width) / 2 - this.closeButtonWidth / 2);
		closeY = Math.round(-(this.height === 0 ? this.backgroundImage.height : this.height) / 2 + this.closeButtonHeight / 2);
		this._addComponent(this.container, tgfComponents.Button, {
			x: closeX, y: closeY, width: this.closeButtonWidth, height: this.closeButtonHeight,
			image: s_tgf_transparent, buttonId: this.closeButtonId,
			onClick: function(component) {
				if (self.onClose) { self.onClose(self); }
				if(self.onClick){ self.onClick(self, component.buttonId); }
				tgfDialogs.ButtonBox.prototype.disappear.call(self);
			}
		}, this.closeButtonProperties);
	}
	
	for(var ii = 0; ii < this.showSettings.length; ii++){
		switch(this.showSettings[ii]){
		case "stars":
			for(var i = 0; i < 3; i++){
				this.createStars(this.container, tgfComponents.Star, i);
			}
			this.hasEmphasizedStats = false;
			break;
		case "score":
			if(this.hasEmphasizedStats){ this.emphasizedStatsText = this.score.toString(); this.createText("emphasized"); }
			else if(this.hasPrimaryStats) { this.primaryStatsText = this.score.toString(); this.createText("primary"); }
			else if(this.hasSecondaryStats) { this.secondaryStatsText = this.score.toString(); this.createText("secondary"); }
			break;
		case "time":
			if(this.hasEmphasizedStats){ this.emphasizedStatsText = this.time.toString(); this.createText("emphasized"); }
			else if(this.hasPrimaryStats) { this.primaryStatsText = this.time.toString(); this.createText("primary"); }
			else if(this.hasSecondaryStats) { this.secondaryStatsText = this.time.toString(); this.createText("secondary"); }   
			break;
		case "moves":
			if(this.hasEmphasizedStats){ this.emphasizedStatsText = this.moves.toString(); this.createText("emphasized"); }
			else if(this.hasPrimaryStats) { this.primaryStatsText = this.moves.toString(); this.createText("primary"); }
			else if(this.hasSecondaryStats) { this.secondaryStatsText = this.moves.toString(); this.createText("secondary"); }
			break;
		case "highscore":
			if(this.hasEmphasizedStats){ this.emphasizedStatsText = this.highscore.toString(); this.createText("emphasized"); }
			else if(this.hasPrimaryStats) { this.primaryStatsText = this.highscore.toString(); this.createText("primary"); }
			else if(this.hasSecondaryStats) { this.secondaryStatsText = this.highscore.toString(); this.createText("secondary"); }
			break;
		}
	}
	
	if(this.hasNextButton){
		var nextButton = new tgfComponents.Button({
			image: this.nextButtonImage, x: this.nextButtonX, y: this.nextButtonY,
			buttonId: this.nextButtonId,
			onClick: function(component){
				if(self.onClick){ self.onClick(self, component.buttonId); }
			}
		});
		
		this.container.addComponent(nextButton);
	}
	
	if(this.hasRestartButton){
		var restartButton = new tgfComponents.Button({
			image: this.restartButtonImage, x: this.restartButtonX, y: this.restartButtonY,
			buttonId: this.restartButtonId,
			onClick: function(component){
				if(self.onClick){ self.onClick(self, component.buttonId); }
			}
		});
		
		this.container.addComponent(restartButton);
	}
	
	if(this.hasFailedLabel){
		this.failLabelComponent = new tgfComponents.Label({
			text: this.failLabelText, dictionaryKey: this.failLabelDictionaryKey, x: this.failLabelX, y: this.failLabelY, font: this.failLabelFont 
		});
		
		this.container.addComponent(this.failLabelComponent);
	}
	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.container.addComponent(this.components[i]);
		}
	}
};

//Processing required when freeing the dialog from use
tgfDialogs.EndPlayLost.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.backgroundComponent = undefined;
	this.emphasizedStatsHeaderComponent = undefined;
	this.emphasizedStatsComponent = undefined;
	this.primaryStatsHeaderComponent = undefined;
	this.primaryStatsComponent = undefined;
	this.secondaryStatsHeaderComponent = undefined;
	this.secondaryStatsComponent = undefined;
	this.failLabelComponent = undefined;
	this.containerComponent = undefined;
};

//Processing required when showing the dialog
tgfDialogs.EndPlayLost.prototype.doShow = function() {
	"use strict";
};

//Processing required when hiding the dialog
tgfDialogs.EndPlayLost.prototype.doHide = function() {
	"use strict";
};

//******************************************************
//*****    Script Resource: DialogSplashScreen
//******************************************************

// ***************************************
// tgfDialogs.SplashScreen
//
// This dialog displays a splash screen for a particular time
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-10-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbKeyCodes, tbLoader, tbVector, tbEase */
/*global tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfFunctions, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.splashScreen = {
	image: null,										// The image
	color: "white",										// The color of the background
	duration: 2,										// Time to show the splash screen in seconds
	components: [],										// The additional components to add
	// Additional properties for the components
	pictureProperties: null,							// Properties for the picture component
	timerProperties: null								// Properties for the timer component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.SplashScreen = function(properties) {
	"use strict";
	this.name = "SplashScreen";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.splashScreen);
	this.setProperties(tgfSettings.splashScreenDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.SplashScreen, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.SplashScreen.prototype.disappear = function() {
	"use strict";
	this.hide();
};


// ***************************************
// Internal methods
// ***************************************


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.SplashScreen.prototype.doPrepare = function() {
	"use strict";
	var i, self = this;
	// Position
	this.x = tgfGraphics.mainCanvas.width/2;
	this.y = tgfGraphics.mainCanvas.height/2;
	// Create the image
	if (this.image) {
		this.pictureComponent = new tgfComponents.Picture( {
				image: this.image
			} );
		this.pictureComponent.setProperties(this.pictureProperties);
		this.addComponent(this.pictureComponent);
	}
	// Create the timer
	this.timerComponent = new tgfComponents.Timer( {
		interval: this.duration,
		repeat: 1,
		onTick: function (component) { self.hide(); }
	} );
		this.timerComponent.setProperties(this.timerProperties);
		this.addComponent(this.timerComponent);
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.SplashScreen.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.pictureComponent = undefined;
	this.timerComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.SplashScreen.prototype.doShow = function() {
	"use strict";
	// Draw the color on the background canvas
	if (this.color) {
		tbGraphics.setCanvas(tgfGraphics.backgroundCanvas);
		tbGraphics.clearColor(this.color);
		tbGraphics.setCanvas(tgfGraphics.mainCanvas);
	}
};

// Processing required when hiding the dialog
tgfDialogs.SplashScreen.prototype.doHide = function() {
	"use strict";
};

//******************************************************
//*****    Script Resource: DialogLoadScreen
//******************************************************

// ***************************************
// tgfDialogs.LoadScreen
//
// This dialog displays a loading screen
//
// THIS IS A VERY PRELIMINARY VERSION, JUST FOR TESTING
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbKeyCodes, tbLoader, tbVector, tbEase */
/*global tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfFunctions, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.loadScreen = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	width: tgfScale(480),
	height: tgfScale(480),
	backgroundImage: s_tgf_frame,						// The background image
	gameLogo: null,										// Logo image for the game
	companyLogo: null,									// Logo image for the company
	gameLogoX: tgfScale(0),								// Horizontal position of the logo
	gameLogoY: tgfScale(-100),							// Vertical position of the logo
	gameLogoScale: undefined,
	companyLogoX: tgfScale(0),							// Horizontal position of the company logo
	companyLogoY: tgfScale(276),						// Vertical position of the company logo
	barX: tgfScale(0),									// Horizontal position of the progress bar
	barY: tgfScale(100),								// Vertical position of the progress bar
	barWidth: tgfScale(300),							// Width of the progress bar
	barHeight:0,										// Height of the progress bar
	progressFunction: null,								// Function that will return the progress

	appearEffect: {effect: tgfEffects.alpha, duration: 0.2, startAlpha: 0, ease: tbEase.easeOutCubic},
	disappearEffect: {effect: tgfEffects.alpha, duration: 0.2, endAlpha: 0, ease: tbEase.easeInCubic},
	darken: false,										// Whether to darken the background
	fillImage: null,									// The pattern image to fill the screen
	fillTime: 60,										// Time for a single rotation of the fill
	fillDistance: tgfScale(200),						// Distance the fill Image should move

	components: [],										// The additional components to add
	onComplete: null,									// Function to be called when loading is complete
	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	containerProperties: null,							// Properties for the effect container
	backgroundProperties: null,							// Properties for the background component
	gameLogoProperties: null,							// Properties for the game logo component
	companyLogoProperties: null,						// Properties for the company logo component
	barProperties: null									// Properties for the progress bar component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.LoadScreen = function(properties) {
	"use strict";
	this.name = "LoadScreen";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.loadScreen);
	this.setProperties(tgfSettings.loadScreenDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.LoadScreen, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.LoadScreen.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.LoadScreen.prototype.doPrepare = function() {
	"use strict";
	var i, self = this, sc, fillEffect;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Create the darkener
	if (this.darken) {
		this.darkener = new tgfComponents.Darkener( {
			width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
		} );
		this.darkener.setProperties(this.darkenerProperties);
		this.addComponent(this.darkener);
	}
	// Do the background fill
	if (this.fillImage !== null) {
		fillEffect = function(component, effect, time) {
				component.x = self.fillDistance/2 * Math.sin(2 * Math.PI * time / self.fillTime);
				component.y = self.fillDistance/2 * - Math.cos(2 * Math.PI * time / self.fillTime);
			};
		this.fillerComponent = new tgfComponents.Base( {
				effects: { effect: fillEffect, duration: 9999999 }
			} );
		this.fillerComponent.onDraw = function (component) {
				self.fillImage.drawTiled(0, -self.x - self.fillDistance/2, -self.y - self.fillDistance/2, tbGraphics.width + self.fillDistance, tbGraphics.height + self.fillDistance, 1);
			};
		this.addComponent(this.fillerComponent);
	}
	// Create the container
	this.container = new tgfComponents.Container( {
			effects: [ this.appearEffect, { effect: "show", duration: 99999999 }, this.disappearEffect ],
			onSubEffectStart: function (component, effect) {
					if (effect === self.disappearEffect && self.darken) {
						self.darkener.makeLight(self.darkener.duration, self.container.effects[2].duration-self.darkener.duration);
					}
				},
			onEffectEnd: function (component) {
					self.hide();
				}
		} );
	this.container.setProperties(this.containerProperties);
	this.addComponent(this.container);
	// The background image
	if(this.backgroundImage){
		this.background = new tgfComponents.Picture( {
			image: this.backgroundImage,
			createFromSlices: true,
			width: this.width === 0 ? this.backgroundImage.width : this.width,
			height: this.height === 0 ? this.backgroundImage.height : this.height
		} );
		this.background.setProperties(this.backgroundProperties);
		this.container.addComponent(this.background);
	}
	// Add the logos
	sc = Math.min(1, this.width / this.gameLogo.width, (this.height/2) / this.gameLogo.height);
	if(this.gameLogoScale){
		sc = this.gameLogoScale;
	}

	this.gameLogoComponent = new tgfComponents.Picture( {
			x: this.gameLogoX, y: this.gameLogoY, xScale: sc, yScale: sc,
			image: this.gameLogo
		} );
	this.gameLogoComponent.setProperties(this.gameLogoProperties);
	this.container.addComponent(this.gameLogoComponent);
	this.companyLogoComponent = new tgfComponents.Picture( {
			x: this.companyLogoX, y: this.companyLogoY,
			image: this.companyLogo
		} );
	this.companyLogoComponent.setProperties(this.companyLogoProperties);
	this.container.addComponent(this.companyLogoComponent);
	// Create the progress bar
	this.barComponent = new tgfComponents.ProgressBar( {
			x: this.barX, y: this.barY, width: this.barWidth, height: this.barHeight,
			progressFunction: this.progressFunction,
			onFull: function (component) {
					if (self.onComplete) { self.onComplete(self); }
					tgfDialogs.LoadScreen.prototype.disappear.call(self);
				}
		} );
	this.barComponent.setProperties(this.barProperties);
	this.container.addComponent(this.barComponent);
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.LoadScreen.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.background = undefined;
	this.container = undefined;
	this.darkener = undefined;
	this.fillerComponent = undefined;
	this.gameLogoComponent = undefined;
	this.companyLogoComponent = undefined;
	this.barComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.LoadScreen.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the dialog
tgfDialogs.LoadScreen.prototype.doHide = function() {
	"use strict";
};

//******************************************************
//*****    Script Resource: DialogTitleScreen
//******************************************************

// ***************************************
// tgfDialogs.TitleScreen
//
// This dialog displays a loading screen
//
// THIS IS A VERY PRELIMINARY VERSION, JUST FOR TESTING
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbKeyCodes, tbLoader, tbVector, tbEase */
/*global tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfFunctions, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.titleScreen = {
	backgroundImage: null,								// The background image

	gameLogo: null,										// Logo image for the game
	gameLogoAppearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-500), endY: tgfScale(-100), ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	gameLogoDisappearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-100), endY: tgfScale(-500), ease: tbEase.easeInOvershoot, easeArgument: 1.2},

	companyLogo: null,									// Logo image for the company
	companyLogoX: tgfScale(0),							// Horizontal position of the company logo
	companyLogoY: tgfScale(276),						// Vertical position of the company logo

	playButtonImage: s_tgf_button,						// Image for the play button
	playButtonDictionaryKey: "",						// Dictionary key for the play button
	playButtonFont: f_tgf_button,						// Font for the play button
	playButtonIcon: s_tgf_icon_play,					// Icon for the play button
	playButtonX: tgfScale(0),							// Horizontal position of the play button
	playButtonY: tgfScale(100),							// Vertical position of the play button
	playButtonWidth: tgfScale(300),						// Width of the play button
	playButtonHeight: tgfScale(0),						// Height of the play button

	menuButtonImage: s_tgf_button,						// Image for the menu button
	menuButtonIcon: s_tgf_icon_options,					// Icon for the menu button
	menuButtonX: tgfScale(-300),						// Horizontal position of the menu button
	menuButtonY: tgfScale(100),							// Vertical position of the menu button
	menuButtonWidth: tgfScale(0),						// Width of the menu button
	menuButtonHeight: tgfScale(0),						// Height of the menu button

	components: [],										// The additional components to add

	onPlay: null,										// Function to be called when the play button is pressed
	onMenu: null,										// Function to be called when the menu button is pressed

	// Additional properties for the components
	gameLogoProperties: null,							// Properties for the game logo component
	companyLogoProperties: null,						// Properties for the company logo component
	playButtonProperties: null,							// Properties for the play button component
	menuButtonProperties: null							// Properties for the menu button component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.TitleScreen = function(properties) {
	"use strict";
	this.name = "TitleScreen";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.titleScreen);
	this.setProperties(tgfSettings.titleScreenDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.TitleScreen, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.TitleScreen.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.gameLogoComponent.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.TitleScreen.prototype.doPrepare = function() {
	"use strict";
	var i, self = this;
	// Position
	this.x = tgfGraphics.mainCanvas.width/2;
	this.y = tgfGraphics.mainCanvas.height/2;
	// Create the game logo
	this.gameLogoComponent = new tgfComponents.Picture( {
			image: this.gameLogo,
			effects: [ this.gameLogoAppearEffect, { effect: "show", duration: 99999999 }, this.gameLogoDisappearEffect ],
			onEffectEnd: function (component) {
					self.hide();
				}
		} );
	this.gameLogoComponent.setProperties(this.gameLogoProperties);
	this.addComponent(this.gameLogoComponent);

	// Create the play button
	this.playButtonComponent = new tgfComponents.Button( {
			image: this.playButtonImage,
			x: this.playButtonX, y: this.playButtonY, width: this.playButtonWidth, height: this.playButtonHeight,
			text: "PLAY", dictionaryKey: this.playButtonDictionaryKey, fontUp: this.playButtonFont, offsetYDown: 2,
			icon: this.playButtonIcon, iconPosition: "right",
			touchMargin: tgfScale(30), shortcutKey: tbKeyCodes.vkEnter,
			onClick: function (component) {
					if (self.onPlay) { self.onPlay(self); }
					self.playButtonComponent.hide();
					self.menuButtonComponent.hide();
					tgfDialogs.TitleScreen.prototype.disappear.call(self);
				}
		} );
	this.playButtonComponent.setProperties(this.playButtonProperties);
	this.addComponent(this.playButtonComponent);
	// Create the menu button
	this.menuButtonComponent = new tgfComponents.Button( {
			image: this.menuButtonImage,
			x: this.menuButtonX, y: this.menuButtonY, width: this.menuButtonWidth, height: this.menuButtonHeight,
			icon: this.menuButtonIcon, iconPosition: "center",
			touchMargin: tgfScale(30),
			onClick: function (component) {
					if (self.onMenu) { self.onMenu(self); }
				}
		} );
	this.menuButtonComponent.setProperties(this.menuButtonProperties);
	this.addComponent(this.menuButtonComponent);
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.TitleScreen.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.gameLogoComponent = undefined;
	this.companyLogoComponent = undefined;
	this.playButtonComponent = undefined;
	this.menuButtonComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.TitleScreen.prototype.doShow = function() {
	"use strict";
	// Draw the background on the background canvas
	if (this.backgroundImage) {
		tbGraphics.setCanvas(tgfGraphics.backgroundCanvas);
		this.backgroundImage.drawCombinedSimple(0, 0);
		tbGraphics.setCanvas(tgfGraphics.mainCanvas);
	}
};

// Processing required when hiding the dialog
tgfDialogs.TitleScreen.prototype.doHide = function() {
	"use strict";
};

//******************************************************
//*****    Script Resource: DialogTutorial
//******************************************************

// ***************************************
// tgfDialogs.Tutorial
//
// This dialog displays a tutorial.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbKeyCodes */
/*global tgfFunctions, tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfAnalytics, tgfScale, tgfEffects */


tgfSettings.dialogDefaults.tutorial = {
	x: undefined,                                       // X-position. When undefined it is placed in the center
	y: undefined,                                       // Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,                       // The background image
	marginLeft: tgfScale(40),                           // Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),                          // Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),                            // Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),                         // Bottom margin whether there is no text, images, etc.
	titlePercentage: 20,                                // Percentage of the box for the title
	imagePercentage: 30,                                // Percentage of the box for the image
	messagePercentage: 30,                              // Percentage of the box for the message (if any)
	buttonPercentage: 20,                               // Percentage of the box for the buttons
	tutorial: [],                                       // The array with the tutorial data, each with properties image, titleKey, messageKey, and animationSpeed
	titleFont: f_tgf_title,                             // Font to be used for the title
	messageFont: f_tgf_text,                            // Font to be used for the message
	previousButtonImage: s_tgf_tutorial_previous,       // The previous button image
	nextButtonImage: s_tgf_tutorial_next,               // The next button image
	closeButtonImage: s_tgf_tutorial_close,             // The close button image
	showButtons: true,                                  // Whether to show the buttons
	interval: 999999,                                   // Interval for automatic progress
	progressOnClick: false,                             // Whether to progress when the screen is clicked
	darken: true,                                       // Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	components: [],                                     // The additional components to add
	// Additional properties for the components
	darkenerProperties: null,                           // Properties for the darkener component
	backgroundProperties: null,                         // Properties for the background component
	titleProperties: null,                              // Properties for the title component
	imageProperties: null,                              // Properties for the image component
	textProperties: null,                               // Properties for the text component
	timerProperties: null,                              // Properties for the timer component
	buttonPreviousProperties: null,                     // Properties for the previous button
	buttonNextProperties: null,                         // Properties for the next button
	buttonCloseProperties: null                         // Properties for the close button
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.Tutorial = function(properties) {
	"use strict";
	this.name = "Tutorial";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.tutorial);
	this.setProperties(tgfSettings.tutorialDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.Tutorial, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.Tutorial.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};

// Sets the tutorial page
tgfDialogs.Tutorial.prototype.setTutorialPage = function(ind) {
	"use strict";
	var tutPage;
	// Abort if no pages have been assigned.
	if(this.tutorial.length <= 0) { return; }        
	// Correct the index
	if (ind < 0) { ind = 0; }
	if (ind >= this.tutorial.length) { ind = this.tutorial.length-1; }
	// Remember the page
	this.page = ind;
	// Set the page properties
	tutPage = this.tutorial[ind];
	this.title.setProperties( { dictionaryKey: tutPage.titleKey } );
	this.title.recreate();
	this.image.setProperties( { image: tutPage.image } );
	if (tutPage.animationSpeed !== undefined) {
		this.image.setProperties( { animationSpeed: tutPage.animationSpeed } );
	}
	this.message.setProperties( { dictionaryKey: tutPage.messageKey } );
	this.message.recreate();
	// Set the buttons to the correct state
	if (this.showButtons) {
		if (ind <= 0) {
			this.previousButton.setProperties( { alpha: 0.4 } );
			this.previousButton.deactivate(0);
		} else {
			this.previousButton.setProperties( { alpha: 1 } );
			this.previousButton.activate(0);
		}
		if (ind >= this.tutorial.length-1) {
			this.nextButton.setProperties( { alpha: 0.4 } );
			this.nextButton.deactivate(0);
		} else {
			this.nextButton.setProperties( { alpha: 1 } );
			this.nextButton.activate(0);
		}
	}
	// Avoid an immediate timer move
	this.timer.reset();
};


// ***************************************
// Internal methods
// ***************************************

// Add a component to the dialog and returns it
tgfDialogs.Tutorial.prototype._addComponentToDialog = function(Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	this.addComponent(comp);
	return comp;
};

// Add a component to the parent component and returns it
tgfDialogs.Tutorial.prototype._addComponentToComponent = function(parent, Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.components.push(comp);
	return comp;
};


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.Tutorial.prototype.doPrepare = function() {
	"use strict";
	var self = this, i, darkener, layoutVert, layoutHor, ww, hh;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Create the darkener
	if (this.darken) {
		darkener = this._addComponentToDialog(tgfComponents.Darkener, {
			width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
		}, this.darkenerProperties);
	}
	// Create the background image container
	this.container = this._addComponentToDialog(tgfComponents.Picture, {
		image: this.backgroundImage, createFromSlices: true,
		width: this.width === 0 ? this.backgroundImage.width : this.width,
		height: this.height === 0 ? this.backgroundImage.height : this.height,
		effects: [ this.appearEffect, { effect: "show", duration: 999999 }, this.disappearEffect ],
		onSubEffectStart: function (component, effect) {
			if (effect === self.disappearEffect && self.darken) {
				darkener.makeLight(darkener.duration, self.container.effects[2].duration-darkener.duration);
			}
		},
		onEffectEnd: function (component) {
			self.hide();
		}
	}, this.backgroundProperties);
	// Create the layout of the other components
	ww = this.width === 0 ? this.backgroundImage.width : this.width;
	ww -= this.marginLeft + this.marginRight;
	hh = this.height === 0 ? this.backgroundImage.height : this.height;
	hh -= this.marginTop + this.marginBottom;
	layoutVert = this._addComponentToComponent(this.container, tgfComponents.LayoutVertical, {
		x: Math.round((this.marginLeft - this.marginRight)/2),
		y: Math.round((this.marginTop - this.marginBottom)/2),
		width: ww, height: hh,
		adaptWidth: [true, false, true, false],
		adaptHeight: [true, false, true, true],
		componentGap: 0,
		componentHeight: [
				Math.round(this.titlePercentage * hh / 100),
				Math.round(this.imagePercentage * hh / 100),
				Math.round(this.messagePercentage * hh / 100),
				Math.round(this.buttonPercentage * hh / 100)
			]
	});
	// Create title, image, and message
	this.title = this._addComponentToComponent(layoutVert, tgfComponents.Label, { font: this.titleFont }, this.titleProperties);
	this.image = this._addComponentToComponent(layoutVert, tgfComponents.Picture, { }, this.imageProperties);
	this.message = this._addComponentToComponent(layoutVert, tgfComponents.Label, { font: this.messageFont, splitLines: true }, this.messageProperties);
	// Create the buttons part
	if (this.showButtons) {
		layoutHor = this._addComponentToComponent(layoutVert, tgfComponents.LayoutHorizontal, {
			width: ww - tgfScale(100),
			adaptWidth: false,
			adaptHeight: false,
			alignment: "spread"
		});
		this.previousButton = this._addComponentToComponent(layoutHor, tgfComponents.Button, {
				image: this.previousButtonImage,
				shortcutKey: tbKeyCodes.vkLeft, touchMargin: tgfScale(20), reactOnDown: true,
				onClick: function (component) { tgfDialogs.Tutorial.prototype.setTutorialPage.call(self, self.page-1); }
			}, this.buttonPreviousProperties);
		this.nextButton = this._addComponentToComponent(layoutHor, tgfComponents.Button, {
				image: this.nextButtonImage,
				shortcutKey: tbKeyCodes.vkRight, touchMargin: tgfScale(20), reactOnDown: true,
				onClick: function (component) { tgfDialogs.Tutorial.prototype.setTutorialPage.call(self, self.page+1); }
			}, this.buttonNextProperties);
		this.closeButton = this._addComponentToComponent(layoutHor, tgfComponents.Button, {
				image: this.closeButtonImage,
				shortcutKey: tbKeyCodes.vkEscape, touchMargin: tgfScale(20), reactOnDown: true,
				onClick: function (component) { tgfDialogs.Tutorial.prototype.disappear.call(self); }
			}, this.buttonCloseProperties);
	}
	// Create the timer
	this.timer = this._addComponentToComponent(this.container, tgfComponents.Timer, {
			enabled: true, interval: this.interval, repeat: this.tutorial.length,
			onTick: function (component) {
					if (self.page >= self.tutorial.length-1) {
						tgfDialogs.Tutorial.prototype.disappear.call(self);
					} else {
						tgfDialogs.Tutorial.prototype.setTutorialPage.call(self, self.page+1);
					}
				}
		}, this.timerProperties);
	if (this.progressOnClick) { this.timer.onTouchDown = this.timer.onTick; }
	// Add the additional components, if any
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.Tutorial.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.container = undefined;
	this.title = undefined;
	this.image = undefined;
	this.message = undefined;
	this.previousButton = undefined;
	this.nextButton = undefined;
	this.closeButton = undefined;
};

// Processing required when showing the dialog
tgfDialogs.Tutorial.prototype.doShow = function() {
	"use strict";
	// Set the first tutorial page
	this.setTutorialPage(0);
};



//******************************************************
//*****    Script Resource: DialogGameTutorial
//******************************************************

// ***************************************
// tgfDialogs.GameTutorial
//
// This dialog displays an in-game tutorial.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbKeyCodes */
/*global tgfFunctions, tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfAnalytics, tgfScale, tgfEffects */


tgfSettings.dialogDefaults.gameTutorial = {
	titleX: 0,                                          // X-position of the title
	titleY: tgfScale(-200),                             // Y-position of the title
	imageX: 0,                                          // X-position of the image
	imageY: 0,                                          // Y-position of the image
	messageX: 0,                                        // X-position of the message
	messageY: tgfScale(200),                            // Y-position of the message
	tutorial: [],                                       // The array with the tutorial data, each with properties image, titleKey, messageKey, and animationSpeed
	titleFont: f_tgf_title,                             // Font to be used for the title
	messageFont: f_tgf_text,                            // Font to be used for the message
	interval: 3,                                        // Interval for automatic progress
	progressOnClick: true,                              // Whether to progress when the screen is clicked
	darken: true,                                       // Whether to darken the background
	darkColor: "white",                                 // Color for darkening
	darkAlpha: 0.6,                                     // Alpha version for the darkening
	components: [],                                     // The additional components to add
	// Additional properties for the components
	darkenerProperties: null,                           // Properties for the darkener component
	titleProperties: null,                              // Properties for the title component
	imageProperties: null,                              // Properties for the image component
	textProperties: null,                               // Properties for the text component
	timerProperties: null                               // Properties for the timer component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.GameTutorial = function(properties) {
	"use strict";
	this.name = "GameTutorial";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.gameTutorial);
	this.setProperties(tgfSettings.gameTutorialDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.GameTutorial, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.GameTutorial.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	if (this.darkenerComponent) {
		this.darkenerComponent.makeLight(this.darkenerComponent.duration, 0);
	} else {
		this.hide();
	}
};

// Sets the tutorial page
tgfDialogs.GameTutorial.prototype.setTutorialPage = function(ind) {
	"use strict";
	var tutPage;
	// Abort if no pages have been assigned.
	if(this.tutorial.length <= 0) { return; }    
	// Correct the index
	if (ind < 0) { ind = 0; }
	if (ind >= this.tutorial.length) { ind = this.tutorial.length-1; }
	// Remember the page
	this.page = ind;
	// Set the page properties
	tutPage = this.tutorial[ind];
	this.titleComponent.setProperties( { dictionaryKey: tutPage.titleKey } );
	this.titleComponent.recreate();
	this.imageComponent.setProperties( { image: tutPage.image } );
	if (tutPage.animationSpeed !== undefined) {
		this.imageComponent.setProperties( { animationSpeed: tutPage.animationSpeed } );
	}
	this.messageComponent.setProperties( { dictionaryKey: tutPage.messageKey } );
	this.messageComponent.recreate();
	// Avoid an immediate timer move
	this.timerComponent.reset();
};


// ***************************************
// Internal methods
// ***************************************

// Add a component to the dialog and returns it
tgfDialogs.GameTutorial.prototype._addComponentToDialog = function(Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	this.addComponent(comp);
	return comp;
};


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.GameTutorial.prototype.doPrepare = function() {
	"use strict";
	var self = this, i;
	// Position
	this.x = tgfGraphics.mainCanvas.width/2;
	this.y = tgfGraphics.mainCanvas.height/2;
	// Create the darkener
	if (this.darken) {
		this.darkenerComponent = this._addComponentToDialog(tgfComponents.Darkener, {
			width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height,
			darkColor: this.darkColor, darkAlpha: this.darkAlpha,
			onLight: function (component) { self.hide(); }
		}, this.darkenerProperties);
	}
	// Create title, image, and message
	this.titleComponent = this._addComponentToDialog(tgfComponents.Label, { x: this.titleX, y: this.titleY, font: this.titleFont }, this.titleProperties);
	this.imageComponent = this._addComponentToDialog(tgfComponents.Picture, { x: this.imageX, y: this.imageY }, this.imageProperties);
	this.messageComponent = this._addComponentToDialog(tgfComponents.Label, { 
		x: this.messageX, y: this.messageY, 
		width: tgfGraphics.mainCanvas.width/2, height: tgfGraphics.mainCanvas.height/4,
		font: this.messageFont, splitLines: true, fitToBox:true 
	}, this.messageProperties);
	// Create the timer
	this.timerComponent = this._addComponentToDialog(tgfComponents.Timer, {
			enabled: true, interval: this.interval, repeat: this.tutorial.length,
			onTick: function (component) {
					if (self.page >= self.tutorial.length-1) {
						tgfDialogs.GameTutorial.prototype.disappear.call(self);
					} else {
						tgfDialogs.GameTutorial.prototype.setTutorialPage.call(self, self.page+1);
					}
				}
		}, this.timerProperties);
	if (this.progressOnClick) { this.timerComponent.onTouchDown = this.timerComponent.onTick; } 
	// Add the additional components, if any
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.GameTutorial.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.darkenerComponent = undefined;
	this.titleComponent = undefined;
	this.imageComponent = undefined;
	this.messageComponent = undefined;
	this.timerComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.GameTutorial.prototype.doShow = function() {
	"use strict";
	// Set the first tutorial page
	this.setTutorialPage(0);
};



//******************************************************
//*****    Script Resource: DialogCompletionScreen
//******************************************************

// ***************************************
// tgfDialogs.CompletionScreen
//
// This dialog displays a simple completion screen screen
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 25-10-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbKeyCodes, tbLoader, tbVector, tbEase */
/*global tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfFunctions, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.completionScreen = {
	backgroundImage: null,								// The background image
	congratulationImage: null,							// The congratulation image, null for no image
	congratulationDictionaryKey: "flowCompletionCongratulations",	// Dictionary key for the congratulation text, "" for no text
	congratulationFont: f_tgf_title,					// Font for the congratulation text
	congratulationX: 0,									// Horizontal position of the congratulation (when not using a move effect)
	congratulationY: tgfScale(-100),					// Vertical position of the congratulation (when not using a move effect)
	congratulationTextX: 0,								// Horizontal position of the text w.r.t. the congratulation 
	congratulationTextY: 0,								// Vertical position of the text w.r.t. the congratulation
	congratulationAppearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-400), endY: tgfScale(-100), ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	congratulationDisappearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-100), endY: tgfScale(-400), ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	continueButtonImage: s_tgf_button,					// Image for the continue button
	continueButtonDictionaryKey: "flowCompletionContinue",			// Dictionary key for the continue button
	continueButtonFont: f_tgf_button,					// Font for the continue button
	continueButtonIcon: null,							// Icon for the continue button
	continueButtonIconPosition: "left",					// The position of the icon for the continue button
	continueButtonX: tgfScale(0),						// Horizontal position of the continue button
	continueButtonY: tgfScale(200),						// Vertical position of the continue button
	continueButtonWidth: tgfScale(400),					// Width of the continue button
	continueButtonHeight: tgfScale(0),					// Height of the continue button
	// Additional components
	components: [],										// The additional components to add
	// Callbacks
	onContinue: null,									// Function to be called when the continue button is pressed (default dialog is hidden)
	// Additional properties for the components
	congratulationPictureProperties: null,				// Further properties for the congratulation picture component
	congratulationLabelProperties: null,				// Further properties for the congratulation label component
	continueButtonProperties: null						// Further properties for the continue button component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.CompletionScreen = function(properties) {
	"use strict";
	this.name = "CompletionScreen";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.completionScreen);
	this.setProperties(tgfSettings.completionScreenDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.CompletionScreen, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.CompletionScreen.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.congratulationComponent.startSubEffect(2);
};


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.CompletionScreen.prototype.doPrepare = function() {
	"use strict";
	var i, self = this;
	// Position
	this.x = tgfGraphics.mainCanvas.width/2;
	this.y = tgfGraphics.mainCanvas.height/2;
	// Create the congratulation component with picture and label
	this.congratulationComponent = new tgfComponents.Container( {
			x: this.congratulationX, y: this.congratulationY,
			effects: [ this.congratulationAppearEffect, { effect: "show", duration: 99999999 }, this.congratulationDisappearEffect ],
			onEffectEnd: function (component) {
					self.hide();
				}
		} );
	this.addComponent(this.congratulationComponent);
	if (this.congratulationImage) { 
		this.congratulationPictureComponent = new tgfComponents.Picture( {
				image: this.congratulationImage
			} );
		this.congratulationPictureComponent.setProperties(this.congratulationPictureProperties);
		this.congratulationComponent.addComponent(this.congratulationPictureComponent);
	}
	if (this.congratulationDictionaryKey !== "") { 
		this.congratulationLabelComponent = new tgfComponents.Label( {
				x : this.congratulationTextX, y : this.congratulationTextY,
				dictionaryKey: this.congratulationDictionaryKey,
				font: this.congratulationFont
			} );
		this.congratulationLabelComponent.setProperties(this.congratulationLabelProperties);
		this.congratulationComponent.addComponent(this.congratulationLabelComponent);
	}
	// Create the button component
	this.continueButtonComponent = new tgfComponents.Button( {
			image: this.continueButtonImage,
			x: this.continueButtonX, y: this.continueButtonY, width: this.continueButtonWidth, height: this.continueButtonHeight,
			text: "<CONTINUE>", dictionaryKey: this.continueButtonDictionaryKey, fontUp: this.continueButtonFont, offsetYDown: 2,
			icon: this.continueButtonIcon, iconPosition: this.continueButtonIconPosition,
			touchMargin: tgfScale(30), shortcutKey: tbKeyCodes.vkEnter,
			onClick: function (component) {
					if (self.onContinue) { self.onContinue(self); }
					self.continueButtonComponent.hide();
					tgfDialogs.CompletionScreen.prototype.disappear.call(self);
				}
		} );
	this.continueButtonComponent.setProperties(this.continueButtonProperties);
	this.addComponent(this.continueButtonComponent);
	// Add the additional components, if any
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.CompletionScreen.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.congratulationComponent = undefined;
	this.congratulationPictureComponent = undefined;
	this.congratulationLabelComponent = undefined;
	this.continueButtonComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.CompletionScreen.prototype.doShow = function() {
	"use strict";
	// Draw the background on the background canvas
	if (this.backgroundImage) {
		tbGraphics.setCanvas(tgfGraphics.backgroundCanvas);
		this.backgroundImage.drawCombinedSimple(0, 0);
		tbGraphics.setCanvas(tgfGraphics.mainCanvas);
	}
};

// Processing required when hiding the dialog
tgfDialogs.CompletionScreen.prototype.doHide = function() {
	"use strict";
};

//******************************************************
//*****    Script Resource: DialogTitleScreen2
//******************************************************

// ***************************************
// tgfDialogs.TitleScreen
//
// This dialog displays a loading screen
//
// THIS IS A VERY PRELIMINARY VERSION, JUST FOR TESTING
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbKeyCodes, tbLoader, tbVector, tbEase */
/*global tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfFunctions, tgfScale, tgfEffects */

tgfSettings.dialogDefaults.titleScreen2 = {
	backgroundImage: null,                              // The background image
	
	imageObjArray: [],//[{image: s_flagIcon_us, layer: 3, x: tgfScale(0), y: tgfScale(0)}, {image: s_flagIcon_de, layer: 0, x: tgfScale(10), y: tgfScale(10)}, {image: s_flagIcon_nl, layer: 2, x: tgfScale(20), y: tgfScale(20)},{image: s_flagIcon_de, layer: 10, x: tgfScale(40), y: tgfScale(40)}],
	imageObjReady: [],
	
	gameLogo: null,  // Logo image for the game
	gameLogoX: tgfScale(0),
	gameLogoY: tgfScale(-500),
	gameLogoAppearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-500), endY: tgfScale(-135), ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	gameLogoDisappearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-135), endY: tgfScale(-500), ease: tbEase.easeInOvershoot, easeArgument: 1.2},

	playButtonImage: s_tgf_button,                      // Image of the play button
	playButtonDictionaryKey: "startScreenPlay",         // Dictionary key of the play button
	playButtonText: "",                                 // Text of the play button
	playButtonFont: f_tgf_button,                       // Font of the play button
	playButtonIcon: s_tgf_icon_play,                    // Icon of the play button
	playButtonX: tgfScale(0),                           // Horizontal position of the play button
	playButtonY: tgfScale(120),                         // Vertical position of the play button
	playButtonWidth: tgfScale(300),                     // Width of the play button
	playButtonHeight: tgfScale(104),                    // Height of the play button
	playButtonAppear: {effect: tgfEffects.scale, duration: 0.5, startScale: tgfScale(0), endScale: tgfScale(1), ease: tbEase.easeOutElastic, easeArgument: 1 },
	playButtonDisappear: {effect: tgfEffects.scale, duration: 0.5, startScale: tgfScale(1), endScale: tgfScale(0), ease: tbEase.easeOutElastic, easeArgumrnts: 0},
	playButtonElastic: {effect: tgfEffects.popElastic, duration: 4, startScaleX: 1, endScaleX: 1.25, startScaleY: 1, endScaleY: 0.9, easeArgument: 1, name: "elastic"},

	menuButtonImage: s_tgf_button,                      // Image for the menu button
	menuButtonIcon: s_tgf_icon_options,                 // Icon for the menu button
	menuButtonX: tgfScale(-300),                        // Horizontal position of the menu button
	menuButtonY: tgfScale(100),                         // Vertical position of the menu button
	menuButtonWidth: tgfScale(0),                       // Width of the menu button
	menuButtonHeight: tgfScale(0),                      // Height of the menu button
	menuButtonText: "",
	menuButtonFont: f_tgf_button,
	menuButtonDictionary: "",
	
	modeButtonImage: s_tgf_button,                          // Image of mode button
	modeButtonDictionaryKey: ["Easy", "Medium", "Hard"],    // Dictionary keys of mode button
	modeButtonFont: f_tgf_button,                           // Font of mode button
	modeButtonIconPosition: "right",
	modeButtonText: [],                                     // Text of mode button (but not really needed)
	modeButtonIcon: [s_tgf_icon_difficulty_easy, s_tgf_icon_difficulty_medium, s_tgf_icon_difficulty_hard], // Icons of mode button
	modeButtonX: tgfScale(0),                               // Vertical position of mode button
	modeButtonY: tgfScale(200),                             // Horizontal position of mode button
	modeButtonWidth: tgfScale(400),                         // Width of mode button
	modeButtonHeight: tgfScale(0),                          // Height of mode button
	modeButtonCreate: false,                                // Does mode button exist
	modeButtonCount: tgfScale(0),                           // Mode counter
	
	companyLogo: s_logo_tinglygames_small,              // Image of the Logo
	companyLogoPosition: [{x: tgfScale(0), y: tgfScale(276)}],
	companyLogoWidth: tgfScale(0),                      // Width of the logo
	companyLogoHeight: tgfScale(0),                     // Height of the logo
	companyLogoLink: "http://www.tinglygames.com",      // Link of the company
	
	languageButtonImage: s_tgf_button,                  // Images of Button
	languageButtonIcon: [],                             // Flag Icon
	languageButtonX: tgfScale(-300),                    // Vertical position of the language button
	languageButtonY: tgfScale(200),                     // Horizontal position of the language button
	languageButtonWidth: tgfScale(0),                   // Width of the language button
	languageButtonHeigth: tgfScale(0),                  // Height of the language button
	languageButtonCreate: false,                        // Does this language button exist?
	languageButtonCounter: tgfScale(0),                 // Selected array position of the excisting languages

	buyButtonImage: s_tgf_button,
	buyButtonWidth: tgfScale(200),
	buyButtonHeight: tgfScale(92),
	buyButtonText: "Buy",
	buyButtonIcon: s_button_drop_icon_coin,
	buyButtonX: tgfScale(-200),
	buyButtonY: tgfScale(-400),
	hasBuyButton: false,

	galleryImage: s_btn_standard,
	galleryWidth: tgfScale(300),
	galleryHeight: tgfScale(100),
	galleryX: tgfScale(0),
	galleryY: tgfScale(350),
	galleryText: "Gallery",
	hasGallery: false,
	
	_fbLogin: false,
	showFacebook: false,
	hasMultiplay: false,
	hasWallet: false,
	
	multiplayButtonImage: s_btn_standard,
	multiplayButtonDictionaryKey: "Random Match",
	multiplayButtonFont: f_tgf_button,
	multiplayButtonX: tgfScale(0),
	multiplayButtonY: tgfScale(138),
	multiplayButtonWidth: tgfScale(420),
	multiplayButtonHeight: tgfScale(104),
	
	components: [],                                     // The additional components to add

	onPlay: null,                                       // Function to be called when the play button is pressed
	onMenu: null,                                       // Function to be called when the menu button is pressed
	onLanguage: null,                                   // Function to be called when the language button is pressed
	onMode: null,                                       // Function to be called when the mode button is pressed
	onCompany: null,                                    // Function(s) to be called when the company logo is pressed
	onMultiplay: null,
	onLogin: null,
	onFriends: null,
	onWallet: null,
	onGallery: null,
		
	// Additional properties for the components
	gameLogoProperties: null,
	companyLogoProperties: null,                        // Properties for the company logo component
	playButtonProperties: null,                         // Properties for the play button component
	menuButtonProperties: null,                         // Properties for the menu button component
	modeButtonProperties: null,                         // Properties for the difficulty button component
	languageButtonProperties: null                      // Properties for the language button component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.TitleScreen2 = function(properties) {
	"use strict";
	this.name = "TitleScreen";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.titleScreen2);
	this.setProperties(tgfSettings.titleScreenDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.TitleScreen2, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.TitleScreen2.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	if(this.playButtonComponent !== undefined) {this.playButtonComponent.startSubEffect(3);}
	if(this.menuButtonComponent !== undefined) {this.menuButtonComponent.hide();}
	if(this.gameLogoComponent !== undefined) {this.gameLogoComponent.startSubEffect(2);}
	if(this.modeButtonComponent !== undefined) {this.modeButtonComponent.hide();}
	if(this.languageButtonComponent !== undefined) {this.languageButtonComponent.hide();}
};

// ***************************************
// Internal methods
// ***************************************

tgfDialogs.TitleScreen2.prototype.resizeGame = function() {
	var avH = window.availHeight;
	var inH = window.innerHeight;
	
	console.log(avH + "  OR   " + inH);
	
	var gameContainer = tgfGraphics.container;
	gameContainer.style.height = window.availHeight || window.innerHeight;
}

tgfDialogs.TitleScreen2.prototype.openLanguage = function(){
	var self = this, dialog;
	if(tgfSettings.flow.showLanguageDialog){
		if(tgfSettings.flow.languageScreenProperties){
			dialog = new tgfDialogs.LanguageScreen(tgfSettings.flow.languageScreenProperties);
			dialog.onClick = function(dialog, buttonId){
				tbGame.resumeTokens();
				dialog.changeLanguage(buttonId);
			};
			dialog.onHide = function(dialog){self.checkLanguageSelection()};
			tbGame.pauseTokens();
			dialog.show();
		}else{
			console.log("No languageScreenProperties can be found");
		}
	}
};

tgfDialogs.TitleScreen2.prototype.openMenu = function(){
	var dialog;
	if (tgfSettings.flow.showTitleMenuDialog) {
		if(tgfSettings.flow.titleMenuProperties){
			dialog = new tgfDialogs.OptionScreen(tgfSettings.flow.titleMenuProperties);
			dialog.onClick = function(dialog) { 
				
			};
			// Show it, pausing the other tokens
			dialog.onHide = function(dialog) { tbGame.resumeTokens(); };
			tbGame.pauseTokens();
			dialog.show();
		}else{
			console.log("No titleMenuProperties can be found");
		}
	}
};

tgfDialogs.TitleScreen2.prototype.checkLanguageSelection = function(){
	var curLanguage = tgfDictionary.getLanguage();
	this.languageButtonComponent.icon = tgfDictionary.getLanguageFlag(curLanguage);
	this.languageButtonComponent.recreate();
};

tgfDialogs.TitleScreen2.prototype.updateLanguage = function(){
	"use strict";
	var tmpSelectedLanguage = tgfDictionary.getLanguage();
	tgfDictionary.setLanguage(tmpSelectedLanguage);
	
	if(this.playButtonComponent){
		this.playButtonComponent.recreate();
	}
};

tgfDialogs.TitleScreen2.prototype.getAllFlags = function(){
	var availableLanguage = tgfDictionary.getAvailableLanguages();
	var curLanguage = tgfDictionary.getLanguage();
	for(var i = 0; i < availableLanguage.length; i++){
		var tmpLanguage = tgfDictionary.getLanguageFlag(availableLanguage[i]);
		this.languageButtonIcon.push(tmpLanguage);
		if(availableLanguage[i] === curLanguage){
			this.languageButtonCounter = i;
		}
	}
};


tgfDialogs.TitleScreen2.prototype._createImageArray = function(imageObj){
	
	var tmpImage = new tgfComponents.Picture({
		x: imageObj.x, y: imageObj.y, image: imageObj.image, layer: imageObj.layer
	});
	
	this.imageObjReady.push(tmpImage);
};

tgfDialogs.TitleScreen2.prototype._sortImageLayer = function(imageArray){
	
	imageArray.sort(function(a,b){ return a.layer - b.layer;});
	this._drawImageArray(imageArray);
};

tgfDialogs.TitleScreen2.prototype._drawImageArray = function(imageArray){
	console.log(imageArray);
	for(var i = 0; i < imageArray.length; i++){
		this.components.push(imageArray[i]);
	}
};

tgfDialogs.TitleScreen2.prototype.fbLogin = function(){
	"use strict";
	var _this = this;
	
	if(FacebookWrapper.instance.isLoggedIn()) {
		this.fbButtonComponent.hide();
		this.fbFriendChallenge.show();
		this.fbFriendChallenge.activate();
		return;
	}
	
	FacebookWrapper.instance.login(function() {
		console.log("Fb Success");
		_this.fbButtonComponent.hide();
		_this.fbFriendChallenge.show();
		_this.fbFriendChallenge.activate();
	}, function() {
		console.log("Fb Fail");
	});
};

tgfDialogs.TitleScreen2.prototype.buyItemSuccess = function(){
		console.log("Buy Callback Success");
};

// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.TitleScreen2.prototype.doPrepare = function() {
	"use strict";
	var i, self = this;
	// Position
	this.x = tgfGraphics.mainCanvas.width/2;
	this.y = tgfGraphics.mainCanvas.height/2;

	//this.gameLogoAppearEffect = {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(-500), endY: self.gameLogoY, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	//this.gameLogoDisappearEffect = {effect: tgfEffects.move, duration: 0.8, startY: self.gameLogoY, endY: tgfScale(-500), ease: tbEase.easeInOvershoot, easeArgument: 1.2},


	window.addEventListener('orientationchange', function(){ self.resizeGame(); }, false);
	
	// Create the game logo
	this.gameLogoComponent = new tgfComponents.Picture( {
			image: this.gameLogo,
			y: this.gameLogoY, x: this.gameLogoX,
			effects: [ this.gameLogoAppearEffect, { effect: "show", duration: 99999999 }, this.gameLogoDisappearEffect ],
			onEffectEnd: function (component) {
					self.hide();
				}
		} );
	this.gameLogoComponent.setProperties(this.gameLogoProperties);
	this.addComponent(this.gameLogoComponent);
	
	
	
	// Create the play button
	if(!this.hasMultiplay){
		this.playButtonComponent = new tgfComponents.Button( {
				image: this.playButtonImage,
				x: this.playButtonX, y: this.playButtonY, width: this.playButtonWidth, height: this.playButtonHeight, 
				text: this.playButtonText, dictionaryKey: this.playButtonDictionaryKey, fontUp: this.playButtonFont, offsetYDown: 2,
				effects: [this.playButtonAppear, this.playButtonElastic, { effect: "show", duration: 99999999 }, this.playButtonDisappear],
				icon: this.playButtonIcon, iconPosition: "right",
				touchMargin: tgfScale(30), shortcutKey: tbKeyCodes.vkEnter,
				onSubEffectEnd: function(component ,effect){
					if(effect.name === "elastic"){self.playButtonComponent.startSubEffect(1);}
				},
				onClick: function (component) {
					if (self.onPlay) { self.onPlay("play"); }
						tgfDialogs.TitleScreen2.prototype.disappear.call(self);
					}
			} );
		this.playButtonComponent.setProperties(this.playButtonProperties);
		this.addComponent(this.playButtonComponent);
	}
	
	if(this.hasMultiplay){
		this.multiplayComponent = new tgfComponents.Button({
			image: this.multiplayButtonImage, x: this.multiplayButtonX, y: this.multiplayButtonY,
			effects: [this.playButtonAppear, this.playButtonElastic, { effect: "show", duration: 99999999 }, this.playButtonDisappear],
			dictionaryKey: this.multiplayButtonDictionaryKey, width: this.multiplayButtonWidth, height: this.multiplayButtonHeight,
			fontUp: this.multiplayButtonFont,
			onSubEffectEnd: function(component ,effect){
				if(effect.name === "elastic"){self.multiplayComponent.startSubEffect(1);}
			},
			onClick: function(component){
				if(self.onMultiplay){ self.onMultiplay(self); }
				self.deactivate();
				//tgfDialogs.TitleScreen2.prototype.disappear.call(self);
			}
		});
		
		this.addComponent(this.multiplayComponent);
	}

	if(this.hasGallery){
		this.galleryComponent = new tgfComponents.Button({
			image: this.galleryImage, width: this.galleryWidth, height: this.galleryHeight,
			x: this.galleryX, y: this.galleryY, text: this.galleryText,
			onClick: function(components){
				if(self.onGallery){
					self.onGallery("gallery");
				}
			}
		});

		this.addComponent(this.galleryComponent);
	}
	
	this.leftAnchor = new tgfComponents.AnchorComponent({ });
	
	if(this.showFacebook){
		this.fbButtonComponent = new tgfComponents.Button({
			image: s_button_default_facebook, icon: s_button_default_icon_facebook, x: tgfScale(0), y: tgfScale(185),
			marginRight: tgfScale(0), marginLeft: tgfScale(50), iconTextDistance: tgfScale(2),
			text: "Login to Facebook", fontUp: NotSoStoutDeco, width: tgfScale(400), height: tgfScale(104),
			onClick: function(component){
				if(self.fbLogin){self.fbLogin();}
			}
		});
		
		this.addComponent(this.fbButtonComponent);
		
		this.fbFriendChallenge = new tgfComponents.Button({
			image: s_button_default_green, text: "Challenge a friend",
			width: tgfScale(400), height: tgfScale(104), fontUp: NotSoStoutDeco,
			x: tgfScale(0), y: tgfScale(185),
			onClick: function(component){
				if(self.onFriends){self.onFriends();}
			}
		});
		
		this.addComponent(this.fbFriendChallenge);
	}
	// Create the menu button
	this.menuButtonComponent = new tgfComponents.Button({
			image: this.menuButtonImage, text: this.menuButtonText, fontUp: this.menuButtonFont,
			dictionaryKey: this.menuButtonDictionary,
			x: this.menuButtonX, y: this.menuButtonY, width: this.menuButtonWidth, height: this.menuButtonHeight,
			icon: this.menuButtonIcon, iconPosition: "center",
			touchMargin: tgfScale(30),
			onClick: function (component) {
					if (self.onMenu) { self.onMenu(self); }
					else{self.openMenu();}
			}
	});
	
	this.menuButtonComponent.setProperties(this.menuButtonProperties);
	this.leftAnchor.addComponent(this.menuButtonComponent);
	
	this.addComponent(this.leftAnchor);//this.menuButtonComponent);
	
	//If mode button wanted, it will be added
	if(this.modeButtonCreate){
		this.modeButtonComponent = new tgfComponents.Button({
			image: this.modeButtonImage,
			icon: this.modeButtonIcon, iconPosition: this.modeButtonIconPosition,
			text: this.modeButtonText, dictionaryKey: this.modeButtonDictionaryKey, fontUp: this.modeButtonFont, offsetYDown: 2,
			x: this.modeButtonX, y: this.modeButtonY, width: this.modeButtonWidth, height: this.modeButtonHeight,
			toggleIndex: this.modeButtonCount,
			toggleAutomatic: true,
			onClick: function (component){
				if(self.onMode){self.onMode(self);}
				else{}
				this.modeButtonCount = component.toggleIndex;
			}
		});
		
		this.modeButtonComponent.setProperties(this.modeButtonProperties);
		this.addComponent(this.modeButtonComponent);
	}

	if(this.hasBuyButton){
		this.buyButtonComponent = new tgfComponents.Button({
			image: this.buyButtonImage, icon: this.buyButtonIcon,
			width: this.buyButtonWidth, height: this.buyButtonHeight,
			x: this.buyButtonX, y: this.buyButtonY, text: this.buyButtonText,
			onClick: function(){
				tgfHooks.payment(undefined, "1.99$", "test_item", self.buyItemSuccess, undefined);
			}
		});

		this.addComponent(this.buyButtonComponent);
	}
	
	if(this.languageButtonCreate){
		if(this.languageButtonIcon.length === 0){this.getAllFlags();}
		this.languageButtonComponent = new tgfComponents.Button({
			image: this.languageButtonImage,
			icon: this.languageButtonIcon[this.languageButtonCounter],
			x: this.languageButtonX,
			y: this.languageButtonY,
			width: this.languageButtonWidth, height: this.languageButtonHeigth,
			onClick: function(component){
				if(self.onLanguage){self.onLanguage(self);}
				else{ self.openLanguage(); }
			}
		});
		
		this.languageButtonComponent.setProperties(this.languageButtonProperties);
		this.addComponent(this.languageButtonComponent);
	}
	
	this.rightAnchor = new tgfComponents.AnchorComponent({anchorCoordinates:  new tbVector(1,0)})
	
	if(this.hasWallet){
		
		this.walletComponent = new tgfComponents.Button({
			image: s_button_drop_right, icon: s_button_drop_icon_coin,
			text: "0", fontUp: NotSoStoutDeco,
			x: tgfScale(-100), y: tgfScale(580),
			width: tgfScale(153), height: tgfScale(114),
			onClick: function(component){
				if(self.onWallet){self.onWallet();}
			}
		});
		
		this.rightAnchor.addComponent(this.walletComponent);
		this.addComponent(this.rightAnchor);
	}
	
	//Check if Array and add company logo
	if(Object.prototype.toString.call(this.companyLogo) === '[object Array]'){
		//if(Object.prototype.toString.call(this.companyLogoPosition) !== '[object Array]'){console.log("Forgot to set the companyLogoPosition Array")}
		//if(Object.prototype.toString.call(this.companyLogoLink) !== '[object Array]'){console.log("Forgot to set the companyLogoLink Array")}
		for(var i = 0; i < this.companyLogo.length; i++){
			this.companyLogoComponent = new tgfComponents.Picture({
				image: this.companyLogo[i],
				x: this.companyLogoPosition[i].x, y: this.companyLogoPosition[i].y, width: this.companyLogoWidth, height: this.companyLogoHeight,
				link: this.companyLogoLink[i],
				ii: i,
				onClick: function(component){
					if(self.onCompany){
						self.onCompany[this.ii].call();
					} else {
						if(this.link !== "") {
							window.open(this.link);
						}
					}
				}
			});
		this.companyLogoComponent.setProperties(this.companyLogoProperties);
		this.rightAnchor.addComponent(this.companyLogoComponent);
		this.addComponent(this.rightAnchor);//this.companyLogoComponent);
		}
	}
	else{
		this.companyLogoComponent = new tgfComponents.Picture({
			image: this.companyLogo,
			x: this.companyLogoPosition[0].x, y: this.companyLogoPosition[0].y, width: this.companyLogoWidth, height: this.companyLogoHeight,
			link: this.companyLogoLink,
			onClick: function(component){
				if(this.link !== "") {
					window.open(this.link, '_blank');
				}
			}
		});
		this.companyLogoComponent.setProperties(this.companyLogoProperties);
		this.rightAnchor.addComponent(this.companyLogoComponent);
		this.addComponent(this.rightAnchor);//this.companyLogoComponent);
	}
	
	if(this.languageButtonCreate){
		this.checkLanguageSelection();
	}
	
	//LayerTest
//  for(var i = 0; i < this.imageObjArray.length; i++){
//      this._createImageArray(this.imageObjArray[i]);
//  }
//  this._sortImageLayer(this.imageObjReady);
	
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.addComponent(this.components[i]);
	}
	
};

// Processing required when freeing the dialog from use
tgfDialogs.TitleScreen2.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.gameLogoComponent = undefined;
	this.companyLogoComponent = undefined;
	this.playButtonComponent = undefined;
	this.menuButtonComponent = undefined;
	this.extraButtonComponent = undefined;
	this.companyLogoComponent = undefined;
	this.modeButtonComponent = undefined;
	this.languageButtonComponent = undefined;
	this.fbButtonComponent = undefined;
	this.multiplayComponent = undefined;
	this.fbFriendChallenge = undefined;
	this.walletComponent = undefined;
};

// Processing required when showing the dialog
tgfDialogs.TitleScreen2.prototype.doShow = function() {
	"use strict";
	// Draw the background on the background canvas
	if (this.backgroundImage) {
		tbGraphics.setCanvas(tgfGraphics.backgroundCanvas);
		this.backgroundImage.drawCombinedSimple(0, 0);
		tbGraphics.setCanvas(tgfGraphics.mainCanvas);
	}
	
	
	if(FacebookWrapper.instance && this.fbButtonComponent){
		if(FacebookWrapper.instance.isLoggedIn()){//} && !this._fbLogin) {
			this.fbButtonComponent.hide();
//			this._fbLogin = true;
		}else {
			this.fbFriendChallenge.hide();
		}
	}
};

tgfDialogs.TitleScreen2.prototype.doActivate = function() {
	"use strict";
//	console.log("activate");
	if(FacebookWrapper.instance && this.fbButtonComponent){
		if(FacebookWrapper.instance.isLoggedIn()){//} && !this._fbLogin) {
			this.fbButtonComponent.hide();
//			this._fbLogin = true;
		}else {
			this.fbFriendChallenge.hide();
		}
	}
};



tgfDialogs.TitleScreen2.prototype.onActivate = function(){
	"use strict";
	this.updateLanguage();
};

// Processing required when hiding the dialog
tgfDialogs.TitleScreen2.prototype.doHide = function() {
	"use strict";
};


//******************************************************
//*****    Script Resource: DialogLanguageScreen
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************
tgfSettings.dialogDefaults.languageScreen = {
	buttonScrollBoxWidth: tgfScale(500),
	buttonScrollBoxHeight: tgfScale(500),
	buttonsContainer: [],
	buttonTotalHeight: tgfScale(0),
	
	availableLanguagesIcons:[],
	availableLanguagesNames: [],
	availableLanguagesId: [],
	
	components: [],
	
	scrollBoxProperties: null
};

// The constructor for the dialog
/** @constructor
 *  @base tgfDialogs.ButtonBox
 */
tgfDialogs.LanguageScreen = function(properties) {
	"use strict";
	this.name = "LanguageScreen";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.buttonBox);
	this.setProperties(tgfSettings.dialogDefaults.languageScreen);
	this.setProperties(tgfSettings.titleLanguageDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.LanguageScreen, tgfDialogs.ButtonBox);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.LanguageScreen.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************

// Add a component to the dialog and returns it
tgfDialogs.LanguageScreen.prototype._addComp = function(parent, Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	parent.addComponent(comp);
	return comp;
};

tgfDialogs.LanguageScreen.prototype._addScrollBoxComponent = function(parent, Component, properties, moreProperties, extraProperties){
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	this.buttonsContainer.push(comp);
};

// Add a button to the dialog and returns it
tgfDialogs.LanguageScreen.prototype._addButton = function(parent, button, n, x, y, w) {
	"use strict";	
	var self = this;
	return this._addScrollBoxComponent(parent, tgfComponents.ExtButton, {
			x: x, y: y, width: w, height: 0,
			image: button.image === undefined ? this.buttonDefaultImage : button.image,
			text: this.availableLanguagesNames[n],//button.text === undefined ? "" : button.text,
			languageId: this.availableLanguagesId[n],//button.languageId === undefined ? "" : button.languageId, 
			dictionaryKey: button.key === undefined ? "" : button.key,
			icon: this.availableLanguagesIcons[n]/*button.icon*/, iconPosition: "left",
			font: button.font === undefined ? this.buttonDefaultFont : button.font,
			buttonId: button.id === undefined ? n : button.id,
			buttonHide: button.hide === undefined ? this.buttonDefaultHide : button.hide,
			cancelEvents: false,
			offsetYDown: 2,
			threshold: tgfScale(1.5),
			onClick: function (component) {
				if (component.buttonHide) { tgfDialogs.ButtonBox.prototype.disappear.call(self); }
				if (self.onClick) { self.onClick(self, component.buttonId); }
			}
		}, this.buttonDefaultProperties, button.properties);
};

tgfDialogs.LanguageScreen.prototype.changeLanguage = function(buttonId){
		var languages = tgfDictionary.getAvailableLanguages();
		tgfDictionary.setLanguage(languages[buttonId]);
		
		this.deactivate();
		this.container.startSubEffect(2);
};

tgfDialogs.LanguageScreen.prototype.initLanguages = function(){
	this.availableLanguagesId = tgfDictionary.getAvailableLanguages();
	
	for(var i = 0; i < this.availableLanguagesId.length; i++){
		this.availableLanguagesIcons.push(tgfDictionary.getLanguageFlag(this.availableLanguagesId[i]));
		this.availableLanguagesNames.push(tgfDictionary.getLanguageName(this.availableLanguagesId[i]));
	}
};

// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.LanguageScreen.prototype.doPrepare = function() {
	"use strict";
	var self = this, i, j, n,
	blockLeft = [], blockTop = [], blockWidth = [], blockHeight = [],
	ww, hh, closeX, closeY,
	buttons, buttonLeft, buttonTop, buttonVDistance, buttonHDistance, buttonWidth, buttonHeight,
	darkener;
	// Position
	if (this.x === undefined) { this.x = tgfGraphics.mainCanvas.width/2; }
	if (this.y === undefined) { this.y = tgfGraphics.mainCanvas.height/2; }
	// Determine the position and sizes of the blocks
	ww = this.width === 0 ? this.backgroundImage.width : this.width;
	hh = this.height === 0 ? this.backgroundImage.height : this.height;
	blockLeft[0] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[0] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[0] = Math.round(-hh/2 + this.marginTop);
	blockHeight[0] = Math.round(this.titlePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	blockLeft[1] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[1] = Math.round(ww - this.marginLeft - this.marginRight);
	blockTop[1] = Math.round(blockTop[0] + blockHeight[0]);
	blockHeight[1] = Math.round(this.messagePercentage * (hh - this.marginTop - this.marginBottom) / 100);
	if (this.iconImage) {
		blockWidth[2] = this.iconImage.width;
		blockLeft[2] = blockLeft[1] + blockWidth[1] - blockWidth[2];
		blockTop[2] = blockTop[1];
		blockHeight[2] = blockHeight[1];
		blockWidth[1] -= blockWidth[2] + tgfScale(32);
		if (this.iconPosition === "left") {
			blockLeft[2] = blockLeft[1];
			blockLeft[1] += blockWidth[2] + tgfScale(32);
		}
	}
	blockLeft[3] = Math.round(-ww/2 + this.marginLeft);
	blockWidth[3] = Math.round(ww - this.marginLeft - this.marginRight);
	if (this.buttonHorizontalSize > 0) {
		blockLeft[3] = Math.round(-this.buttonHorizontalSize / 2);
		blockWidth[3] = this.buttonHorizontalSize;
	}
	blockTop[3] = Math.round(blockTop[1] + blockHeight[1]);
	blockHeight[3] = Math.round(this.buttonPercentage * (hh - this.marginTop - this.marginBottom) / 100);
	// Create the darkener
	if (this.darken) {
		darkener = this._addComponent(this, tgfComponents.Darkener, {
				width: tgfGraphics.mainCanvas.width, height: tgfGraphics.mainCanvas.height
			}, this.darkenerProperties);
	}
	// Create the background image container
	this.container = this._addComponent(this, tgfComponents.Picture, {
			image: this.backgroundImage,
			createFromSlices: true,
			width: this.width === 0 ? this.backgroundImage.width : this.width,
			height: this.height === 0 ? this.backgroundImage.height : this.height,
			effects: [ this.appearEffect, { effect: "show", duration: this.lifeTime }, this.disappearEffect ],
			onSubEffectStart: function (component, effect) {
					if (effect === self.disappearEffect && self.darken) {
						darkener.makeLight(darkener.duration, self.container.effects[2].duration-darkener.duration);
					}
				},
			onEffectEnd: function (component) {
					self.hide();
				}
		}, this.backgroundProperties);
	if (this.disappearOnClick) {
		this.container.onTouchDown = function (component) {
				if (self.onClose) { self.onClose(self); }
				tgfDialogs.ButtonBox.prototype.disappear.call(self);
			};
	}
	// Create title
	if (this.titlePercentage) {
		this._addComponent(this.container, tgfComponents.Label, {
				x: Math.round(blockLeft[0] + blockWidth[0]/2), y: Math.round(blockTop[0] + blockHeight[0]/2),
				width: blockWidth[0], height: blockHeight[0],
				text: this.titleText, dictionaryKey: this.titleDictionaryKey,
				font: this.titleFont, fitToBox: true, splitLines: false, surfaceMargin: tgfScale(20)
			}, this.titleProperties);
	}
	// Create message
	if (this.messagePercentage) {
		this._addComponent(this.container, tgfComponents.Label, {
				x: Math.round(blockLeft[1] + blockWidth[1]/2), y: Math.round(blockTop[1] + blockHeight[1]/2),
				width: blockWidth[1], height: blockHeight[1],
				text: this.messageText, dictionaryKey: this.messageDictionaryKey,
				font: this.messageFont, fitToBox: true, splitLines: true, surfaceMargin: tgfScale(20)
			}, this.messageProperties);
	}
	// Create the icon
	if (this.messagePercentage && this.iconImage) {
		this._addComponent(this.container, tgfComponents.Picture, {
				image: this.iconImage,
				x: Math.round(blockLeft[2] + blockWidth[2]/2), y: Math.round(blockTop[2] + blockHeight[2]/2)
			}, this.iconProperties );
	}
	// Create close button
	if (this.hasCloseButton) {
		closeX = Math.round((this.width === 0 ? this.backgroundImage.width : this.width) / 2 - this.closeButtonWidth / 2);
		closeY = Math.round(-(this.height === 0 ? this.backgroundImage.height : this.height) / 2 + this.closeButtonHeight / 2);
		this._addComponent(this.container, tgfComponents.Button, {
				x: closeX, y: closeY, width: this.closeButtonWidth, height: this.closeButtonHeight,
				image: s_tgf_transparent,
				onClick: function(component) {
						if (self.onClose) { self.onClose(self); }
						tgfDialogs.ButtonBox.prototype.disappear.call(self);
					}
			}, this.closeButtonProperties);
	}
		
	//Initialize Languages before create Buttons
	this.initLanguages();
	
	// Create the buttons
	if (this.buttonPercentage) {
		if (this.buttonHorizontal) { buttons = [this.buttons]; } else { buttons = this.buttons; }
		buttonHeight = this.buttonDefaultImage.height;
		buttonVDistance = buttonHeight + this.buttonVerticalGap;
		buttonTop = Math.round(blockTop[3] + buttonHeight/2);
		switch (this.buttonVerticalAlignment) {
			case "top": break;
			case "bottom": buttonTop += blockHeight[3] - buttons.length * buttonVDistance - this.buttonVerticalGap; break;
			default: buttonTop += Math.round((blockHeight[3] - buttons.length * buttonVDistance - this.buttonVerticalGap) / 2); break;
		}
		n = 0;
		for (i = 0; i < buttons.length; i += 1) {
			if (Object.prototype.toString.call(buttons[i]) === "[object Array]") {
				buttonWidth = Math.round((blockWidth[3] - this.buttonHorizontalGap * (buttons[i].length - 1)) / buttons[i].length);
				buttonHDistance = buttonWidth + this.buttonHorizontalGap;
				buttonLeft = Math.round(blockLeft[3] + buttonWidth / 2);
				this.buttonTotalHeight += buttonVDistance + this.buttonVerticalGap;
				for (j = 0; j < buttons[i].length; j += 1) {
					this._addButton(this.container, buttons[i][j], n, buttonLeft + j * buttonHDistance, buttonTop + i * buttonVDistance, buttonWidth);
					n += 1;
				}
			} else {
				this._addButton(this.container, buttons[i], n, Math.round(blockLeft[3] + blockWidth[3] / 2), buttonTop + i * buttonVDistance, blockWidth[3]);
				n += 1;
			}
		}
	}
	
	//Create Language Scroll Box
	this._addComp(this.container, tgfComponents.ScrollBox,{
		scrollHorizontal:false,
		areaX: 0, areaY:0, width: this.buttonScrollBoxWidth, height: this.buttonScrollBoxHeight,
		areaWidth: this.buttonDefaultImage.width,
		areaHeight: this.buttonTotalHeight,
		components: this.buttonsContainer
	}, this.scrollBoxProperties);
	
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

tgfDialogs.LanguageScreen.prototype.doFree = function() {
	"use strict";
	tgfDialogs.LanguageScreen.uber.doFree.call(this);
};
//******************************************************
//*****    Script Resource: DialogOptionScreen
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.dialogDefaults.optionScreen = {
	optionSettings: [],
	optionButtonPositions: [{x: tgfScale(0), y: tgfScale(-180)}, {x: tgfScale(0), y: tgfScale(-80)}, {x: tgfScale(0), y: tgfScale(20)}, {x: tgfScale(0), y: tgfScale(120)}, {x: tgfScale(0), y: tgfScale(220)}],
	optionButtonCurX: tgfScale(0),
	optionButtonCurY: tgfScale(0),
	languageId: undefined,
	generalFont: f_tgf_button,//OpenSansBold,

	fixedTitleImage: undefined,
	fixedTitleX: tgfScale(0),
	fixedTitleY: tgfScale(0),
	
	buttonTutorialImage: s_btn_standard,
	buttonTutorialFont: f_tgf_button,
	buttonTutorialDictionaryKey: "optionsTutorial",
	buttonTutorialWidth: tgfScale(400),
	buttonTutorialHeight: tgfScale(92),
	buttonTutorialText: "",
	buttonTutorialIcon: null,
	
	sliderMusicImageBack: s_tgf_slider_back,
	sliderMusicImageSlider: s_tgf_slider_slider,
	sliderMusicWidth: tgfScale(400),
	sliderMusicHeight: tgfScale(92),
	sliderMusicIcon: s_tgf_icon_music_on,
	
	sliderSoundImageBack: s_tgf_slider_back,
	sliderSoundImageSlider: s_tgf_slider_slider,
	sliderSoundWidth: tgfScale(400),
	sliderSoundHeight: tgfScale(92),
	sliderSoundIcon: s_tgf_icon_sound_on,
	
	buttonMoreImage: s_btn_standard,
	buttonMoreFont: f_tgf_button,
	buttonMoreDictionaryKey: "optionsMoreGames",
	buttonMoreWidth: tgfScale(400),
	buttonMoreHeight: tgfScale(92),
	buttonMoreText: "",
	buttonMoreIcon: null,
	buttonMoreUrl: "http://www.coolgames.com/",
	
	buttonAboutImage: s_btn_standard,
	buttonAboutFont: f_tgf_button,
	buttonAboutDictionaryKey: "optionsAbout_title",
	buttonAboutWidth: tgfScale(400),
	buttonAboutHeight: tgfScale(92),
	buttonAboutText: "",
	buttonAboutIcon: null,
	
	buttonCloseImage: s_btn_standard,
	buttonCloseFont: f_tgf_button,
	buttonCloseDictionaryKey: "Close",
	buttonCloseWidth: tgfScale(400),
	buttonCloseHeight: tgfScale(92),
	buttonCloseText: "",
	buttonCloseIcon: null,
	
	buttonExitImage: s_btn_standard,
	buttonExitFont: f_tgf_button,
	buttonExitDictionaryKey: "optionsExit",
	buttonExitWidth: tgfScale(400),
	buttonExitHeight: tgfScale(92),
	buttonExitText: "",
	buttonExitIcon: null,
	buttonExitHasClose: false,
	
	buttonResumeImage: s_btn_standard,
	buttonResumeFont: f_tgf_button,
	buttonResumeDictionaryKey: "optionsResume",
	buttonResumeWidth: tgfScale(400),
	buttonResumeHeight: tgfScale(92),
	buttonResumeText: "",
	buttonResumeIcon: null,
	
	buttonQuitImage: s_btn_standard,
	buttonQuitFont: f_tgf_button,
	buttonQuitDictionaryKey: "optionsQuit",
	buttonQuitWidth: tgfScale(400),
	buttonQuitHeight: tgfScale(92),
	buttonQuitText: "",
	buttonQuitIcon: null,
	
	//Quit window properties
	quitTitleText: "",
	quitTitleX: tgfScale(0),
	quitTitleY: tgfScale(-120),
	quitTitleWidth: tgfScale(400),
	quitTitleHeight: tgfScale(200),
	quitTitleDictionaryKey: "optionsRestartConfirmationText",
	quitTitleFont: f_tgf_text,

	//NOT IN USE
	quitSubtitleText: "",
	quitSubtitleX: tgfScale(0),
	quitSubtitleY: tgfScale(-80),
	quitSubtitleDictionaryKey: "If you quit now you will \n lose all progress made \n during this level. Are you \n sure you want to quit?",
	quitSubtitleFont: f_tgf_button,
	
	quitYesButtonImage: s_btn_standard,
	quitYesButtonX: tgfScale(0),
	quitYesButtonY: tgfScale(120),
	quitYesButtonWidth: tgfScale(400),
	quitYesButtonHeight: tgfScale(92),
	quitYesButtonText: "",
	quitYesButtonDictionaryKey: "optionsQuitConfirmBtn_Yes",
	quitYesButtonId: "",
	
	quitNoButtonImage: s_btn_standard,
	quitNoButtonX: tgfScale(0),
	quitNoButtonY: tgfScale(220),
	quitNoButtonWidth: tgfScale(400),
	quitNoButtonHeight: tgfScale(92),
	quitNoButtonText: "",
	quitNoButtonDictionaryKey: "optionsQuitConfirmBtn_No",
	/////////
	
	buttonLanguageImage: s_btn_standard,
	buttonLanguageIcon: [],
	buttonLanguageText: [],
	buttonLanguageToggle: 0,
	availableLanguagesId: [],
	buttonLanguageWidth: tgfScale(400),
	buttonLanguageHeight: tgfScale(92),

	customOldX: undefined,
	
	oldButtonMusicImage: s_btn_standard,
	oldButtonMusicIcon: [s_icon_toggle_music_on, s_icon_toggle_music_off],
	oldButtonMusicWidth: tgfScale(200),
	oldButtonMusicHeight: tgfScale(92),
	oldButtonMusicOffset: tgfScale(0),
	
	oldButtonFxImage: s_btn_standard,
	oldButtonFxIcon: [s_icon_toggle_sfx_on, s_icon_toggle_sfx_off],
	oldButtonFxWidth: tgfScale(200),
	oldButtonFxHeight: tgfScale(92),
	oldButtonFxOffset: tgfScale(0),

	hasAlternativeClose: false,
	
	onTutorial: null,
	onMusic: null,
	onMusicChange: null,
	onSound: null,
	onSoundChange: null,
	onMoreGames: null,
	onAbout: null,
	onClose: null,
	onExit: null,
	onResume: null,
	onQuit: null,
	onQuitYes: null,
	onQuitNo: null,
	
	base: null,
	
	firstContainer: null,
	secondContainer: null,
	
	tutorialProperties: null,
	musicProperties: null,
	soundProperties: null,
	languageProperties: null,
	moreGamesProperties: null,
	aboutProperties: null,
	closeProperties: null,
	exitProperties: null,
	resumeProperties:  null,
	quitProperties: null
};

// The constructor for the dialog
/** @constructor
 *  @base tgfDialogs.ButtonBox
 */
tgfDialogs.OptionScreen = function(properties) {
	"use strict";
	this.name = "OptionScreen";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.buttonBox);
	
	this.setProperties(tgfSettings.dialogDefaults.optionScreen)
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.OptionScreen, tgfDialogs.ButtonBox);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.OptionScreen.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************

tgfDialogs.OptionScreen.prototype.switchWindow = function(){
	this.firstContainer.hide();
	this.secondContainer.show();
	this.secondContainer.activate();
};

tgfDialogs.OptionScreen.prototype.switchText = function(){
	this.secondContainer.hide();
};


tgfDialogs.OptionScreen.prototype.openLanguage = function(){
	var dialog;
	if(tgfSettings.flow.showLanguageDialog){
		if(tgfSettings.flow.languageScreenProperties){
			dialog = new tgfDialogs.LanguageScreen(tgfSettings.flow.languageScreenProperties);
			dialog.onClick = function(dialog, buttonId){
				tbGame.resumeTokens();
				dialog.changeLanguage(buttonId);
			};
			tbGame.pauseTokens();
			dialog.show();
		}else{
			console.log("No languageScreenProperties can be found");
		}
	}
};

tgfDialogs.OptionScreen.prototype.openTutorial = function(){
	var dialog;
	if(tgfSettings.flow.showTutorialScreen){
		if(tgfSettings.flow.tutorialMenuProperties){
			dialog = new tgfDialogs.Tutorial(tgfSettings.flow.tutorialMenuProperties);
			dialog.onClick = function(dialog){
				tbGame.resumeTokens();
			};
			tbGame.pauseTokens();
			dialog.show();
		}else{
			console.log("No tutorialMenuProperties can be found");
		}
	}
};

tgfDialogs.OptionScreen.prototype.openAbout = function(){
	var dialog;
	dialog = new tgfDialogs.AboutScreen({
		backgroundImage: this.aboutBackgroundImage,
		hasCloseButton: true
	});
	dialog.onHide = function(dialog){
		tbGame.resumeTokens();
	};
	tbGame.pauseTokens();
	dialog.show();
};

tgfDialogs.OptionScreen.prototype.arrangeOptionScreen = function(i){
	this.optionButtonCurX = this.optionButtonPositions[i].x;
	this.optionButtonCurY = this.optionButtonPositions[i].y;
};


tgfDialogs.OptionScreen.prototype.manageVolumeIcon = function(icon, curIcon, curValue, noCall){
	if(icon[0] === curIcon){
		this.setValue(0, noCall);
		icon = icon[1];
	}else{
		this.setValue(curValue, noCall);
		icon = icon[2];
	}
};

tgfDialogs.OptionScreen.prototype.changeLanguage = function(buttonId){
	this.languageId = buttonId;
	var languages = tgfDictionary.getAvailableLanguages();
	tgfDictionary.setLanguage(languages[buttonId]);
	tgfStatus.setLanguage(languages[buttonId]);
};

tgfDialogs.OptionScreen.prototype.initLanguages = function(){
	var tmpSelectedLanguage = tgfDictionary.getLanguage();
	
	this.availableLanguagesId = tgfDictionary.getAvailableLanguages();
	for(var i = 0; i < this.availableLanguagesId.length; i++){
		this.buttonLanguageIcon.push(tgfDictionary.getLanguageFlag(this.availableLanguagesId[i]));
		this.buttonLanguageText.push(tgfDictionary.getLanguageName(this.availableLanguagesId[i]));
		if(tmpSelectedLanguage === this.availableLanguagesId[i]){
			this.buttonLanguageToggle = i;
		}
	}
};


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.OptionScreen.prototype.doPrepare = function() {
	"use strict";
	var self = this, i;
	var counter = 0;
	tgfDialogs.OptionScreen.uber.doPrepare.call(this);
	
	this.firstContainer = new tgfComponents.Container({});
	this.secondContainer = new tgfComponents.Container({});

	if(this.fixedTitleImage){
		this.fixedTitleComponent = new tgfComponents.Picture({
			image: this.fixedTitleImage, x: this.fixedTitleX, y: this.fixedTitleY
		});

		this.firstContainer.addComponent(this.fixedTitleComponent);
	}
	
	for(var i = 0; i < this.optionSettings.length; i++){
//      console.log(this.optionSettings[i]);
//      console.log("Y: " + this.optionButtonPositions[i].y);
		
		if(!tgfHooks.getMoreGamesFunction() && this.optionSettings[i] === "moregames"){
			counter++;
			continue;
		}

		if(tgfHooks.getBrowser !== undefined) {
			if (tgfHooks.getBrowser() && (this.optionSettings[i] === "audio" || this.optionSettings[i] === "oldSound")) {
				counter++;
				continue;
			}
		}
		
		this.arrangeOptionScreen(i - counter);
		
		switch(this.optionSettings[i]){
		case "tutorial":
			//Create Tutorial Button
			this.tutorialComponent = new tgfComponents.Button({
				image: this.buttonTutorialImage, fontUp: this.generalFont,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonTutorialWidth, height: this.buttonTutorialHeight,
				text: this.buttonTutorialText, dictionaryKey: this.buttonTutorialDictionaryKey,
				onClick: function(component){
					if (self.onTutorial) { self.onTutorial(self); }
					else{self.openTutorial();}
				}
			});
			this.tutorialComponent.setProperties(this.tutorialProperties);
			this.firstContainer.addComponent(this.tutorialComponent);
			
			//this.container.addComponent(this.tutorialComponent);
			break;
		case "music":
			//Create Music Slider
			this.musicComponent = new tgfComponents.Slider({
				icon: this.sliderMusicIcon, imageBack: this.sliderMusicImageBack, imageSlider: this.sliderMusicImageSlider,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.sliderMusicWidth, height: this.sliderMusicHeight,
				onChange: function(component, value){
					if (self.onMusicChange) { self.onMusicChange(self); }
					else{
						tgfAudio.setMusicGain(value / 100);
					}
				},
				onIconClick: function(component){
					if (self.onMusic) { self.onMusic(self); }
					else{
					}
				}
			});
			this.musicComponent.setProperties(this.musicProperties);
			this.firstContainer.addComponent(this.musicComponent);
			
			//this.container.addComponent(this.musicComponent);
			break;
		case "audio":
			//Create FX Slider
			this.soundEffectComponent = new tgfComponents.Slider({
				icon: this.sliderSoundIcon, imageBack: this.sliderSoundImageBack, imageSlider: this.sliderSoundImageSlider,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.sliderSoundWidth, height: this.sliderSoundHeight,
				onChange: function(component, value){
					if (self.onSoundChange) { self.onSoundChange(self); }
					else{
						tgfAudio.setEffectsGain(value / 100);
					}
				},
				onIconClick: function(component){
					if (self.onSound) { self.onSound(self); }
					else{}
				}
			});
			this.soundEffectComponent.setProperties(this.soundProperties);
			this.firstContainer.addComponent(this.soundEffectComponent);
			
			//this.container.addComponent(this.soundEffectComponent);
			break;
		case "oldSound":
			
			var musicX = this.optionButtonCurX / 2;
			var fxX = this.optionButtonCurX * 2;
			
			if(musicX === 0){
				if(this.customOldX){
					musicX = -this.customOldX;
				} else {
					musicX = tgfScale(-100);
				}
			}
			if(fxX === 0){
				if(this.customOldX){
					fxX = this.customOldX;
				} else {
					fxX = tgfScale(100);
				}
			}
			var prefs = tgfStatus.getPreferencesData();
			
			var isEffectMuted = 1;
			if(!prefs.effectsMuted){
				isEffectMuted = 0;
			}
			
			var isMusicMuted = 1;
			if(!prefs.musicMuted){
				isMusicMuted = 0;
			} 
			
			this.musicComponent = new tgfComponents.Button({
				image: this.oldButtonMusicImage, x: musicX + this.oldButtonMusicOffset, y: this.optionButtonCurY,
				icon: this.oldButtonMusicIcon, iconPosition: "center", fontUp: this.generalFont,
				width: this.oldButtonMusicWidth, height: this.oldButtonMusicHeight,
				toggleIndex: isMusicMuted,
				toggleAutomatic: true,
				onClick: function(component){
					if(self.onMusic){ self.onMusic(self); }
					else{
						
					}
					
					switch(component.toggleIndex){
					case 0:
						tgfAudio.unmuteMusic();
						tgfStatus.setAudio(undefined, undefined, false, undefined);
						break;
					case 1:
						tgfAudio.muteMusic();
						tgfStatus.setAudio(undefined, undefined, true, undefined);
						break;
					}
				}
			});

			//if(tgfHooks.getBrowser !== undefined){
			//	if(!tgfHooks.getBrowser()){
			//		this.musicComponent.setProperties(this.musicProperties);
			//		this.firstContainer.addComponent(this.musicComponent);
			//	}
			//} else {
			//	this.musicComponent.setProperties(this.musicProperties);
			//	this.firstContainer.addComponent(this.musicComponent);
			//}
			this.musicComponent.setProperties(this.musicProperties);
			this.firstContainer.addComponent(this.musicComponent);
			
			//this.container.addComponent(this.musicComponent);
			
			this.soundEffectComponent = new tgfComponents.Button({
				image: this.oldButtonFxImage, x: fxX + this.oldButtonFxOffset, y: this.optionButtonCurY,
				icon: this.oldButtonFxIcon, iconPosition: "center", fontUp: this.generalFont,
				width: this.oldButtonFxWidth, height: this.oldButtonFxHeight, 
				toggleIndex: isEffectMuted,
				toggleAutomatic: true,
				onClick: function(component){
					if(self.onSound){ self.onSound(self); }
					else{
						
					}
					
					switch(component.toggleIndex){
					case 0:
						tgfAudio.unmuteEffects();
						tgfStatus.setAudio(false, undefined, undefined, undefined);
						break;
					case 1:
						tgfAudio.muteEffects();
						tgfStatus.setAudio(true, undefined, undefined, undefined);
						break;
					}
				}
			});

			//if(tgfHooks.getBrowser !== undefined){
			//	if(!tgfHooks.getBrowser()){
			//		this.soundEffectComponent.setProperties(this.soundProperties);
			//		this.firstContainer.addComponent(this.soundEffectComponent);
			//	}
			//} else {
			//	this.soundEffectComponent.setProperties(this.soundProperties);
			//	this.firstContainer.addComponent(this.soundEffectComponent);
			//}
			this.soundEffectComponent.setProperties(this.soundProperties);
			this.firstContainer.addComponent(this.soundEffectComponent);
			
			//this.container.addComponent(this.soundEffectComponent);
			break;
		case "oldLanguage":
			this.initLanguages();
			
			var tmpLanguage = new tgfComponents.Button({
				image: this.buttonLanguageImage, icon: this.buttonLanguageIcon, iconPosition: "left",
				marginLeft: tgfScale(40),
				text: this.buttonLanguageText, toggleIndex: this.buttonLanguageToggle,
				width: this.buttonLanguageWidth, height: this.buttonLanguageHeight,
				x: this.optionButtonCurX, y: this.optionButtonCurY, fontUp: this.generalFont,
				toggleAutomatic: true,
				onClick: function(component){
					self.changeLanguage(component.toggleIndex);
				}
				
			});

			this.firstContainer.addComponent(tmpLanguage);

			//this.container.addComponent(tmpLanguage);
			break;
		case "moregames":
			//Create More Games Button
			this.moreGamesComponent = new tgfComponents.Button({
				image: this.buttonMoreImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonMoreWidth, height: this.buttonMoreHeight,
				text: this.buttonMoreText, link: this.buttonMoreUrl, dictionaryKey: this.buttonMoreDictionaryKey, fontUp: this.generalFont,
				onClick: function(component){
					if(self.onMoreGames) {
						self.onMoreGames();
					} else if(tgfHooks.callRedirect){
						console.log("redirect hook Called");
						tgfHooks.callRedirect();
					} else if (tgfHooks.getMoreGamesUrl() !== undefined){
//						if (self.onMoreGames) { self.onMoreGames(self); }
						window.open(tgfHooks.getMoreGamesUrl());					
					}
				}
			});
			this.moreGamesComponent.setProperties(this.moreGamesProperties);
			this.firstContainer.addComponent(this.moreGamesComponent);
			
			//this.container.addComponent(this.moreGamesComponent);
			break;
		case "about":
			//Create About Button
			this.aboutComponent = new tgfComponents.Button({
				image: this.buttonAboutImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonAboutWidth, height: this.buttonAboutHeight,
				text: this.buttonAboutText, dictionaryKey: this.buttonAboutDictionaryKey, fontUp: this.generalFont,
				onClick: function(component){
					if (self.onAbout) { self.onAbout(self); }
					else{
						self.openAbout();
					}
				}
			});
			this.aboutComponent.setProperties(this.aboutProperties);
			this.firstContainer.addComponent(this.aboutComponent);
			
			//this.container.addComponent(this.aboutComponent);
			break;
		case "close":
			this.closeComponent = new tgfComponents.Button({
				image: this.buttonCloseImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonCloseWidth, height: this.buttonCloseHeight,
				text: this.buttonCloseText, dictionaryKey: this.buttonCloseDictionaryKey,fontUp: this.generalFont,
				buttonId: this.quitYesButtonId,
				onClick: function (component){
					if(self.hasAlternativeClose){
						self.disappear();
						if(self.onQuitYes){ self.onQuitYes(self, component.buttonId); }
					} else if(self.onClose){
						self.onClose(self);
					} else{
						
					}
				}
			});
			this.closeComponent.setProperties(this.closeProperties);
			this.firstContainer.addComponent(this.closeComponent);
			
			//this.container.addComponent(this.closeComponent);
			break;
		case "exit":
			this.exitComponent = new tgfComponents.Button({
				image: this.buttonExitImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonExitWidth, height: this.buttonExitHeight,
				text: this.buttonExitText, dictionaryKey: this.buttonExitDictionaryKey, fontUp: this.generalFont,
				onClick: function (component){
					if(self.onExit){ self.onExit(self);}
					else{
						if(self.buttonExitHasClose){
							tgfDialogs.OptionScreen.prototype.disappear.call(self);
						}
					}
				}
			});
			this.exitComponent.setProperties(this.exitProperties);
			this.firstContainer.addComponent(this.exitComponent);
			
			//this.container.addComponent(this.exitComponent);
			break;
		case "resume":
			this.resumeComponent = new tgfComponents.Button({
				image: this.buttonResumeImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonResumeWidth, height: this.buttonResumeHeight,
				text: this.buttonResumeText, dictionaryKey: this.buttonResumeDictionaryKey, fontUp: this.generalFont,
				onClick: function (component){
					if(self.onResume){ self.onResume(self);}
					else{
						self.disappear();
					}
				}
			});
			this.resumeComponent.setProperties(this.resumeProperties);
			this.firstContainer.addComponent(this.resumeComponent);
			
			//this.container.addComponent(this.resumeComponent);
			break;
		case "quit":
			this.quitComponent = new tgfComponents.Button({
				image: this.buttonQuitImage,
				x: this.optionButtonCurX, y: this.optionButtonCurY, width: this.buttonQuitWidth, height: this.buttonQuitHeight,
				text: this.buttonQuitText, dictionaryKey: this.buttonQuitDictionaryKey, fontUp: this.generalFont,
				onClick: function (component){
					if(self.onQuit){ self.onQuit(self);}
					else{
						self.switchWindow();
					}
				}
			});
			this.quitComponent.setProperties(this.quitProperties);
			this.firstContainer.addComponent(this.quitComponent);
			
			//this.container.addComponent(this.quitComponent);
			
			var quitTitle = new tgfComponents.Label({
				text: this.quitTitleText, dictionaryKey: this.quitTitleDictionaryKey, x: this.quitTitleX, y: this.quitTitleY,
				width: this.quitTitleWidth, height: this.quitTitleHeight, font: this.quitTitleFont,  splitLines: true, fitToBox: true
			})
			
			this.secondContainer.addComponent(quitTitle);
			
//          var quitSubtitle = new tgfComponents.Label({
//              text: this.quitSubtitleText, dictionaryKey: this.quitSubtitleDictionaryKey, x: this.quitSubtitleX, y: this.quitSubtitleY,
//              fontUp: this.quitSubtitleFont 
//          });
//          
//          this.secondContainer.addComponent(quitSubtitle);
			
			var quitYes = new tgfComponents.Button({
				image: this.quitYesButtonImage, x: this.quitYesButtonX, y: this.quitYesButtonY, width: this.quitYesButtonWidth,
				height: this.quitYesButtonHeight, dictionaryKey: this.quitYesButtonDictionaryKey, fontUp: this.generalFont,
				text: this.quitYesButtonText, buttonId: this.quitYesButtonId,
				onClick: function(component){
					self.disappear();
					if(self.onQuitYes){ self.onQuitYes(self, component.buttonId); }
				}
			});
			
			this.secondContainer.addComponent(quitYes);
			
			var quitNo = new tgfComponents.Button({
				image: this.quitNoButtonImage, x: this.quitNoButtonX, y: this.quitNoButtonY, width: this.quitNoButtonWidth,
				height: this.quitNoButtonHeight, dictionaryKey: this.quitNoButtonDictionaryKey, fontUp: this.generalFont,
				text: this.quitNoButtonText,
				onClick: function(component){
					self.secondContainer.hide();
					self.firstContainer.show();
					self.firstContainer.activate();
				}
			});
			
			this.secondContainer.addComponent(quitNo);
			
			
			
			this.container.addComponent(this.secondContainer);
			break;
		}
	}
	
	this.container.addComponent(this.firstContainer);
	
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

tgfDialogs.OptionScreen.prototype.doShow = function(){
	this.secondContainer.hide();
};

// Processing required when freeing the dialog from use
tgfDialogs.OptionScreen.prototype.doFree = function() {
	"use strict";
	tgfDialogs.OptionScreen.uber.doFree.call(this);
	this.tutorialComponent = undefined;
	this.musicComponent = undefined;
	this.soundEffectComponent = undefined;
	this.moreGamesComponent = undefined;
	this.aboutComponent = undefined;
	this.closeComponent = undefined;
	this.exitComponent = undefined;
	this.resumeComponent = undefined;
	this.quitComponent = undefined;
};




//******************************************************
//*****    Script Resource: DialogLevelPopUp
//******************************************************


tgfSettings.dialogDefaults.levelPopUp = {
		
	popUpBackgroundImage: typeof s_overlay_options !== "undefined" ? s_overlay_options : null, 
		
		//Fill Properties
		levelPressed: 0,
		mode: tgfSettings.game.currentMode,
		//starHighScore: 0,
		highScore: 0,
		fbFriends: [],
		levelGoal: null,                            // ?????
		
		isPressed: false,
		
		titleText: "",
		titleTextDictionary: "",
		titleTextDict: "",
		titleFont: f_tgf_title,
		
		playButtonImage: s_btn_standard,
		playButtonIcon: s_tgf_icon_play,
		playButtonX: tgfScale(0),
		playButtonY: tgfScale(200),
		playButtonWidth: tgfScale(300),
		playButtonHeight: tgfScale(92),
		playButtonIconPosition: "rigth",
		playButtonText: "",
		playButtonDictionaryKey: "startScreenPlay",
		playButtonFont: f_tgf_button,
		
		starExist: true,
		
		starsBackgroundImages: [s_star01_empty, s_star02_empty, s_star03_empty],
		starsBackgroundPositions: [{x: tgfScale(-177), y: tgfScale(-117)}, {x: tgfScale(0), y: tgfScale(-140)}, {x: tgfScale(177), y: tgfScale(-114)}],
		
		firstStarImage: s_star01_fill,
		firstStarX: tgfScale(-177),
		firstStarY: tgfScale(-117),
//      firstStarWidth: tgfScale(200),
//      firstStarHeight: tgfScale(200),
		
		secondStarImage: s_star02_fill,
		secondStarX: tgfScale(0),
		secondStarY: tgfScale(-140),
//      secondStarWidth: tgfScale(200),
//      secondStarHeight: tgfScale(200),
		
		thirdStarImage: s_star03_fill,
		thirdStarX: tgfScale(177),
		thirdStarY: tgfScale(-117),
//      thirdStarWidth: tgfScale(200),
//      thirdStarHeight: tgfScale(200),
		
		labelTitleText: "",
		labelTitleDictionaryKey: "Goal",
		labelTitleX: tgfScale(0),
		labelTitleY: tgfScale(20),
		labelTitleFont: f_tgf_title,
		
		labelText: "",
		labelDictionaryKey: "",
		labelX: tgfScale(0),
		labelY: tgfScale(60),
		labelWidth: tgfScale(500),
		labelHeight: tgfScale(400),
		labelFont: f_tgf_text,
		
		
		showHighScore: true,
		
		components: [],
		
		onPlay: null
};

// The constructor for the dialog
/** @constructor
 *  @base tgfDialogs.ButtonBox
 */
tgfDialogs.LevelPopUp = function(properties) {
	"use strict";
	this.name = "LevelPopUp";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.buttonBox);
	
	this.setProperties(tgfSettings.dialogDefaults.levelPopUp)
	this.setProperties(tgfSettings.levelSelectionProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.LevelPopUp, tgfDialogs.ButtonBox);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.LevelPopUp.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};

tgfDialogs.LevelPopUp.prototype.playDisappear = function(){
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************
//Initialize About Screen
tgfDialogs.LevelPopUp.prototype.initPopUp = function(){
	var self = this;
	var nullScore = 0;
	var _playSettings = playSettings();
	var curLevelStats = tgfStatus.getPlayData(this.mode, this.levelPressed);
//  if(this.showHighScore){
//      if(curLevelStats.maxScore){
//          this.labelText = curLevelStats.maxScore.toString();
//      } else {
//          this.labelText = nullScore.toString();
//      }
//  }
	
	
	
	if(this.starExist){
		var highStars = curLevelStats.maxStars;
		
		for(var i = 0; i < 3; i++){
			
			var tmpStarBackground = new tgfComponents.Picture({
				image: this.starsBackgroundImages[i], x: this.starsBackgroundPositions[i].x, y: this.starsBackgroundPositions[i].y
			});
			
			this.container.addComponent(tmpStarBackground);
		}
		
		if(highStars > 0){
			var tmpStar = new tgfComponents.Picture({
				image: this.firstStarImage, x: this.firstStarX, y: this.firstStarY 
			});
			
			this.container.addComponent(tmpStar);
		}
		if(highStars > 1){
			var tmpStar = new tgfComponents.Picture({
				image: this.secondStarImage, x: this.secondStarX, y: this.secondStarY 
			});
			
			this.container.addComponent(tmpStar);
		}
		if(highStars > 2){
			var tmpStar = new tgfComponents.Picture({
				image: this.thirdStarImage, x: this.thirdStarX, y: this.thirdStarY 
			});
			
			this.container.addComponent(tmpStar);
		}
		
	}
	
	this.playButtonComponent = new tgfComponents.Button({
		image: this.playButtonImage, x: this.playButtonX, y: this.playButtonY, width: this.playButtonWidth, height: this.playButtonHeight,
		icon: this.playButtonIcon, iconPosition: this.playButtonIconPosition,
		text: this.playButtonText, dictionaryKey: this.playButtonDictionaryKey, fontUp: this.playButtonFont,
		offsetYDown: 2, buttonId: this.levelPressed,
		onClick: function(component){
			tgfDialogs.LevelPopUp.prototype.playDisappear.call(self);
			self.isPressed = true;
		}
	});
	this.container.addComponent(this.playButtonComponent);
	
	var _image = undefined;
	
	switch(_playSettings.levels[this.levelPressed - 1].general.mode){
	 case "points":
		 var target = _playSettings.levels[this.levelPressed - 1].points.scoreNeeded;
		 this.labelText = tgfDictionary.getText("GoalText_01").replace("<TARGET>", target.toString());
		 this.labelTitleDictionaryKey = "LevelTheme_01";
		 _image = s_ui_highscore;
		 break;
	 case "type":
		 var target = _playSettings.levels[this.levelPressed - 1].type.amountNeeded;
		 var type = _playSettings.levels[this.levelPressed - 1].type.typeNeeded;
		 this.labelText = tgfDictionary.getText("GoalText_02").replace("<TARGET>", target.toString());
		 this.labelTitleDictionaryKey = "LevelTheme_02";
		 switch(type){
			 case "BIGCORNER":           
				 _image = s_shape_bigcorner;
				 break;
			 case "BIGSQUARE":
				 _image = s_shape_bigsquare; 
					break;
			 case "DASH":
				 _image = s_shape_dash;
				 break;
			 case "DOT":
				 _image = s_shape_dot;
				 break;
			 case "FRIKANDEL":
				 _image = s_shape_frikandel;
				 break;
			 case "KROKET":
				 _image = s_shape_kroket;
				 break;
			 case "LINE":
				 _image = s_shape_line;
				 break;
			 case "MINICORNER":
				 _image = s_shape_minicorner;
				 break;
			 case "SQUARE":
				 _image = s_shape_square;
				 break;
			}
		 break;
	 case "counter":
		 var target = _playSettings.levels[this.levelPressed - 1].counter.counterBlockLocations.length;
		 this.labelText = tgfDictionary.getText("GoalText_03").replace("<TARGET>", target.toString());
		 this.labelTitleDictionaryKey = "LevelTheme_03";
		 _image = s_shape_blockerblock;
		 break;
	 }
	
	if(_image){
		var imageComponent = new tgfComponents.Picture({
			image: _image, x: tgfScale(0), y: tgfScale(113)
		});
		
		this.container.addComponent(imageComponent);
	}
	 
	 this.labelTitleComponent = new tgfComponents.Label({
		 x: this.labelTitleX, y: this.labelTitleY, text: this.labelTitleText, dictionaryKey: this.labelTitleDictionaryKey, font: this.labelTitleFont
	 });
	 
	 this.container.addComponent(this.labelTitleComponent);
	 
	this.labelComponent = new tgfComponents.Label({
		x: this.labelX, y: this.labelY,/* width: this.labelWidth, height: this.labelHeight,*/ text: this.labelText, dictionaryKey: this.labelDictionaryKey, font: this.labelFont
	});
	
	this.container.addComponent(this.labelComponent);
	
};

// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.LevelPopUp.prototype.doPrepare = function() {
	"use strict";
	var self = this, i; 
	this.backgroundImage = this.popUpBackgroundImage;
	
	this.titleText = tgfDictionary.getText(this.titleTextDict).replace("<VALUE>", this.levelPressed.toString());
	this.marginTop = tgfScale(20);
	tgfDialogs.LevelPopUp.uber.doPrepare.call(this);
	
	this.initPopUp();
	
	
	this.container.onHide = function(){ if(self.onPlay && self.isPressed){ self.onPlay(self, self.levelPressed); } };
	
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.LevelPopUp.prototype.doFree = function() {
	"use strict";
	tgfDialogs.AboutScreen.uber.doFree.call(this);
	this.playButtonComponent = undefined;
	this.starImageComponent = undefined;
	this.labelComponent = undefined;
	this.labelTitleComponent = undefined;
};


//******************************************************
//*****    Script Resource: DialogAboutScreen
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.dialogDefaults.aboutScreen = {
		aboutBackgroundImage: typeof s_overlay_options !== "undefined" ? s_overlay_options : null, 
		aboutTitleDictionaryKey: "optionsAbout_header_publisher",
		aboutTitleText: "", 
		aboutTitleFont: f_tgf_title, 
		aboutTitleX: tgfScale(0), 
		aboutTitleY: tgfScale(-250),
		aboutImage: s_logo_tinglygames_large, 
		aboutImageX: tgfScale(0), 
		aboutImageY: tgfScale(-100), 
		aboutImageUrl: "http://www.coolgames.com/",
		aboutLabelText: "",
		aboutLabelDictionary: "optionsAbout_text",
		aboutLabelTextX: tgfScale(0), 
		aboutLabelTextY: tgfScale(100), 
		aboutLabelUrl: "http://www.coolgames.com/",
		aboutLabelFont: f_tgf_text,
		aboutButtonImage: s_btn_standard, 
		aboutButtonText: "", 
		aboutButtonDictionaryKey: "optionsAbout_backBtn", 
		aboutButtonFont: f_tgf_button, 
		aboutButtonX: tgfScale(0), 
		aboutButtonY: tgfScale(200), 
		aboutButtonWidth: tgfScale(400), 
		aboutButtonHeight: tgfScale(92),
		titleWidthOffset: tgfScale(0),
				
		onBack: null,
		
		components: [],
		
		titleProperties: null,
		pictureProperties: null,
		lableProperties: null,
		buttonProperties: null
};

// The constructor for the dialog
/** @constructor
 *  @base tgfDialogs.ButtonBox
 */
tgfDialogs.AboutScreen = function(properties) {
	"use strict";
	this.name = "AboutScreen";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.buttonBox);
	
	this.setProperties(tgfSettings.dialogDefaults.aboutScreen)
	this.setProperties(tgfSettings.optionsAboutDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.AboutScreen, tgfDialogs.ButtonBox);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.AboutScreen.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};


// ***************************************
// Internal methods
// ***************************************
//Initialize About Screen
tgfDialogs.AboutScreen.prototype.initAbout = function(){
	var self = this;
	
	this.titleComponent = new tgfComponents.Label({
		text: this.aboutTitleText, dictionaryKey: this.aboutTitleDictionaryKey, x: this.aboutTitleX, y: this.aboutTitleY, font: this.aboutTitleFont, width: this.aboutBackgroundImage.width - this.titleWidthOffset
	});
	this.container.addComponent(this.titleComponent);
	
	this.pictureComponent = new tgfComponents.Picture({image: this.aboutImage, 
		x: this.aboutImageX, y: this.aboutImageY, url: this.aboutImageUrl,
		onClick: function(){
			var link = this.url;
			if(link){
				window.open(link);
			}
		}});
	this.container.addComponent(this.pictureComponent);
	
	this.lableComponent = new tgfComponents.Label({
		text: this.aboutLabelText, dictionaryKey: this.aboutLabelDictionary,
		x: this.aboutLabelTextX, y: this.aboutLabelTextY, url: this.aboutLabelUrl,
		font: this.aboutLabelFont,
		onClick: function(){
			var link = this.url;
			if(link){
				window.open(link);
			}
		}});
	this.container.addComponent(this.lableComponent);
	
	this.buttonComponent = new tgfComponents.Button({
		image: this.aboutButtonImage,
		x: this.aboutButtonX, y: this.aboutButtonY, width: this.aboutButtonWidth, height: this.aboutButtonHeight,
		text: this.aboutButtonText, dictionaryKey: this.aboutButtonDictionaryKey, fontUp: this.aboutButtonFont,
		onClick: function(){
			if(self.onBack){self.onBack(self);}
			else{self.disappear();}  
		}});
	this.container.addComponent(this.buttonComponent);
};

// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.AboutScreen.prototype.doPrepare = function() {
	"use strict";
	var self = this, i; 
	this.backgroundImage = this.aboutBackgroundImage;
	tgfDialogs.AboutScreen.uber.doPrepare.call(this);
	
	this.initAbout();
	
	// Add the additional components
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.AboutScreen.prototype.doFree = function() {
	"use strict";
	tgfDialog.AboutScreen.uber.doFree.call(this);
	this.titleComponent = undefined;
	this.pictureComponent = undefined;
	this.lableComponent = undefined;
	this.buttonComponent = undefined;
};

//******************************************************
//*****    Script Resource: DialogMatchMaking
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.dialogDefaults.matchMaking = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	backgroundImage: s_tgf_frame,						// The background image
	marginLeft: tgfScale(40),							// Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),							// Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),							// Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),							// Bottom margin whether there is no text, images, etc.
	titlePercentage: 25,								// Percentage of the box for the title
	messagePercentage: 75,								// Percentage of the box for the message (if any)
	titleText: "",										// Text for the title
	titleDictionaryKey: "",								// Dictionary key for the title
	titleFont: f_tgf_title,								// Font to be used for the title
	messageText: "",									// Text for the message
	messageDictionaryKey: "",							// Dictionary key for the message
	messageFont: f_tgf_text,							// Font to be used for the message
	iconImage: null,									// Image for the icon
	iconPosition: "right",								// Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,								// Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),						// Width of the close button
	closeButtonHeight: tgfScale(96),					// Height of the close button
	darken: true,										// Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	//disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(0), endY: tgfScale(-500), ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 9999999999,										// How long it will stay visible before disappearing
	disappearOnClick: false,								// Whether to disappear when the screen is clicked
	components: [],										// The additional components to add
	onClose: null,										// Function to be called when clicking the close button
	
	defaultPlayerImage: typeof s_avatar140 !== "undefined" ? s_avatar140 : undefined,
	playerImageSize: tgfScale(130),
	nameFont: f_tgf_text,
	
	thisPlayerImagePath: undefined,
	thisPlayerImage: undefined,
	thisPlayerName: "Guest",
	thisPlayerX: tgfScale(-235),
	thisPlayerY: tgfScale(-97),
	
	otherPlayerImagePath: undefined,
	otherPlayerImage: undefined,
	otherPlayerName: "Guest",
	otherPlayerX: tgfScale(235),
	otherPlayerY: tgfScale(-97),
	
	cancelButtonImage: typeof s_button_default_green !== "undefined" ? s_button_default_green : undefined,
	cancelButtonText: "Cancel",
	cancelButtonX: tgfScale(0),
	cancelButtonY: tgfScale(190),
	cancelButtonWidth: tgfScale(200),
	cancelButtonHeight: tgfScale(104),
	cancelButtonFont: typeof NotSoStoutDeco !== "undefined" ? NotSoStoutDeco : undefined,
	canceled: false,
	
	onMatchMade: null,
	onCancel: null,
	
	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	backgroundProperties: null,							// Properties for the background container component
	titleProperties: null,								// Properties for the title component
	messageProperties: null,							// Properties for the message component
	iconProperties: null,								// Properties for the icon component
	closeButtonProperties: null							// Properties for the close button component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.MessageBox
 */
tgfDialogs.MatchMaking = function(properties) {
	"use strict";
	this.name = "MatchMaking";
	
	//FireBaseRef
	this.dataRef = null;
	this.PlayerState = {Watching: 0, Joining: 1, Playing: 2};
	this.currentPlayerState;
	this.playerRef;
	this.opponentPlayerRef;
	this.player = -1;
	this.fbUser;
	this.opponentProps;
	this.roomName = "";
	this.roomFull = false;
	this.dataRenewed = false;
	this.matchMade = false;
	this.matchmakingTimer = 3000;
	this.mTurn = false;

	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.matchMaking);
	this.setProperties(tgfSettings.startPlayDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }

	this.getDataRef();
};

// Inherit the message box dialog
tgfDialogs.inherit(tgfDialogs.MatchMaking, tgfDialogs.MessageBox);

tgfDialogs.MatchMaking.prototype.getDataRef = function(){
	"use strict";
	this.dataRef = tgfFirebase.getDataRef();
	if(this.dataRef){
		this.fbUser = tgfFirebase.getUser();
		this.createRoom(this.dataRef);
	} else {
		console.log("NO FIREBASE REFERENCE SET");
	}
};

tgfDialogs.MatchMaking.prototype.createRoom = function(dataRef){
	"use strict";
	this.currentPlayerState = this.PlayerState.Watching;
	this.roomConnection();
};

tgfDialogs.MatchMaking.prototype.roomConnection = function(){
	"use strict";
	var self = this;
	
	this.dataRef.once('value', function(snapshot){
		if(!snapshot.hasChild('game')){
			self.dataRef.child('game').set({dummy:0});
			self.findRoom();
		} else {
			self.findRoom();
		}
	});
};

tgfDialogs.MatchMaking.prototype.findRoom = function(){
	"use strict";
	var self = this;
	var room;
	var basePath = this.dataRef.child("game");
	basePath.once('value', function(snapshot){
		var total = snapshot.numChildren();
		snapshot.forEach(function(snap){
			var gameRoom = snap.val();
			if(gameRoom.game > 0 && gameRoom.game < 2){
				if(self.fbUser.info !== undefined){
					if(gameRoom.player0.uid === self.fbUser.info.uid){
						var tmpPath = basePath.push({game:0});
						var basePathKey = tmpPath.key();
						self.playerConnection(basePathKey);
						return true;
					} else {
						room = snap.key();
						self.playerConnection(room);
						return true;
					}
				} else {					
					room = snap.key();
					self.playerConnection(room);
					return true;
				}
			} else {
				total--;
			}
			
			if(total === 0){
				var tmpPath = basePath.push({game:0});
				var basePathKey = tmpPath.key();
				self.playerConnection(basePathKey);
				return true;
			}
		});
	});
};

tgfDialogs.MatchMaking.prototype.playerConnection = function(room){
	"use strict";
	var self = this;
	
	this.dataRef.child('game/' + room +'/player0/online').on('value', function(snap){
		if(snap.val() === null && self.currentPlayerState === self.PlayerState.Watching){
			self.tryToJoin(0, room);
		}
	});
	
	this.dataRef.child('game/' + room +'/player1/online').on('value', function(snap){
		
		if(snap.val() === null && self.currentPlayerState === self.PlayerState.Watching){
			self.tryToJoin(1, room);
		}
	});
	
	this.dataRef.child('game/' + room + '/game').on('value', function(snap){
		if(snap.val() === 2){
			self.roomFull = true;
			self.fullRoom();
		}
	});
};

tgfDialogs.MatchMaking.prototype.tryToJoin = function(playerNum, room){
	"use strict";
	var self = this;
	
	this.currentPlayerState = this.PlayerState.Joining;
	this.dataRef.child('game/' + room +'/player' + playerNum + '/online').transaction(function(value){
		if(value === null){
			return true;
		}else {
			//console.log("ANOTHER USER Connected");
			return;
		}
	}, function(error, committed){
		if(committed){
			self.currentPlayerState = self.PlayerState.Playing;
			//Start Game
			self.dataRef.child('game/' + room +'/player' + playerNum).transaction(function(snap){
				var uid = "guest123456789";
				if(self.fbUser.info !== undefined){
					uid = self.fbUser.info.uid;
				}
				
				var _name = "GUEST123";
				if(self.fbUser.info !== undefined){
					_name = self.fbUser.info.name;
				}
				
				var _url = "noUrl";
				if(self.fbUser.profilePicturePath !== undefined){
					_url = self.fbUser.profilePicturePath;
				}
				
				var _urlBig = "noUrl";
				if(self.fbUser.profilePicturePathBig !== undefined){
					_urlBig = self.fbUser.profilePicturePathBig;
				}
				
				var info = {
						online: true,
						uid: uid,
						name: _name,
						url: _url,
						urlBig: _urlBig
				};
				
				self.roomName = room;
				
				return info;
			});
			
			self.startMulti(playerNum, room);
		} else {
			self.currentPlayerState = self.PlayerState.Watching;
		}
	});
};

tgfDialogs.MatchMaking.prototype.setOpponentsVisuals = function(data){
	"use strict";
	this.setOpponent(data);
};

tgfDialogs.MatchMaking.prototype.matchMakerCountdown = function(){
	var self = this;
	var counter = 0;
	
//	if(this.matchMade){
//		this.matchmakingTimer -= 10;//timePassed;
//		if(this.matchmakingTimer < 0){
//			this.disappear();
//			this.matchMade = false;
//		}
//	}
	

};

tgfDialogs.MatchMaking.prototype.fullRoom = function(){
	"use strict";
	
	var self = this;
	var counter = 0;
	
	
	if(this.roomFull){
		this.opponentPlayerRef.on('value', function(snap){
			self.opponentProps = snap.val();
			if(self.opponentProps === null || counter >= 1){return;}
			console.log("runs once");
			if(self.opponentProps){
				if(self.opponentProps.urlBig && self.opponentProps.urlBig !== "noUrl"){
					self.oppImageBig = tgfFirebase.createImage(self.opponentProps.urlBig, self.playerImageSize);
					self.oppImage = tgfFirebase.createImage(self.opponentProps.url, FacebookFriendImageSize._80x80);
					//self.uiOpponentImageComponent.image = oppImage;
				}
				if(self.opponentProps.name){
					self.oppName;
					
					var cutIndex = self.opponentProps.name.indexOf(" ");
					if(cutIndex !== -1){self.oppName =  self.opponentProps.name.substr(0, cutIndex);}
					else{self.oppName =  self.opponentProps.name;}
					//self.uiOpponentNameComponent.text = oppName;
					//self.uiOpponentNameComponent.recreate();
				}
			}
			counter++;
		});
		
		this.cancelButtonComponent.hide();
		this.throbberComponent.hide();
		
//		if(this.onMatchMade){
//			
//			var properties = {
//				dataRef: this.dataRef,
//				player: this.player,
//				playerRef: this.playerRef,
//				opponentPlayerRef: this.opponentPlayerRef,
//				opponentProps: this.opponentProps,
//				roomName: this.roomName,
//				oppName: this.oppName,
//				oppImage: this.oppImage,
//				fbUser: this.fbUser,
//				matchDialog: this
//			};
//			
//			this.onMatchMade(properties);
//		}
		
		this.roomFull = false;
	}
};


tgfDialogs.MatchMaking.prototype.startMulti = function(playerNum, room){
	"use strict";
	var self = this;
	var counter = 0;
	this.player = playerNum;
	this.playerRef = this.dataRef.child('game/' + room +'/player' + playerNum);
	this.opponentPlayerRef = this.dataRef.child('game/' + room +'/player' + (1 - playerNum));
	
	self.dataRef.child('game/' + room + '/game').transaction(function(value){
		return value + 1;
	});
	
	this.opponentPlayerRef.on('value', function(snap){
		self.opponentProps = snap.val();
		if(self.opponentProps === null || counter >= 1){return;}
		console.log("runs once");
		if(self.opponentProps){
			if(self.opponentProps.urlBig && self.opponentProps.urlBig !== "noUrl"){
				self.oppImageBig = tgfFirebase.createImage(self.opponentProps.urlBig, self.playerImageSize);
				self.oppImage = tgfFirebase.createImage(self.opponentProps.url, FacebookFriendImageSize._80x80);
				//self.uiOpponentImageComponent.image = oppImage;
			}
			if(self.opponentProps.name){
				self.oppName;
				
				var cutIndex = self.opponentProps.name.indexOf(" ");
				if(cutIndex !== -1){self.oppName =  self.opponentProps.name.substr(0, cutIndex);}
				else{self.oppName =  self.opponentProps.name;}
//				self.uiOpponentNameComponent.text = oppName;
//				self.uiOpponentNameComponent.recreate();
			}
		}
		
		var opps = {
			name: self.oppName,
			image: self.oppImageBig
		};
		
		self.setOpponentsVisuals(opps);
		self.matchMade = true;
		
		if(self.onMatchMade){
			
			var properties = {
				dataRef: self.dataRef,
				player: self.player,
				playerRef: self.playerRef,
				opponentPlayerRef: self.opponentPlayerRef,
				opponentProps: self.opponentProps,
				roomName: self.roomName,
				oppName: self.oppName,
				oppImage: self.oppImage,
				fbUser: self.fbUser,
				matchDialog: self
			};
			
			self.onMatchMade(properties);
		}
		
		counter++;
	});	
};

tgfDialogs.MatchMaking.prototype.setOpponent = function(data){
	"use strict";
	
	if(data.image !== undefined){
		this.otherPlayerImage.image = data.image;
	}
	
	if(data.name !== undefined){
		this.otherPlayerLabel.text = data.name;
		this.otherPlayerLabel.recreate();
	}
};

tgfDialogs.MatchMaking.prototype.setMyProps = function(){
	"use strict";
	
	if(this.fbUser.profilePicturePath){
		this.thisPlayerImagePath = this.fbUser.profilePicturePathBig;
	}
	if(this.fbUser.info){
		var myName;
		var cutIndex = this.fbUser.info.name.indexOf(" ");
		if(cutIndex !== -1){myName = this.fbUser.info.name.substr(0, cutIndex);}
		else{myName =  this.fbUser.info.name;}
		
		this.thisPlayerName = myName;
	}
};

tgfDialogs.MatchMaking.prototype.setUi = function(){
	"use strict";
	
	var self = this;
	
	if(this.thisPlayerImagePath){
		this.thisPlayerImage = tgfFirebase.createImage(this.thisPlayerImagePath, this.playerImageSize);
	}else {
		this.thisPlayerImage = this.defaultPlayerImage;
	}
	
	this.thisPlayerImage = new tgfComponents.Picture({
		image: this.thisPlayerImage, x: this.thisPlayerX, y: this.thisPlayerY, width: this.playerImageSize, height: this.playerImageSize
	});
	
	this.container.addComponent(this.thisPlayerImage);
	
	this.thisPlayerLabel = new tgfComponents.Label({
		text: this.thisPlayerName, x: this.thisPlayerX, y: this.thisPlayerY + 125, font: this.nameFont
	});
	
	this.container.addComponent(this.thisPlayerLabel);
	
	if(this.otherPlayerImagePath){
		this.otherPlayerImage =  tgfFirebase.createImage(this.otherPlayerImagePath, this.playerImageSize);
	}else {
		this.otherPlayerImage = this.defaultPlayerImage;
	}
	
	this.otherPlayerImage = new tgfComponents.Picture({
		image: this.otherPlayerImage, x: this.otherPlayerX, y: this.otherPlayerY, width: this.playerImageSize, height: this.playerImageSize
	});
	
	this.container.addComponent(this.otherPlayerImage);
	
	this.otherPlayerLabel = new tgfComponents.Label({
		text: this.otherPlayerName, x: this.otherPlayerX, y: this.otherPlayerY + 125, font: this.nameFont
	});
	
	this.container.addComponent(this.otherPlayerLabel);
	
	
	this.cancelButtonComponent = new tgfComponents.Button({
		image: this.cancelButtonImage, x: this.cancelButtonX, y: this.cancelButtonY, width: this.cancelButtonWidth, height: this.cancelButtonHeight,
		text: this.cancelButtonText, fontUp: this.cancelButtonFont,
		onClick: function(components){
				self.canceled = true;
				self.cancelRoom();
				self.hide();
		}
	});
	
	this.container.addComponent(this.cancelButtonComponent);
	
//	this.titleLabelComponent = new tgfComponents.Label({
//		text: "Get ready to play!", font: NotSoStoutDeco, x: tgfScale(0), y: tgfScale(-210)
//	});
	
//	this.container.addComponent(this.titleLabelComponent);
	
	this.throbberComponent = new tgfComponents.Picture({
		image: s_throbber, animationSpeed: 10, x: tgfScale(0), y: tgfScale(-90) 
	});
	
	this.container.addComponent(this.throbberComponent);
};

tgfDialogs.MatchMaking.prototype.cancelRoom = function(){
	"use strict";
	this.dataRef.child('game/' + this.roomName).off();
	this.dataRef.child('game/' + this.roomName).remove();
};

tgfDialogs.MatchMaking.prototype.disappear = function(){
	"use strict";
	tgfDialogs.MatchMaking.uber.disappear.call(this);
};

tgfDialogs.MatchMaking.prototype.doPrepare = function(){
	"use strict";
	tgfDialogs.MatchMaking.uber.doPrepare.call(this);
	var _playSettings = playSettings();
	
	
	this.setMyProps();
	this.setUi();
};

tgfDialogs.MatchMaking.prototype.doHide = function(){
	"use strict";
};

tgfDialogs.MatchMaking.prototype.doFree = function(){
	"use strict";
	this.thisPlayerComponent = undefined;
	this.otherPlayerComponent = undefined;
};
//******************************************************
//*****    Script Resource: DialogEndMultiplayer
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************

tgfSettings.dialogDefaults.matchEnd = {
	x: undefined,										// X-position. When undefined it is placed in the center
	y: undefined,										// Y-position. When undefined it is placed in the center
	backgroundImage: typeof s_overlay_matchmaking !== "undefined" ? s_overlay_matchmaking : undefined,						// The background image
	marginLeft: tgfScale(40),							// Left margin whether there is no text, images, etc.
	marginRight: tgfScale(40),							// Right margin whether there is no text, images, etc.
	marginTop: tgfScale(40),							// Top margin whether there is no text, images, etc.
	marginBottom: tgfScale(40),							// Bottom margin whether there is no text, images, etc.
	titlePercentage: 25,								// Percentage of the box for the title
	messagePercentage: 75,								// Percentage of the box for the message (if any)
	titleText: "",										// Text for the title
	titleDictionaryKey: "",								// Dictionary key for the title
	titleFont: f_tgf_title,								// Font to be used for the title
	messageText: "",									// Text for the message
	messageDictionaryKey: "",							// Dictionary key for the message
	messageFont: f_tgf_text,							// Font to be used for the message
	iconImage: null,									// Image for the icon
	iconPosition: "right",								// Position for the icon w.r.t. the message ("left" or "right")
	hasCloseButton: false,								// Whether there is a close button (in the background at the top-right)
	closeButtonWidth: tgfScale(96),						// Width of the close button
	closeButtonHeight: tgfScale(96),					// Height of the close button
	darken: true,										// Whether to darken the background
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	//disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.move, duration: 0.8, startY: tgfScale(0), endY: tgfScale(-500), ease: tbEase.easeInOvershoot, easeArgument: 1.2},
	lifeTime: 9999999999,										// How long it will stay visible before disappearing
	disappearOnClick: false,								// Whether to disappear when the screen is clicked
	components: [],										// The additional components to add
	onClose: null,										// Function to be called when clicking the close button
	
	defaultPlayerImage: typeof s_avatar140 !== "undefined" ? s_avatar140 : undefined,
	playerImageSize: tgfScale(130),
	nameFont: f_tgf_text,
	
	thisPlayerImagePath: undefined,
	thisPlayerImage: undefined,
	thisPlayerName: "Guest",
	thisPlayerX: tgfScale(-235),
	thisPlayerY: tgfScale(-97),
	
	otherPlayerImagePath: undefined,
	otherPlayerImage: undefined,
	otherPlayerName: "NAME",
	otherPlayerX: tgfScale(235),
	otherPlayerY: tgfScale(-97),
	
	homeButtonImage: typeof s_button_default_red !== "undefined" ? s_button_default_red : undefined,
	homeButtonText: "Home",
	homeButtonX: tgfScale(0),
	homeButtonY: tgfScale(190),
	homeButtonWidth: tgfScale(200),
	homeButtonHeight: tgfScale(104),
	homeButtonFont: typeof NotSoStoutDeco !== "undefined" ? NotSoStoutDeco : undefined,
	
	home: false,
	rematch: false,
	onHome: null,
	onRematch: null,
	
	fbuser: null,
	dataRef: null,
	
	// Additional properties for the components
	darkenerProperties: null,							// Properties for the darkener component
	backgroundProperties: null,							// Properties for the background container component
	titleProperties: null,								// Properties for the title component
	messageProperties: null,							// Properties for the message component
	iconProperties: null,								// Properties for the icon component
	closeButtonProperties: null							// Properties for the close button component
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.MessageBox
 */
tgfDialogs.MatchEnd = function(properties) {
	"use strict";
	this.name = "MatchEnd";

	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.matchEnd);
	this.setProperties(tgfSettings.startPlayDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the message box dialog
tgfDialogs.inherit(tgfDialogs.MatchEnd, tgfDialogs.MessageBox);

tgfDialogs.MatchEnd.prototype.getDataRef = function(){
	"use strict";
	this.dataRef = tgfFirebase.getDataRef();
};

tgfDialogs.MatchEnd.prototype.setUi = function(){
	"use strict";
	
	var self = this;
	
	if(this.thisPlayerImage === undefined){
		if(this.thisPlayerImagePath){
			this.thisPlayerImage = tgfFirebase.createImage(this.thisPlayerImagePath, this.playerImageSize);
		}else {
			this.thisPlayerImage = this.defaultPlayerImage;
		}		
	}
	
	this.thisPlayerImage = new tgfComponents.Picture({
		image: this.thisPlayerImage, x: this.thisPlayerX, y: this.thisPlayerY, width: this.playerImageSize, height: this.playerImageSize
	});
	
	this.container.addComponent(this.thisPlayerImage);
	
	this.thisPlayerLabel = new tgfComponents.Label({
		text: this.thisPlayerName, x: this.thisPlayerX, y: this.thisPlayerY + 125, font: this.nameFont
	});
	
	this.container.addComponent(this.thisPlayerLabel);
	
	if(this.otherPlayerImage){		
		if(this.otherPlayerImagePath){
			this.otherPlayerImage =  tgfFirebase.createImage(this.otherPlayerImagePath, this.playerImageSize);
		}else {
			this.otherPlayerImage = this.defaultPlayerImage;
		}
	}
	
	this.otherPlayerImage = new tgfComponents.Picture({
		image: this.otherPlayerImage, x: this.otherPlayerX, y: this.otherPlayerY, width: this.playerImageSize, height: this.playerImageSize
	});
	
	this.container.addComponent(this.otherPlayerImage);
	
	this.otherPlayerLabel = new tgfComponents.Label({
		text: this.otherPlayerName, x: this.otherPlayerX, y: this.otherPlayerY + 125, font: this.nameFont
	});
	
	this.container.addComponent(this.otherPlayerLabel);
	
	this.homeButtonComponent = new tgfComponents.Button({
		image: this.homeButtonImage, x: this.homeButtonX, y: this.homeButtonY, width: this.homeButtonWidth, height: this.homeButtonHeight,
		text: this.homeButtonText, fontUp: this.homeButtonFont,
		onClick: function(components){
			if(self.onHome){ self.onHome(components); }
			self.home = true;
			self.disappear();
		}
	});
	
	this.container.addComponent(this.homeButtonComponent);
	
//	this.titleLabelComponent = new tgfComponents.Label({
//		text: this.titleText, font: NotSoStoutDeco, x: tgfScale(0), y: tgfScale(-210)
//	});
//	
//	this.container.addComponent(this.titleLabelComponent);
};

tgfDialogs.MatchEnd.prototype.disappear = function(){
	"use strict";
	tgfDialogs.MatchMaking.uber.disappear.call(this);
};

tgfDialogs.MatchEnd.prototype.hide = function(){
	"use strict";
	tgfDialogs.MatchMaking.uber.hide.call(this);
};

tgfDialogs.MatchEnd.prototype.doPrepare = function(){
	"use strict";
	tgfDialogs.MatchMaking.uber.doPrepare.call(this);
	
	this.setUi();
};

tgfDialogs.MatchMaking.prototype.handleBeginStep = function(timePassed){
	"use strict";
	if (!this.isActive) { return; }
	
};

tgfDialogs.MatchMaking.prototype.doHide = function(){
	"use strict";
	
};

tgfDialogs.MatchMaking.prototype.doFree = function(){
	"use strict";
};
//******************************************************
//*****    Script Resource: AnchorComponent
//******************************************************

/* global
	tgfComponents,
	tbVector
 */

/**
 * @constructor
 * @base tgfComponents.Base
 */

tgfComponents.AnchorComponent = function(properties) {
	"use strict";

	this.initialize();

	this.ini

	this.width  = tgfScale(200);
	this.height = tgfScale(200);

	// Set user properties
	if (properties !== undefined) {
		this.setProperties(properties);
	}

	if( !this.anchorCoordinates ) {
		this.anchorCoordinates = new tbVector(0,0);
	}
};

tgfComponents.inherit(tgfComponents.AnchorComponent, tgfComponents.Base);

tgfComponents.AnchorComponent.prototype.setPosition = function () {
	"use strict";
	var anchorX = tgfGraphics.visibleLeft + tgfGraphics.visibleWidth  * this.anchorCoordinates.x;
	var anchorY = tgfGraphics.visibleTop  + tgfGraphics.visibleHeight * this.anchorCoordinates.y;

	if(this.parent) {
		this.x = this.parent.screenToComponentX(anchorX, anchorY);
		this.y = this.parent.screenToComponentY(anchorX, anchorY);
	}
	else {
		this.x = anchorX;
		this.y = anchorY;
	}
};

tgfComponents.AnchorComponent.prototype.doBeginStep = function (timepassed) {
	"use strict";
	this.setPosition();
};

tgfComponents.AnchorComponent.prototype.doPrepare = function (timepassed) {
	"use strict";
	this.setPosition();
};

//******************************************************
//*****    Script Resource: ComponentLobbyList
//******************************************************

// ***************************************
// tgfComponents.ComponentLobbyList
//
// This is an empty template for a new component
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 2592015
// ***************************************

// TODO: Everywhere replace Template and template by the appropriate name

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.componentLobbyList = {

       _hasTop: true,                  // use top image
       _hasLast: true,                 // use specific lastitem image

       imageTop: s_lobby_boxTop,
       imageItem: s_lobby_playerBox,
       imageItemLast: s_lobby_playerBoxLast,
       sliceMargin: [],
       isTopNineSliced: false,
       isItemNineSliced: false,
       nineSliceWidth: tgfScale(800),

       fontTopSize: 28,
       fontTopFillColor: '#000000',
       fontTopAlign: 'center',
       fontTopOffset: {
               x: 0,
               y: 4
       },

       font: f_default,
       headingText: 'DEFAULT',

       components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.ComponentLobbyList = function(properties) {
       "use strict";
       this.name = "ComponentLobbyList";           // The name of the component
       // Initialize properties
       this.initialize(tgfSettings.componentDefaults.componentLobbyList);

       if (tgfSettings.lobbyScreenDialogProperties) {

               this.setProperties(tgfSettings.lobbyScreenDialogProperties);
       }
       // Set user properties
       if (properties !== undefined) { this.setProperties(properties); }

       // setup data here
       // this._hasTop = true;
       // this._hasLast = true;

       this.listItems = [];
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ComponentLobbyList, tgfComponents.Base);



// ***************************************
// Size information (e.g. for design support)
// TODO: Override these when not default
// ***************************************


// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.ComponentLobbyList.prototype.getWidth = function() {
       "use strict";
       return this.width === undefined ? 0 : this.width;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.ComponentLobbyList.prototype.getHeight = function() {
       "use strict";


       if (this._hasTop) this.height = this.imageTop.height;

       var len = this.items.length;

       for (var i = 0; i < len; i++) {

               if (i == (len - 1) && this._hasLast) {
                       this.height += this.imageItem.height;
               }
               else {
                       this.height += this.imageItem.height;
               }
       }

       if (this._hasLast) this.height += this.imageItemLast.height;

       return this.height === undefined ? 0 : this.height;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.ComponentLobbyList.prototype.getLeft = function() {
       "use strict";
       return -this.getWidth() / 2;
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.ComponentLobbyList.prototype.getTop = function() {
       "use strict";
       return -this.getHeight() / 2;
};


// ***************************************
// Specific methods for this component
// ***************************************



// ***************************************
// Internal methods
// ***************************************



// ***************************************
// Preparing, showing and activating
//       These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.ComponentLobbyList.prototype.doPrepare = function() {
       "use strict";

       var i;

       var posY = this.y || 0;
       var items = this.items || [];

       var itemHeight = this.imageItem.height;

       // passed listitem defined?
       if (!this.componentItemClass) {
               throw new Error('ComponentLobbyList.componentItemClass not defined');
               return;
       }


       if (this._hasTop) {

           if(this.isTopNineSliced){
               this._listTop = new tgfComponents.Picture({
                   createFromSlices: true,
                   sliceMarginsArray: this.sliceMargin,
                   width: this.nineSliceWidth,
                   x: ((tgfGraphics.areaWidth - this.nineSliceWidth) / 2) + this.x, 
                   y: 0,
                   image: this.imageTop
               });
           } else {
                this._listTop = new tgfComponents.Picture({
                    x: ((tgfGraphics.areaWidth - this.imageTop.width) / 2) + this.x, y: 0,
                    image: this.imageTop
                });
           }

           this.components.push(this._listTop);


           // todo > clean up!
          this.fontTop = this.font.clone();
          this.fontTop.fontSize = this.fontTopSize;//28;
          this.fontTop.fillColor = this.fontTopFillColor;
          this.fontTop.align = this.fontTopAlign;

          var textProps = {
                  text: this.headingText,
                   font: this.fontTop,
                   x: (tgfGraphics.areaWidth / 2 + this.fontTopOffset.x) + this.x,
                   y: this.fontTopOffset.y,
                   height: this.imageTop.height,
                   //align: 'center',
                   fitToBox: false,
                   baseline: 'middle'
           };

           this._textTop = new tgfComponents.Label(textProps);
           this.components.push(this._textTop);

           this.listItems.push(this._listTop);
       }


       var len = this.items.length;
       var item;

       var posY = 0;
       if (this._hasTop) {

               posY = this._listTop.y + this._listTop.getHeight();
               // console.log(this._listTop.getHeight());
       }

       // create 'empty item'
       if (this.items.length == 0) {

       }
       // create list normally
       else
       {
               for (var i = 0; i < len; i++) {


                  // add normal entry
                  item = new this.componentItemClass({type: this.type, x: (tgfGraphics.areaWidth/2) + this.x, y:posY, image: this.imageItem, data: this.items[i], isItemNineSliced: this.isItemNineSliced, nineSliceWidth: this.nineSliceWidth});
                  this.components.push(item);

                  this.listItems.push(item);
                  posY += this.imageItem.height;
               }
       }



       if (this._hasLast) {

               this._listBottom = new tgfComponents.Picture({x: ((tgfGraphics.areaWidth - this.imageTop.width) / 2) + this.x, y: posY, image: this.imageItemLast});
               this.components.push(this._listBottom);

               this.listItems.push(this._listBottom);
       }




       // Add the child components
       if (this.components) {
               for (i = 0; i < this.components.length; i += 1) {
                       this.addComponent(this.components[i]);
               }
       }
};

tgfComponents.ComponentLobbyList.prototype.setItems = function(items) {

       this.items = items;

       var len = this.items.length;

       var posY = this.y;
       if (this._hasTop) {
               posY = this._listTop.y + this._listTop.getHeight() / 2;
       }



       var item;

       for (var i = 0; i < len; i++) {

               // add normal entry
               item = new this.componentItemClass({type: this.type, x: tgfGraphics.areaWidth/2, y:posY + this.imageItem.height/2, image: this.imageItem, data: this.items[i]});
               this.components.push(item);

               this.listItems.push(item);

               posY += this.imageItem.height;
       }
};


// Processing required when freeing the component from use
// tgfComponents.ComponentLobbyList.prototype.doFree = function() {
//     "use strict";
// };

// // Processing required when showing the component
// tgfComponents.ComponentLobbyList.prototype.doShow = function() {
//     "use strict";
// };

// // Processing required when hiding the component
// tgfComponents.ComponentLobbyList.prototype.doHide = function() {
//     "use strict";
// };

// // Processing required when activating the component
// tgfComponents.ComponentLobbyList.prototype.doActivate = function() {
//     "use strict";
// };

// // Processing required when deactivating the component
// tgfComponents.ComponentLobbyList.prototype.doDeactivate = function() {
//     "use strict";
// };


// // ***************************************
// // Methods called when events must be processed
// //       These can be removed when no processing is required
// //       When they return true, this event is no further processed
// //          by other components in the dialog
// //       Never call these methods yourself in other components,
// //          Use the inherited handle methods instead
// // ***************************************

// // Called at the beginning of each step
// tgfComponents.ComponentLobbyList.prototype.doBeginStep = function(timePassed) {
//     "use strict";
// };

// // Called when a touch is started or if a mouse button is pressed
// tgfComponents.ComponentLobbyList.prototype.doTouchDown = function(finger, x, y) {
//     "use strict";
// };

// // Called when a touch is ended or if a mouse button is released
// tgfComponents.ComponentLobbyList.prototype.doTouchUp = function(finger, x, y) {
//     "use strict";
// };

// // Called when the position of the mouse wheel is changed
// tgfComponents.ComponentLobbyList.prototype.doMouseWheel = function(delta, x, y) {
//     "use strict";
// };

// // Called immediately when a touch is started or if a mouse button is pressed
// tgfComponents.ComponentLobbyList.prototype.doImmediateTouchDown = function(finger, x, y) {
//     "use strict";
// };

// // Called immediately when a touch is ended or if a mouse button is released
// tgfComponents.ComponentLobbyList.prototype.doImmediateTouchUp = function(finger, x, y) {
//     "use strict";
// };

// // Called if the key with the given keyCode is pressed
// tgfComponents.ComponentLobbyList.prototype.doKeyDown = function(keyCode) {
//     "use strict";
// };

// // Called if the key with the given keyCode is released
// tgfComponents.ComponentLobbyList.prototype.doKeyUp = function(keyCode) {
//     "use strict";
// };

// // Called if a global alarm is reached
// tgfComponents.ComponentLobbyList.prototype.doAlarm = function(alarm) {
//     "use strict";
// };

// // Called if a special or userdefined event happens
// tgfComponents.ComponentLobbyList.prototype.doSpecial = function(id, args) {
//     "use strict";
// };

// // Called at the end of each step
// tgfComponents.ComponentLobbyList.prototype.doEndStep = function(timePassed) {
//     "use strict";
// };

// // Called just before drawing (also when not active)
// tgfComponents.ComponentLobbyList.prototype.doUpdateVisuals = function(timePassed) {
//     "use strict";
// };

// // Called when the component must be drawn (relative to position 0, 0)
// tgfComponents.ComponentLobbyList.prototype.doDraw = function() {
//     "use strict";
// };

// // Called after drawing the subcomponents
// tgfComponents.ComponentLobbyList.prototype.doEndDraw = function() {
//     "use strict";
// };

//******************************************************
//*****    Script Resource: ComponentLobbyListItem
//******************************************************

// ***************************************
// tgfComponents.ComponentLobbyListItem
//
// This is an empty template for a new component
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 2592015
// ***************************************

// TODO: Everywhere replace Template and template by the appropriate name

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.componentLobbyListItem = {

   isLast: false,
    nineSliceWidth: tgfScale(0),
    sliceMargin: [],
   components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */
tgfComponents.ComponentLobbyListItem = function(properties) {
   "use strict";

   // console.log('ComponentLobbyListItem'); 

   this.name = "ComponentLobbyListItem";           // The name of the component
   // Initialize properties
   this.initialize(tgfSettings.componentDefaults.componentLobbyListItem);
   // Set user properties
   if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ComponentLobbyListItem, tgfComponents.Base);



// ***************************************
// Size information (e.g. for design support)
// TODO: Override these when not default
// ***************************************

/*
// Returns the width of the component. Must be overriden if it is not the width property
tgfComponents.ComponentLobbyListItem.prototype.getWidth = function() {
   "use strict";
   return this.width === undefined ? 0 : this.width;
};

// Returns the height of the component. Must be overriden if it is not the height property
tgfComponents.ComponentLobbyListItem.prototype.getHeight = function() {
   "use strict";
   return this.height === undefined ? 0 : this.height;
};

// Returns the left position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.ComponentLobbyListItem.prototype.getLeft = function() {
   "use strict";
   return -this.getWidth() / 2;
};

// Returns the top position of the component (in its own coordinate system). Must be overriden if it is not centered
tgfComponents.ComponentLobbyListItem.prototype.getTop = function() {
   "use strict";
   return -this.getHeight() / 2;
};
*/

// ***************************************
// Specific methods for this component
// ***************************************



// ***************************************
// Internal methods
// ***************************************



// ***************************************
// Preparing, showing and activating
//       These can be removed if no processing is required
// ***************************************

// Processing required when preparing the component for use
tgfComponents.ComponentLobbyListItem.prototype.doPrepare = function() {
   "use strict";
   var i;

   if (this.image) {
      if(this.isItemNineSliced){
          this.background = new tgfComponents.Picture({
              createFromSlices: true,
              sliceMarginsArray: this.sliceMargin,
              width: this.nineSliceWidth,
              x: -Math.round(this.nineSliceWidth/2), 
              y: 0, 
              image: this.image
          });
      } else {
          this.background = new tgfComponents.Picture({
              x: -Math.round(this.image.width/2), y: 0, image: this.image
          });
      }
       this.components.push(this.background);
   }

   this.container = new tgfComponents.Container({x: -Math.round(this.image.width/2), y: 0, width: Math.round(this.image.width), height: Math.round(this.image.height) });
   this.components.push(this.container);

   if (this.data != undefined) {
       this._parseData();
   }

   // Add the child components
   if (this.components) {
       for (i = 0; i < this.components.length; i += 1) {
           this.addComponent(this.components[i]);
       }
   }
};


tgfComponents.ComponentLobbyListItem.prototype._parseData = function() {

};

tgfComponents.ComponentLobbyListItem.prototype.doPrepareAfterComponentsAdded = function() {

   // skin component here 
};

// Processing required when freeing the component from use
tgfComponents.ComponentLobbyListItem.prototype.doFree = function() {
   "use strict";
};

// Processing required when showing the component
tgfComponents.ComponentLobbyListItem.prototype.doShow = function() {
   "use strict";
};

// Processing required when hiding the component
tgfComponents.ComponentLobbyListItem.prototype.doHide = function() {
   "use strict";
};

// Processing required when activating the component
tgfComponents.ComponentLobbyListItem.prototype.doActivate = function() {
   "use strict";
};

// Processing required when deactivating the component
tgfComponents.ComponentLobbyListItem.prototype.doDeactivate = function() {
   "use strict";
};


// ***************************************
// Methods called when events must be processed
//       These can be removed when no processing is required
//       When they return true, this event is no further processed
//          by other components in the dialog
//       Never call these methods yourself in other components,
//          Use the inherited handle methods instead
// ***************************************

// Called at the beginning of each step
tgfComponents.ComponentLobbyListItem.prototype.doBeginStep = function(timePassed) {
   "use strict";
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.ComponentLobbyListItem.prototype.doTouchDown = function(finger, x, y) {
   "use strict";
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.ComponentLobbyListItem.prototype.doTouchUp = function(finger, x, y) { 
   "use strict";
};

// Called when the position of the mouse wheel is changed
tgfComponents.ComponentLobbyListItem.prototype.doMouseWheel = function(delta, x, y) {
   "use strict";
};

// Called immediately when a touch is started or if a mouse button is pressed
tgfComponents.ComponentLobbyListItem.prototype.doImmediateTouchDown = function(finger, x, y) {
   "use strict";
};

// Called immediately when a touch is ended or if a mouse button is released
tgfComponents.ComponentLobbyListItem.prototype.doImmediateTouchUp = function(finger, x, y) { 
   "use strict";
};

// Called if the key with the given keyCode is pressed
tgfComponents.ComponentLobbyListItem.prototype.doKeyDown = function(keyCode) { 
   "use strict";
};

// Called if the key with the given keyCode is released
tgfComponents.ComponentLobbyListItem.prototype.doKeyUp = function(keyCode) { 
   "use strict";
};

// Called if a global alarm is reached
tgfComponents.ComponentLobbyListItem.prototype.doAlarm = function(alarm) { 
   "use strict";
};

// Called if a special or userdefined event happens
tgfComponents.ComponentLobbyListItem.prototype.doSpecial = function(id, args) { 
   "use strict";
};

// Called at the end of each step
tgfComponents.ComponentLobbyListItem.prototype.doEndStep = function(timePassed) { 
   "use strict";
};

// Called just before drawing (also when not active)
tgfComponents.ComponentLobbyListItem.prototype.doUpdateVisuals = function(timePassed) { 
   "use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.ComponentLobbyListItem.prototype.doDraw = function() {
   "use strict";
};

// Called after drawing the subcomponents
tgfComponents.ComponentLobbyListItem.prototype.doEndDraw = function() {
   "use strict";
};

//******************************************************
//*****    Script Resource: DialogLobby
//******************************************************

// ***************************************
// tgfDialogs.DialogLobby
//
// A template for new dialogs
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// TODO: Everywhere replace Template and template by the appropriate name

// Directives for jslint
/*global tgfSettings, tgfDialogs, tgfComponents */

tgfSettings.dialogDefaults.dialogLobby = {

	backgroundImage: null,

	listSpacing: 28,

	listOffset: [
		{
			x: 0,
			y: 0
		},
		{
			x: 0,
			y: 0
		},
		{
			x: 0,
			y: 0
		}
	],

	paddingTop: 0,
	paddingBottom: 0,

	componentLobbyListClass: tgfComponents.ComponentLobbyList,
	componentLobbyListItemClass: tgfComponents.ComponentLobbyListItem,

	headings: {
		active: 'YOUR TURN',
		inactive: 'THEIR TURN',
		done: 'FINISHED MATCHES',
	},

	components: []                  // The additional components to add
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.DialogLobby = function(properties) {
	"use strict";

	this.name = "DialogLobby";         // The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.dialogLobby);

	// add base settings
	if (tgfSettings.lobbyScreenDialogProperties) {

		this.setProperties(tgfSettings.lobbyScreenDialogProperties);
	}

	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }


	// console.log(this.paddingTop, this.paddingBottom);
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.DialogLobby, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************


// ***************************************
// Internal methods
// ***************************************


// ***************************************
// Preparing and showing
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.DialogLobby.prototype.doPrepare = function() {
	"use strict";
	var i;

	
	this._getInitialData();



	if (this.backgroundImage) {
		
		this._backgroundImage = this.backgroundImage.clone();
		this.baseContainer.addChild(this._backgroundImage);
	}



	// list active games
	var posY = this.paddingTop + this.listOffset[0].y;
	var listHeight;


	// console.log('posY', posY);

	this._listActive = new this.componentLobbyListClass({
		type: 'active',
		x: this.listOffset[0].x,
		y: posY, 
		items: this._data.active, 
		// items: [], 
		componentItemClass: this.componentLobbyListItemClass, 
		headingText: this.headings.active
	});   

	// list inactive games
	listHeight = this._listActive.getHeight();
	posY = this._listActive.y + listHeight + this.listSpacing + this.listOffset[1].y;

	this._listInactive = new this.componentLobbyListClass({
		type: 'inactive',
        x: this.listOffset[1].x,
		y: posY, 
		items: this._data.inactive, 
		// items: [],
		componentItemClass: this.componentLobbyListItemClass,
		headingText: this.headings.inactive
	});

	// list completed/done games
	listHeight = this._listInactive.getHeight();
	posY = this._listInactive.y + listHeight + this.listSpacing + this.listOffset[2].y;
	
	this._listDone = new this.componentLobbyListClass({
		type: 'done',
        x: this.listOffset[2].x,
		y: posY, 
		items: this._data.done, 
		componentItemClass: this.componentLobbyListItemClass, 
		headingText: this.headings.done
	});

	// container
	this._listContainer = new tgfComponents.Container({x: 0, y: 0});
	this._listContainer.components.push(this._listActive);
	this._listContainer.components.push(this._listInactive);
	this._listContainer.components.push(this._listDone);


	var areaHeight = this._listActive.y + this._listActive.getHeight() + this._listInactive.getHeight() + this._listDone.getHeight() + (2 * this.listSpacing) + this.paddingBottom + this.listOffset[0].y + this.listOffset[1].y + this.listOffset[2].y;

	// scroll
	var scrollProps = {};
	scrollProps.x = 0,
	scrollProps.y = 0,
	scrollProps.scrollHorizontal = false;				// Whether to allow horizontal scrolling
	scrollProps.scrollVertical = true;				// Whether to allow vertical scrolling
	scrollProps.width = tgfGraphics.areaWidth;
	scrollProps.height = tgfGraphics.areaHeight;						// The height of the area in the box
	scrollProps.areaWidth = tgfGraphics.areaWidth;						// The width of the area in the box
	scrollProps.areaHeight = areaHeight;						// The height of the area in the box
	scrollProps.clip = true;							// Whether to clip the subcomponents
	scrollProps.showHorizontalScrollBar = false;		// Whether to show the horizontal scroll bar when required
	scrollProps.showVerticalScrollBar = false;		// Whether to show the vertical scroll bar when required
	scrollProps.cancelEvents = false;	
	
	this._scrollBox = new tgfComponents.ScrollBox(scrollProps);
	this._scrollBox.components.push(this._listContainer);
	this.components.push(this._scrollBox);

	// this._listContainer.x = 0;//tgfGraphics.areaWidth/2;
	// this._listContainer.y = 0;//tgfGraphics.areaHeight/2;
	// this.components.push(this._listContainer);
	

	this.doPrepareCustom();


	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}

	// this.doPrepareAfterComponentsAdded();

	// this._data = MultiplayerController.getLobby().getData(this._onGetLobbyData.bind(this));
};

tgfDialogs.DialogLobby.prototype._getInitialData = function() {

	// overwrite me

	if (!this._data) {

		// dummy data
		this._data = {};
		this._data.active = [];
		this._data.inactive = [];
		this._data.done = [];
	}
};


tgfDialogs.DialogLobby.prototype._onGetLobbyData = function(data) {

	// console.log(this, data);

	this._data = data;

	this._populateLobby();
};

tgfDialogs.DialogLobby.prototype._populateLobby = function() {

	console.log('populate');

	// this._listActive.setItems
};

// Processing required when freeing the dialog from use
tgfDialogs.DialogLobby.prototype.doPrepareCustom = function() {
	// override me
};// Processing required when freeing the dialog from use


tgfDialogs.DialogLobby.prototype.doPrepareAfterComponentsAdded = function() {
	// override me
};

tgfDialogs.DialogLobby.prototype.handleBeginStep = function(timePassed) {
	"use strict";

	if (!this.isActive) { return; }

	tgfDialogs.Base.prototype.handleBeginStep.call(this, timePassed);

	this._scroll = this._scrollBox.getScroll();

	if (this._afterBeginStep) this._afterBeginStep(timePassed);

};

tgfDialogs.DialogLobby.prototype.handleEndStep = function(timePassed) {
	"use strict";
	
	if (!this.isActive) { return; }

	tgfDialogs.Base.prototype.handleEndStep.call(this, timePassed);

	this._scroll = this._scrollBox.getScroll();

	if (this._afterEndStep) this._afterEndStep(timePassed);

};


tgfDialogs.DialogLobby.prototype.handleSpecial = function(id, args) {

	// console.log('DialogLobby.handleSpecial', id, args);

	switch (id) {
		case 'room-select' : {

			// flowController.currentAction = actionStartPlay;
			this.onRoomSelected(args);


			break;
		}
		case 'room-create' : {

			// flowController.currentAction = actionStartPlay;
			this.onRoomCreate();

			// this.free();

			break;
		}
	}

	tgfDialogs.Base.prototype.handleSpecial.call(this, id, args);
};


tgfDialogs.DialogLobby.prototype.onRoomSelected = function(args) {

	console.log('onRoomSelected', args);

	this.free();
};

tgfDialogs.DialogLobby.prototype.onRoomCreate = function() {

	console.log('onRoomCreated');

	this.free();
};


// tgfDialogs.DialogLobby.prototype.doFree = function() {
// 	"use strict";
// 	this.removeAllComponents();
// };

// // Processing required when showing the dialog
// tgfDialogs.DialogLobby.prototype.doShow = function() {
// 	"use strict";

// 	// if (this.backgroundImage) {
// 	// 	tbGraphics.setCanvas(tgfGraphics.backgroundCanvas);

// 	// 	// temp full screen image hack
// 	// 	var scaleX = tgfGraphics.areaWidth / this.backgroundImage.width / 2;
// 	// 	var scaleY = tgfGraphics.areaHeight / this.backgroundImage.height / 2;

// 	// 	// console.log(scaleX, scaleY);

// 	// 	this.backgroundImage.drawCombinedExt(0, 0, scaleX, scaleY, 0, 1);
// 	// 	// this.backgroundImage.drawCombinedSimple(0, 0);
// 	// 	tbGraphics.setCanvas(tgfGraphics.mainCanvas);
// 	// }
// };

// // Processing required when hiding the dialog
// tgfDialogs.DialogLobby.prototype.doHide = function() {
// 	"use strict";
// };
//******************************************************
//*****    Script Resource: Environment
//******************************************************

var Environment = (function() {

	var _Environment = function() {

		this._ENVS = {
			MOCK: 'mock',
			DEV: 'dev',
			QA: 'qa',
			DEMO: 'demo',
			PROD: 'prod',
		}

		console.log('ENV::Environment::Environment');

		this._env = null;
	}

	_Environment.prototype.constructor = _Environment;

	_Environment.prototype.setOnce = function(env) {

		if (this._env != null) {
			throw new Error('ENV::!!Environment can and should only be set once!!');

			return;
		}

		switch (env) {
			case this._ENVS.MOCK : 
			case this._ENVS.DEV : 
			case this._ENVS.QA : 
			case this._ENVS.DEMO : 
			case this._ENVS.PROD : {

				this._env = env;
				console.log('   ENV::Environment set as:', this._env);

				break;
			}
			default : {
				
				throw new Error('ENV::!!Environment not a valid value!!', env);
			}
		}

		switch (env) {

			case this._ENVS.DEMO : 
			case this._ENVS.PROD : {

				if (window.console) {
					
					console.log('   ENV::Logging disabled!!');
					if (window.console.log) window.console.log = function() {};
					if (window.console.warn) window.console.warn = function() {};
					if (window.console.error) window.console.error = function() {};
					if (window.console.info) window.console.info = function() {};
				}

				break;
			}
			default : {
				console.log('   ENV::not demo or prod');
			}
		}
	}

	_Environment.prototype.getEnvironments = function() {

		return this._ENVS;
	}

	_Environment.prototype.get = function() {

		return this._env;
	}

	return new _Environment();
}());


//******************************************************
//*****    Script Resource: EnvDev
//******************************************************

Environment.setOnce(Environment._ENVS.DEV);
console.log('ENV::' + Environment.get());
//******************************************************
//*****    Script Resource: ArrayFrom
//******************************************************

// Production steps of ECMA-262, Edition 6, 22.1.2.1
if (!Array.from) {
  Array.from = (function () {
    var toStr = Object.prototype.toString;
    var isCallable = function (fn) {
      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
    };
    var toInteger = function (value) {
      var number = Number(value);
      if (isNaN(number)) { return 0; }
      if (number === 0 || !isFinite(number)) { return number; }
      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    };
    var maxSafeInteger = Math.pow(2, 53) - 1;
    var toLength = function (value) {
      var len = toInteger(value);
      return Math.min(Math.max(len, 0), maxSafeInteger);
    };

    // The length property of the from method is 1.
    return function from(arrayLike/*, mapFn, thisArg */) {
      // 1. Let C be the this value.
      var C = this;

      // 2. Let items be ToObject(arrayLike).
      var items = Object(arrayLike);

      // 3. ReturnIfAbrupt(items).
      if (arrayLike == null) {
        throw new TypeError('Array.from requires an array-like object - not null or undefined');
      }

      // 4. If mapfn is undefined, then let mapping be false.
      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
      var T;
      if (typeof mapFn !== 'undefined') {
        // 5. else
        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
        if (!isCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        }

        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 2) {
          T = arguments[2];
        }
      }

      // 10. Let lenValue be Get(items, "length").
      // 11. Let len be ToLength(lenValue).
      var len = toLength(items.length);

      // 13. If IsConstructor(C) is true, then
      // 13. a. Let A be the result of calling the [[Construct]] internal method 
      // of C with an argument list containing the single item len.
      // 14. a. Else, Let A be ArrayCreate(len).
      var A = isCallable(C) ? Object(new C(len)) : new Array(len);

      // 16. Let k be 0.
      var k = 0;
      // 17. Repeat, while k < len (also steps a - h)
      var kValue;
      while (k < len) {
        kValue = items[k];
        if (mapFn) {
          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
        } else {
          A[k] = kValue;
        }
        k += 1;
      }
      // 18. Let putStatus be Put(A, "length", len, true).
      A.length = len;
      // 20. Return A.
      return A;
    };
  }());
}
//******************************************************
//*****    Script Resource: isInteger
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

Number.isInteger = Number.isInteger || function(value) {
	return typeof value === 'number' && 
	  isFinite(value) && 
	  Math.floor(value) === value;
  };
  
//******************************************************
//*****    Script Resource: coolgames_messagingplatform_core
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-messagingplatform-core (1.2.0-builder)
// ---------------------------------------------------------------------------------------
// Generated on Mon Sep 10 2018 15:01:43 GMT+0200 (Central European Summer Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The type of payload
 *
 * @export
 * @enum {string}
 */
var GamePayloadType;
(function (GamePayloadType) {
    /**
     * Used for game update messages
     */
    GamePayloadType["UPDATE"] = "custom_update";
    /**
     * Used for share messages
     */
    GamePayloadType["SHARE"] = "custom_share";
    /**
     * Used for gamebot messages
     */
    GamePayloadType["GAMEBOT"] = "gamebot";
})(GamePayloadType = exports.GamePayloadType || (exports.GamePayloadType = {}));

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The delivery strategy
 *
 * @export
 * @enum {number}
 */
var GameUpdateStrategy;
(function (GameUpdateStrategy) {
    /**
     * The update should be posted immediately
     */
    GameUpdateStrategy[GameUpdateStrategy["IMMEDIATE"] = 0] = "IMMEDIATE";
    /**
     * The update should be posted when the game session ends
     */
    GameUpdateStrategy[GameUpdateStrategy["LAST"] = 1] = "LAST";
    /**
     * The update is posted immediately, and clears any other pending updates
     */
    GameUpdateStrategy[GameUpdateStrategy["IMMEDIATE_CLEAR"] = 2] = "IMMEDIATE_CLEAR";
})(GameUpdateStrategy = exports.GameUpdateStrategy || (exports.GameUpdateStrategy = {}));

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A Messaging Platform feature supported (or not) by the concrete implementation
 *
 * @export
 * @enum {string}
 */
var MessagingPlatformFeature;
(function (MessagingPlatformFeature) {
    /**
     * Player can subscribe to receive bot messages
     */
    MessagingPlatformFeature["BOT_SUBSCRIPTION"] = "BOT_SUBSCRIPTION";
    /**
     * Getting a list of connected friends (friends which already play the game)
     */
    MessagingPlatformFeature["CONNECTED_FRIENDS_LIST"] = "CONNECTED_FRIENDS_LIST";
    /**
     * Getting the current context (room/chat) the player is in.
     */
    MessagingPlatformFeature["CONTEXT"] = "CONTEXT";
    /**
     * Creating a context with specific players
     */
    MessagingPlatformFeature["CREATE_CONTEXT_WITH_PLAYERS"] = "CREATE_CONTEXT_WITH_PLAYERS";
    /**
     * Creating a shortcut for the game
     */
    MessagingPlatformFeature["CREATE_SHORTCUT"] = "CREATE_SHORTCUT";
    /**
     * Sending a game update in the current room (context)
     */
    MessagingPlatformFeature["GAME_UPDATES"] = "GAME_UPDATES";
    /**
     * Getting a list of invitable friends (friends which never played the game before)
     */
    MessagingPlatformFeature["INVITABLE_FRIENDS_LIST"] = "INVITABLE_FRIENDS_LIST";
    /**
     * Send payloads inside messages (game updates and shared content)
     */
    MessagingPlatformFeature["MESSAGE_PAYLOADS"] = "MESSAGE_PAYLOADS";
    /**
     * Getting a callback when the game is interrupted by the platform
     */
    MessagingPlatformFeature["PAUSE_EVENT"] = "PAUSE_EVENT";
    /**
     * Getting the user information
     */
    MessagingPlatformFeature["PLAYER_PROFILE"] = "PLAYER_PROFILE";
    /**
     * Showing a context-selection dialog to the user
     */
    MessagingPlatformFeature["SELECT_CONTEXT"] = "SELECT_CONTEXT";
    /**
     * Share content with selected friends
     */
    MessagingPlatformFeature["SHARE_CONTENT"] = "SHARE_CONTENT";
    /**
     * Switching to a context using the context id
     */
    MessagingPlatformFeature["SWITCH_CONTEXT"] = "SWITCH_CONTEXT";
    /**
     * Switching to another game (cross-promotion)
     */
    MessagingPlatformFeature["SWITCH_GAME"] = "SWITCH_GAME";
})(MessagingPlatformFeature = exports.MessagingPlatformFeature || (exports.MessagingPlatformFeature = {}));

//******************************************************
//*****    Script Resource: coolgames_messagingplatform_fbinstant
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-messagingplatform-fbinstant (1.2.3-builder)
// ---------------------------------------------------------------------------------------
// Generated on Tue Nov 13 2018 13:05:47 GMT+0100 (Central European Standard Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-messagingplatform-core (1.1.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A filter that may be applied to a Context Choose operation
 *
 * @export
 * @enum {string}
 */
var ContextFilter;
(function (ContextFilter) {
    /**
     * Prefer to only surface contexts the game has not been played in before.
     */
    ContextFilter["NEW_CONTEXT_ONLY"] = "NEW_CONTEXT_ONLY";
    /**
     * Include the "Existing Challenges" section, which surfaces actively played-in contexts that the player is a part of.
     */
    ContextFilter["INCLUDE_EXISTING_CHALLENGES"] = "INCLUDE_EXISTING_CHALLENGES";
    /**
     * In sections containing individuals, prefer people who have not played the game.
     */
    ContextFilter["NEW_PLAYERS_ONLY"] = "NEW_PLAYERS_ONLY";
})(ContextFilter = exports.ContextFilter || (exports.ContextFilter = {}));


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An Instant Games error code
 *
 * @export
 * @enum {string}
 */
var ErrorCodeType;
(function (ErrorCodeType) {
    /**
     * Ads are being loaded too frequently.
     */
    ErrorCodeType["ADS_FREQUENT_LOAD"] = "ADS_FREQUENT_LOAD";
    /**
     * We were not able to serve ads to the current user.
     * This can happen if the user has opted out of interest-based ads on their device,
     * or if we do not have ad inventory to show for that user.
     */
    ErrorCodeType["ADS_NO_FILL"] = "ADS_NO_FILL";
    /**
     * Attempted to show an ad that has not been loaded successfully.
     */
    ErrorCodeType["ADS_NOT_LOADED"] = "ADS_NOT_LOADED";
    /**
     * There are too many concurrent ad instances.
     * Load and show existing ad instances before creating new ones.
     */
    ErrorCodeType["ADS_TOO_MANY_INSTANCES"] = "ADS_TOO_MANY_INSTANCES";
    /**
     * The analytics API experienced a problem while attempting to post an event.
     */
    ErrorCodeType["ANALYTICS_POST_EXCEPTION"] = "ANALYTICS_POST_EXCEPTION";
    /**
     * The client requires an update to access the feature that returned this result.
     * If this result is returned on web, it means the feature is not supported by the web client yet.
     * Deprecated in favor of CLIENT_UNSUPPORTED_OPERATION in v5.0 and above
     *
     * @deprecated
     */
    ErrorCodeType["CLIENT_REQUIRES_UPDATE"] = "CLIENT_REQUIRES_UPDATE";
    /**
     * The client does not support the current operation.
     * This may be due to lack of support on the client version or platform,
     * or because the operation is not allowed for the game or player.
     */
    ErrorCodeType["CLIENT_UNSUPPORTED_OPERATION"] = "CLIENT_UNSUPPORTED_OPERATION";
    /**
     * The requested operation is invalid or the current game state.
     * This may include requests that violate limitations, such as exceeding storage thresholds,
     * or are not available in a certain state, such as making a context-specific request in a solo context.
     */
    ErrorCodeType["INVALID_OPERATION"] = "INVALID_OPERATION";
    /**
     * The parameter(s) passed to the API are invalid.
     * Could indicate an incorrect type, invalid number of arguments, or a semantic issue
     * (for example, passing an unserializable object to a serializing function).
     */
    ErrorCodeType["INVALID_PARAM"] = "INVALID_PARAM";
    /**
     * No leaderboard with the requested name was found.
     * Either the leaderboard does not exist yet,
     * or the name did not match any registered leaderboard configuration for the game.
     */
    ErrorCodeType["LEADERBOARD_NOT_FOUND"] = "LEADERBOARD_NOT_FOUND ";
    /**
     * Attempted to write to a leaderboard that's associated with a context
     * other than the one the game is currently being played in.
     */
    ErrorCodeType["LEADERBOARD_WRONG_CONTEXT"] = "LEADERBOARD_WRONG_CONTEXT";
    /**
     * The client experienced an issue with a network request.
     * This is likely due to a transient issue, such as the player's internet connection dropping.
     */
    ErrorCodeType["NETWORK_FAILURE"] = "NETWORK_FAILURE";
    /**
     * Represents a rejection due an existing request that conflicts with this one.
     * For example, we will reject any calls that would surface a Facebook UI
     * when another request that depends on a Facebook UI is pending.
     */
    ErrorCodeType["PENDING_REQUEST"] = "PENDING_REQUEST";
    /**
     * Some APIs or operations are being called too often.
     * This is likely due to the game calling a particular API an excessive amount of times in a very short period.
     * Reducing the rate of requests should cause this error to go away.
     */
    ErrorCodeType["RATE_LIMITED"] = "RATE_LIMITED";
    /**
     * The game attempted to perform a context switch into the current context.
     */
    ErrorCodeType["SAME_CONTEXT"] = "SAME_CONTEXT";
    /**
     * An unknown or unspecified issue occurred.
     * This is the default error code returned when the client does not specify a code.
     */
    ErrorCodeType["UNKNOWN"] = "UNKNOWN";
    /**
     * The user made a choice that resulted in a rejection.
     * For example, if the game calls up the Context Switch dialog and the player closes it,
     * this error code will be included in the promise rejection.
     */
    ErrorCodeType["USER_INPUT"] = "USER_INPUT";
})(ErrorCodeType = exports.ErrorCodeType || (exports.ErrorCodeType = {}));


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the type of a game context.
 *
 * @export
 * @enum {string}
 */
var FBContextType;
(function (FBContextType) {
    /**
     * A facebook post
     */
    FBContextType["POST"] = "POST";
    /**
     * A messenger thread
     */
    FBContextType["THREAD"] = "THREAD";
    /**
     * A facebook group
     */
    FBContextType["GROUP"] = "GROUP";
    /**
     * Default context, where the player is the only participant
     */
    FBContextType["SOLO"] = "SOLO";
})(FBContextType = exports.FBContextType || (exports.FBContextType = {}));


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the current platform that the user is playing on.
 *
 * @export
 * @enum {string}
 */
var Platform;
(function (Platform) {
    Platform["IOS"] = "IOS";
    Platform["ANDROID"] = "ANDROID";
    Platform["WEB"] = "WEB";
    Platform["MOBILE_WEB"] = "MOBILE_WEB";
})(Platform = exports.Platform || (exports.Platform = {}));


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Indicates the intent of the share.
 *
 * @export
 * @enum {string}
 */
var SharePayloadIntent;
(function (SharePayloadIntent) {
    SharePayloadIntent["INVITE"] = "INVITE";
    SharePayloadIntent["REQUEST"] = "REQUEST";
    SharePayloadIntent["CHALLENGE"] = "CHALLENGE";
    SharePayloadIntent["SHARE"] = "SHARE";
})(SharePayloadIntent = exports.SharePayloadIntent || (exports.SharePayloadIntent = {}));


"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the type of the update action to perform.
 *
 * @export
 * @enum {number}
 */
var UpdateAction;
(function (UpdateAction) {
    /**
     * A custom update, with all content specified by the game.
     */
    UpdateAction["CUSTOM"] = "CUSTOM";
    /**
     * An update associated with an Instant Game leaderboard.
     */
    UpdateAction["LEADERBOARD"] = "LEADERBOARD";
})(UpdateAction = exports.UpdateAction || (exports.UpdateAction = {}));


var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Concrete implementation of the Messaging Context interface
 *
 * @export
 * @class FBMessagingContext
 * @implements {IMessagingContext}
 */
var FBMessagingContext = /** @class */ (function () {
    /**
     * Creates an instance of FBMessagingContext.
     *
     * @param {string} id The context id
     * @param {IContextPlayer[]} players The list of players
     * @param {string} type The context type
     *
     * @memberOf FBMessagingContext
     */
    function FBMessagingContext(id, players, type) {
        var _this = this;
        this._id = id;
        this._type = type;
        this._players = [];
        players.forEach(function (player) {
            _this._players.push({
                id: player.getID(),
                name: player.getName(),
                photo: player.getPhoto()
            });
        });
    }
    /**
     * Gets the context id
     *
     * @returns {string} The context id
     *
     * @memberOf FBMessagingContext
     */
    FBMessagingContext.prototype.getId = function () {
        return this._id;
    };
    /**
     * The list of players, which includes the user him/herself.
     * IMPORTANT: this list might not be complete, since FB returns only active players
     * (people who played the game in the last 90 days)
     *
     * For more info, please refer to the documentation:
     * https://developers.facebook.com/docs/games/instant-games/sdk/fbinstant6.0
     * (getPlayersAsync)
     *
     * @returns {IMessagingPlayer[]} A promise with the active players
     *
     * @memberOf FBMessagingContext
     */
    FBMessagingContext.prototype.getPlayers = function () {
        return this._players;
    };
    /**
     * Gets the context type, which can be "THREAD", "GROUP" or "POST".
     * The "SOLO" value is not a possible here, since the context won't have an id.
     * In this case, the current context (from the service class) will be null.
     *
     * For more info, please refer to the documentation:
     * https://developers.facebook.com/docs/games/instant-games/sdk/fbinstant6.0
     * (getType)
     *
     * @returns {string}
     *
     * @memberOf FBMessagingContext
     */
    FBMessagingContext.prototype.getType = function () {
        return this._type;
    };
    return FBMessagingContext;
}());
exports.FBMessagingContext = FBMessagingContext;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fb_instant_sdk_definitions_1 = require("@coolgames/fb-instant-sdk-definitions");
var FBMessagingPlatformInfo = /** @class */ (function () {
    /**
     * Creates an instance of FBMessagingPlatformInfo.
     *
     * @param {string} loc The locale
     * @param {string} platf The platform
     * @param {string} version The sdk version
     *
     * @memberOf FBMessagingPlatformInfo
     */
    function FBMessagingPlatformInfo(loc, platf, version) {
        this.locale = loc;
        this.messagingPlatform = platf;
        this.sdkVersion = version;
    }
    /**
     * Convenience method to check if the messaging app is running on mobile.
     *
     * @returns {boolean} True if the game is running on mobile, false otherwise
     *
     * @memberOf FBMessagingPlatformInfo
     */
    FBMessagingPlatformInfo.prototype.isMobile = function () {
        return this.messagingPlatform !== Platform.WEB;
    };
    return FBMessagingPlatformInfo;
}());
exports.FBMessagingPlatformInfo = FBMessagingPlatformInfo;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_messagingplatform_core_1 = require("@coolgames/coolgames-messagingplatform-core");
var fb_instant_sdk_definitions_1 = require("@coolgames/fb-instant-sdk-definitions");
var FBMessagingPlatformServiceSettings_1 = require("./FBMessagingPlatformServiceSettings");
var FBMessagingPlatformServiceInitState_1 = require("./FBMessagingPlatformServiceInitState");
var FBMessagingContext_1 = require("./FBMessagingContext");
var FBMessagingPlatformInfo_1 = require("./FBMessagingPlatformInfo");
/**
 * Concrete implementation of the Messaging Platform for the Facebook Instant Games.
 *
 * @export
 * @class FBMessagingPlatformService
 * @implements {IMessagingPlatformService}
 */
var FBMessagingPlatformService = /** @class */ (function () {
    /**
     * Creates an instance of FBMessagingPlatformService.
     *
     * @param {IFBInstant} fbInstant The FBInstant SDK
     * @param {IFBMessagingPlatformServiceSettings} [settings] The service settings
     *
     * @memberOf FBMessagingPlatformService
     */
    function FBMessagingPlatformService(fbInstant, settings) {
        var _a;
        /**
         * Supported features
         *
         * @private
         * @type { [feature: MessagingPlatformFeature]: boolean }
         * @memberOf FBMessagingPlatformService
         */
        this._supportedFeatures = (_a = {},
            _a[MessagingPlatformFeature.PLAYER_PROFILE] = true,
            _a[MessagingPlatformFeature.CONNECTED_FRIENDS_LIST] = true,
            _a[MessagingPlatformFeature.INVITABLE_FRIENDS_LIST] = false,
            _a[MessagingPlatformFeature.GAME_UPDATES] = true,
            _a[MessagingPlatformFeature.SHARE_CONTENT] = true,
            _a[MessagingPlatformFeature.MESSAGE_PAYLOADS] = true,
            _a[MessagingPlatformFeature.CONTEXT] = true,
            _a[MessagingPlatformFeature.SELECT_CONTEXT] = true,
            _a[MessagingPlatformFeature.SWITCH_CONTEXT] = true,
            _a[MessagingPlatformFeature.CREATE_CONTEXT_WITH_PLAYERS] = true,
            _a[MessagingPlatformFeature.BOT_SUBSCRIPTION] = true,
            _a[MessagingPlatformFeature.CREATE_SHORTCUT] = true,
            _a[MessagingPlatformFeature.SWITCH_GAME] = true,
            _a);
        /**
         * The pause listeners
         *
         * @private
         * @type {IMessagingPlatformPauseListener[]}
         * @memberOf FBMessagingPlatformService
         */
        this._pauseListeners = [];
        /**
         * The initialization listeners
         *
         * @private
         * @type {IFBMessagingPlatformInitListener[]}
         * @memberOf FBMessagingPlatformService
         */
        this._initListeners = [];
        this._initializationState = FBMessagingPlatformServiceInitState.NOT_INITIALIZED;
        this._fbInstant = fbInstant;
        this._settings = settings || new FBMessagingPlatformServiceSettings();
        this._fbInstant.onPause(this._onPauseCallback.bind(this));
    }
    /**
     * Convenience method for other services which depends on FB Instant
     *
     * @returns {IFBInstant} The reference to the FBInstant sdk
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.getFBInstant = function () {
        return this._fbInstant;
    };
    /**
     * Convenience method to know the state of this service
     *
     * @returns {FBMessagingPlatformServiceInitState}
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.getInitializationState = function () {
        return this._initializationState;
    };
    /**
     * Initializes the Service.
     *
     * Internally, this method is split in two distinct calls to the FB SDK: "initializeAsync" and "startGameAsync".
     *
     * The guidelines from Facebook specify that, after calling "initializeAsync", the game should start
     * "loading resources in parallel", and after "the game has finished initial loading and is ready to start"
     * it should call the "startGameAsync".
     *
     * This service handles the "game is ready" event through the "loader" parameter, calling "getLoadingProgress" from time to time.
     * Once the initial loading progress reaches 100%, the call to "startGameAsync" is triggered.
     *
     * References:
     * https://developers.facebook.com/docs/games/instant-games/best-practices#load-times-and-performance
     * https://developers.facebook.com/docs/games/instant-games/sdk/fbinstant6.0#fbinstant
     * https://boostermedia.jira.com/wiki/spaces/GAMESTUDIODEVELOPMENT/pages/451805199/Messaging+Platform+Module
     *
     * @returns {Promise<void>} A promise that the service will be initialized. It resolves only when the initial loading progress comes to 100%.
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.initialize = function (loader) {
        var _this = this;
        if (this._initializationState !== FBMessagingPlatformServiceInitState.NOT_INITIALIZED) {
            return new Promise(function (resolve, reject) {
                reject("Initialize was already called");
            });
        }
        this._initializationState = FBMessagingPlatformServiceInitState.INITIALIZING;
        var self = this;
        return new Promise(function (resolve, reject) {
            // first, initialize FB (asynchronously)
            self._fbInstant.initializeAsync().then(function () { return __awaiter(_this, void 0, void 0, function () {
                var lastProgress, currentProgress;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            self._initializationState = FBMessagingPlatformServiceInitState.WAITING_FOR_INITIAL_LOADING;
                            lastProgress = 0;
                            _a.label = 1;
                        case 1:
                            if (!(lastProgress < 100)) return [3 /*break*/, 3];
                            currentProgress = loader.getLoadingProgress();
                            if (currentProgress !== lastProgress) {
                                self._fbInstant.setLoadingProgress(currentProgress);
                                lastProgress = currentProgress;
                            }
                            return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._settings.initialLoadingCheckInterval); })];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 1];
                        case 3:
                            // performing the second initialization step (calling startGameAsync from the FB Instant SDK)
                            self._initializationState = FBMessagingPlatformServiceInitState.FINISHING_INITIALIZATION;
                            return [2 /*return*/, self._fbInstant.startGameAsync()];
                    }
                });
            }); })
                .then(function () {
                self._initializationState = FBMessagingPlatformServiceInitState.INITIALIZED;
                self._initListeners.forEach(function (listener) { return listener.initializationFinished(); });
                self._removeAllInitListeners();
                resolve();
            })
                .catch(function (reason) {
                self._initializationState = FBMessagingPlatformServiceInitState.NOT_INITIALIZED;
                self._initListeners.forEach(function (listener) { return listener.initializationFailed(reason); });
                reject(reason);
            });
            // we don't need to wait the initializeAsync promise to resolve to start the initial loading
            loader.startInitialLoading();
        });
    };
    /**
     * Gets the player profile information.
     *
     * If the service is not fully initialized, there is no guarantee this object will be complete.
     * This is because the FB SDK has the user id available after "initializeAsync" resolves,
     * and the rest of the information available after "startGameAsync".
     * For many reasons, game might need the user id in advance, so this method can be called
     * before the initialization is resolved (but keep in mind the returned value might be null).
     *
     * @returns {IMessagingPlayer} The player information
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.getPlayer = function () {
        if (this._initializationState === FBMessagingPlatformServiceInitState.NOT_INITIALIZED ||
            this._initializationState === FBMessagingPlatformServiceInitState.INITIALIZING) {
            return null;
        }
        return {
            id: this._fbInstant.player.getID(),
            name: this._fbInstant.player.getName(),
            photo: this._fbInstant.player.getPhoto()
        };
    };
    /**
     * Checks if a feature is supported
     *
     * @param {MessagingPlatformFeature} feature The desired feature
     * @returns {boolean} True if supported, false otherwise
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.isFeatureSupported = function (feature) {
        if (!this._supportedFeatures.hasOwnProperty(feature)) {
            console.error("Feature " + feature + " is not configured on FBMessagingPlatformService");
            return false;
        }
        return this._supportedFeatures[feature];
    };
    /**
     * Gets a list of connected friends (friends that have played this game before)
     *
     * @returns {Promise<IMessagingPlayer[]>} A promise to return the list of connected friends
     *
     * @memberOf IMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.getConnectedFriends = function () {
        var self = this;
        return new Promise(function (resolve, reject) {
            if (self._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
                reject("Not initialized");
            }
            self._fbInstant.player.getConnectedPlayersAsync().then(function (players) {
                var result = [];
                for (var i = 0; i < players.length; i++) {
                    result.push({
                        id: players[i].getID(),
                        name: players[i].getName(),
                        photo: players[i].getPhoto()
                    });
                }
                resolve(result);
            }, function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * This is not supported on Facebook. (It will resolve with an empty list)
     *
     * Gets a list of invitable friends (friends that did not play the game before)
     *
     * @returns {Promise<IMessagingPlayer[]>} A promise to return the list of invitable friends
     *
     * @memberOf IMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.getInvitableFriends = function () {
        console.warn("Method 'getInvitableFriends' is not implemented on Facebook");
        var self = this;
        return new Promise(function (resolve, reject) {
            if (self._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
                reject("Not initialized");
            }
            resolve([]);
        });
    };
    /**
     * Shows a list of people to select and shares the specified context.
     * The "intent" is always set to "SHARE" (not configurable).
     *
     * This data must be less than or equal to 1000 characters when stringified.
     * The user may choose to cancel the share action and close the dialog, and
     * the returned promise will resolve when the dialog is closed regardless if
     * the user actually shared the content or not.
     *
     * @param {IShareContent} content The content to share
     * @returns {Promise<void>} A promise that the share will be sent
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.shareContent = function (content) {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var payload = {};
        payload.data = content.payload;
        payload.type = GamePayloadType.SHARE;
        var sharePayload = {
            intent: SharePayloadIntent.SHARE,
            image: content.image,
            text: content.text,
            data: payload
        };
        return this._fbInstant.shareAsync(sharePayload);
    };
    /**
     * Sends a game update for the current context
     *
     * @param {IGameUpdateContent} update The update to send
     * @returns {Promise<void>} A promise that the update will be sent
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.sendGameUpdate = function (update) {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var payload = {};
        payload.data = update.payload;
        payload.type = GamePayloadType.UPDATE; // forcing the correct type here
        var updatePayload = {
            action: "CUSTOM",
            cta: update.buttonText || "Play",
            template: update.template,
            image: update.image,
            text: update.text,
            data: payload,
            strategy: (update.strategy) ? GameUpdateStrategy[update.strategy] : "IMMEDIATE"
        };
        return this._fbInstant.updateAsync(updatePayload);
    };
    /**
     * Gets the data associated with the entry point.
     * This data can be set from a shared content or a game update.
     *
     * @returns {Promise<IEntryPointPayload>} The entry point data, if any
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.getEntryPointData = function () {
        var _this = this;
        if (this._initializationState === FBMessagingPlatformServiceInitState.NOT_INITIALIZED ||
            this._initializationState === FBMessagingPlatformServiceInitState.INITIALIZING) {
            return new Promise(function (resolve, reject) { return reject("Service is not initialized"); });
        }
        var self = this;
        return new Promise(function (resolve, reject) {
            self._fbInstant.getEntryPointAsync().then(function (entryPointName) {
                var entryPointData = _this._fbInstant.getEntryPointData() || {};
                if (entryPointData.type && entryPointData.data) {
                    var data = (typeof entryPointData.data === 'string' || entryPointData.data instanceof String) ?
                        JSON.parse(entryPointData.data) : entryPointData.data;
                    resolve({
                        name: entryPointName,
                        type: entryPointData.type,
                        data: data
                    });
                }
                else {
                    /**
                     * Backwards compatibility fallback to handle cases where the entrypoint
                     * data was passed before IEntryPointPayload existed and was enforced.
                     */
                    resolve({
                        name: entryPointName,
                        type: null,
                        data: entryPointData
                    });
                }
            }, function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * Gets the current context information (cached and lazy initialized).
     *
     * The promise can resolve with "null", which means user is in a "SOLO" context.
     *
     * If user is in a context, all context info is fetched (id, players, type),
     * and cached, until the context is changed with "switchContext", "selectContext" or "createContext"
     *
     * @returns {Promise<IMessagingContext>} A promise with the current context
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.getCurrentContext = function () {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var self = this;
        return new Promise(function (resolve, reject) {
            // check if user is in a context
            var context = self._fbInstant.context;
            if (!context) {
                // "SOLO" context
                resolve(null);
                return;
            }
            // checking the cached context
            if (self._currentContext) {
                // checking if the context from FB changed somehow (sanity check)
                if (self._currentContext.getId() === self._fbInstant.context.getID()) {
                    resolve(self._currentContext);
                    return;
                }
            }
            if (self._fbInstant.context.getType() === "SOLO") {
                self._setCurrentContext(self._fbInstant.context, []);
                resolve(self._currentContext);
                return;
            }
            // fetching the context information from Facebook
            self._fbInstant.context.getPlayersAsync().then(function (players) {
                self._setCurrentContext(self._fbInstant.context, players);
                resolve(self._currentContext);
            }, function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * Opens a context selection dialog for the player. If the player selects an available context, the client will attempt to switch into that context, and resolve if successful. Otherwise, if the player exits the menu or the client fails to switch into the new context, this function will reject.
     *
     * @returns {Promise<IMessagingContext>}
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.selectContext = function () {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var self = this;
        return new Promise(function (resolve, reject) {
            // check if user is in a context
            var context = self._fbInstant.context;
            if (!context) {
                reject("context doesn't exist");
                return;
            }
            // switching the context
            context.chooseAsync().then(function () {
                // fetching the context information from Facebook
                return self._fbInstant.context.getPlayersAsync();
            })
                .then(function (players) {
                // caching it
                self._setCurrentContext(self._fbInstant.context, players);
                // resolving
                resolve(self._currentContext);
            })
                .catch(function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * Request a switch into a specific context.
     * The promise will resolve when the game has switched into the specified context.
     * If the specified context id is the same as the current one's, this promise will fail. As in the same if the specified context id doesn't exist.
     *
     * @param {string} ctxId The id of the context we need to switch to
     * @returns {Promise<IMessagingContext>} A promise which resolves with the new current context
     *
     * @memberOf IMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.switchContext = function (contextId) {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var self = this;
        return new Promise(function (resolve, reject) {
            // check if user is in a context
            var context = self._fbInstant.context;
            if (!context) {
                reject("context doesn't exist");
                return;
            }
            // checking if it's the same context
            if (context.getID() === contextId) {
                reject(ErrorCodeType.SAME_CONTEXT);
                return;
            }
            // switching the context
            context.switchAsync(contextId).then(function () {
                // fetching the context information from Facebook
                return self._fbInstant.context.getPlayersAsync();
            })
                .then(function (players) {
                // caching it
                self._setCurrentContext(self._fbInstant.context, players);
                // resolving
                resolve(self._currentContext);
            })
                .catch(function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * Attempts to create or switch into a context between the current player and THE FIRST PLAYER in the specified array.
     * The promise will resolve when the game has switched into the new context.
     *
     * @param {string[]} playerIds An array containing only one connected player id. Others will be ignored for FB.
     * @returns {Promise<IMessagingContext>} A promise which resolves with the new current context
     *
     * @memberOf IMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.createContext = function (playerIds) {
        var _this = this;
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var self = this;
        return new Promise(function (resolve, reject) {
            // checking the selected user
            if (!playerIds || playerIds.length === 0) {
                reject("Player id is required");
                return;
            }
            var connectedPlayer = playerIds[0];
            // checking if referred player is the current user
            var user = _this.getPlayer();
            if (connectedPlayer === user.id) {
                reject("Player id cannot be the current player");
                return;
            }
            // checking if the context is set on the FB SDK
            var context = self._fbInstant.context;
            if (!context) {
                reject("context doesn't exist");
                return;
            }
            // checking the player ids parameter (just a warning)
            if (playerIds.length > 1) {
                console.warn("FB createContext implementation accepts only one connected player. Ignoring the other(s).");
            }
            // checking if the current context already has the referred player id
            self.getCurrentContext().then(function (currentContext) {
                if (currentContext && currentContext.getPlayers().length === 2) {
                    if (currentContext.getPlayers()[0].id === connectedPlayer ||
                        currentContext.getPlayers()[1].id === connectedPlayer) {
                        reject(ErrorCodeType.SAME_CONTEXT); // rejecting with the same error from FB
                        return;
                    }
                }
                return context.createAsync(connectedPlayer);
            })
                .then(function () {
                // context was created, fetching the context information from Facebook
                return self._fbInstant.context.getPlayersAsync();
            })
                .then(function (players) {
                // caching it
                self._setCurrentContext(self._fbInstant.context, players);
                // resolving
                resolve(self._currentContext);
            })
                .catch(function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * Gets the platform info. It works only after the service is initialized
     *
     * @returns {IMessagingPlatformInfo} The platform info, or null if the service is not initialized
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.getPlatformInfo = function () {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            console.warn("Service must be initialized before calling 'getPlatformInfo'");
            return null;
        }
        return new FBMessagingPlatformInfo(this._fbInstant.getLocale(), this._fbInstant.getPlatform(), this._fbInstant.getSDKVersion());
    };
    /**
     * Adds a pause listener
     *
     * @param {IMessagingPlatformPauseListener} pauseListener The pause listener
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.addPauseListener = function (pauseListener) {
        this._pauseListeners.push(pauseListener);
    };
    /**
     * Removes a pause listener
     *
     * @param {IMessagingPlatformPauseListener} pauseListener The pause listener
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.removePauseListener = function (pauseListener) {
        this._pauseListeners = this._pauseListeners.filter(function (listener) { return pauseListener !== listener; });
    };
    /**
     * Remove all pause listeners
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.removeAllPauseListeners = function () {
        this._pauseListeners = [];
    };
    /**
     * Adds an init listener.
     *
     * If the service is already initialized, the "initializationFinished" method is triggered right away.
     *
     * @param {IFBMessagingPlatformInitListener} listener The init listener
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.addInitListener = function (listener) {
        if (this._initializationState === FBMessagingPlatformServiceInitState.INITIALIZED) {
            // calling the listener right away
            listener.initializationFinished();
            return;
        }
        if (this._initListeners.indexOf(listener) < 0) {
            this._initListeners.push(listener);
        }
    };
    /**
     * Removes an init listener.
     *
     * @param {IFBMessagingPlatformInitListener} listener The init listener
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.removeInitListener = function (listener) {
        this._initListeners = this._initListeners.filter(function (l) { return l !== listener; });
    };
    /**
     * Subscribes the user to receive gamebot messages
     *
     * @returns {Promise<void>}
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.subscribeToGameBot = function () {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var self = this;
        return new Promise(function (resolve, reject) {
            // facebook requires to call the "canSubscribe" method first
            self._fbInstant.player.canSubscribeBotAsync()
                .then(function (canSubscribe) {
                if (canSubscribe) {
                    self._fbInstant.player.subscribeBotAsync()
                        .then(function () {
                        resolve();
                    })
                        .catch(function (reason) {
                        reject(reason);
                    });
                }
                else {
                    reject("Couldn't subscribe");
                }
            })
                .catch(function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * Creates a shortcut for the game
     *
     * @returns {Promise<void>}
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.createShortcut = function () {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var self = this;
        return new Promise(function (resolve, reject) {
            // facebook requires to call the "canSubscribe" method first
            self._fbInstant.canCreateShortcutAsync()
                .then(function (canCreate) {
                if (canCreate) {
                    self._fbInstant.createShortcutAsync()
                        .then(function () {
                        resolve();
                    })
                        .catch(function (reason) {
                        reject(reason);
                    });
                }
                else {
                    reject("Couldn't create shortcut");
                }
            })
                .catch(function (reason) {
                reject(reason);
            });
        });
    };
    /**
     * Switches to other game (cross-promotion)
     *
     * @param {string} appId The game id
     * @param {Object} [data] Optional payload data
     * @returns {Promise<void>}
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype.switchToGame = function (appId, data) {
        if (this._initializationState !== FBMessagingPlatformServiceInitState.INITIALIZED) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        return this._fbInstant.switchGameAsync(appId, data);
    };
    /**
     * Remove all init listeners
     *
     * @memberOf FBMessagingPlatformService
     */
    FBMessagingPlatformService.prototype._removeAllInitListeners = function () {
        this._initListeners = [];
    };
    FBMessagingPlatformService.prototype._setCurrentContext = function (context, players) {
        // making sure user is part of retrieved list
        var user = this.getPlayer();
        if (!players.some(function (p) { return p.getID() === user.id; })) // if player is not inside
         {
            players.push({
                getID: function () { return user.id; },
                getName: function () { return user.name; },
                getPhoto: function () { return user.photo; }
            });
        }
        // creating the new context
        this._currentContext = new FBMessagingContext(context.getID(), players, context.getType());
    };
    FBMessagingPlatformService.prototype._onPauseCallback = function () {
        for (var _i = 0, _a = this._pauseListeners; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener.onMessagingPlatformPaused();
        }
    };
    return FBMessagingPlatformService;
}());
exports.FBMessagingPlatformService = FBMessagingPlatformService;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Representation of the service's internal initialization state
 *
 * @export
 * @enum {number}
 */
var FBMessagingPlatformServiceInitState;
(function (FBMessagingPlatformServiceInitState) {
    /**
     * The service was not initialized, or previous initialization failed
     */
    FBMessagingPlatformServiceInitState[FBMessagingPlatformServiceInitState["NOT_INITIALIZED"] = 0] = "NOT_INITIALIZED";
    /**
     * The service is performing the first initialization step, which consists of
     * triggering the "initializeAsync" function from the FB SDK and wait for the promise to resolve.
     */
    FBMessagingPlatformServiceInitState[FBMessagingPlatformServiceInitState["INITIALIZING"] = 1] = "INITIALIZING";
    /**
     * The service is waiting for the initial loading to be finished.
     * At this state, the service is requesting the initial loading progress from the handler reference.
     */
    FBMessagingPlatformServiceInitState[FBMessagingPlatformServiceInitState["WAITING_FOR_INITIAL_LOADING"] = 2] = "WAITING_FOR_INITIAL_LOADING";
    /**
     * The service is performing the second initialization step, which is
     * to trigger the "startGameAsync" function from the FB SDK and wait for the promise to resolve
     */
    FBMessagingPlatformServiceInitState[FBMessagingPlatformServiceInitState["FINISHING_INITIALIZATION"] = 3] = "FINISHING_INITIALIZATION";
    /**
     * The service is initialized
     */
    FBMessagingPlatformServiceInitState[FBMessagingPlatformServiceInitState["INITIALIZED"] = 4] = "INITIALIZED";
})(FBMessagingPlatformServiceInitState = exports.FBMessagingPlatformServiceInitState || (exports.FBMessagingPlatformServiceInitState = {}));

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Settings for the service
 *
 * @export
 * @class FBMessagingPlatformServiceSettings
 */
var FBMessagingPlatformServiceSettings = /** @class */ (function () {
    /**
     * Creates an instance of FBMessagingPlatformServiceSettings.
     *
     * @param {IFBMessagingPlatformServiceSettings} [config] Optional configuration for this settings
     *
     * @memberOf FBMessagingPlatformServiceSettings
     */
    function FBMessagingPlatformServiceSettings(config) {
        /**
         * The initial loading check interval, in milliseconds (default 100)
         *
         * @type {number}
         * @memberOf IFBMessagingPlatformServiceSettings
         */
        this.initialLoadingCheckInterval = 100;
        if (config) {
            for (var key in config) {
                if (config.hasOwnProperty(key)) {
                    this[key] = config[key];
                }
            }
        }
    }
    return FBMessagingPlatformServiceSettings;
}());
exports.FBMessagingPlatformServiceSettings = FBMessagingPlatformServiceSettings;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

//******************************************************
//*****    Script Resource: coolgames_analytics_ga
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-analytics-ga (3.0.0-builder)
// ---------------------------------------------------------------------------------------
// Generated on Fri Apr 20 2018 14:02:22 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-analytics-core (3.0.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_analytics_core_1 = require("@coolgames/coolgames-analytics-core");
/**
 * Concrete implementation of the Analytics service for GameAnalytics
 *
 * @export
 * @class GameAnalyticsService
 * @implements {IAnalyticsService}
 */
var GameAnalyticsService = /** @class */ (function () {
    /**
     * Creates an instance of GameAnalyticsService.
     * @param {string} gameKey The game key from GA
     * @param {string} gameSecret The game secret from GA
     * @param {AnalyticsServiceSettings} settings The settings object
     *
     * @memberOf GameAnalyticsService
     */
    function GameAnalyticsService(gameKey, gameSecret, settings) {
        this._gameKey = gameKey;
        this._gameSecret = gameSecret;
        this._settings = settings;
        this._initialized = false;
        this._sessionEnded = false;
        this._eventQueue = new AnalyticsEventQueue();
        this._bindEndSessionFunction();
    }
    /**
     * Gets the number of enqueued events
     *
     * @public
     * @returns {number} The number of enqueued events
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype.getNumberOfQueuedEvents = function () {
        return this._eventQueue.getNumberOfQueuedEvents();
    };
    /**
     * Initializes the Analytics service. This function also triggers the START_SESSION event.
     *
     * @returns {Promise<void>} A promise which resolves after the service is initialized
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype.initialize = function () {
        var _this = this;
        var self = this;
    };
    /**
     * Method to know if the service is initialized
     *
     * @returns {boolean} If the service is initialized
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype.isInitialized = function () {
        return this._initialized;
    };
    /**
     * Stops the periodic activation of submitting queued events, adds a SESSION_END event and submits queued events.
     *
     * @returns {void}
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype.endSession = function () {
        if (!this._initialized) {
            console.warn('GameAnalyticsService: session is not initialized!');
            return;
        }
        else if (this._sessionEnded) {
            console.warn('GameAnalyticsService: session was already ended!');
            return;
        }
        console.log("GameAnalyticsService: will end session");
        //GameAnalytics("endSession");
        this._sessionEnded = true;
    };
    /**
     * Submit custom event id's. Useful for tracking metrics specifically needed for your game.
     * The design event is available for you to add your own event-id hierarchy (e.g. ["controlPreference", "cellFirstPopulated"]).
     *
     * @param {string[]} eventIds The eventId is a hierarchy array of strings that can consist of 1-5 segments. Each segment can have a max length of 32.
     * @param {number} [value] A float event tied to the eventId. Will result in sum & mean values being available.
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype.reportDesignEvent = function (eventIds, value) {
        if (!this._initialized) {
            console.warn('GameAnalyticsService: session is not initialized, queuing event...');
            var event_1 = new AnalyticsEventObject(AnalyticsEventType.Design);
            event_1.eventIds = eventIds;
            event_1.value = value;
            this._eventQueue.addEvent(event_1);
            return;
        }
        else if (this._sessionEnded) {
            console.warn('GameAnalyticsService: session was ended!');
            return;
        }
        else if (!eventIds || eventIds.length === 0 || eventIds.length > 5) {
            console.warn('GameAnalyticsService: design event id is incorrect!');
            return;
        }
        eventIds.forEach(function (element) {
            if (!element || element.length === 0) {
                console.warn('GameAnalyticsService: design event id  "' +
                    element + '" is invalid!');
                return;
            }
            else if (element.length > 32) {
                console.warn('GameAnalyticsService: design event id  "' +
                    element + '" is too big!');
                return;
            }
        });
        var eventId = eventIds.join(":");
        if (!value) {
            //GameAnalytics("addDesignEvent", eventId);
        }
        else {
            //GameAnalytics("addDesignEvent", eventId, value);
        }
    };
    /**
     * Progression events are used to track attempts at completing some part of a game (level, area). A defined area follow a 3 tier hierarchy structure (could be world:stage:level) to indicate what part of the game the player is trying to complete.
     * When a player is starting a progression attempt a start event should be added.
     * When the player then finishes the attempt a fail or complete event should be added along with a score if needed.
     *
     * @param {AnalyticsProgressionStatus} status Status of added progression
     * @param {string[]} eventIds Required progression locations (min 1, max 3 progression events)
     * @param {number} [score] An optional score when a user completes or fails a progression attempt. Remember to set progression02 and/or progression03 if they are not used when using score parameter.
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype.reportProgression = function (status, eventIds, score) {
        if (!eventIds || eventIds.length === 0) {
            console.warn('GameAnalyticsService: progression event id is required!');
            return;
        }
        if (eventIds.length > 3) {
            console.warn('GameAnalyticsService: too many progression event ids (GA can only handle up to 3 ids)!');
            return;
        }
        var progression01 = eventIds[0];
        var progression02 = (eventIds.length > 1) ? eventIds[1] : null;
        var progression03 = (eventIds.length > 2) ? eventIds[2] : null;
        if (!this._initialized) {
            console.warn('GameAnalyticsService: session is not initialized, queuing event...');
            var event_2 = new AnalyticsEventObject(AnalyticsEventType.Progression);
            event_2.progressionStatus = status;
            event_2.progression.push(progression01);
            if (progression02) {
                event_2.progression.push(progression02);
            }
            if (progression03) {
                event_2.progression.push(progression03);
            }
            event_2.value = score;
            this._eventQueue.addEvent(event_2);
            return;
        }
        else if (this._sessionEnded) {
            console.warn('GameAnalyticsService: session was ended!');
            return;
        }
        //GameAnalytics("addProgressionEvent", GameAnalyticsService._convertToProgressionStatus(status), progression01, progression02, progression03, score);
    };
    /**
     * Submit exception stack traces or custom error messages.
     * You must group the events by severity level and attach a message.
     *
     * @param {AnalyticsErrorSeverity} severity Severity of error
     * @param {string} msg Error message
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype.reportError = function (severity, msg) {
        if (!this._initialized) {
            console.warn('GameAnalyticsService: session is not initialized, queuing event...');
            var event_3 = new AnalyticsEventObject(AnalyticsEventType.Error);
            event_3.severity = severity;
            event_3.msg = msg;
            this._eventQueue.addEvent(event_3);
            return;
        }
        else if (this._sessionEnded) {
            console.warn('GameAnalyticsService: session was ended!');
            return;
        }
        GameAnalytics("addErrorEvent", GameAnalyticsService._convertToErrorSeverity(severity), msg);
    };
    /**
     * Binds an end session to the window.
     * This overrides any event previously bound by other code, so maybe it should be improved.
     *
     * @private
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype._bindEndSessionFunction = function () {
        var self = this;
        window.onbeforeunload = function (e) {
            self.endSession();
        };
    };
    /**
     * Sets the initialization flags.
     *
     * @private
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype._startSession = function () {
        this._initialized = true;
        this._sessionEnded = false;
    };
    /**
     * Handles clearing the enqueued events and submits them
     *
     * @private
     * @param {AnalyticsEventObject} event
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype._sendAnalyticsEventObject = function (event) {
        switch (event.type) {
            case AnalyticsEventType.Design:
                this.reportDesignEvent(event.eventIds, event.value);
                break;
            case AnalyticsEventType.Error:
                this.reportError(event.severity, event.msg);
                break;
            case AnalyticsEventType.Progression:
                this.reportProgression(event.progressionStatus, [
                    event.progression[0],
                    event.progression.length > 1 ? event.progression[1] : null,
                    event.progression.length > 2 ? event.progression[2] : null
                ], event.value ? event.value : null);
                break;
            case AnalyticsEventType.AdRequest:
            case AnalyticsEventType.AdClick:
            case AnalyticsEventType.AdImpression:
            default:
                console.warn("GameAnalyticsService: unhandled event type: " + event.type);
                break;
        }
    };
    /**
     * Handles clearing the enqueued events and submits them
     *
     * @private
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService.prototype._handleQueue = function () {
        var _this = this;
    };
    /**
     * Utility method to convert the error severity enumeration from the module to the GA SDK one
     *
     * @private
     * @static
     * @param {AnalyticsErrorSeverity} severity The error severity
     * @returns {gameanalytics.EGAErrorSeverity}
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService._convertToErrorSeverity = function (severity) {
        switch (severity) {
            case AnalyticsErrorSeverity.Critical:
                return gameanalytics.EGAErrorSeverity.Critical;
            case AnalyticsErrorSeverity.Error:
                return gameanalytics.EGAErrorSeverity.Error;
            case AnalyticsErrorSeverity.Warning:
                return gameanalytics.EGAErrorSeverity.Warning;
            case AnalyticsErrorSeverity.Info:
                return gameanalytics.EGAErrorSeverity.Info;
            case AnalyticsErrorSeverity.Debug:
                return gameanalytics.EGAErrorSeverity.Debug;
            default:
                return gameanalytics.EGAErrorSeverity.Undefined;
        }
    };
    /**
     * Utility method to convert the progression status enumeration from the module to the GA SDK one
     *
     * @private
     * @static
     * @param {AnalyticsProgressionStatus} status The progression status
     * @returns {gameanalytics.EGAProgressionStatus}
     *
     * @memberOf GameAnalyticsService
     */
    GameAnalyticsService._convertToProgressionStatus = function (status) {
        switch (status) {
            case AnalyticsProgressionStatus.Start:
                return gameanalytics.EGAProgressionStatus.Start;
            case AnalyticsProgressionStatus.Complete:
                return gameanalytics.EGAProgressionStatus.Complete;
            case AnalyticsProgressionStatus.Fail:
                return gameanalytics.EGAProgressionStatus.Fail;
            default:
                return gameanalytics.EGAProgressionStatus.Undefined;
        }
    };
    return GameAnalyticsService;
}());
exports.GameAnalyticsService = GameAnalyticsService;
//******************************************************
//*****    Script Resource: games_backend_core
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// coolgames-backend-core (1.2.0-builder)
// Generated on Tue Oct 23 2018 15:52:20 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
	return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This class represents a user connectivity status
 *
 * @export
 * @class UserConnectivityStatus
 */
var UserConnectivityStatus = /** @class */ (function () {
	function UserConnectivityStatus() {
	}
	return UserConnectivityStatus;
}());
exports.UserConnectivityStatus = UserConnectivityStatus;

//******************************************************
//*****    Script Resource: games_backend_gamesparks
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-backend-gamesparks (1.6.0-builder)
// ---------------------------------------------------------------------------------------
// Generated on Fri Jun 21 2019 15:57:38 GMT+0200 (Central European Summer Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-backend-core (1.3.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_backend_core_1 = require("@coolgames/coolgames-backend-core");
var crypto_js_1 = require("crypto-js");
var GameSparksRoom_1 = require("./GameSparksRoom");
var GameSparksMatchmaking_1 = require("./GameSparksMatchmaking");
// tslint:disable:no-string-literal
// tslint:disable:object-literal-sort-keys
// tslint:disable:forin
// tslint:disable:prefer-for-of
/**
 * Enumeration with possible GameSparksBackendService states
 *
 * @export
 * @enum {number}
 */
var GameSparksBackendServiceState;
(function (GameSparksBackendServiceState) {
    GameSparksBackendServiceState[GameSparksBackendServiceState["Unitialized"] = 0] = "Unitialized";
    GameSparksBackendServiceState[GameSparksBackendServiceState["Disconnected"] = 1] = "Disconnected";
    GameSparksBackendServiceState[GameSparksBackendServiceState["Connecting"] = 2] = "Connecting";
    GameSparksBackendServiceState[GameSparksBackendServiceState["Connected"] = 3] = "Connected";
    GameSparksBackendServiceState[GameSparksBackendServiceState["Reconnecting"] = 4] = "Reconnecting";
})(GameSparksBackendServiceState = exports.GameSparksBackendServiceState || (exports.GameSparksBackendServiceState = {}));
/**
 * A concrete implementation of the IGamesBackendService interface for GameSparks
 *
 * @export
 * @class GameSparksBackendService
 * @implements {IGamesBackendService}
 */
var GameSparksBackendService = /** @class */ (function () {
    /**
     * Creates an instance of GameSparksBackendService.
     *
     * @param {IGameSparks} gamesparks The GameSparks SDK instance
     * @param {string} apiKey The GameSparks api key
     * @param {string} apiSecret The GameSparks api secret key
     *
     * @memberOf GameSparksBackendService
     */
    function GameSparksBackendService(gamesparks, apiKey, apiSecret) {
        /**
         * Reference for the current room
         *
         * @private
         * @type {GameSparksRoom}
         * @memberOf GameSparksBackendService
         */
        this._currentRoom = null;
        /**
         * The player identity configuration
         *
         * @private
         * @type {IPlayerConfig}
         * @memberOf GameSparksBackendService
         */
        this._playerConfig = null;
        /**
         * The challenge request data sent to gamesparks to create a new challenge
         *
         * For more information, see https://docs.gamesparks.com/api-documentation/request-api/multiplayer/createchallengerequest.html
         *
         * @private
         * @type {ICreateChallengeRequest}
         * @memberOf GameSparksBackendService
         */
        this._defaultChallengeRequestData = {
            autoStartJoinedChallengeOnMaxPlayers: true,
            challengeShortCode: "CHALLENGE",
            maxAttempts: 0,
            maxPlayers: 2,
            minPlayers: 2,
            silent: false
        };
        /**
         * Connection callbacks
         *
         * @private
         * @type {*}
         * @memberOf GameSparksBackendService
         */
        this._checkConnectionCallbacks = {};
        /**
         * Connection timeout callbacks
         *
         * @private
         * @type {*}
         * @memberOf GameSparksBackendService
         */
        this._checkConnectionTimeouts = {};
        /**
         * The difference between the server time and the local user time
         *
         * @private
         * @type {number}
         * @memberOf GameSparksBackendService
         */
        this._serverTimeDiff = 0;
        this._gamesparks = gamesparks;
        this._apiKey = apiKey;
        this._apiSecret = apiSecret;
        this._state = GameSparksBackendServiceState.Unitialized;
        this._listeners = [];
        this._networkListeners = [];
    }
    Object.defineProperty(GameSparksBackendService.prototype, "currentRoom", {
        /**
         * Get the current room
         *
         * @readonly     *
         * @memberOf GameSparksBackendService
         */
        get: function () {
            return this._currentRoom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSparksBackendService.prototype, "playerConfig", {
        /**
         * Gets the player config (info)
         *
         * @readonly
         *
         * @memberOf GameSparksBackendService
         */
        get: function () {
            return this._playerConfig;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSparksBackendService.prototype, "state", {
        /**
         * Gets the state of this GameSparksBackendService instance
         *
         * @readonly
         * @type {GameSparksBackendServiceState}
         * @memberOf GameSparksBackendService
         */
        get: function () {
            return this.__state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSparksBackendService.prototype, "_state", {
        /**
         * Sets the state of this GameSparksBackendService instance
         *
         * @private
         *
         * @memberOf GameSparksBackendService
         */
        set: function (state) {
            if (state === GameSparksBackendServiceState.Connected &&
                this.__state === GameSparksBackendServiceState.Connected) {
                return;
            }
            // onExit
            switch (this.__state) {
                case GameSparksBackendServiceState.Connected:
                    if (this._isDebugMode) {
                        console.log(">>>>>> Cancelling Checking");
                    }
                    window.clearInterval(this._connectionCheckHandler);
                    break;
            }
            // setting new state
            if (this._isDebugMode) {
                console.log(">>>>>> Set state to: " + state);
            }
            var previousState = this.__state;
            this.__state = state;
            // onEnter
            switch (this.__state) {
                case GameSparksBackendServiceState.Connected:
                    this._connectionCheckCounter = 0;
                    var self_1 = this;
                    if (this._isDebugMode) {
                        console.log(">>>>>> Scheduling Checking");
                    }
                    this._connectionCheckHandler = window.setInterval(function () { self_1._checkConnection(); }, GameSparksBackendService.INTERNET_CHECK_INTERVAL);
                    break;
                case GameSparksBackendServiceState.Disconnected:
                    if (previousState === GameSparksBackendServiceState.Connecting ||
                        previousState === GameSparksBackendServiceState.Reconnecting) {
                        if (this._connectionErrorCallback) {
                            this._connectionErrorCallback("Couldn't connect to server");
                        }
                    }
                    else if (previousState === GameSparksBackendServiceState.Connected) {
                        if (this._currentRoom) {
                            this._currentRoom.disconnect();
                            this._currentRoom = null;
                        }
                        this._cleanUpMatchMaking();
                        for (var i = this._networkListeners.length - 1; i >= 0; i--) {
                            this._networkListeners[i].disconnected();
                        }
                    }
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSparksBackendService.prototype, "gameSparksUserId", {
        /**
         * Get the GameSparks user id
         *
         * @readonly
         * @memberOf GameSparksBackendService
         */
        get: function () {
            return this._gameSparksUserId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Saves data in the remote server, related to the specified match
     *
     * @static
     * @param {GameSparksBackendService} be The GameSparksBackendService instance
     * @param {string} matchId The match id
     * @param {string[]} labels The labels to save
     * @param {Object[]} datas The data to save
     * @param {GamesBackendDoneCallback} onDone A callback to be called after the data is saved
     * @param {GamesBackendErrorCallback} onError A callback to be called if the method fails
     * @param {GamesBackendErrorCallback} expirationTime Match expiration time (seconds)
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.saveMatchData = function (be, matchId, labels, datas, onDone, onError, expirationTime) {
        if (expirationTime === void 0) { expirationTime = -1; }
        be._gamesparks.sendWithData("LogEventRequest", {
            "DATAS": datas,
            "eventKey": "MD_SAVE",
            "LABELS": labels,
            "MATCH": matchId,
            "MATCH_EXP_TIME": expirationTime
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                if (onDone) {
                    onDone();
                }
            }
            else {
                if (be._isDebugMode) {
                    console.error(JSON.stringify(response));
                }
                if (onError) {
                    onError("error saving data: " + JSON.stringify(response));
                }
            }
        });
    };
    /**
     * Sends a message inside a room
     *
     * @static
     * @param {GameSparksBackendService} be
     * @param {string} matchId
     * @param {Object} msg
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.sendRoomMessage = function (be, matchId, msg) {
        be._gamesparks.sendWithData("LogChallengeEventRequest", {
            "challengeInstanceId": matchId,
            "eventKey": "M_MSG",
            "MSG": msg
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                /* */
            }
            else {
                if (be._isDebugMode) {
                    console.error(JSON.stringify(response));
                }
            }
        });
    };
    /**
     * Gets and ISO date string from a date object
     *
     * @static
     * @param {Date} date Date to be converted
     * @returns {string}
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.getIsoDateString = function (date) {
        var dateString = date.toISOString();
        return dateString.substr(0, dateString.lastIndexOf(".")) + "Z";
    };
    /**
     * Gets location from the server
     *
     * @returns {string}
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.getLocation = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._gamesparks.sendWithData("AccountDetailsRequest", {}, function (response) {
                if (!response["error"] && response.location != null) {
                    resolve(response.location.country);
                }
                else {
                    if (_this._isDebugMode) {
                        console.error(JSON.stringify(response));
                    }
                    reject("error retrieving location: " + JSON.stringify(response));
                }
            });
        });
    };
    /**
     * Initializes this instance, connecting it with the GameSparks server and authenticating the user
     *
     * @param {IPlayerConfig | string} playerConfig The profile of the facebook user or for legacy code the userid
     * @param {boolean} isProdBuild If it points to the production env or not (the preview env)
     * @param {() => void} [onDone] Callback to be called when user is authenticated
     * @param {(error: string) => void} [onError] Callback to be called in case of error
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.initialize = function (playerConfig, isProdBuild, onDone, onError) {
        if (typeof playerConfig === "string") {
            this._userId = playerConfig.toLowerCase();
            this._password = this._userId;
        }
        else {
            playerConfig.userID = playerConfig.userID.toLowerCase();
            this._userId = playerConfig.userID;
            this._password = playerConfig.password ? playerConfig.password : this._userId;
            this._playerConfig = playerConfig;
        }
        this._isProdBuild = isProdBuild;
        this._state = GameSparksBackendServiceState.Connecting;
        this._initGameSparks(onDone, onError);
    };
    /**
     * Reconnects the GamesBackend service. To be used after a disconnection.
     *
     * @param {() => void} [onDone]  A callback to trigger after the server is initialized
     * @param {(error: string) => void} [onError] A callback to trigger if there's an error during initialization
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.reconnect = function (onDone, onError) {
        if (this.state !== GameSparksBackendServiceState.Disconnected) {
            if (onError) {
                onError("GameSparksBackendService needs to be initialized before you can reconnect");
            }
            return;
        }
        this._state = GameSparksBackendServiceState.Reconnecting;
        this._initGameSparks(onDone, onError);
    };
    /**
     * Convenience method to leave the Current Room (if existent)
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.leaveRoom = function () {
        if (this._currentRoom) {
            // clear listeners
            this._currentRoom.disconnect();
            // clear BackendService
            this.cleanUpRoom();
        }
    };
    /**
     * Saves player data on the server side.
     * The data is identified in the server by its "label", so
     * there must be a label for each data you want to store.
     *
     * @param {string[]} label An array with labels (one for each data)
     * @param {Object[]} data An array of json objects
     * @param {() => void} onDone Default empty callback
     * @param {(error: string) => void} onError Error callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.savePlayerData = function (label, data, onDone, onError) {
        if (!this.isInitialized()) {
            console.error("GameSparksBackendService is not initialized");
            if (onError) {
                onError("GameSparksBackendService is not initialized");
            }
            return;
        }
        this._gamesparks.sendWithData("LogEventRequest", {
            "eventKey": "PD_SAVE",
            "LABELS": label,
            "DATAS": data
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                if (onDone) {
                    onDone();
                }
            }
            else {
                if (onError) {
                    onError("error saving data: " + JSON.stringify(response));
                }
            }
        });
    };
    /**
     * Retrieves data from the server for a specific label (or more than one)
     *
     * @param {string[]} labels An array of labels (at least one)
     * @param {(data: Object) => void} onDone A callback with the data, or an empty object in case of error
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.getPlayerData = function (labels, onDone) {
        if (!this.isInitialized()) {
            console.error("GameSparksBackendService is not initialized");
            if (onDone) {
                onDone({});
            }
            return;
        }
        this._gamesparks.sendWithData("LogEventRequest", {
            "eventKey": "PD_GET",
            "LABELS": labels
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                var responseObj = {};
                for (var i = 0; i < labels.length; i++) {
                    responseObj[labels[i]] = response["scriptData"][labels[i]];
                }
                if (onDone) {
                    onDone(responseObj);
                }
            }
            else {
                if (onDone) {
                    onDone({ "error": response["error"] });
                }
            }
        });
    };
    /**
     * Sets the default challenge request data, used in creating matches and challenges
     *
     * @param {ICreateChallengeRequest} data
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.setDefaultChallengeRequestData = function (data) {
        this._defaultChallengeRequestData = data;
    };
    /**
     * Returns the default challenge request data
     *
     * @returns {ICreateChallengeRequest}
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.getDefaultChallengeRequestData = function () {
        return this._defaultChallengeRequestData;
    };
    /**
     * Gets the time from the server, in milliseconds, since 01/01/1970
     *
     * @param {(data: Object) => void} onData Response object which contains the "time" value
     * @param {(error: string) => void} onError Error callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.getServerTime = function (onData, onError) {
        // this method is used at initialization time (server sync), so the state check had to be removed from here
        this._gamesparks.sendWithData("LogEventRequest", {
            "eventKey": "TIME_GET"
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                if (onData) {
                    onData({ "time": response["scriptData"].time });
                }
            }
            else {
                if (onError) {
                    onError("error saving data: " + JSON.stringify(response));
                }
            }
        });
    };
    /**
     * Gets a list of all matches related to the current user
     *
     * @param {string[]} dataLabels Optional array of data labels you want to get along with the list
     * @param {GamesBackendDataCallback} onDone A callback with the data, or an empty object in case of error
     * @param {boolean} includeCompletedMatches If true the completed matches will be returned. (default false)
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.listMatches = function (dataLabels, onDone, includeCompletedMatches) {
        if (!this.isInitialized()) {
            console.error("GameSparksBackendService is not initialized");
            onDone({});
            return;
        }
        var self = this;
        var requestData = {
            "entryCount": 0,
            "offset": 0,
            "shortCode": "CHALLENGE",
            "states": ["RUNNING", "WAITING", "RECEIVED", "ISSUED"]
        };
        if (includeCompletedMatches) {
            requestData["states"].push("COMPLETE");
        }
        this._gamesparks.sendWithData("ListChallengeRequest", requestData, function (response) {
            var challenges = response["challengeInstances"];
            if (challenges && challenges.length > 0) {
                var responseObj_1 = {};
                for (var i = 0; i < challenges.length; i++) {
                    var challenge = challenges[i];
                    var challengeData = {};
                    if (challenge.scriptData) {
                        if ("creationDate" in challenge.scriptData) {
                            challengeData["creationDate"] = new Date(challenge.scriptData["creationDate"] - self._serverTimeDiff);
                        }
                        if ("isLastMatchFromContext" in challenge.scriptData) {
                            challengeData["isLastMatchFromContext"] = challenge.scriptData["isLastMatchFromContext"];
                        }
                        if ("expirationTime" in challenge.scriptData) {
                            var expirationDate = challenge.scriptData["expirationTime"] - self._serverTimeDiff;
                            challengeData["expirationDate"] = new Date(expirationDate);
                        }
                    }
                    if (challenge.challenger) {
                        challengeData["challenger"] = challenge.challenger["name"];
                    }
                    if (challenge.challenged && challenge.challenged.length > 0) {
                        challengeData["challenged"] = challenge.challenged[0]["name"];
                    }
                    if (challenge.challengeMessage) {
                        challengeData["contextId"] = challenge.challengeMessage;
                    }
                    challengeData["state"] = challenge.state;
                    responseObj_1[challenge["challengeId"]] = { "_challengeData": challengeData };
                }
                if (!dataLabels || dataLabels.length < 1) {
                    if (onDone) {
                        onDone(responseObj_1);
                    }
                }
                else {
                    var challengeIds = [];
                    for (var i = 0; i < challenges.length; i++) {
                        challengeIds.push(challenges[i]["challengeId"]);
                    }
                    self.getMatchesData(challengeIds, dataLabels, function (data) {
                        if (onDone) {
                            responseObj_1 = self._mergeMatchDataObjects(responseObj_1, data);
                            onDone(responseObj_1);
                        }
                    }, null);
                }
            }
            else {
                if (onDone) {
                    onDone({});
                }
            }
        });
    };
    /**
     * Request to create a match on the server.
     * If by the time of request we don't know the id of the person to challenge,
     * a match should be created in a way the challenged people can join later.
     *
     * @param {string[]} opponents The id's of all the challenged players (optional)
     * @param {Object} [initialData] Optional field to initialize the match with some data already (along with labels)
     * @param {(matchId: string) => void} [onDone] Callback to get the match id, if everything is alright
     * @param {(error: string) => void} [onError] Error callback
     * @param {string} [contextId=null] Optional parameter to bind this match to a context
     * @param {number} [expirationTime=-1] Optional parameter to set the match an expiration time
     * @returns {void}
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.createMatch = function (opponents, initialData, onDone, onError, contextId, expirationTime) {
        if (contextId === void 0) { contextId = null; }
        if (expirationTime === void 0) { expirationTime = -1; }
        if (!this.isInitialized()) {
            console.error("GameSparksBackendService is not initialized");
            if (onError) {
                onError("GameSparksBackendService is not initialized");
            }
            return;
        }
        var self = this;
        if (!opponents || opponents.length < 1) {
            GameSparksBackendService.createChallenge(self, null, initialData, onDone, onError, contextId, expirationTime);
        }
        else {
            for (var i = 0; i < opponents.length; i++) {
                opponents[i] = opponents[i].toLowerCase();
            }
            this._gamesparks.sendWithData("LogEventRequest", {
                "eventKey": "PID_GET",
                "USERNAMES": opponents,
                "CREATE_ON_FAIL": "true"
            }, function (response) {
                if (response["error"]) {
                    if (onError) {
                        onError("error getting response from gamesparks");
                    }
                    return;
                }
                else {
                    var resp = response["scriptData"].userIds;
                    var userIds = [];
                    for (var i = 0; i < opponents.length; i++) {
                        var userId = resp[opponents[i]];
                        if (userId) {
                            userIds.push(userId);
                        }
                    }
                    GameSparksBackendService.createChallenge(self, userIds, initialData, onDone, onError, contextId, expirationTime);
                }
            });
        }
    };
    /**
     * Removes the current player from the specified matches.
     * Important to notice user cannot be added to the same match(es) again.
     * Additionally, game is responsible to control when to remove the player from the match
     * (ideally only after the match is completed)
     *
     * @param {string[]} matchIds The match ids
     * @param {() => void} onDone Callback to be triggered after player is removed from to the match
     * @param {(error: string) => void} [onError] Error callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.removePlayerFromMatches = function (matchIds, onDone, onError) {
        var self = this;
        this._gamesparks.sendWithData("LogEventRequest", {
            "MATCH_IDS": matchIds,
            "eventKey": "P_REM_MATCHES"
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                if (onDone) {
                    onDone();
                }
            }
            else {
                if (self._isDebugMode) {
                    console.error(JSON.stringify(response));
                }
                if (onError) {
                    onError("error removing user from match(es): " + JSON.stringify(response));
                }
                else if (onDone) {
                    onDone();
                }
            }
        });
    };
    /**
     * Request to search an opponent on the server and create a match between two random users
     *
     * @param {String} matchGroupName A match group
     * @param {Object} [initialData]  Optional field to initialize the matchData with some data already (MatchFound returns challenger matchData
     * @param {Object} [participantData] Optional field to initialize the participantData with some data already (MatchFound merges playerData)
     * @param {number} [rank] The rank of the player
     * @param {() => void} [onDone] Callback to get the match id, if everything is alright
     * @param {(error: string) => void} [onError] Error callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.startMatching = function (matchGroupName, initialData, participantData, rank, onDone, onError) {
        GameSparksBackendService.startMatchmaking(this, matchGroupName, initialData, participantData, rank, onDone, onError);
    };
    /**
     * Request to cancel searching an opponent on the server when creating a match between two random users.
     *
     * @param {String} matchGroupName  A match group
     * @param {() => void} [onDone] Callback to get the match id, if everything is alright
     * @param {(error: string) => void} [onError] Error callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.cancelMatching = function (matchGroupName, onDone, onError) {
        GameSparksBackendService.cancelMatchmaking(this, matchGroupName, onDone, onError);
    };
    /**
     * Gets the last match associated with a context id
     *
     * @param {string} contextId The contextId
     * @param {string[]} [dataLabels] Optional array of data labels you want to get along with the match id
     * @returns {Promise<Object>} An object with the last match id (if any) and associated dataLabels
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.getLastMatchFromContext = function (contextId, dataLabels) {
        var _this = this;
        var self = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this._gamesparks.sendWithData("LogEventRequest", {
                    "eventKey": "MCID_GET",
                    "CONTEXTID": contextId,
                    "LABELS": dataLabels
                }, function (response) {
                    if (!response["error"] && response["scriptData"].result === "OK") {
                        var challenge = response["scriptData"].challenge;
                        resolve(challenge);
                    }
                    else {
                        if (self._isDebugMode) {
                            console.error(JSON.stringify(response));
                        }
                        reject("error retrieving match from context: " + JSON.stringify(response));
                    }
                });
                return [2 /*return*/];
            });
        }); });
    };
    /**
     * Retrieves data stored in the remote server, related to this match
     *
     * @param {string[]} matchIds The match IDs
     * @param {string[]} labels The label(s) to retrieve
     * @param {(data: Object) => void} onDone A callback which will handle the retrieved data
     * @param {(error: string) => void} onError An error callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.getMatchesData = function (matchIds, labels, onDone, onError) {
        var self = this;
        this._gamesparks.sendWithData("LogEventRequest", {
            "eventKey": "MD_GET",
            "LABELS": labels,
            "MATCHES": matchIds
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                var challenges = response["scriptData"].challenges;
                challenges = self.convertToChallengeMap(challenges);
                if (onDone) {
                    onDone(challenges);
                }
            }
            else {
                if (self._isDebugMode) {
                    console.error(JSON.stringify(response));
                }
                if (onError) {
                    onError("error getting match data: " + JSON.stringify(response));
                }
                else if (onDone) {
                    onDone({});
                }
            }
        });
    };
    /**
     * Request to join an existing match.
     *
     * @param {string} matchId The match ID
     * @param {() => void} onDone Callback to be triggered after player is added to the match
     * @param {(error: string) => void} onError Callback to be triggered if the player cannot be added to the match
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.joinMatch = function (matchId, onDone, onError) {
        if (!this.isInitialized()) {
            console.error("GameSparksBackendService is not initialized");
            onError("GameSparksBackendService is not initialized");
            return;
        }
        var self = this;
        this._gamesparks.sendWithData("JoinChallengeRequest", {
            "challengeInstanceId": matchId
        }, function (response) {
            if (response["error"] || response["joined"] === false) {
                if (self._isDebugMode) {
                    console.error(JSON.stringify(response));
                }
                if (onError) {
                    onError("Couldn't join match");
                }
                return;
            }
            else {
                if (onDone) {
                    onDone();
                }
            }
        });
    };
    /**
     * Method used to create a room for a specific match.
     * User can be active in only one room, thus entering a room will make user leave the current one (if any).
     *
     * @param {string} matchId The id of the corresponding match
     * @param {IGamesBackendRoomListener} roomListener  A listener for the room
     * @returns {IGamesBackendRoom}
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.enterRoom = function (matchId, roomListener) {
        // verify if there's an existing room
        if (this._currentRoom) {
            this._currentRoom.disconnect();
        }
        this._currentRoom = new GameSparksRoom(matchId, this);
        if (roomListener) {
            this._currentRoom.addListener(roomListener);
        }
        this._currentRoom.connect();
        return this._currentRoom;
    };
    /**
     * Adds a listener to the service
     *
     * @param {IGamesBackendServiceListener} listener The object which will handle service events
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.addListener = function (listener) {
        this._listeners.push(listener);
    };
    /**
     * Adds a network listener to the service
     *
     * @param {IGamesBackendNetworkListener} listener The object which will handle network events
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.addNetworkListener = function (listener) {
        this._networkListeners.push(listener);
    };
    /**
     * Removes a listener from the service
     *
     * @param {IGamesBackendServiceListener} listener The object to remove
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.removeListener = function (listener) {
        var index = this._listeners.indexOf(listener);
        if (index > -1) {
            this._listeners.splice(index, 1);
        }
    };
    /**
     * Removes a network listener from the service
     *
     * @param {IGamesBackendNetworkListener} listener The object to remove
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.removeNetworkListener = function (listener) {
        var index = this._networkListeners.indexOf(listener);
        if (index > -1) {
            this._networkListeners.splice(index, 1);
        }
    };
    /**
     * Sets debug messages for this module
     *
     * @param {boolean} debug If debug mode is on it outputs to the console
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.setDebugMode = function (debug) {
        this._isDebugMode = debug;
    };
    /**
     * Gets a list of UserConnectivityStatus for a list of users.
     * This implementation removes possible duplicates.
     *
     * @param {string[]} userIds The user ids to get the connectivity status
     * @param {(userStatusList: UserConnectivityStatus[]) => void} onDone The callback with the list of user connectivity status
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.getPlayerConnectivityStatus = function (userIds, onDone) {
        if (!this.isInitialized()) {
            console.error("GameSparksBackendService is not initialized");
            if (onDone) {
                onDone([]);
            }
            return;
        }
        // removing possible duplicates
        var uniqueIds = {};
        for (var i = 0; i < userIds.length; i++) {
            uniqueIds[userIds[i].toLowerCase()] = 1;
        }
        userIds = Object.keys(uniqueIds);
        this._gamesparks.sendWithData("LogEventRequest", {
            "eventKey": "PLAYER_ROOM_GET",
            "PLAYER_IDS": userIds
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                if (onDone) {
                    var resp = [];
                    var players = response["scriptData"].players;
                    if (players) {
                        for (var i = 0; i < players.length; i++) {
                            var status_1 = new UserConnectivityStatus();
                            status_1.userId = players[i].playerId;
                            status_1.online = players[i].online;
                            status_1.currentMatchId = players[i].matchId;
                            if (status_1.currentMatchId === "null") {
                                status_1.currentMatchId = null;
                            }
                            resp.push(status_1);
                        }
                    }
                    onDone(resp);
                }
            }
            else {
                console.error("Error getting user room statuses: " + JSON.stringify(response));
                if (onDone) {
                    onDone([]);
                }
            }
        });
    };
    /**
     * Checks what is the connectivity status from the opponents
     * by sending a message and wait for the proper response.
     * If a defined timeout is reach, the opponent is given as offline.
     * This method shouldn't be called in a constant time interval,
     * but only in critical places instead (eg. at the end of the current user's turn).
     *
     * @param {string} userId The user id of the opponent
     * @param {(userStatus: UserConnectivityStatus) => void} callback The callback with the list of user connectivity status
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.checkOpponentConnectivityStatus = function (userId, callback) {
        userId = userId.toLowerCase();
        // preventing this method to be called in a loop
        if (this._checkConnectionCallbacks[userId]) {
            return;
        }
        var self = this;
        // sending message to GS
        this._gamesparks.sendWithData("LogEventRequest", {
            "eventKey": "P_MSG",
            "MSG": { "ping": "send_connection_status" },
            "USER_ID": userId
        }, function (response) {
            if (callback) {
                if (!response["error"] && response["scriptData"].result === "OK") {
                    // hold the callback to be called after client replies to it
                    self._checkConnectionCallbacks[userId] = callback;
                    // schedule timeout for user response
                    self._checkConnectionTimeouts[userId] = setTimeout(function () {
                        if (self._checkConnectionCallbacks[userId]) {
                            var status_2 = new UserConnectivityStatus();
                            status_2.userId = userId;
                            status_2.online = false;
                            status_2.currentMatchId = null;
                            callback(status_2);
                            delete self._checkConnectionCallbacks[userId];
                            delete self._checkConnectionTimeouts[userId];
                        }
                    }, GameSparksBackendService.PING_CHECK_INTERVAL);
                }
                else {
                    var status_3 = new UserConnectivityStatus();
                    status_3.userId = userId;
                    status_3.online = false;
                    status_3.currentMatchId = null;
                    callback(status_3);
                }
            }
        });
    };
    /**
     * Clears the current room
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.cleanUpRoom = function () {
        this._currentRoom = null;
        this.sendWithData("LogEventRequest", {
            "MATCH_ID": "null",
            "eventKey": "PLAYER_ROOM_SET"
        }, function (response) { });
    };
    /**
     * Remove the matchmaking helper instance
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._cleanUpMatchMaking = function () {
        this._matchMaking = null;
    };
    /**
     * Checks if the service is initialized, which in this case would be
     * only when the internal state is "Connected"
     *
     * @returns {boolean} True if the current state is "Connected", false otherwise
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.isInitialized = function () {
        return this.state === GameSparksBackendServiceState.Connected;
    };
    /**
     * Sends a message to GameSparks.
     * This method is used by other concrete GameSparks implementations to send messages to the server.
     *
     * @param {string} eventName The event name
     * @param {*} parameters The parameters
     * @param {Function} callback The callback to be triggered after the request is done
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.sendWithData = function (eventName, parameters, callback) {
        this._gamesparks.sendWithData(eventName, parameters, callback);
    };
    /**
     * Required by GDPR, this method allows the game to get all player data at once.
     *
     * @returns {Promise<Object>} A representation of all player sensitive data
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.downloadAllPlayerData = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // sending message to GS
            _this._gamesparks.sendWithData("LogEventRequest", {
                "eventKey": "GDPR_DOWNLOAD"
            }, function (response) {
                if (!response["error"] && response["scriptData"].result === "OK") {
                    resolve(response["scriptData"].playerData);
                }
                else {
                    reject("error downloading player data: " + JSON.stringify(response));
                }
            });
        });
    };
    /**
     * Required by GDPR, this method removes the user completely from the server.
     *
     * @returns {Promise<void>} A promise that all player data is purged from server and the app can quit.
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.removePlayerFromServer = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // sending message to GS
            _this._gamesparks.sendWithData("LogEventRequest", {
                "eventKey": "GDPR_DELETE"
            }, function (response) {
                if (!response["error"]) {
                    resolve();
                }
                else {
                    reject("error removing player data: " + JSON.stringify(response));
                }
            });
        });
    };
    GameSparksBackendService.prototype._checkConnection = function () {
        if (this.state !== GameSparksBackendServiceState.Connected) {
            return;
        }
        // checking amount of tries
        if (this._connectionCheckCounter > GameSparksBackendService.FAIL_GRACEFULLY_AFTER) {
            // Failing "gracefully"
            if (this._isDebugMode) {
                console.log(">>>>>> Failing gracefully");
            }
            this._gamesparks.disconnect();
            this._state = GameSparksBackendServiceState.Disconnected;
            return;
        }
        this._connectionCheckCounter++;
        if (this._isDebugMode) {
            console.log(">>>>>> Checking Connection: " + this._connectionCheckCounter);
        }
        if (this._connectionCheckCounter === 2) {
            if (this._isDebugMode) {
                console.log(">>>>>> Connection Became Unstable");
            }
            // notify connection became unstable
            for (var i = this._networkListeners.length - 1; i >= 0; i--) {
                this._networkListeners[i].unstableConnectionStarted();
            }
        }
        var self = this;
        if (("onLine" in navigator) && navigator.onLine) {
            if (self._connectionCheckCounter > 1) {
                if (self._isDebugMode) {
                    console.log(">>>>>> Connection Became Stable");
                }
                // notify connection got stable again
                for (var i = self._networkListeners.length - 1; i >= 0; i--) {
                    self._networkListeners[i].connectionNormalized();
                }
            }
            self._connectionCheckCounter = 0;
        }
    };
    GameSparksBackendService.prototype._initGameSparks = function (onDone, onError) {
        this._connectionErrorCallback = onError;
        var self = this;
        if (this._isProdBuild) {
            this._gamesparks.initLive({
                key: this._apiKey,
                logger: function (ev) { return self._log(ev); },
                onClose: function (ev) { return self._onCloseWebSocket(ev); },
                onError: function (ev) { return self._onWebSocketError(ev); },
                onInit: function () { return self._onGameSparkInit(onDone); },
                onMessage: function (msg) { return self._onGameSparkMessage(msg); },
                onNonce: function (nounce) { return self._onNonce(nounce); },
                onOpen: function (ev) { return self._onOpenWebSocket(ev); }
            });
        }
        else {
            this._gamesparks.initPreview({
                key: this._apiKey,
                logger: function (ev) { return self._log(ev); },
                onClose: function (ev) { return self._onCloseWebSocket(ev); },
                onError: function (ev) { return self._onWebSocketError(ev); },
                onInit: function () { return self._onGameSparkInit(onDone); },
                onMessage: function (msg) { return self._onGameSparkMessage(msg); },
                onNonce: function (nounce) { return self._onNonce(nounce); },
                onOpen: function (ev) { return self._onOpenWebSocket(ev); }
            });
        }
    };
    /**
     * Callback function to hmac sha256 a nonce with the secret. It's assumed you will have your own method of securing the secret;
     *
     * @private
     * @param {string} nonce String to hash
     * @returns {string}
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._onNonce = function (nonce) {
        return CryptoJS.enc.Base64.stringify(CryptoJS.HmacSHA256(nonce, this._apiSecret));
    };
    /**
     * Init callback
     *
     * @private
     * @param {Function} callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._onGameSparkInit = function (callback) {
        var self = this;
        this._gamesparks.sendWithData("AuthenticationRequest", {
            "password": this._password,
            "userName": this._userId
        }, function (response) {
            self._gameSparksUserId = response["userId"];
            if (self._isDebugMode) {
                console.log("gamesparks user id: " + self._gameSparksUserId);
            }
            self._onLoginResponse(response, callback);
        });
    };
    /**
     * Login callback
     *
     * @private
     * @param {*} response
     * @param {Function} callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._onLoginResponse = function (response, callback) {
        var self = this;
        if (response["error"]) {
            if (response["error"].DETAILS === "UNRECOGNISED") {
                // try registering the user
                this._gamesparks.sendWithData("RegistrationRequest", {
                    "password": this._password,
                    "userName": this._userId,
                    "displayName": "" + this._userId,
                    "segments": {},
                }, function (resp) {
                    if (resp["error"]) {
                        self._state = GameSparksBackendServiceState.Disconnected;
                        if (self._connectionErrorCallback) {
                            self._connectionErrorCallback("error from registering: " + JSON.stringify(response["error"]));
                        }
                    }
                    else {
                        self._onGameSparkInit(callback);
                    }
                });
            }
            else {
                this._state = GameSparksBackendServiceState.Disconnected;
                if (this._connectionErrorCallback) {
                    this._connectionErrorCallback("error from login: " + JSON.stringify(response["error"]));
                }
            }
        }
        else {
            self._syncServerTime(function () {
                if (self._playerConfig) {
                    self._gamesparks.sendWithData("LogEventRequest", {
                        "eventKey": "PD_SAVE",
                        "LABELS": ["__identityInfo"],
                        "DATAS": [self._playerConfig]
                    }, function (resp) {
                        if (callback) {
                            callback();
                        }
                    });
                }
                else if (callback) {
                    callback();
                }
            });
        }
    };
    /**
     * Used to sync the local time to the server time
     *
     * @private
     * @param {Function} callback
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._syncServerTime = function (callback) {
        var _this = this;
        var self = this;
        this.getServerTime(function (data) {
            self._serverTimeDiff = data["time"] - Date.now();
            _this._state = GameSparksBackendServiceState.Connected;
            if (callback) {
                callback();
            }
            if (_this._connectionErrorCallback) {
                _this._connectionErrorCallback = null;
            }
        }, function (error) {
            _this._state = GameSparksBackendServiceState.Disconnected;
            if (_this._connectionErrorCallback) {
                _this._connectionErrorCallback("error from login: " + JSON.stringify(error));
            }
        });
    };
    /**
     * Message handler
     *
     * @private
     * @param {*} msg
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._onGameSparkMessage = function (msg) {
        if (this._isDebugMode) {
            console.log(JSON.stringify(msg));
        }
        // verifying if it's a message for the current room
        if (msg["@class"] === ".ScriptMessage") {
            var data = msg["data"];
            if (data["type"] === "CHALLENGE_MSG") {
                if (this.currentRoom) {
                    if (data["challengeId"] === this.currentRoom.matchID) {
                        // notify the current room
                        this.currentRoom.onMessageReceived(data["msg"]);
                    }
                }
                for (var i = this._listeners.length - 1; i >= 0; i--) {
                    this._listeners[i].messageReceived(msg, this);
                }
            }
            else if (data["type"] === "PLAYER_CONNECTED") {
                for (var i = this._listeners.length - 1; i >= 0; i--) {
                    this._listeners[i].playerConnected(data["playerID"]);
                }
            }
            else if (data["type"] === "PLAYER_DISCONNECTED") {
                for (var i = this._listeners.length - 1; i >= 0; i--) {
                    this._listeners[i].playerDisconnected(data["playerID"]);
                }
            }
            else if (data["type"] === "PLAYER_ROOM_CHANGED") {
                var matchId = data["matchID"];
                if (matchId === "null") {
                    matchId = null;
                }
                for (var i = this._listeners.length - 1; i >= 0; i--) {
                    this._listeners[i].playerRoomUpdate(data["playerID"], matchId);
                }
            }
            else if (data["type"] === "PLAYER_MSG") {
                var _msg = data["msg"];
                if (_msg["ping"]) {
                    var senderId = data["senderId"];
                    if (_msg["ping"] === "send_connection_status") {
                        var payload = {
                            "eventKey": "P_MSG",
                            "USER_ID": senderId,
                            "MSG": {
                                "ping": "connection_status",
                                "userId": this._userId,
                                "online": true,
                                "matchId": ((this._currentRoom) ? this._currentRoom.matchID : "null")
                            }
                        };
                        this._gamesparks.sendWithData("LogEventRequest", payload, function (response) { });
                    }
                    else if (_msg["ping"] === "connection_status") {
                        if (this._checkConnectionCallbacks[senderId]) {
                            // clear the timeout interval
                            clearTimeout(this._checkConnectionTimeouts[senderId]);
                            delete this._checkConnectionTimeouts[senderId];
                            // replies with response status
                            var status_4 = new UserConnectivityStatus();
                            status_4.userId = senderId;
                            status_4.online = true;
                            status_4.currentMatchId = _msg["matchId"];
                            if (status_4.currentMatchId === "null") {
                                status_4.currentMatchId = null;
                            }
                            this._checkConnectionCallbacks[senderId](status_4);
                            delete this._checkConnectionCallbacks[senderId];
                        }
                    }
                }
                else {
                    for (var i = this._listeners.length - 1; i >= 0; i--) {
                        this._listeners[i].messageReceived(_msg, this);
                    }
                }
            }
        }
        else if (msg["@class"] === ".SessionTerminatedMessage") {
            // disconnected by GameSparks (probably a new simultaneous device)
            this._gamesparks.disconnect();
        }
        else {
            if (this._matchMaking) {
                this._matchMaking.messageReceived(msg, this);
            }
        }
    };
    /**
     * Called when the socket is opened
     *
     * @private
     * @param {*} ev
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._onOpenWebSocket = function (ev) {
        if (this._isDebugMode) {
            console.log(">>>>>> Web Socket Opened");
        }
    };
    /**
     * Called when the socket is closed
     *
     * @private
     * @param {*} ev
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._onCloseWebSocket = function (ev) {
        if (this._isDebugMode) {
            console.warn(">>>>>> Web Socket Closed");
        }
        this._state = GameSparksBackendServiceState.Disconnected;
    };
    /**
     * Called when there is an websocket error
     *
     * @private
     * @param {*} ev
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._onWebSocketError = function (ev) {
        if (this._isDebugMode) {
            console.error(">>>>>> Web Socket Error: " + JSON.stringify(ev));
        }
        if (this._connectionErrorCallback) {
            this._connectionErrorCallback(ev);
        }
    };
    /**
     * The logger callback
     *
     * @private
     * @param {*} ev
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._log = function (ev) {
        if (this._isDebugMode) {
            console.log(">>>>>> GameSparks Log: " + JSON.stringify(ev));
        }
    };
    /**
     * Merges the two passed objects
     *
     * @private
     * @param {*} challengeData
     * @param {*} matchData
     * @returns
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype._mergeMatchDataObjects = function (challengeData, matchData) {
        var mergedData = {};
        for (var matchId in matchData) {
            mergedData[matchId] = matchData[matchId];
        }
        for (var matchId in challengeData) {
            if (mergedData[matchId]) {
                mergedData[matchId]["_challengeData"] = challengeData[matchId]["_challengeData"];
            }
        }
        return mergedData;
    };
    /**
     * Private function to be used when the matchmaking is finished
     *
     * @private
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.onFinishMatchmaking = function () {
        if (this._isDebugMode) {
            console.log('GameSparksBackendService::onFinishMatchmaking', this);
        }
        this._matchMaking = undefined;
    };
    /**
     * Converts a challenge array to a map
     *
     * @private
     * @param {*} challengeList
     * @returns {*}
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.prototype.convertToChallengeMap = function (challengeList) {
        if (Array.isArray(challengeList)) {
            // it's the new format
            var challengeMap = {};
            for (var i = challengeList.length - 1; i >= 0; i--) {
                var c = challengeList[i];
                challengeMap[c["id"]] = c;
            }
            return challengeMap;
        }
        else {
            // it's the old format (which was causing GS API Stream to blow up)
            return challengeList;
        }
    };
    /**
     * Internal method for starting the matchmaking
     *
     * @private
     * @static
     * @param {GameSparksBackendService} be
     * @param {String} matchGroupName
     * @param {*} initialData
     * @param {*} playerData
     * @param {*} rank
     * @param {GamesBackendDataCallback} onDone
     * @param {GamesBackendErrorCallback} onError
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.startMatchmaking = function (be, matchGroupName, initialData, playerData, rank, onDone, onError) {
        var date = new Date();
        date.setDate(date.getDate() + 100); // 100 days from now
        var isoDate = GameSparksBackendService.getIsoDateString(date);
        // set or default initialData, add isoDate
        initialData = initialData || {};
        initialData["isoDate"] = isoDate;
        // set or default playerData
        playerData = playerData || {};
        // set or default rank
        rank = rank || 0;
        var requestData = {
            "customQuery": {},
            "matchData": initialData,
            "matchGroup": matchGroupName,
            "matchShortCode": "MATCH_RND",
            "participantData": playerData,
            "skill": rank
        };
        if (be._matchMaking) {
            onError("GameSparksBackendService.startMatchmaking::matchmaking already in progress");
            return;
        }
        be._matchMaking = new GameSparksMatchmaking(be, be.onFinishMatchmaking, onDone, onError);
        be._gamesparks.sendWithData("MatchmakingRequest", requestData, function (response) {
            if (be._isDebugMode) {
                console.log('GameSparksBackendService.startMatchmaking.response -->', response);
            }
        });
    };
    /**
     * Internal method for canceling the matchmaking search
     *
     * @private
     * @static
     * @param {GameSparksBackendService} be
     * @param {String} matchGroupName
     * @param {GamesBackendDoneCallback} onDone
     * @param {GamesBackendErrorCallback} onError
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.cancelMatchmaking = function (be, matchGroupName, onDone, onError) {
        var requestData = {
            "action": "cancel",
            "customQuery": {},
            "matchData": {},
            "matchGroup": matchGroupName,
            "matchShortCode": "MATCH_RND",
            "participantData": {},
            "skill": 0
        };
        be._gamesparks.sendWithData("MatchmakingRequest", requestData, function (response) {
            if (be._isDebugMode) {
                console.log('GameSparksBackendService.cancelMatchmaking.response -->', response);
            }
            be._matchMaking = undefined;
        });
    };
    /**
     * Internal method for creating a challenge
     *
     * @private
     * @static
     * @param {GameSparksBackendService} be
     * @param {string[]} userIds
     * @param {*} initialData
     * @param {GamesBackendCreateMatchCallback} onDone
     * @param {GamesBackendErrorCallback} onError
     * @param {string} [contextId=null]
     * @param {number} [expirationTime=-1]
     * @returns
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.createChallenge = function (be, userIds, initialData, onDone, onError, contextId, expirationTime) {
        if (contextId === void 0) { contextId = null; }
        if (expirationTime === void 0) { expirationTime = -1; }
        if (!be.isInitialized()) {
            console.error("GameSparksBackendService is not initialized");
            if (onError) {
                onError("GameSparksBackendService is not initialized");
            }
            return;
        }
        var date = new Date();
        date.setDate(date.getDate() + 100); // 100 days from now
        var isoDate = GameSparksBackendService.getIsoDateString(date);
        var requestData = be.getDefaultChallengeRequestData();
        requestData.endTime = isoDate;
        if (userIds && userIds.length > 0) {
            requestData.usersToChallenge = userIds;
        }
        else {
            requestData.accessType = "PUBLIC";
        }
        if (contextId) {
            requestData.challengeMessage = contextId;
        }
        be._gamesparks.sendWithData("CreateChallengeRequest", requestData, function (response) {
            var challengeId = response["challengeInstanceId"];
            if (challengeId) {
                if (initialData) {
                    var initial_labels = [];
                    var initial_datas = [];
                    var counter = 0;
                    for (var propertyName in initialData) {
                        if (initialData.hasOwnProperty(propertyName)) {
                            initial_labels[counter] = propertyName;
                            initial_datas[counter] = initialData[propertyName];
                            counter++;
                        }
                    }
                    GameSparksBackendService.saveMatchData(be, challengeId, initial_labels, initial_datas, function () { onDone(challengeId); }, onError, expirationTime);
                }
                else {
                    if (onDone) {
                        onDone(challengeId);
                    }
                }
                return;
            }
            else {
                if (onError) {
                    onError(JSON.stringify(response["error"]));
                }
            }
        });
    };
    /**
     * Configures the check interval for the internet
     *
     * @private
     * @static
     * @type {number}
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.INTERNET_CHECK_INTERVAL = 200; // (in milliseconds)
    /**
     * Configures the number of reconnection attempts to fail gracefully
     *
     * @private
     * @static
     * @type {number}
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.FAIL_GRACEFULLY_AFTER = 10;
    /**
     * Time interval for pinging the server (currently not used, too many API calls !)
     *
     * @private
     * @static
     *
     * @memberOf GameSparksBackendService
     */
    GameSparksBackendService.PING_CHECK_INTERVAL = 1000; // (in milliseconds)
    return GameSparksBackendService;
}());
exports.GameSparksBackendService = GameSparksBackendService;

"use strict";
// tslint:disable:no-string-literal
// tslint:disable:no-unused-variable
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Helper class for matchmaking
 *
 * @export
 * @class GameSparksMatchmaking
 * @implements {IGamesBackendMatchmaking}
 */
var GameSparksMatchmaking = /** @class */ (function () {
    /**
     * Creates an instance of GameSparksMatchmaking.
     *
     * @param {GameSparksBackendService} be Backend service reference
     * @param {GamesBackendDoneCallback} onMatchmakingDone Called on the backend service when matchmaking is done
     * @param {GamesBackendDataCallback} onDone Done callback
     * @param {GamesBackendErrorCallback} onError Error callback
     *
     * @memberOf GameSparksMatchmaking
     */
    function GameSparksMatchmaking(be, onMatchmakingDone, onDone, onError) {
        /**
         * Was a match found
         *
         * @private
         * @type {boolean}
         *
         * @memberOf GameSparksMatchmaking
         */
        this._matchFound = false;
        /**
         * Is the challange started
         *
         * @private
         * @type {boolean}
         * @memberOf GameSparksMatchmaking
         */
        this._challengeStarted = false;
        /**
         * is the match started
         *
         * @private
         * @type {boolean}
         * @memberOf GameSparksMatchmaking
         */
        this._matchStarted = false;
        this._be = be;
        this._onDone = onDone;
        this._onError = onError;
        this._matchFound = false;
        this._challengeStarted = false;
        this._matchStarted = false;
        this._onMatchmakingDone = onMatchmakingDone;
        this._challengeData = {};
    }
    /**
     * Triggered when matchmaking procedure receives an update
     *
     * @param {*} msg
     * @param {GameSparksBackendService} be
     *
     * @memberOf GameSparksMatchmaking
     */
    GameSparksMatchmaking.prototype.messageReceived = function (msg, be) {
        var type = msg["@class"];
        switch (type) {
            case ".MatchNotFoundMessage": {
                if (this._onError) {
                    this._onError("No match found");
                }
                if (this._onMatchmakingDone) {
                    this._onMatchmakingDone.call(be);
                }
                break;
            }
            case ".MatchFoundMessage": {
                this._challengeData["matchData"] = msg["matchData"];
                this._challengeData["participants"] = msg["participants"];
                this._matchFound = true;
                console.log("   _matchData", this._challengeData["matchData"]);
                console.log("   _participants", this._challengeData["participants"]);
                this._checkMatchReady(be);
                break;
            }
            case ".ChallengeStartedMessage": {
                var challenge = msg["challenge"];
                this._challengeData["challengeId"] = challenge["challengeId"];
                this._challengeData["scriptData"] = challenge["scriptData"];
                this._challengeStarted = true;
                this._checkMatchReady(be);
                break;
            }
        }
    };
    /**
     * Check is the matchmaking succeded and call the callbacks
     *
     * @private
     * @param {GameSparksBackendService} be
     *
     * @memberOf GameSparksMatchmaking
     */
    GameSparksMatchmaking.prototype._checkMatchReady = function (be) {
        console.log('GSMatchMaking.checkMatchReady', this._matchFound, this._challengeStarted);
        if (this._matchFound && this._challengeStarted && !this._matchStarted) {
            this._matchStarted = true;
            if (this._onDone) {
                this._onDone(this._challengeData);
            }
            if (this._onMatchmakingDone) {
                this._onMatchmakingDone.call(be);
            }
        }
    };
    return GameSparksMatchmaking;
}());
exports.GameSparksMatchmaking = GameSparksMatchmaking;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var GameSparksBackendService_1 = require("./GameSparksBackendService");
// tslint:disable:no-string-literal
/**
 * Implementation of a match "room" for GameSparks.
 * After getting the room, player is able to receive and send messages, and also check opponent connectivity status.
 *
 * @export
 * @class GameSparksRoom
 * @implements {IGamesBackendRoom}
 */
var GameSparksRoom = /** @class */ (function () {
    /**
     * Creates an instance of GameSparksRoom.
     *
     * @param {string} matchId The id of the match
     * @param {GameSparksBackendService} be The GameSparksBackendService instance
     *
     * @memberOf GameSparksRoom
     */
    function GameSparksRoom(matchId, be) {
        this._matchID = matchId;
        this._be = be;
        this._listeners = [];
        this._connected = false;
    }
    Object.defineProperty(GameSparksRoom.prototype, "matchID", {
        /**
         * The ID of the corresponding match
         *
         * @readonly
         *
         * @memberOf GameSparksRoom
         */
        get: function () {
            return this._matchID;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Method to know if the room is currently connected to the remote server
     *
     * @returns {boolean} If the room is connected
     *
     * @memberOf GamesBackendRoom
     */
    GameSparksRoom.prototype.isConnected = function () {
        return this._connected;
    };
    /**
     * Adds a listener to the room
     *
     * @param {IGamesBackendRoomListener} listener The object which will handle room events
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.addListener = function (listener) {
        this._listeners.push(listener);
    };
    /**
     * Removes a listener from this room
     *
     * @param {IGamesBackendRoomListener} listener The object to remove
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.removeListener = function (listener) {
        var index = this._listeners.indexOf(listener);
        if (index > -1) {
            this._listeners.splice(index, 1);
        }
    };
    /**
     * Sends a message to the other players (when connected to this room)
     *
     * @param {Object} msg The message to send
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.sendMessage = function (msg) {
        GameSparksBackendService.sendRoomMessage(this._be, this._matchID, msg);
    };
    /**
     * Retrieves data stored in the remote server, related to this match
     *
     * @param {string[]} labels The label(s) to retrieve
     * @param {(data: Object) => void} callback A callback which will handle the retrieved data
     * @param {(error: string) => void} errorCallback A callback to be called if the method fails
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.getMatchData = function (labels, callback, errorCallback) {
        var self = this;
        this._be.getMatchesData([this._matchID], labels, function (data) { return callback(data[self._matchID]); }, errorCallback);
    };
    /**
     * Saves data in the remote server, related to this match
     *
     * @param {string[]} labels The labels to save
     * @param {any[]} datas The data to save
     * @param {() => void} callback A callback to be called after the data is saved
     * @param {(error: string) => void} errorCallback A callback to be called if the method fails
     * @param {number} [expirationTime] Optional parameter to set an expiration time for this match (in seconds)
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.saveMatchData = function (labels, datas, callback, errorCallback, expirationTime) {
        if (expirationTime === void 0) { expirationTime = -1; }
        GameSparksBackendService.saveMatchData(this._be, this._matchID, labels, datas, callback, errorCallback, expirationTime);
    };
    /**
     * Remove all listeners, notify GameSparks and disconnect room from the remote server
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.leaveRoom = function () {
        // clear listeners
        this.disconnect();
        // clear BackendService
        this._be.cleanUpRoom();
    };
    /**
     * Cleans up the room and notifies the listeners
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.disconnect = function () {
        for (var i = this._listeners.length - 1; i >= 0; i--) {
            this._listeners[i].disconnected(this);
        }
        this._listeners = [];
        this._connected = false;
    };
    /**
     * Triggered after the room is connected, will notify GameSparks and then all listeners
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.connect = function () {
        var self = this;
        // notify GameSparks about current match Id
        this._be.sendWithData("LogEventRequest", {
            "MATCH_ID": this._matchID,
            "eventKey": "PLAYER_ROOM_SET"
        }, function (response) {
            if (!response["error"] && response["scriptData"].result === "OK") {
                self._connected = true;
                for (var i = self._listeners.length - 1; i >= 0; i--) {
                    self._listeners[i].connected(self);
                }
            }
        });
    };
    /**
     * Handles a message forwarded by the GamesBackendService to this room
     *
     * @param {Object} msg The message to be forwarded to this room's listeners
     *
     * @memberOf GameSparksRoom
     */
    GameSparksRoom.prototype.onMessageReceived = function (msg) {
        for (var i = this._listeners.length - 1; i >= 0; i--) {
            this._listeners[i].messageReceived(msg, this);
        }
    };
    return GameSparksRoom;
}());
exports.GameSparksRoom = GameSparksRoom;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

//******************************************************
//*****    Script Resource: images_publisher_core
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// coolgames-imagespublisher-core (1.0.0-builder)
// Generated on Tue Jan 23 2018 14:44:33 GMT+0100 (W. Europe Standard Time)
// DO NOT MODIFY THIS FILE ! 
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
	return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

//******************************************************
//*****    Script Resource: images_publisher_uno
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-imagespublisher-uno (1.0.1-builder)
// ---------------------------------------------------------------------------------------
// Generated on Wed May 02 2018 11:39:07 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-imagespublisher-core (1.0.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * UNO concrete implementation of the Images Publisher Service
 *
 * @export
 * @class UNOImagesPublisherService
 * @implements {IImagesPublisherService}
 */
var UNOImagesPublisherService = /** @class */ (function () {
    /**
     * Creates an instance of UNOImagesPublisherService.
     *
     * @param {string} appId The app id
     * @param {boolean} [isProd] If the images are uploaded to production (live). Default "true"
     *
     * @memberOf UNOImagesPublisherService
     */
    function UNOImagesPublisherService(appId, isProd) {
        if (isProd === void 0) { isProd = true; }
        this._appId = appId;
        this._endPoint = (isProd) ? UNOImagesPublisherService.UNO_ENDPOINT_PROD : UNOImagesPublisherService.UNO_ENDPOINT_STAGE;
    }
    /**
     * Uploads an image to the server and gets an url back.
     *
     * @param {string} userId The id of the player which the stored file will be associated
     * @param {string} image The image, in a base64 encoded string
     * @returns {Promise<string>} A promise with the url of the published image file
     *
     * @memberOf UNOImagesPublisherService
     */
    UNOImagesPublisherService.prototype.uploadImage = function (userId, image) {
        var _this = this;
        var self = this;
        return new Promise(function (resolve, reject) {
            if (!userId || !image) {
                reject("not possible to upload image without userId or image");
            }
            else {
                var uploadUrl = _this._endPoint + "/" + self._appId + "/" + userId;
                var blob = UNOImagesPublisherService._base64ImageToBlob(image);
                var xhr_1 = new XMLHttpRequest();
                xhr_1.open('POST', uploadUrl, true);
                xhr_1.onload = function () {
                    if (xhr_1.response && xhr_1.status !== 200) {
                        reject(xhr_1.responseText);
                    }
                    else {
                        resolve(xhr_1.responseText);
                    }
                };
                xhr_1.onerror = function (error) {
                    reject("error on uploading image : " + error.target.status);
                };
                xhr_1.send(blob);
            }
        });
    };
    /**
     * Converts a base64 string to a blob, so it can be sent to UNO
     *
     * @private
     * @static
     * @param {string} imageStr The image, as a base64 string
     * @returns {Blob} The string converted to a blob
     *
     * @memberOf UNOImagesPublisherService
     */
    UNOImagesPublisherService._base64ImageToBlob = function (imageStr) {
        var byteString = atob(imageStr.split(',')[1]);
        var imageType = UNOImagesPublisherService._getContentTypeFromBase64String(imageStr);
        var ab = new ArrayBuffer(byteString.length);
        var ia = new Uint8Array(ab);
        for (var i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        return (new Blob([ab], { type: imageType }));
    };
    /**
     * Extracts the content type from a base64 string image
     *
     * @private
     * @static
     * @param {string} imageStr The image, as a base64 string
     * @returns {string} The content type from the image
     *
     * @memberOf UNOImagesPublisherService
     */
    UNOImagesPublisherService._getContentTypeFromBase64String = function (imageStr) {
        // Example of base64 image: "data:image/jpeg;base64....."
        return imageStr.split(';')[0].split(':')[1];
    };
    /**
     * The PROD endpoint url from the uno imageuploader service
     *
     * @private
     * @static
     * @type {string}
     * @memberOf UNOImagesPublisherService
     */
    UNOImagesPublisherService.UNO_ENDPOINT_PROD = "https://imageuploader.facebook.live.uno.one/production/upload";
    /**
     * The STAGE endpoint url from the uno imageuploader service
     *
     * @private
     * @static
     * @type {string}
     * @memberOf UNOImagesPublisherService
     */
    UNOImagesPublisherService.UNO_ENDPOINT_STAGE = "https://imageuploader.facebook.stage.uno.one/production/upload";
    return UNOImagesPublisherService;
}());
exports.UNOImagesPublisherService = UNOImagesPublisherService;
//******************************************************
//*****    Script Resource: instant_notification_core
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-instantnotifications-core (2.3.0-builder)
// ---------------------------------------------------------------------------------------
// Generated on Tue Jan 29 2019 15:11:46 GMT+0100 (W. Europe Standard Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a notification to be sent to a user.
 *
 * @export
 * @class InstantNotification
 */
var InstantNotification = /** @class */ (function () {
    function InstantNotification() {
    }
    return InstantNotification;
}());
exports.InstantNotification = InstantNotification;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

//******************************************************
//*****    Script Resource: instant_notifications_gamesparks
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-instantnotifications-gamesparks (2.3.0-builder)
// ---------------------------------------------------------------------------------------
// Generated on Tue Jan 29 2019 16:36:26 GMT+0100 (W. Europe Standard Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-backend-core (1.1.0-builder)
// - coolgames-backend-gamesparks (1.2.0-builder)
// - coolgames-imagespublisher-core (1.0.0-builder)
// - coolgames-instantnotifications-core (2.3.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_instantnotifications_core_1 = require("@coolgames/coolgames-instantnotifications-core");
/**
 * Concrete Instant Notification implementation for GameSparks
 *
 * @export
 * @class GameSparksInstantNotificationsService
 * @implements {IInstantNotificationsService}
 */
var GameSparksInstantNotificationsService = /** @class */ (function () {
    /**
     * Creates an instance of GameSparksInstantNotificationsService.
     * @param {GameSparksBackendService} gameSparksService The GameSparks service instance
     * @param {string} appAccessToken The Messenger Platform app-access-token (to send the gamebot messages)
     * @param {IImagesPublisherService} imagesPublisherService
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    function GameSparksInstantNotificationsService(gameSparksService, appAccessToken, imagesPublisherService) {
        this._appAccessToken = appAccessToken;
        this._gameSparksService = gameSparksService;
        this._imagesPublisherService = imagesPublisherService;
    }
    /**
     * Schedules a GameBot notification for a user.
     *
     * @param {string} userId The id of the user to send the notification
     * @param {InstantNotification} notification The notification to schedule
     * @param {number} [priority] The priority of the notification.
     * @returns {Promise<string>} The id of the scheduled notification
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.scheduleNotification = function (userId, notification, priority) {
        var _this = this;
        userId = userId.toLowerCase();
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
            }
            else {
                if (notification.image && !notification.imageUrl && _this._imagesPublisherService) {
                    _this._imagesPublisherService.uploadImage(userId, notification.image).then(function (imageUrl) {
                        notification.imageUrl = imageUrl;
                        _this._sendScheduleEvent(userId, notification, priority, resolve, reject);
                    }, function (error) {
                        console.warn("Couldn't upload image... scheduling it anyways");
                        _this._sendScheduleEvent(userId, notification, priority, resolve, reject);
                    });
                }
                else {
                    _this._sendScheduleEvent(userId, notification, priority, resolve, reject);
                }
            }
        });
    };
    /**
     * Cancels the referenced notifications.
     *
     * @param {string} userId The id of the user
     * @param {string[]} notificationIds The ids of the notifications to cancel
     * @returns {Promise<void>} Confirmation promise
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.cancelScheduledNotifications = function (userId, notificationIds) {
        var _this = this;
        userId = userId.toLowerCase();
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
            }
            else {
                _this._gameSparksService.sendWithData("LogEventRequest", {
                    "eventKey": "INST_CANCEL",
                    "USER_ID": userId,
                    "NOTIFICATION_IDS": notificationIds
                }, function (response) {
                    if (!response.error && response.scriptData.result === "OK") {
                        resolve();
                    }
                    else {
                        reject("error cancelling notifications: " + JSON.stringify(response));
                    }
                });
            }
        });
    };
    /**
     * Cancels all schedule notifications from the specified user.
     * This method is handy when you start the application and want to clear everything from the server.
     *
     * @param {string} userId The id of the user
     * @returns {Promise<void>} Confirmation promise
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.cancelAllScheduleNotifications = function (userId) {
        var _this = this;
        userId = userId.toLowerCase();
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
            }
            else {
                _this._gameSparksService.sendWithData("LogEventRequest", {
                    "eventKey": "INST_CANCEL_ALL",
                    "USER_ID": userId
                }, function (response) {
                    if (!response.error && response.scriptData.result === "OK") {
                        resolve();
                    }
                    else {
                        reject("error cancelling all notifications: " + JSON.stringify(response));
                    }
                });
            }
        });
    };
    /**
     *
     * Gets a list of all notifications scheduled on the server side for the specified user.
     *
     * @param {string} userId The id of the user
     * @returns {Promise<string[]>} A list of notification ids
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.getScheduleNotifications = function (userId) {
        var _this = this;
        userId = userId.toLowerCase();
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
            }
            else {
                _this._gameSparksService.sendWithData("LogEventRequest", {
                    "eventKey": "INST_GET_LIST",
                    "USER_ID": userId
                }, function (response) {
                    if (!response.error && response.scriptData.result === "OK") {
                        resolve(response.scriptData.notificationIds);
                    }
                    else {
                        reject("error getting notification list: " + JSON.stringify(response));
                    }
                });
            }
        });
    };
    /**
     * Gets info from a specific notification.
     *
     * @param {string} userId The id of the user
     * @param {string} notificationId The notification id
     * @returns {Promise<InstantNotification>} The Notification info
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.getNotificationInfo = function (userId, notificationId) {
        var _this = this;
        userId = userId.toLowerCase();
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
            }
            else {
                _this._gameSparksService.sendWithData("LogEventRequest", {
                    "eventKey": "INST_GET_INFO",
                    "USER_ID": userId,
                    "NOTIFICATION_ID": notificationId
                }, function (response) {
                    if (!response.error && response.scriptData.result === "OK") {
                        var notificationResp = response.scriptData.notification;
                        if (notificationResp) {
                            var notificationInfo = new InstantNotification();
                            notificationInfo.scheduleTime = Date.now() + notificationResp.seconds;
                            notificationInfo.reminderMessage = notificationResp.message;
                            notificationInfo.reminderSubtitle = notificationResp.subtitle;
                            notificationInfo.buttons = notificationResp.buttons;
                            notificationInfo.payloads = notificationResp.payloads;
                            notificationInfo.image = notificationResp.image;
                            resolve(notificationInfo);
                        }
                        else {
                            reject("couldn't get notification info");
                        }
                    }
                    else {
                        reject("error getting notification info: " + JSON.stringify(response));
                    }
                });
            }
        });
    };
    /**
     * Adds a match notification at the end of the turn.
     *
     * The message is added to be sent to the next player (the player who has to take action in the next turn)
     *
     * @param {string} matchId The match id
     * @param {string} nextPlayerId The player who has to take action in the next turn
     * @param {IInstantMessage} message The message to be sent by the gamebot
     * @param {number} [displayRank] An optional priority - as higher the better (in case of a carrousel is used)
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.addEndOfTurnMatchNofitication = function (matchId, nextPlayerId, message, displayRank) {
        var _this = this;
        nextPlayerId = nextPlayerId.toLowerCase();
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
            }
            else if (!message.image && !message.imageUrl) {
                console.error("Image parameter is mandatory for Match Notifications");
                reject("Image parameter is mandatory for Match Notifications");
            }
            else {
                var promise = new Promise(function (emptyResolve, emptyReject) {
                    emptyResolve(message.imageUrl);
                });
                if (message.image && !message.imageUrl && _this._imagesPublisherService) {
                    promise = _this._imagesPublisherService.uploadImage(nextPlayerId, message.image);
                }
                promise.then(function (imageUrl) {
                    message.imageUrl = imageUrl;
                    delete (message.image);
                    _this._gameSparksService.sendWithData("LogEventRequest", {
                        "eventKey": "INST_MSG_ADD_MATCH",
                        "MATCH_ID": matchId,
                        "NEXT_PLAYER_ID": nextPlayerId,
                        "MSG": message,
                        "RANK": displayRank
                    }, function (response) {
                        if (!response.error && response.scriptData.result === "OK") {
                            resolve();
                        }
                        else {
                            reject("error removing match notification: " + JSON.stringify(response));
                        }
                    });
                }, function (error) {
                    console.error("Couldn't upload image, match notification won't be sent");
                    reject("Couldn't upload image, match notification won't be sent");
                });
            }
        });
    };
    /**
     * Removes a notification for a match that is finished (game over, deleted, expired, etc)
     *
     * @param {string} finishedMatchId The id of the match to remove
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.removeMatchNotification = function (finishedMatchId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
            }
            else {
                _this._gameSparksService.sendWithData("LogEventRequest", {
                    "eventKey": "INST_MSG_REM_MATCH",
                    "MATCH_ID": finishedMatchId
                }, function (response) {
                    if (!response.error && response.scriptData.result === "OK") {
                        resolve();
                    }
                    else {
                        reject("error removing match notification: " + JSON.stringify(response));
                    }
                });
            }
        });
    };
    /**
     * Method used to upload a user specific image to be shared on Suggested Friend messages.
     * If the user doesn't upload an image, friends won't get the suggestion messages.
     *
     * @param {{ url?: string, base64?: string }} image The image url or a base64 string
     * @return {Promise<void>} The promise that the shared image will be uploaded for the current user
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.setSuggestedFriendSharedImage = function (image) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // checking if service is initialized
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                return;
            }
            // checking if parameter contains url or base64 image
            if (!image.url && !image.base64) {
                console.error("Please specify an image url or a base64 image on setSuggestedFriendSharedImage");
                reject("Please specify an image url or a base64 image on setSuggestedFriendSharedImage");
                return;
            }
            // getting current user info
            var playerInfo = _this._gameSparksService.playerConfig;
            if (!playerInfo) {
                console.error("The player config must be present on GameSparksBackendService to update suggested friend notifications");
                reject("The player config must be present on GameSparksBackendService to update suggested friend notifications");
                return;
            }
            var promise = new Promise(function (emptyResolve, emptyReject) {
                emptyResolve(image.url);
            });
            if (image.base64 && !image.url && _this._imagesPublisherService) {
                promise = _this._imagesPublisherService.uploadImage(playerInfo.userID, image.base64);
            }
            promise.then(function (imageUrl) {
                _this._gameSparksService.sendWithData("LogEventRequest", {
                    "eventKey": "INST_MSG_SET_SUG_FRIENDS_IMG",
                    "IMG_URL": imageUrl
                }, function (response) {
                    if (!response.error && response.scriptData.result === "OK") {
                        resolve();
                    }
                    else {
                        reject("error setting share image for suggested friend notifications: " + JSON.stringify(response));
                    }
                });
            }, function (error) {
                console.error("Couldn't upload image, shared image won't be sent");
                reject("Couldn't upload image, shared image won't be sent");
            });
        });
    };
    /**
     * Method used to push suggested friend notifications to the user. Please keep bandwidth in mind!
     * The server keeps the same order defined by client inside the carrousel, but in FB there's a limit of 10 images.
     * If the limit is reached, exceeded messages are kept for the next time user will get a scheduled message.
     * Images cannot be sent from this method (each friend will push a shared image to be used instead).
     *
     * @param {ISuggestedFriendMessage[]} notifications The notifications to push to server (without images!)
     * @return {Promise<void>} The promise that notifications will be stored for the current player
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.setSuggestedFriendNotifications = function (notifications) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // checking if service is initialized
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                return;
            }
            _this._gameSparksService.sendWithData("LogEventRequest", {
                "eventKey": "INST_MSG_SET_SUG_FRIENDS_MSG",
                "NOTIFICATIONS": notifications
            }, function (response) {
                if (!response.error && response.scriptData.result === "OK") {
                    resolve();
                }
                else {
                    reject("error setting suggested friend notifications: " + JSON.stringify(response));
                }
            });
        });
    };
    /**
     * Method used to push leaderboard updates to friends.
     * The limit depends on server and messenger platform (in FB and GS the limit is 10).
     * If the limit is reached, exceeded messages are kept for the next time user will get a scheduled message.
     *
     * @param {string[]} friends The IDs of the friends that will receive the corresponding messages
     * @param {IInstantMessage[]} notifications The messages to push to the server
     * @returns {Promise<void>} The promise that it will register these messages
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.addLeaderboardNotifications = function (friends, notifications) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // checking if service is initialized
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                return;
            }
            if (!friends || !notifications || !(friends.length > 0) || (friends.length !== notifications.length)) {
                console.error("Invalid parameters passed to addLeaderboardNotifications");
                reject("Invalid parameters passed to addLeaderboardNotifications");
                return;
            }
            for (var i = 0; i < friends.length; i++) {
                friends[i] = friends[i].toLowerCase();
            }
            _this._gameSparksService.sendWithData("LogEventRequest", {
                "eventKey": "INST_MSG_ADD_LB",
                "FRIENDS": friends,
                "NOTIFICATIONS": notifications
            }, function (response) {
                if (!response.error && response.scriptData.result === "OK") {
                    resolve();
                }
                else {
                    reject("error adding leaderboard notifications: " + JSON.stringify(response));
                }
            });
        });
    };
    /**
     * Method used to remove all the leaderboard notifications registered for the current user
     * This should be called in two cases:
     *  1. when the user visits the leaderboard screen
     *              OR
     *  2. the player position on the leaderboard increased (to remove potential outdated messages)
     *
     * @returns {Promise<void>} The promise that it will remove the messages
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.removeLeaderboardNotifications = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // checking if service is initialized
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                return;
            }
            _this._gameSparksService.sendWithData("LogEventRequest", {
                "eventKey": "INST_MSG_REM_LB"
            }, function (response) {
                if (!response.error && response.scriptData.result === "OK") {
                    resolve();
                }
                else {
                    reject("error adding leaderboard notifications: " + JSON.stringify(response));
                }
            });
        });
    };
    /**
     * Method used to check if the users can receive instant notifications
     *
     * @param {string[]} userIds
     * @returns {Promise<IUserNotificationStatus[]>}
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype.canUsersReceiveNotifications = function (userIds) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // checking if service is initialized
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                reject("GameSparksBackendService is required to be initialized for working with Instant Notifications");
                return;
            }
            userIds = userIds.map(function (userId) {
                return userId.toLowerCase();
            });
            _this._gameSparksService.sendWithData("LogEventRequest", {
                "eventKey": "INST_MSG_FOLLOWING",
                "IDS": userIds
            }, function (response) {
                if (!response.error && response.scriptData.result === "OK" && response.scriptData.list) {
                    var result = [];
                    for (var i = 0; i < response.scriptData.list.length; i++) {
                        var item = response.scriptData.list[i];
                        result.push({ id: item.id, canReceiveNotifications: item.following });
                    }
                    resolve(result);
                }
                else {
                    reject("canUsersReceiveNotifications error: " + JSON.stringify(response));
                }
            });
        });
    };
    /**
     * Internal function which sends the notification information to GameSparks
     *
     * @private
     * @param {string} userId The user which will receive the scheduled message
     * @param {InstantNotification} notification The notification info
     * @param {number} priority The priority of the notification
     * @param {*} resolve The resolve function from the caller Promise
     * @param {*} reject The reject function from the caller Promise
     *
     * @memberOf GameSparksInstantNotificationsService
     */
    GameSparksInstantNotificationsService.prototype._sendScheduleEvent = function (userId, notification, priority, resolve, reject) {
        var seconds = notification.scheduleTime.getTime() - Date.now();
        if (!seconds || seconds < 0) {
            seconds = 0;
        }
        seconds = Math.floor(seconds / 1000);
        var payload = {
            "eventKey": "INST_SCHED",
            "USER_ID": userId,
            "APP_TOKEN": this._appAccessToken,
            "NOTIFICATION": {
                "priority": priority,
                "seconds": seconds,
                "message": notification.reminderMessage,
                "subtitle": notification.reminderSubtitle,
                "buttons": notification.buttons,
                "payloads": notification.payloads
            }
        };
        if (notification.imageUrl) {
            payload.NOTIFICATION.image = notification.imageUrl;
        }
        this._gameSparksService.sendWithData("LogEventRequest", payload, function (response) {
            if (!response.error && response.scriptData.result === "OK") {
                resolve(response.scriptData.notificationId || "");
            }
            else {
                reject("error scheduling notification: " + JSON.stringify(response));
            }
        });
    };
    return GameSparksInstantNotificationsService;
}());
exports.GameSparksInstantNotificationsService = GameSparksInstantNotificationsService;

//******************************************************
//*****    Script Resource: coolgames_ads_core
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// coolgames-ads-core (1.0.4-builder)
// Generated on Thu Apr 19 2018 12:10:16 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Statuses from the Ad Service class
 *
 * @export
 * @enum {number}
 */
var AdServiceStatus;
(function (AdServiceStatus) {
    AdServiceStatus[AdServiceStatus["SUCCESS"] = 0] = "SUCCESS";
    AdServiceStatus[AdServiceStatus["NOT_INITIALIZED"] = 1] = "NOT_INITIALIZED";
    AdServiceStatus[AdServiceStatus["NO_AD_SUPPORT"] = 2] = "NO_AD_SUPPORT";
    AdServiceStatus[AdServiceStatus["AD_BEING_WATCHED"] = 3] = "AD_BEING_WATCHED";
    AdServiceStatus[AdServiceStatus["TIMER_STILL_RUNNING"] = 4] = "TIMER_STILL_RUNNING";
    AdServiceStatus[AdServiceStatus["NO_PLACEMENT_ID"] = 5] = "NO_PLACEMENT_ID";
})(AdServiceStatus = exports.AdServiceStatus || (exports.AdServiceStatus = {}));
/**
 * Loading statuses from the ads
 *
 * @export
 * @enum {number}
 */
var AdLoadingStatus;
(function (AdLoadingStatus) {
    AdLoadingStatus[AdLoadingStatus["LOADING"] = 0] = "LOADING";
    AdLoadingStatus[AdLoadingStatus["LOADED"] = 1] = "LOADED";
    AdLoadingStatus[AdLoadingStatus["NOT_LOADED"] = 2] = "NOT_LOADED";
})(AdLoadingStatus = exports.AdLoadingStatus || (exports.AdLoadingStatus = {}));
//******************************************************
//*****    Script Resource: coolgames_ads_fbinstant
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-ads-fbinstant (2.0.0-builder)
// ---------------------------------------------------------------------------------------
// Generated on Thu Apr 19 2018 17:36:15 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-ads-core (1.0.4-builder)
// - coolgames-messagingplatform-core (1.0.0-builder)
// - coolgames-messagingplatform-fbinstant (1.0.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
	return exports;
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	return new (P || (P = Promise))(function (resolve, reject) {
		function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
var __generator = (this && this.__generator) || function (thisArg, body) {
	var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	function verb(n) { return function (v) { return step([n, v]); }; }
	function step(op) {
		if (f) throw new TypeError("Generator is already executing.");
		while (_) try {
			if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
			if (y = 0, t) op = [0, t.value];
			switch (op[0]) {
				case 0: case 1: t = op; break;
				case 4: _.label++; return { value: op[1], done: false };
				case 5: _.label++; y = op[1]; op = [0]; continue;
				case 7: op = _.ops.pop(); _.trys.pop(); continue;
				default:
					if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
					if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
					if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
					if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
					if (t[2]) _.ops.pop();
					_.trys.pop(); continue;
			}
			op = body.call(thisArg, _);
		} catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
		if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	}
};
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_ads_core_1 = require("@coolgames/coolgames-ads-core");
/**
 * Concrete implementation of the IAdService interface for FB Instant Games
 *
 * @export
 * @class InstantGameAdsService
 * @implements {IAdService}
 */
var InstantGameAdsService = /** @class */ (function () {
	/**
	 * Creates an instance of InstantGameAdsService.
	 *
	 * @param {FBMessagingPlatformService} messagingService The FB
	 *
	 * @memberOf InstantGameAdsService
	 */
	function InstantGameAdsService(messagingService) {
		/**
		 * If the sdk configuration supports interstitials
		 *
		 * @private
		 * @type {boolean}
		 * @memberOf InstantGameAdsService
		 */
		this._isSupportingInterstitialAds = true;
		/**
		 * If the sdk configuration supports rewarding ads (videos)
		 *
		 * @private
		 * @type {boolean}
		 * @memberOf InstantGameAdsService
		 */
		this._isSupportingRewardedAds = true;
		/**
		 * The current insterstitial placement id
		 *
		 * @private
		 * @type {string}
		 * @memberOf InstantGameAdsService
		 */
		this._interstitialPlacementId = null;
		/**
		 * The current rewarded video placement id
		 *
		 * @private
		 * @type {string}
		 * @memberOf InstantGameAdsService
		 */
		this._rewardedPlacementId = null;
		/**
		 * The loading status of the insterstitial ad
		 *
		 * @private
		 * @type {number}
		 * @memberOf InstantGameAdsService
		 */
		this._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
		/**
		 * The loading status of the rewarding video
		 *
		 * @private
		 * @type {number}
		 * @memberOf InstantGameAdsService
		 */
		this._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
		/**
		 * The current promise for the loading of the interstitial
		 *
		 * @private
		 * @type {Promise<void>}
		 * @memberOf InstantGameAdsService
		 */
		this._interstitialLoadPromise = null;
		/**
		 * The current promise for the loading of the rewarding video
		 *
		 * @private
		 * @type {Promise<void>}
		 * @memberOf InstantGameAdsService
		 */
		this._rewardedLoadPromise = null;
		/**
		 * If this service instance is initialized
		 *
		 * @private
		 * @type {boolean}
		 * @memberOf InstantGameAdsService
		 */
		this._isInitialized = false;
		/**
		 * If user is watching an ad
		 *
		 * @private
		 * @type {boolean}
		 * @memberOf InstantGameAdsService
		 */
		this._isWatching = false;
		/**
		 * Cooldown timer for rewarding videos
		 *
		 * @private
		 * @type {number}
		 * @memberOf InstantGameAdsService
		 */
		this._rewardedTimer = 0;
		/**
		 * Cooldown timer for interstitials
		 *
		 * @private
		 * @type {number}
		 * @memberOf InstantGameAdsService
		 */
		this._interstitialTimer = 0;
		/**
		 * The callback to be triggered when an ad instance is available after a request (successful ad request)
		 *
		 * @private
		 * @type {Function}
		 * @memberOf InstantGameAdsService
		 */
		this._interstitialAdRequestCallback = null;
		/**
		 * The callback to be triggered when an ad instance is available after a request (successful ad request)
		 *
		 * @private
		 * @type {Function}
		 * @memberOf InstantGameAdsService
		 */
		this._rewardedAdRequestCallback = null;
		this._messagingService = messagingService;
		this._instantSDK = this._messagingService.getFBInstant();
	}
	/**
	 * Initializes the Ad Service
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.initialize = function () {
		var _this = this;
		var self = this;
		return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
			var _this = this;
			return __generator(this, function (_a) {
				self._messagingService.addInitListener({
					initializationFinished: function () {
						self._isSupportingInterstitialAds = _this._interstitialAdSupport();
						self._isSupportingRewardedAds = _this._rewardedAdSupport();
						self._isInitialized = true;
						resolve();
					},
					initializationFailed: function (reason) {
						reject("InstantGameAdsService failed to initialize : " + reason);
					}
				});
				return [2 /*return*/];
			});
		}); });
	};
	/**
	 * Convenience method to know if interstitials are supported
	 *
	 * @returns {boolean} If interstitials are supported
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.isInterstitialAdsSupported = function () {
		if (!this._isInitialized) {
			throw new Error("InstantGameAds not initialized");
		}
		return this._isSupportingInterstitialAds;
	};
	/**
	 * Convenience method to know if rewarded ads are supported
	 *
	 * @returns {boolean} If rewarded ads are supported
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.isRewardedAdsSupported = function () {
		if (!this._isInitialized) {
			throw new Error("InstantGameAds not initialized");
		}
		return this._isSupportingRewardedAds;
	};
	/**
	 * Sets interstitial restriction timer
	 *
	 * @param {number} timer Cooldown for interstitials (in milliseconds, from now)
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.setInterstitialTimer = function (timer) {
		this._interstitialTimer = timer + Date.now();
	};
	/**
	 * Sets rewarded restriction timer
	 *
	 * @param {number} timer Cooldown for rewarded videos (in milliseconds, from now)
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.setRewardedTimer = function (timer) {
		this._rewardedTimer = timer + Date.now();
	};
	/**
	 * Convenience method to check if the timer is still restricting insterstitials
	 *
	 * @returns {boolean} If the restrictive timer is active for interstitials
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.isInterstitialTimerActive = function () {
		return ((this._interstitialTimer - Date.now()) > 0);
	};
	/**
	 * Convenience method to check if the timer is still restricting rewarded ads
	 *
	 * @returns {boolean} If the restrictive timer is active for rewarded ads
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.isRewardedTimerActive = function () {
		return ((this._rewardedTimer - Date.now()) > 0);
	};
	/**
	 * Sets the placement id for interstitials
	 *
	 * @param {string} placementId The placement id
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.setInterstitialId = function (placementId) {
		this._interstitialPlacementId = placementId;
	};
	/**
	 * Sets the placement id for rewarding videos
	 *
	 * @param {string} placementId The placement id
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.setRewardedId = function (placementId) {
		this._rewardedPlacementId = placementId;
	};
	/**
	 * Sets the callback for the interstitial ads filling
	 *
	 * @param {Function} callback Function to be called if the request for the ad succeeds
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.setInterstitialAdRequestCallback = function (callback) {
		this._interstitialAdRequestCallback = callback;
	};
	/**
	 * Sets the callback for the rewarding video ads filling
	 *
	 * @param {Function} callback Function to be called if the request for the ad succeeds
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.setRewardedAdRequestCallback = function (callback) {
		this._rewardedAdRequestCallback = callback;
	};
	/**
	 * Preload an interstitial ad
	 *
	 * @returns {Promise<AdServiceStatus>} A promise which resolves with the status, or rejects with a FB error
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.prepareInterstitialAd = function () {
		var _this = this;
		var self = this;
		return new Promise(function (resolve, reject) {
			if (!_this._isInitialized) {
				resolve(AdServiceStatus.NOT_INITIALIZED);
				return;
			}
			if (!_this._isSupportingInterstitialAds) {
				resolve(AdServiceStatus.NO_AD_SUPPORT);
				return;
			}
			if (!_this._interstitialPlacementId) {
				resolve(AdServiceStatus.NO_PLACEMENT_ID);
				return;
			}
			if (_this._interstitialInstance && _this._interstitialLoadStatus === AdLoadingStatus.LOADED) {
				resolve(AdServiceStatus.SUCCESS);
				return;
			}
			else if (_this._interstitialInstance && _this._interstitialLoadStatus === AdLoadingStatus.NOT_LOADED) {
				_this._interstitialLoadPromise = _this._interstitialInstance.loadAsync();
				_this._interstitialLoadStatus = AdLoadingStatus.LOADING;
				_this._interstitialLoadPromise
					.then(function () {
					self._interstitialLoadStatus = AdLoadingStatus.LOADED;
					resolve(AdServiceStatus.SUCCESS);
				})
					.catch(function (e) {
					self._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
					self._interstitialInstance = null;
					reject(e);
				});
				return;
			}
			else if (_this._interstitialInstance && _this._interstitialLoadStatus === AdLoadingStatus.LOADING) {
				_this._interstitialLoadPromise
					.then(function () {
					self._interstitialLoadStatus = AdLoadingStatus.LOADED;
					resolve(AdServiceStatus.SUCCESS);
				})
					.catch(function (e) {
					self._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
					self._interstitialInstance = null;
					reject(e);
				});
				return;
			}
			_this._instantSDK.getInterstitialAdAsync(_this._interstitialPlacementId)
				.then(function (ad) {
				return _this._loadInterstitial(ad);
			})
				.then(function () {
				self._interstitialLoadStatus = AdLoadingStatus.LOADED;
				resolve(AdServiceStatus.SUCCESS);
			})
				.catch(function (e) {
				self._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
				self._interstitialInstance = null;
				reject(e);
			});
		});
	};
	/**
	 * Preloads a rewarded ad
	 *
	 * @returns {Promise<AdServiceStatus>} A promise which resolves with the status, or rejects with a FB error
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.prepareRewardedAd = function () {
		var _this = this;
		var self = this;
		return new Promise(function (resolve, reject) {
			if (!_this._isInitialized) {
				resolve(AdServiceStatus.NOT_INITIALIZED);
				return;
			}
			if (!_this._isSupportingRewardedAds) {
				resolve(AdServiceStatus.NO_AD_SUPPORT);
				return;
			}
			if (!_this._rewardedPlacementId) {
				resolve(AdServiceStatus.NO_PLACEMENT_ID);
				return;
			}
			if (_this._rewardedInstance && _this._rewardedLoadStatus === AdLoadingStatus.LOADED) {
				resolve(AdServiceStatus.SUCCESS);
				return;
			}
			if (_this._rewardedInstance && _this._rewardedLoadStatus === AdLoadingStatus.NOT_LOADED) {
				_this._rewardedLoadStatus = AdLoadingStatus.LOADING;
				_this._rewardedLoadPromise = _this._rewardedInstance.loadAsync()
					.then(function () {
					self._rewardedLoadStatus = AdLoadingStatus.LOADED;
					resolve(AdServiceStatus.SUCCESS);
				})
					.catch(function (e) {
					self._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
					self._rewardedInstance = null;
					reject(e);
				});
				return;
			}
			if (_this._rewardedInstance && _this._rewardedLoadStatus === AdLoadingStatus.LOADING) {
				_this._rewardedLoadPromise
					.then(function () {
					self._rewardedLoadStatus = AdLoadingStatus.LOADED;
					resolve(AdServiceStatus.SUCCESS);
				})
					.catch(function (e) {
					self._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
					self._rewardedInstance = null;
					reject(e);
				});
				return;
			}
			_this._instantSDK.getRewardedVideoAsync(_this._rewardedPlacementId)
				.then(function (ad) {
				return _this._loadRewardedAd(ad);
			})
				.then(function () {
				self._rewardedLoadStatus = AdLoadingStatus.LOADED;
				resolve(AdServiceStatus.SUCCESS);
			})
				.catch(function (e) {
				self._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
				self._rewardedInstance = null;
				reject(e);
			});
		});
	};
	/**
	 * Shows an interstitial ad.
	 * If there's no preloaded ad, then this function will request one on demand.
	 *
	 * @param {Function} onShowCallback Function to be called when the show request is triggered
	 * @param {Function} onClickCallback (NOT SUPPORTED) Function to be called when the user clicks the ad
	 * @returns {Promise<AdServiceStatus>} Promise which will resolve with a Success status at the end of ad, resolve with another service status, or reject with the FB error
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.showInterstitialAd = function (onShowCallback, onClickCallback) {
		var _this = this;
		if (onShowCallback === void 0) { onShowCallback = null; }
		if (onClickCallback === void 0) { onClickCallback = null; }
		var self = this;
		return new Promise(function (resolve, reject) {
			if (!_this._isInitialized) {
				resolve(AdServiceStatus.NOT_INITIALIZED);
				return;
			}
			if (!_this._isSupportingInterstitialAds) {
				resolve(AdServiceStatus.NO_AD_SUPPORT);
				return;
			}
			if (_this._isWatching) {
				resolve(AdServiceStatus.AD_BEING_WATCHED);
				return;
			}
			if ((_this._interstitialTimer - Date.now()) > 0) {
				resolve(AdServiceStatus.TIMER_STILL_RUNNING);
				return;
			}
			if (_this._interstitialInstance && _this._interstitialLoadStatus === AdLoadingStatus.LOADED) {
				_this._showInterstitialAd(onShowCallback, resolve, reject);
			}
			else if (_this._interstitialInstance && _this._interstitialLoadStatus === AdLoadingStatus.LOADING) {
				_this._interstitialLoadPromise
					.then(function () {
					_this._showInterstitialAd(onShowCallback, resolve, reject);
				})
					.catch(function (e) {
					reject(e);
				});
			}
			else if (_this._interstitialInstance && _this._interstitialLoadStatus === AdLoadingStatus.NOT_LOADED) {
				_this.prepareInterstitialAd()
					.then(function () {
					_this._showInterstitialAd(onShowCallback, resolve, reject);
				})
					.catch(function (e) {
					reject(e);
				});
			}
			else if (!_this._interstitialInstance) {
				_this._instantSDK.getInterstitialAdAsync(self._interstitialPlacementId)
					.then(function (ad) {
					return _this._loadInterstitial(ad);
				})
					.then(function () {
					_this._showInterstitialAd(onShowCallback, resolve, reject);
				})
					.catch(function (e) {
					reject(e);
				});
			}
		});
	};
	/**
	 * Shows a rewarding video ad.
	 * If there's no preloaded ad, then this function will request one on demand.
	 *
	 * @param {Function} onShowCallback Function to be called when the show request is triggered
	 * @param {Function} onClickCallback (NOT SUPPORTED) Function to be called when the user clicks the ad
	 * @returns {Promise<AdServiceStatus>} Promise which will resolve with a Success status at the end of ad, resolve with another service status, or reject with the FB error
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype.showRewardedAd = function (onShowCallback, onClickCallback) {
		var _this = this;
		if (onShowCallback === void 0) { onShowCallback = null; }
		if (onClickCallback === void 0) { onClickCallback = null; }
		var self = this;
		return new Promise(function (resolve, reject) {
			if (!_this._isInitialized) {
				resolve(AdServiceStatus.NOT_INITIALIZED);
				return;
			}
			if (!_this._isSupportingRewardedAds) {
				resolve(AdServiceStatus.NO_AD_SUPPORT);
				return;
			}
			if (_this._isWatching) {
				resolve(AdServiceStatus.AD_BEING_WATCHED);
				return;
			}
			if ((_this._rewardedTimer - Date.now()) > 0) {
				resolve(AdServiceStatus.TIMER_STILL_RUNNING);
				return;
			}
			if (_this._rewardedInstance && _this._rewardedLoadStatus === AdLoadingStatus.LOADED) {
				_this._showRewardedAd(onShowCallback, resolve, reject);
			}
			else if (_this._rewardedInstance && _this._rewardedLoadStatus === AdLoadingStatus.LOADING) {
				self._rewardedLoadPromise
					.then(function () {
					_this._showRewardedAd(onShowCallback, resolve, reject);
				})
					.catch(function (e) {
					reject(e);
				});
			}
			else if (_this._rewardedInstance && _this._rewardedLoadStatus === AdLoadingStatus.NOT_LOADED) {
				self.prepareRewardedAd()
					.then(function () {
					_this._showRewardedAd(onShowCallback, resolve, reject);
				})
					.catch(function (e) {
					reject(e);
				});
			}
			else if (!_this._rewardedInstance) {
				_this._instantSDK.getRewardedVideoAsync(self._rewardedPlacementId)
					.then(function (ad) {
					return _this._loadRewardedAd(ad);
				})
					.then(function () {
					_this._showRewardedAd(onShowCallback, resolve, reject);
				})
					.catch(function (e) {
					reject(e);
				});
			}
		});
	};
	/**
	 * Check if the SDK supports interstitial ads
	 *
	 * @private
	 * @returns {boolean} If interstitial ads are supported
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype._interstitialAdSupport = function () {
		var fbSupportedApis = this._instantSDK.getSupportedAPIs();
		var rewardedAdsSupported = false;
		fbSupportedApis.forEach(function (supportedApiString) {
			if (supportedApiString === 'getInterstitialAdAsync') {
				rewardedAdsSupported = true;
			}
		}, this);
		return rewardedAdsSupported;
	};
	/**
	 * Check if the SDK supports rewarding ads
	 *
	 * @private
	 * @returns {boolean} If rewarding video ads are supported
	 *
	 * @memberOf InstantGameAdsService
	 */
	InstantGameAdsService.prototype._rewardedAdSupport = function () {
		var fbSupportedApis = this._instantSDK.getSupportedAPIs();
		var rewardedAdsSupported = false;
		fbSupportedApis.forEach(function (supportedApiString) {
			if (supportedApiString === 'getRewardedVideoAsync') {
				rewardedAdsSupported = true;
			}
		}, this);
		return rewardedAdsSupported;
	};
	/**
	 * Handle what should happen when attempting to show an interstitial ad.
	 *
	 * @private
	 * @param onShowCallback
	 * @param onClickCallback
	 * @param resolve
	 * @param reject
	 */
	InstantGameAdsService.prototype._showInterstitialAd = function (onShowCallback, resolve, reject) {
		var _this = this;
		if (onShowCallback) {
			onShowCallback();
		}
		this._isWatching = true;
		this._interstitialInstance.showAsync()
			.then(function () {
			_this._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
			_this._interstitialInstance = null;
			_this._isWatching = false;
			resolve(AdServiceStatus.SUCCESS);
		})
			.catch(function (e) {
			_this._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
			_this._interstitialInstance = null;
			_this._isWatching = false;
			reject(e);
		});
	};
	/**
	 * Handle what should happen when attempting to show an rewarded ad.
	 *
	 * @private
	 * @param onShowCallback
	 * @param onClickCallback
	 * @param resolve
	 * @param reject
	 */
	InstantGameAdsService.prototype._showRewardedAd = function (onShowCallback, resolve, reject) {
		var _this = this;
		if (onShowCallback) {
			onShowCallback();
		}
		this._isWatching = true;
		this._rewardedInstance.showAsync()
			.then(function () {
			_this._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
			_this._rewardedInstance = null;
			_this._isWatching = false;
			resolve(AdServiceStatus.SUCCESS);
		})
			.catch(function (e) {
			_this._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
			_this._rewardedInstance = null;
			_this._isWatching = false;
			reject(e);
		});
	};
	/**
	 * Initialize the loading of the interstitial ad, store and return the load promise.
	 *
	 * @private
	 * @param ad
	 * @returns {Promise} load promise for the interstitial ad.
	 */
	InstantGameAdsService.prototype._loadInterstitial = function (ad) {
		if (this._interstitialAdRequestCallback) {
			this._interstitialAdRequestCallback();
		}
		this._interstitialInstance = ad;
		this._interstitialLoadPromise = this._interstitialInstance.loadAsync();
		return this._interstitialLoadPromise;
	};
	/**
	 * Initialize the loading of the rewarded ad, store and return the load promise.
	 *
	 * @private
	 * @param ad
	 * @returns {Promise} load promise for the rewarded ad.
	 */
	InstantGameAdsService.prototype._loadRewardedAd = function (ad) {
		if (this._rewardedAdRequestCallback) {
			this._rewardedAdRequestCallback();
		}
		this._rewardedInstance = ad;
		this._rewardedLoadPromise = this._rewardedInstance.loadAsync();
		return this._rewardedLoadPromise;
	};
	return InstantGameAdsService;
}());
exports.InstantGameAdsService = InstantGameAdsService;

//******************************************************
//*****    Script Resource: coolgames_ads_mock
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// coolgames-ads-mock (1.0.1-builder)
// Generated on Fri Apr 20 2018 09:52:55 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_ads_core_1 = require("@coolgames/coolgames-ads-core");
var MockAdsServiceSettings_1 = require("./MockAdsServiceSettings");
var timers_1 = require("timers");
/**
 * Mock implementation of the Ads Service interface
 *
 * @export
 * @class MockAdsService
 * @implements {IAdService}
 * @author Sam Lynch
 */
var MockAdsService = /** @class */ (function () {
    /**
     * Creates an instance of MockAdsService.
     * @param {MockAdsServiceSettings} [config] The settings for this service
     *
     * @memberOf MockAdsService
     */
    function MockAdsService(config) {
        /**
         * If the sdk configuration supports interstitials
         *
         * @private
         * @type {boolean}
         * @memberOf MockAdsService
         */
        this._isSupportingInterstitialAds = false;
        /**
         * If the sdk configuration supports rewarding ads (videos)
         *
         * @private
         * @type {boolean}
         * @memberOf MockAdsService
         */
        this._isSupportingRewardedAds = false;
        /**
         * The mock instance of an interstitial
         *
         * @private
         * @type {boolean}
         * @memberOf MockAdsService
         */
        this._interstitialInstance = false;
        /**
         * The mock instance of an rewarded ad
         *
         * @private
         * @type {boolean}
         * @memberOf MockAdsService
         */
        this._rewardedInstance = false;
        /**
         * If user is watching an ad
         *
         * @private
         * @type {boolean}
         * @memberOf MockAdsService
         */
        this._isWatching = false;
        /**
         * The loading status of the insterstitial ad
         *
         * @private
         * @type {number}
         * @memberOf MockAdsService
         */
        this._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
        /**
         * Cooldown timer for rewarding videos
         *
         * @private
         * @type {number}
         * @memberOf MockAdsService
         */
        this._rewardedTimer = 0;
        /**
         * Cooldown timer for interstitial videos
         *
         * @private
         * @type {number}
         * @memberOf MockAdsService
         */
        this._interstitialTimer = 0;
        /**
         * The loading status of the rewarding video
         *
         * @private
         * @type {number}
         * @memberOf MockAdsService
         */
        this._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
        /**
         * The current promise for the loading of the rewarded ad
         *
         * @private
         * @type {Promise<void>}
         * @memberOf MockAdsService
         */
        this._rewardedLoadPromise = null;
        /**
         * The placement id for rewarded ads
         *
         * @private
         * @type {string}
         * @memberOf MockAdsService
         */
        this._rewardedPlacementId = null;
        /**
         * The placement id for interstitial ads
         *
         * @private
         * @type {string}
         * @memberOf MockAdsService
         */
        this._interstitialPlacementId = null;
        /**
         * The current promise for the loading of the interstitial
         *
         * @private
         * @type {Promise<void>}
         * @memberOf MockAdsService
         */
        this._interstitialLoadPromise = null;
        /**
         * The callback to be triggered when an ad instance is available after a request (successful ad request)
         *
         * @private
         * @type {Function}
         * @memberOf MockAdsService
         */
        this._rewardedAdRequestCallback = null;
        if (!config) {
            config = new MockAdsServiceSettings();
        }
        this._config = config;
    }
    /**
     * Initializes the Ad Service
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.initialize = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._isSupportingInterstitialAds = _this._config.supportInterstitials;
            _this._isSupportingRewardedAds = _this._config.supportRewardedVideos;
            _this._initialized = true;
            resolve();
        });
    };
    /**
     * Convenience method to know if interstitials are supported
     *
     * @returns {boolean} If interstitials are supported
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.isInterstitialAdsSupported = function () {
        if (!this._initialized) {
            throw new Error("MockAdsService is not initialized");
        }
        return this._config.supportInterstitials;
    };
    /**
     * Convenience method to know if rewarding videos are supported
     *
     * @returns {boolean} If rewarding videos are supported
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.isRewardedAdsSupported = function () {
        if (!this._initialized) {
            throw new Error("MockAdsService is not initialized");
        }
        return this._config.supportRewardedVideos;
    };
    /**
     * Sets interstitial restriction timer
     *
     * @param {number} timer Cooldown for interstitials (in milliseconds, from now)
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.setInterstitialTimer = function (timer) {
        this._interstitialTimer = timer + Date.now();
    };
    /**
     * Sets the placement id for interstitials
     *
     * @param {string} placementId The placement id
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.setInterstitialId = function (placementId) {
        this._interstitialPlacementId = placementId;
    };
    /**
     * Sets rewarded restriction timer
     *
     * @param {number} timer Cooldown for rewarded videos (in milliseconds, from now)
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.setRewardedTimer = function (timer) {
        this._rewardedTimer = timer + Date.now();
    };
    /**
     * Convenience method to check if the timer is still restricting insterstitials
     *
     * @returns {boolean} If the restrictive timer is active for interstitials
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.isInterstitialTimerActive = function () {
        return ((this._interstitialTimer - Date.now()) > 0);
    };
    /**
     * Convenience method to check if the timer is still restricting rewarded ads
     *
     * @returns {boolean} If the restrictive timer is active for rewarded ads
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.isRewardedTimerActive = function () {
        return ((this._rewardedTimer - Date.now()) > 0);
    };
    /**
     * Sets the placement id for rewarding videos
     *
     * @param {string} placementId The placement id
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.setRewardedId = function (placementId) {
        this._rewardedPlacementId = placementId;
    };
    /**
     * Asynchronously fetch an interstitial ad instance (if one is not already available) and preload it for viewing later
     *
     * @returns {Promise<AdServiceStatus>} A promise which resolves with the status, or rejects with an error
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.prepareInterstitialAd = function () {
        var _this = this;
        var self = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._initialized) {
                            resolve(AdServiceStatus.NOT_INITIALIZED);
                            return [2 /*return*/];
                        }
                        if (!this._isSupportingInterstitialAds) {
                            resolve(AdServiceStatus.NO_AD_SUPPORT);
                            return [2 /*return*/];
                        }
                        if (!this._interstitialPlacementId) {
                            resolve(AdServiceStatus.NO_PLACEMENT_ID);
                            return [2 /*return*/];
                        }
                        if (!(this._interstitialInstance && this._interstitialLoadStatus === AdLoadingStatus.LOADED)) return [3 /*break*/, 1];
                        // We already have a loaded instance
                        resolve(AdServiceStatus.SUCCESS);
                        return [2 /*return*/];
                    case 1:
                        if (!(this._interstitialInstance && this._interstitialLoadStatus === AdLoadingStatus.NOT_LOADED)) return [3 /*break*/, 2];
                        this._interstitialLoadPromise = new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime); });
                        this._interstitialLoadStatus = AdLoadingStatus.LOADING;
                        this._interstitialLoadPromise
                            .then(function () {
                            self._interstitialLoadStatus = AdLoadingStatus.LOADED;
                            resolve(AdServiceStatus.SUCCESS);
                        })
                            .catch(function (e) {
                            self._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
                            reject(e);
                        });
                        return [2 /*return*/];
                    case 2:
                        if (!(this._interstitialInstance && this._interstitialLoadStatus === AdLoadingStatus.LOADING)) return [3 /*break*/, 3];
                        this._interstitialLoadPromise
                            .then(function () {
                            self._interstitialLoadStatus = AdLoadingStatus.LOADED;
                            resolve(AdServiceStatus.SUCCESS);
                        })
                            .catch(function (e) {
                            self._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
                            reject(e);
                        });
                        return [2 /*return*/];
                    case 3:
                        if (!!this._interstitialInstance) return [3 /*break*/, 6];
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime); })];
                    case 4:
                        _a.sent();
                        // simulate interstitialInstanceError here
                        if (self._config.interstitialInstanceError) {
                            self._interstitialInstance = false;
                            reject(self._config.interstitialInstanceError);
                        }
                        else {
                            self._interstitialInstance = true;
                        }
                        if (self._interstitialAdRequestCallback) {
                            self._interstitialAdRequestCallback();
                        }
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime); })];
                    case 5:
                        _a.sent();
                        if (!self._config.interstitialLoadError) {
                            self._interstitialLoadStatus = AdLoadingStatus.LOADED;
                            resolve(AdServiceStatus.SUCCESS);
                        }
                        else {
                            self._interstitialInstance = false;
                            self._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
                            reject(self._config.interstitialLoadError);
                        }
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Asynchronously fetch a rewarded ad instance (if one is not already available) and preload it for viewing later
     *
     * @returns {Promise<AdServiceStatus>} A promise which resolves with the status, or rejects with a FB error
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.prepareRewardedAd = function () {
        var _this = this;
        var self = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._initialized) {
                            resolve(AdServiceStatus.NOT_INITIALIZED);
                            return [2 /*return*/];
                        }
                        if (!this._isSupportingRewardedAds) {
                            resolve(AdServiceStatus.NO_AD_SUPPORT);
                            return [2 /*return*/];
                        }
                        if (!this._rewardedPlacementId) {
                            resolve(AdServiceStatus.NO_PLACEMENT_ID);
                            return [2 /*return*/];
                        }
                        if (this._rewardedInstance && this._rewardedLoadStatus === AdLoadingStatus.LOADED) {
                            resolve(AdServiceStatus.SUCCESS);
                            return [2 /*return*/];
                        }
                        if (this._rewardedInstance && this._rewardedLoadStatus === AdLoadingStatus.NOT_LOADED) {
                            this._rewardedLoadStatus = AdLoadingStatus.LOADING;
                            this._rewardedLoadPromise = new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime); })
                                .then(function () {
                                self._rewardedLoadStatus = AdLoadingStatus.LOADED;
                                resolve(AdServiceStatus.SUCCESS);
                            })
                                .catch(function (e) {
                                self._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
                                reject(e);
                            });
                            return [2 /*return*/];
                        }
                        if (this._rewardedInstance && this._rewardedLoadStatus === AdLoadingStatus.LOADING) {
                            this._rewardedLoadPromise
                                .then(function () {
                                self._rewardedLoadStatus = AdLoadingStatus.LOADED;
                                resolve(AdServiceStatus.SUCCESS);
                            })
                                .catch(function (e) {
                                self._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
                                reject(e);
                            });
                            return [2 /*return*/];
                        }
                        if (!!this._rewardedInstance) return [3 /*break*/, 3];
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime); })];
                    case 1:
                        _a.sent();
                        // simulate rewardedInstanceError here
                        if (self._config.rewardedInstanceError) {
                            self._rewardedInstance = false;
                            reject(self._config.rewardedInstanceError); // reject because that's how the FBInstant module does it
                        }
                        else {
                            self._rewardedInstance = true;
                        }
                        if (self._rewardedAdRequestCallback) {
                            self._rewardedAdRequestCallback();
                        }
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime); })];
                    case 2:
                        _a.sent();
                        if (!self._config.rewardedLoadError) {
                            self._rewardedLoadStatus = AdLoadingStatus.LOADED;
                            resolve(AdServiceStatus.SUCCESS);
                        }
                        else {
                            self._rewardedInstance = false;
                            self._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
                            reject(self._config.rewardedLoadError);
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Shows an interstitial ad.
     * If there's no preloaded ad, then this function will request one on demand.
     *
     * @param {Function} onShowCallback Function to be called when the show request is triggered
     * @param {Function} onClickCallback Function to be called when the user clicks the ad
     * @returns {Promise<AdServiceStatus>} Promise which will resolve with a Success status at the end of ad, resolve with another service status, or reject with the FB error
     *
     * @memberOf InstantGameAdsService
     */
    MockAdsService.prototype.showInterstitialAd = function (onShowCallback, onClickCallback) {
        var _this = this;
        if (onShowCallback === void 0) { onShowCallback = null; }
        if (onClickCallback === void 0) { onClickCallback = null; }
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!this._initialized) {
                    resolve(AdServiceStatus.NOT_INITIALIZED);
                    return [2 /*return*/];
                }
                if (!this._isSupportingInterstitialAds) {
                    resolve(AdServiceStatus.NO_AD_SUPPORT);
                    return [2 /*return*/];
                }
                if (this._isWatching) {
                    resolve(AdServiceStatus.AD_BEING_WATCHED);
                    return [2 /*return*/];
                }
                if ((this._interstitialTimer - Date.now()) > 0) {
                    resolve(AdServiceStatus.TIMER_STILL_RUNNING);
                    return [2 /*return*/];
                }
                if (this._interstitialInstance && this._interstitialLoadStatus === AdLoadingStatus.LOADED) {
                    this._showInterstitialAd(onShowCallback, onClickCallback, resolve, reject);
                }
                else if (this._interstitialInstance && this._interstitialLoadStatus === AdLoadingStatus.LOADING) {
                    this._interstitialLoadPromise.then(function () {
                        _this._showInterstitialAd(onShowCallback, onClickCallback, resolve, reject);
                    });
                }
                else if (this._interstitialInstance && this._interstitialLoadStatus === AdLoadingStatus.NOT_LOADED) {
                    this.prepareInterstitialAd()
                        .then(function () {
                        _this._showInterstitialAd(onShowCallback, onClickCallback, resolve, reject);
                    });
                }
                else if (!this._interstitialInstance) {
                    this.prepareInterstitialAd()
                        .then(function () {
                        _this._showInterstitialAd(onShowCallback, onClickCallback, resolve, reject);
                    });
                }
                return [2 /*return*/];
            });
        }); });
    };
    /**
     * Shows a rewarding video ad.
     * If there's no preloaded ad, then this function will request one on demand.
     *
     * @param {Function} onShowCallback Function to be called when the show request is triggered
     * @param {Function} onClickCallback Function to be called when the user clicks the ad
     * @returns {Promise<AdServiceStatus>} Promise which will resolve with a Success status at the end of ad, resolve with another service status, or reject with the FB error
     *
     * @memberOf MockAdsService
     */
    MockAdsService.prototype.showRewardedAd = function (onShowCallback, onClickCallback) {
        var _this = this;
        if (onShowCallback === void 0) { onShowCallback = null; }
        if (onClickCallback === void 0) { onClickCallback = null; }
        var self = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!this._initialized) {
                    resolve(AdServiceStatus.NOT_INITIALIZED);
                    return [2 /*return*/];
                }
                if (!this._isSupportingRewardedAds) {
                    resolve(AdServiceStatus.NO_AD_SUPPORT);
                    return [2 /*return*/];
                }
                if (this._isWatching) {
                    resolve(AdServiceStatus.AD_BEING_WATCHED);
                    return [2 /*return*/];
                }
                if ((this._rewardedTimer - Date.now()) > 0) {
                    resolve(AdServiceStatus.TIMER_STILL_RUNNING);
                    return [2 /*return*/];
                }
                if (this._rewardedInstance && this._rewardedLoadStatus === AdLoadingStatus.LOADED) {
                    this._showRewardedAd(onShowCallback, onClickCallback, resolve, reject);
                }
                else if (this._rewardedInstance && this._rewardedLoadStatus === AdLoadingStatus.LOADING) {
                    self._rewardedLoadPromise
                        .then(function () {
                        _this._showRewardedAd(onShowCallback, onClickCallback, resolve, reject);
                    })
                        .catch(function (err) {
                        reject(err);
                    });
                }
                else if (this._rewardedInstance && this._rewardedLoadStatus === AdLoadingStatus.NOT_LOADED) {
                    self.prepareRewardedAd()
                        .then(function () {
                        _this._showRewardedAd(onShowCallback, onClickCallback, resolve, reject);
                    })
                        .catch(function (err) {
                        reject(err);
                    });
                }
                else if (!this._rewardedInstance) {
                    self.prepareRewardedAd()
                        .then(function () {
                        _this._showRewardedAd(onShowCallback, onClickCallback, resolve, reject);
                    });
                }
                return [2 /*return*/];
            });
        }); });
    };
    /**
     * Sets the callback to be called when the interstitial request resolves
     *
     * @param {Function} callback
     */
    MockAdsService.prototype.setInterstitialAdRequestCallback = function (callback) {
        this._interstitialAdRequestCallback = callback;
    };
    /**
     * Sets the callback to be called when the rewarded ad request resolves
     *
     * @param {Function} callback
     */
    MockAdsService.prototype.setRewardedAdRequestCallback = function (callback) {
        this._rewardedAdRequestCallback = callback;
    };
    /**
     * Handle what should happen when attempting to show an interstitial ad.
     *
     * @private
     * @param {Function} onShowCallback
     * @param {Function} onClickCallback
     * @param {Function} resolve
     * @param {Function} reject
     * @returns {Promise<void>}
     */
    MockAdsService.prototype._showInterstitialAd = function (onShowCallback, onClickCallback, resolve, reject) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var self;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        self = this;
                        this._isWatching = true;
                        if (onShowCallback) {
                            onShowCallback();
                        }
                        // adInstance.showAsync emulation
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime * 0.5); })];
                    case 1:
                        // adInstance.showAsync emulation
                        _a.sent();
                        // onClick emulation
                        if (onClickCallback && this._config.triggerOnClickCallbacks === true) {
                            onClickCallback();
                        }
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime * 0.5); })];
                    case 2:
                        _a.sent();
                        // showAsync emulation
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.defaultAdShowTime); })
                                .then(function () {
                                if (!self._config.interstitialLoadError) {
                                    _this._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
                                    _this._interstitialInstance = null;
                                    _this._isWatching = false;
                                    resolve(AdServiceStatus.SUCCESS);
                                }
                                else {
                                    _this._interstitialLoadStatus = AdLoadingStatus.NOT_LOADED;
                                    _this._interstitialInstance = null;
                                    _this._isWatching = false;
                                    reject(self._config.interstitialLoadError);
                                }
                            })];
                    case 3:
                        // showAsync emulation
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Handle what should happen when attempting to show an rewarded ad.
     *
     * @private
     * @param {Function} onShowCallback
     * @param {Function} onClickCallback
     * @param {Function} resolve
     * @param {Function} reject
     */
    MockAdsService.prototype._showRewardedAd = function (onShowCallback, onClickCallback, resolve, reject) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var self;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        self = this;
                        this._isWatching = true;
                        if (onShowCallback) {
                            onShowCallback();
                        }
                        // adInstance.showAsync emulation
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime * 0.5); })];
                    case 1:
                        // adInstance.showAsync emulation
                        _a.sent();
                        // onClick emulation
                        if (onClickCallback && this._config.triggerOnClickCallbacks === true) {
                            onClickCallback();
                        }
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.asyncResponseTime * 0.5); })];
                    case 2:
                        _a.sent();
                        // showAsync emulation
                        return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, self._config.defaultAdShowTime); })
                                .then(function () {
                                if (!self._config.rewardedLoadError) {
                                    _this._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
                                    _this._rewardedInstance = null;
                                    _this._isWatching = false;
                                    resolve(AdServiceStatus.SUCCESS);
                                }
                                else {
                                    _this._rewardedLoadStatus = AdLoadingStatus.NOT_LOADED;
                                    _this._rewardedInstance = null;
                                    _this._isWatching = false;
                                    reject(self._config.rewardedLoadError);
                                }
                            })
                                .catch(function (err) {
                                reject(err);
                            })];
                    case 3:
                        // showAsync emulation
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return MockAdsService;
}());
exports.MockAdsService = MockAdsService;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Settings for the Mock Ads Service class
 *
 * @export
 * @class MockAdsServiceSettings
 */
var MockAdsServiceSettings = /** @class */ (function () {
    function MockAdsServiceSettings() {
        /**
         * Default time to retrieve an ad instance (milliseconds)
         *
         * @type {number}
         */
        this.defaultAdGetTime = 100;
        /**
         * Default time to load an ad instance (milliseconds)
         *
         * @type {number}
         */
        this.defaultAdLoadTime = 100;
        /**
         * Default time to show an ad instance (milliseconds)
         *
         * @type {number}
         */
        this.defaultAdShowTime = 100;
        /**
         * Sets if the mock should simulate support for rewarded videos
         *
         * @type {boolean}
         * @memberOf MockAdsServiceSettings
         */
        this.supportRewardedVideos = true;
        /**
         * Sets if the mock should simulate support for interstitials
         *
         * @type {boolean}
         * @memberOf MockAdsServiceSettings
         */
        this.supportInterstitials = true;
        /**
         * Amount of time to fake async operation (in milliseconds)
         *
         * @public
         * @type {number}
         * @memberOf MockAdsServiceSettings
         */
        this.asyncResponseTime = 250;
        /**
         * The error to emulate when loading interstitials (set to null to succeed)
         *
         * @public
         * @type {string}
         * @memberOf MockAdsServiceSettings
         */
        this.interstitialLoadError = null;
        /**
         * The error to emulate when loading interstitials (set to null to succeed)
         *
         * @public
         * @type {AdServiceStatus}
         * @memberOf MockAdsServiceSettings
         */
        this.interstitialInstanceError = null;
        /**
         * If true, mimic the user clicking on the ad
         *
         * @public
         * @type {boolean}
         * @memberOf MockAdsServiceSettings
         */
        this.triggerOnClickCallbacks = false;
        /**
         * The error to emulate when loading rewarded (set to null to succeed)
         *
         * @public
         * @type {string}
         * @memberOf MockAdsServiceSettings
         */
        this.rewardedLoadError = null;
        /**
         * The error to emulate when fetching rewarded instance (set to null to succeed)
         *
         * @public
         * @type {AdServiceStatus}
         * @memberOf MockAdsServiceSettings
         */
        this.rewardedInstanceError = null;
    }
    return MockAdsServiceSettings;
}());
exports.MockAdsServiceSettings = MockAdsServiceSettings;
//******************************************************
//*****    Script Resource: coolgames_leaderboards_coregen
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// coolgames-leaderboards-core (1.2.0-builder)
// Generated on Wed Apr 25 2018 11:48:39 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a leaderboard type from the server side.
 * The parameters need to be configured in specific ways to get the desired leaderboard.
 * Currently supported types are:
 * * Global / Local
 * * Yearly / Montly / Weekly
 *
 * @export
 * @class LeaderboardType
 */
var LeaderboardType = /** @class */ (function () {
    function LeaderboardType() {
        /**
         * If set alone, this field will represent an yearly leaderboard (please use the 4 digits format)
         * It is also REQUIRED when trying to set the MONTH or WEEK.
         *
         * @type {number}
         * @memberOf LeaderboardType
         */
        this.year = 0;
        /**
         * If set, will represent a monthly leaderboard (January = 1).
         * Additionally, setting the YEAR parameter is required if you want to set this one.
         * Finally, don't set the WEEK parameter if you want to set this one.
         *
         * @type {number}
         * @memberOf LeaderboardType
         */
        this.month = 0;
        /**
         * If set, will represent a weekly leaderboard (first week = 1).
         * Additionally, setting the YEAR parameter is required if you want to set this one.
         * Finally, don't set the MONTH parameter if you want to set this one.
         *
         * @type {number}
         * @memberOf LeaderboardType
         */
        this.week = 0;
        /**
         * Leaderboard code (if you use more than one leaderboard on the server side).
         * DON'T set this to null or undefined.
         *
         * @type {string}
         * @memberOf LeaderboardType
         */
        this.leaderboardCode = LeaderboardType.DEFAULT_LEADERBOARD_CODE;
        /**
         * If set, this field would indicate a CONTEXT leaderboard.
         *
         * @type {string}
         * @memberOf LeaderboardType
         */
        this.contextId = "";
    }
    /**
     * Default Leaderboard code to be used in case programmer doesn't specify one
     *
     * @static
     * @type {string}
     * @memberOf LeaderboardType
     */
    LeaderboardType.DEFAULT_LEADERBOARD_CODE = "LB";
    return LeaderboardType;
}());
exports.LeaderboardType = LeaderboardType;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A Leaderboard feature supported (or not) by the concrete implementation
 *
 * @export
 * @enum {string}
 */
var LeaderboardFeature;
(function (LeaderboardFeature) {
    /**
     * Global leaderboard (one leaderboard shared between all players)
     */
    LeaderboardFeature["GLOBAL_LEADERBOARDS"] = "GLOBAL_LEADERBOARDS";
    /**
     * Local leaderboards (one leaderboard per country)
     */
    LeaderboardFeature["LOCAL_LEADERBOARDS"] = "LOCAL_LEADERBOARDS";
    /**
     * Context leaderboard (a leaderboard per context - containing the players in that specific context)
     */
    LeaderboardFeature["CONTEXT_LEADERBOARDS"] = "CONTEXT_LEADERBOARDS";
    /**
     * Supports weekly, monthly, yearly leaderboards
     */
    LeaderboardFeature["TIME_PARTITIONS"] = "TIME_PARTITIONS";
    /**
     * Retrieve the leaderboard data only for a specified list of player ids
     * (can be used to create a friends only leaderboard)
     */
    LeaderboardFeature["USER_FILTER"] = "USER_FILTER";
    /**
     * Supports sending leaderboard game updates in the current context
     */
    LeaderboardFeature["LEADERBOARD_UPDATES"] = "LEADERBOARD_UPDATES";
})(LeaderboardFeature = exports.LeaderboardFeature || (exports.LeaderboardFeature = {}));

//******************************************************
//*****    Script Resource: coolgames_leaderboards_fbinstantgen
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-leaderboards-fbinstant (1.2.1-builder)
// ---------------------------------------------------------------------------------------
// Generated on Thu Apr 26 2018 16:20:05 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-leaderboards-core (1.2.0-builder)
// - coolgames-messagingplatform-core (1.0.0-builder)
// - coolgames-messagingplatform-fbinstant (1.0.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_leaderboards_core_1 = require("@coolgames/coolgames-leaderboards-core");
var fb_instant_sdk_definitions_1 = require("@coolgames/fb-instant-sdk-definitions");
/**
 * Facebook Instant Leaderboards service implementation.
 *
 * @export
 * @class FBLeaderboardService
 * @implements {ILeaderboardService}
 */
var FBLeaderboardService = /** @class */ (function () {
    /**
     * Creates an instance of FBLeaderboardService.
     * @param {FBMessagingPlatformService} messagingService The FB Messaging Platform service
     *
     * @memberOf FBLeaderboardService
     */
    function FBLeaderboardService(messagingService) {
        this._messagingService = null;
        this._fbInstant = null;
        this._isInitialized = false;
        /**
         * Supported features
         *
         * @private
         * @type { [feature: LeaderboardFeature]: boolean }
         * @memberOf FBLeaderboardService
         */
        this._supportedFeatures = (_a = {},
            _a[LeaderboardFeature.GLOBAL_LEADERBOARDS] = true,
            _a[LeaderboardFeature.LOCAL_LEADERBOARDS] = false,
            _a[LeaderboardFeature.CONTEXT_LEADERBOARDS] = true,
            _a[LeaderboardFeature.TIME_PARTITIONS] = false,
            _a[LeaderboardFeature.USER_FILTER] = false,
            _a[LeaderboardFeature.LEADERBOARD_UPDATES] = true,
            _a);
        this._messagingService = messagingService;
        this._fbInstant = this._messagingService.getFBInstant();
        var _a;
    }
    /**
     * Initializes the service.
     *
     * @returns {Promise<void>} A promise that the service is initialized
     *
     * @memberOf ILeaderboardService
     */
    FBLeaderboardService.prototype.initialize = function () {
        var _this = this;
        var self = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                self._messagingService.addInitListener({
                    initializationFinished: function () {
                        self._isInitialized = true;
                        resolve();
                    },
                    initializationFailed: function (reason) {
                        reject("FBMessagingPlatformService failed to initialize : " + reason);
                    }
                });
                return [2 /*return*/];
            });
        }); });
    };
    /**
     * Checks if the specified leaderboard feature is supported by the concrete implementation
     *
     * @param {LeaderboardFeature} feature The desired feature to check
     * @returns {boolean} True if supported, false otherwise
     *
     * @memberOf FBLeaderboardService
     */
    FBLeaderboardService.prototype.isFeatureSupported = function (feature) {
        if (!this._supportedFeatures.hasOwnProperty(feature)) {
            console.error("Feature " + feature + " is not configured on FBLeaderboardService");
            return false;
        }
        return this._supportedFeatures[feature];
    };
    /**
     * Sends the score to the server.
     * IMPORTANT: it takes some time for the score to propagate on the leaderboard(s) an trigger events.
     *
     * @param {number} score The new score
     * @param {string} [countryCode] Not supported on Facebook
     * @param {string} [leaderboardCode] Optional parameter to be used if you have more than one leaderboard setup on the server side
     * @param {string} [contextId] Optional parameter used to specify the context of the leaderboard
     * @param {string[]} [labels] Labels to save to the extra data associated with the player entry
     * @param {Object[]} [playerDatas] Object array of data to save to the extra data associated with the player entry
     *
     * @returns {Promise<void>} The promise object that the score was saved
     *
     * @memberOf FBLeaderboardService
     */
    FBLeaderboardService.prototype.sendScore = function (score, countryCode, leaderboardCode, contextId, labels, playerDatas) {
        var self = this;
        return new Promise(function (resolve, reject) {
            if (!self._isInitialized) {
                reject("Not initialized");
                return;
            }
            if (countryCode != null) {
                console.warn("Local / Country Leaderboards are not supported on the FB platform");
            }
            if (!leaderboardCode) {
                reject("Leaderboard name needed for the Facebook implementation");
                return;
            }
            return self._fbInstant.getLeaderboardAsync(leaderboardCode)
                .then(function (leaderboard) {
                var extra = self._dataToString(labels, playerDatas);
                return leaderboard.setScoreAsync(score, extra);
            })
                .then(function (entry) {
                resolve();
            })
                .catch(function (error) {
                reject(error);
            });
        });
    };
    /**
     * Gets the current position (rank) from the player in the specified leaderboards.
     * Currently, it's not possible to specify a list of friends, for getting the position on a friends leaderboard use the getAroundMe method.
     *
     * @param {LeaderboardType[]} leaderboardTypes An array of desired leaderboards
     * @returns {Promise<any>} The promise object, with the plain response from the server
     *
     * @memberOf FBLeaderboardService
     */
    FBLeaderboardService.prototype.getCurrentPosition = function (leaderboardTypes) {
        var _this = this;
        var self = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var promises, i;
            return __generator(this, function (_a) {
                if (!self._isInitialized) {
                    reject("Not initialized");
                    return [2 /*return*/];
                }
                promises = [];
                for (i = 0; i < leaderboardTypes.length; i++) {
                    promises.push(self._fbInstant.getLeaderboardAsync(leaderboardTypes[i].leaderboardCode));
                }
                Promise.all(promises)
                    .then(function (list) {
                    var positionPromises = [];
                    for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                        var board = list_1[_i];
                        positionPromises.push(board.getPlayerEntryAsync());
                    }
                    return Promise.all(positionPromises);
                })
                    .then(function (entries) {
                    if (entries.length !== leaderboardTypes.length) {
                        console.error("Leaderboard size missmatch");
                    }
                    var returnData = {};
                    for (var i = 0; i < leaderboardTypes.length; i++) {
                        var e = entries[i];
                        if (!e) {
                            returnData[leaderboardTypes[i].leaderboardCode] = null;
                            continue;
                        }
                        var extra = self._stringToData(e.getExtraData());
                        returnData[leaderboardTypes[i].leaderboardCode] =
                            {
                                SCORE: e.getScore(),
                                WEEK: 0,
                                country: "",
                                userName: self._fbInstant.player.getID(),
                                rank: e.getRank(),
                                playerData: extra
                            };
                    }
                    resolve(returnData);
                })
                    .catch(function (error) {
                    console.error(error);
                    reject(error);
                });
                return [2 /*return*/];
            });
        }); });
    };
    /**
     * Gets leaderboard data from the player and people around him/her.
     *
     * @param {LeaderboardType} leaderboardType The leaderboard type
     * @param {number} entryCount The number of entries (above and below) the current position
     * @param {string[]} [playerData] If required, an array with all required "labels" stored on the player data (eg: player level, info, etc)
     * @param {string[]} [friendIds] Not supported on fb-instant
     * @param {number} [includeFirst] If specified, will return also the topmost people from the specified leaderboard
     * @returns {Promise<any>} The promise object, with the plain response from the server
     *
     * @memberOf FBLeaderboardService
     */
    FBLeaderboardService.prototype.getAroundMeData = function (leaderboardType, entryCount, playerData, friendIds, includeFirst) {
        var self = this;
        return new Promise(function (resolve, reject) {
            if (!self._isInitialized) {
                reject("Not initialized");
                return;
            }
            if (friendIds) {
                console.error("USER_FILTER not supported for FB leaderboards");
            }
            if (leaderboardType.year || leaderboardType.month || leaderboardType.week) {
                console.error("TIME_PARTITIONS not supported for FB leaderboards");
            }
            var data = [];
            var leaderboard = null;
            self._fbInstant.getLeaderboardAsync(leaderboardType.leaderboardCode)
                .then(function (l) {
                leaderboard = l;
                if (includeFirst) {
                    return leaderboard.getEntriesAsync(includeFirst, 0);
                }
                else {
                    return new Promise(function (res, rej) { return res([]); });
                }
            })
                .then(function (entries) {
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var e = entries_1[_i];
                    data.push(self._parseEntry(e, playerData));
                }
                return leaderboard.getPlayerEntryAsync();
            })
                .then(function (entry) {
                if (!entry) {
                    resolve(data);
                    return;
                }
                // remove overlapping entries
                var r = entry.getRank();
                var overlap = r - entryCount - data.length;
                if (overlap <= 0) {
                    data = data.splice(data.length - overlap - 1, Math.abs(overlap));
                }
                return leaderboard.getEntriesAsync(2 * entryCount + 1, r - entryCount);
            })
                .then(function (entries) {
                for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {
                    var e = entries_2[_i];
                    data.push(self._parseEntry(e, playerData));
                }
                resolve(data);
            })
                .catch(function (error) {
                console.error(error);
                reject(error);
            });
        });
    };
    /**
     * Gets a list of leaderboard entries
     *
     * @param {LeaderboardType} leaderboardType The leaderboard type
     * @param {number} entryCount The number of entries
     * @param {number} [offset] Optional parameter for pagination
     * @param {string[]} [playerData] If required, an array with all required "labels" stored on the player data (eg: player level, info, etc)
     * @param {string[]} [friendIds] If specified, will return also the topmost people from the specified leaderboard
     * @returns {Promise<any>} The promise object, with the plain response from the server
     *
     * @memberOf FBLeaderboardService
     */
    FBLeaderboardService.prototype.getLeaderboardData = function (leaderboardType, entryCount, offset, playerData, friendIds) {
        var self = this;
        return new Promise(function (resolve, reject) {
            if (!self._isInitialized) {
                reject("Not initialized");
                return;
            }
            if (friendIds) {
                console.error("USER_FILTER not supported for FB leaderboards");
            }
            if (leaderboardType.year || leaderboardType.month || leaderboardType.week) {
                console.error("TIME_PARTITIONS not supported for FB leaderboards");
            }
            var data = [];
            self._fbInstant.getLeaderboardAsync(leaderboardType.leaderboardCode)
                .then(function (leaderboard) {
                return leaderboard.getEntriesAsync(entryCount, offset || 0);
            })
                .then(function (entries) {
                for (var _i = 0, entries_3 = entries; _i < entries_3.length; _i++) {
                    var e = entries_3[_i];
                    data.push(self._parseEntry(e, playerData));
                }
                resolve(data);
            })
                .catch(function (error) {
                reject(error);
            });
        });
    };
    /**
     * Send a game update in the current context
     *
     * @param {LeaderboardType} leaderboardType
     * @returns {Promise<void>}
     *
     * @memberOf FBLeaderboardService
     */
    FBLeaderboardService.prototype.sendLeaderboardUpdate = function (leaderboardType) {
        if (!this._isInitialized) {
            return new Promise(function (resolve, reject) { return reject("Not initialized"); });
        }
        var payload = {
            action: UpdateAction.LEADERBOARD,
            name: leaderboardType.leaderboardCode
        };
        return this._fbInstant.updateAsync(payload);
    };
    FBLeaderboardService.prototype._dataToString = function (labels, data) {
        if (!labels && !data) {
            return null;
        }
        if (!labels || !data) {
            throw new Error("Leaderboard data invalid parameters");
        }
        if (labels.length !== data.length) {
            throw new Error("Leaderboard data length missmatch!");
        }
        var obj = {};
        for (var i = 0; i < labels.length; i++) {
            obj[labels[i]] = data[i];
        }
        return JSON.stringify(obj);
    };
    FBLeaderboardService.prototype._stringToData = function (data, labels) {
        if (!data || data === "") {
            return null;
        }
        var obj = JSON.parse(data);
        if (labels) {
            // tslint:disable-next-line:forin
            for (var key in obj) {
                var foundIt = false;
                for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
                    var l = labels_1[_i];
                    if (l === key) {
                        foundIt = true;
                    }
                }
                if (!foundIt) {
                    delete obj[key];
                }
            }
        }
        return obj;
    };
    FBLeaderboardService.prototype._parseEntry = function (entry, labels) {
        var extra = this._stringToData(entry.getExtraData(), labels);
        var obj = {
            SCORE: entry.getScore(),
            WEEK: 0,
            country: "",
            userName: entry.getPlayer().getID(),
            rank: entry.getRank(),
            playerData: extra
        };
        return obj;
    };
    return FBLeaderboardService;
}());
exports.FBLeaderboardService = FBLeaderboardService;

//******************************************************
//*****    Script Resource: coolgames_leaderboards_gamesparksgen
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-leaderboards-gamesparks (1.2.1-builder)
// ---------------------------------------------------------------------------------------
// Generated on Thu Jul 12 2018 14:30:29 GMT+0200 (W. Europe Daylight Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-backend-gamesparks (1.0.0-builder)
// - coolgames-leaderboards-core (1.2.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_leaderboards_core_1 = require("@coolgames/coolgames-leaderboards-core");
/**
 * Leaderboards implementation for GameSparks
 *
 * @export
 * @class GameSparksLeaderboardService
 * @implements {ILeaderboardService}
 */
var GameSparksLeaderboardService = /** @class */ (function () {
    /**
     * Creates an instance of GameSparksLeaderboardService.
     *
     * @param {GameSparksBackendService} gameSparksService Reference to the GameSparks service
     *
     * @memberOf GameSparksLeaderboardService
     */
    function GameSparksLeaderboardService(gameSparksService) {
        /**
         * Supported features
         *
         * @private
         * @type { [feature: LeaderboardFeature]: boolean }
         * @memberOf GameSparksLeaderboardService
         */
        this._supportedFeatures = (_a = {},
            _a[LeaderboardFeature.GLOBAL_LEADERBOARDS] = true,
            _a[LeaderboardFeature.LOCAL_LEADERBOARDS] = true,
            _a[LeaderboardFeature.CONTEXT_LEADERBOARDS] = false,
            _a[LeaderboardFeature.TIME_PARTITIONS] = true,
            _a[LeaderboardFeature.USER_FILTER] = true,
            _a[LeaderboardFeature.LEADERBOARD_UPDATES] = false,
            _a);
        this._gameSparksService = gameSparksService;
        var _a;
    }
    /**
     * Dummy initialization method
     *
     * @returns {Promise<void>} A promise that the service is initialized
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype.initialize = function () {
        return new Promise(function (resolve, reject) { return resolve(); });
    };
    /**
     * Checks if the specified leaderboard feature is supported by the concrete implementation
     * (FB Instant, Kakao, Line, etc.).
     *
     * @param {LeaderboardFeature} feature The desired feature to check
     * @returns {boolean} True if supported, false otherwise
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype.isFeatureSupported = function (feature) {
        if (!this._supportedFeatures.hasOwnProperty(feature)) {
            console.error("Feature " + feature + " is not configured on GameSparksLeaderboardService");
            return false;
        }
        return this._supportedFeatures[feature];
    };
    /**
     * Sends the score to the server.
     * The score is automatically assigned to the corresponding YEAR / MONTH / WEEK on the server side.
     * IMPORTANT: it takes some time for the score to propagate on the leaderboard(s) an trigger events.
     *
     * @param {number} score The new score
     * @param {string} [countryCode] Optional country code (if not set, it should be handled by the server)
     * @param {string} [leaderboardCode] Optional parameter to be used if you have more than one leaderboard setup on the server side
     * @param {string} [contextId] Ignored on Gamesparks
     * @param {string[]} [labels] Ignored on Gamesparks
     * @param {Object[]} [playerDatas] Ignored on Gamesparks
     *
     * @returns {Promise<void>} The promise object that the score was saved
     *
     * @memberOf GameSparksLeaderboardService.
     */
    GameSparksLeaderboardService.prototype.sendScore = function (score, countryCode, leaderboardCode, contextId, labels, playerDatas) {
        if (countryCode === void 0) { countryCode = null; }
        if (leaderboardCode === void 0) { leaderboardCode = LeaderboardType.DEFAULT_LEADERBOARD_CODE; }
        var self = this;
        return new Promise(function (resolve, reject) {
            leaderboardCode = leaderboardCode || LeaderboardType.DEFAULT_LEADERBOARD_CODE;
            if (!self._gameSparksService || !self._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Leaderboards");
                reject("GameSparksBackendService is required to be initialized for working with Leaderboards");
            }
            else {
                self._gameSparksService.sendWithData("LogEventRequest", {
                    "COUNTRY": countryCode,
                    "eventKey": "SEND_SCORE_" + leaderboardCode,
                    "SCORE": score
                }, function (response) {
                    if (!response[GameSparksLeaderboardService.ERROR]) {
                        resolve();
                    }
                    else {
                        reject("error sending score: " + JSON.stringify(response[GameSparksLeaderboardService.ERROR]));
                    }
                });
            }
        });
    };
    /**
     * Gets the current position (rank) from the player in the specified leaderboards.
     * Currently, it's not possible to specify a list of friends, for getting the position on a friends leaderboard use the getAroundMe method.
     *
     * @param {LeaderboardType[]} leaderboardTypes An array of desired leaderboards
     * @returns {Promise<any>} The promise object, with the plain response from the server
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype.getCurrentPosition = function (leaderboardTypes) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Leaderboards");
                reject("GameSparksBackendService is required to be initialized for working with Leaderboards");
            }
            else if (!leaderboardTypes || leaderboardTypes.length === 0) {
                console.error("LeaderboardType is required to get data from the server");
                reject("LeaderboardType is required to get data from the server");
            }
            else {
                var leaderboardIds = _this._getLeaderboardIds(leaderboardTypes);
                _this._gameSparksService.sendWithData("GetLeaderboardEntriesRequest", {
                    "player": _this._gameSparksService.gameSparksUserId,
                    "leaderboards": leaderboardIds
                }, function (response) {
                    if (!response[GameSparksLeaderboardService.ERROR]) {
                        resolve(response);
                    }
                    else {
                        reject("error getting current position: " + JSON.stringify(response[GameSparksLeaderboardService.ERROR]));
                    }
                });
            }
        });
    };
    /**
     * Gets leaderboard data from the player and people around him/her.
     *
     * @param {LeaderboardType} leaderboardType The leaderboard type
     * @param {number} entryCount The number of entries (above and below) the current position
     * @param {string[]} [playerData=[]] If required, an array with all required "labels" stored on the player data (eg: player level, info, etc)
     * @param {string[]} [friendIds=[]] If specified, it will get a list with only the specified users (including the player). If player has no friends but you still want the friends leaderboard, specify at least the user id in the friend's list
     * @param {number} [includeFirst=0] If specified, will return also the topmost people from the specified leaderboard
     * @returns {Promise<any>} The promise object, with the plain response from the server
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype.getAroundMeData = function (leaderboardType, entryCount, playerData, friendIds, includeFirst) {
        var _this = this;
        if (playerData === void 0) { playerData = []; }
        if (friendIds === void 0) { friendIds = []; }
        if (includeFirst === void 0) { includeFirst = 0; }
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Leaderboards");
                reject("GameSparksBackendService is required to be initialized for working with Leaderboards");
            }
            else if (!leaderboardType) {
                console.error("LeaderboardType is required to get data from the server");
                reject("LeaderboardType is required to get data from the server");
            }
            else {
                friendIds = _this._sanitizeFriendIdList(friendIds);
                var requestData = {
                    "eventKey": "LB_AROUND_ME",
                    "ENTRY_COUNT": entryCount,
                    "INCLUDE_FIRST": (includeFirst || 0),
                    "FRIENDS_LIST": friendIds,
                    "LB_SHORT_CODE": _this._getLeaderboardId(leaderboardType),
                    "PLAYER_DATA_LABELS": playerData
                };
                _this._gameSparksService.sendWithData("LogEventRequest", requestData, function (response) {
                    if (!response[GameSparksLeaderboardService.ERROR]) {
                        resolve({
                            "leaderboardData": response[GameSparksLeaderboardService.SCRIPT_DATA][GameSparksLeaderboardService.LEADERBOARD_DATA],
                            "leaderboardFirstData": response[GameSparksLeaderboardService.SCRIPT_DATA][GameSparksLeaderboardService.LEADERBOARD_FIRST_DATA]
                        });
                    }
                    else {
                        reject("error getting aroundMe data: " + JSON.stringify(response));
                    }
                });
            }
        });
    };
    /**
     * Gets a list of leaderboard entries
     *
     * @param {LeaderboardType} leaderboardType The leaderboard type
     * @param {number} entryCount The number of entries
     * @param {number} [offset=0] Optional parameter for pagination
     * @param {string[]} [playerData=null] If required, an array with all required "labels" stored on the player data (eg: player level, info, etc)
     * @param {string[]} [friendIds=null] If specified, will return also the topmost people from the specified leaderboard
     * @returns {Promise<any>} The promise object, with the plain response from the server
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype.getLeaderboardData = function (leaderboardType, entryCount, offset, playerData, friendIds) {
        var _this = this;
        if (offset === void 0) { offset = 0; }
        if (playerData === void 0) { playerData = null; }
        if (friendIds === void 0) { friendIds = null; }
        return new Promise(function (resolve, reject) {
            if (!_this._gameSparksService || !_this._gameSparksService.isInitialized()) {
                console.error("GameSparksBackendService is required to be initialized for working with Leaderboards");
                reject("GameSparksBackendService is required to be initialized for working with Leaderboards");
            }
            else if (!leaderboardType) {
                console.error("LeaderboardType is required to get data from the server");
                reject("LeaderboardType is required to get data from the server");
            }
            else {
                friendIds = _this._sanitizeFriendIdList(friendIds);
                var requestData = {
                    "eventKey": "LB_DATA_REQUEST",
                    "ENTRY_COUNT": entryCount,
                    "OFFSET": offset,
                    "FRIENDS_LIST": friendIds,
                    "LB_SHORT_CODE": _this._getLeaderboardId(leaderboardType),
                    "PLAYER_DATA_LABELS": playerData
                };
                _this._gameSparksService.sendWithData("LogEventRequest", requestData, function (response) {
                    if (!response[GameSparksLeaderboardService.ERROR]) {
                        resolve({
                            "leaderboardData": response[GameSparksLeaderboardService.SCRIPT_DATA][GameSparksLeaderboardService.LEADERBOARD_DATA]
                        });
                    }
                    else {
                        reject("error getting leaderboard data: " + JSON.stringify(response[GameSparksLeaderboardService.ERROR]));
                    }
                });
            }
        });
    };
    /**
     * Not supported
     * Send a game update in the current context
     *
     * @param {LeaderboardType} leaderboardType
     * @returns {Promise<void>}
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype.sendLeaderboardUpdate = function (leaderboardType) {
        return new Promise(function (resolve, reject) { return resolve(); });
    };
    /**
     * Returns the leaderboard ids for the types array
     *
     * @private
     * @param {LeaderboardType[]} leaderboardTypes
     * @returns {string[]}
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype._getLeaderboardIds = function (leaderboardTypes) {
        var _this = this;
        var leaderboardIds = [];
        leaderboardTypes.forEach(function (leaderboardType) {
            leaderboardIds.push(_this._getLeaderboardId(leaderboardType));
        });
        return leaderboardIds;
    };
    /**
     * Returns the leaderboard id for the type
     *
     * @private
     * @param {LeaderboardType} leaderboardType
     * @returns {string}
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype._getLeaderboardId = function (leaderboardType) {
        // Leaderboard Prefix (Code)
        var leaderboardId = leaderboardType.leaderboardCode || LeaderboardType.DEFAULT_LEADERBOARD_CODE;
        // Global or Local
        leaderboardId += "_";
        if (!leaderboardType.country) {
            leaderboardId += "GLOBAL";
            if (leaderboardType.month > 0) {
                leaderboardId += "_MONTHLY";
            }
            else if (leaderboardType.week > 0) {
                leaderboardId += "_WEEKLY";
            }
            else if (leaderboardType.year > 0) {
                leaderboardId += "_YEARLY";
            }
        }
        else {
            leaderboardId += "LOCAL";
            if (leaderboardType.month > 0) {
                leaderboardId += "_MONTHLY";
            }
            else if (leaderboardType.week > 0) {
                leaderboardId += "_WEEKLY";
            }
            else if (leaderboardType.year > 0) {
                leaderboardId += "_YEARLY";
            }
            leaderboardId += ".COUNTRY.";
            leaderboardId += leaderboardType.country;
        }
        // Checking if leaderboard is split by time
        if (leaderboardType.year > 0) {
            leaderboardId += ".";
            if (leaderboardType.month > 0) {
                // Monthly leaderboard
                leaderboardId += "MONTH.";
                leaderboardId += leaderboardType.year + "_" + leaderboardType.month;
            }
            else if (leaderboardType.week > 0) {
                // Weekly leaderboard
                leaderboardId += "WEEK.";
                leaderboardId += leaderboardType.year + "_" + leaderboardType.week;
            }
            else {
                // Yearly leaderboard
                leaderboardId += "YEAR.";
                leaderboardId += leaderboardType.year;
            }
        }
        return leaderboardId;
    };
    /**
     * Makes sure all IDs sent to gamesparks are lower case
     *
     * @private
     * @param {string[]} list
     * @returns {string[]}
     *
     * @memberOf GameSparksLeaderboardService
     */
    GameSparksLeaderboardService.prototype._sanitizeFriendIdList = function (list) {
        if (list) {
            for (var i = 0; i < list.length; i++) {
                list[i] = list[i].toLowerCase();
            }
        }
        else {
            list = [];
        }
        return list;
    };
    // Static literals
    GameSparksLeaderboardService.ERROR = "error";
    GameSparksLeaderboardService.SCRIPT_DATA = "scriptData";
    GameSparksLeaderboardService.LEADERBOARD_DATA = "leaderboardData";
    GameSparksLeaderboardService.LEADERBOARD_FIRST_DATA = "leaderboardFirstData";
    return GameSparksLeaderboardService;
}());
exports.GameSparksLeaderboardService = GameSparksLeaderboardService;
//******************************************************
//*****    Script Resource: coolgamesanalyticscoregen
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-analytics-core (6.0.0-builder)
// ---------------------------------------------------------------------------------------
// Generated on Wed Mar 20 2019 11:25:36 GMT+0100 (W. Europe Standard Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnalyticsEnvironment;
(function (AnalyticsEnvironment) {
    AnalyticsEnvironment["Dev"] = "dev";
    AnalyticsEnvironment["Staging"] = "qa";
    AnalyticsEnvironment["Demo"] = "demo";
    AnalyticsEnvironment["Prod"] = "prod";
})(AnalyticsEnvironment = exports.AnalyticsEnvironment || (exports.AnalyticsEnvironment = {}));

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var IAnalyticsService_1 = require("./IAnalyticsService");
/**
 * Class for the analytics event objects.
 *
 * @export
 * @class AnalyticsEventObject
 */
var AnalyticsEventObject = /** @class */ (function () {
    /**
     * @param {AnalyticsEventType} type The type of analytics event
     * @memberOf AnalyticsEventObject
     */
    function AnalyticsEventObject(type) {
        /**
         * The value data to send
         * For Design or Progression event
         * @memberOf AnalyticsEventObject
         */
        this.value = 0;
        /**
         * The entry point of the event
         * For Ad-related events
         * @memberOf AnalyticsEventObject
         */
        this.entryPoint = "";
        /**
         * The status of the user progression (if type is an progression)
         * @memberOf AnalyticsEventObject
         */
        this.progressionStatus = AnalyticsProgressionStatus.Undefined;
        /**
         * The severity of the error (if type is an error)
         * @memberOf AnalyticsEventObject
         */
        this.severity = AnalyticsErrorSeverity.Undefined;
        /**
         * An array of progression data to send
         * (if type is Progression, this array length must be at least 1 and less than or equal to 3)
         *
         * @memberOf AnalyticsEventObject
         */
        this.progression = [];
        /**
         * The error message to send in the event
         * (for type Error)
         *
         * @memberOf AnalyticsEventObject
         */
        this.msg = "";
        /**
         * The progression data to send
         * @memberOf AnalyticsEventObject
         */
        this.eventIds = [];
        this.type = type;
    }
    return AnalyticsEventObject;
}());
exports.AnalyticsEventObject = AnalyticsEventObject;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class for storing/handling enqueued analytics events
 *
 * @export
 * @class AnalyticsEventQueue
 */
var AnalyticsEventQueue = /** @class */ (function () {
    function AnalyticsEventQueue() {
        /**
         * The actual event queue/array
         * @private
         * @type {AnalyticsEventObject[]}
         * @memberOf AnalyticsEventQueue
         */
        this._eventQueue = [];
    }
    /**
     * Get the number of queued events
     * @public
     * @returns {number}
     * @memberOf AnalyticsEventQueue
     */
    AnalyticsEventQueue.prototype.getNumberOfQueuedEvents = function () {
        return this._eventQueue.length;
    };
    /**
     * Adds an event to the queue
     * @public
     * @returns {void}
     * @memberOf AnalyticsEventQueue
     */
    AnalyticsEventQueue.prototype.addEvent = function (data) {
        if (!data.type) // We get unknown lint errors when doing "if(!data.type || data.type === AnalyticsEventType.Undefined)"
         {
            console.warn("Analytics event type is undefined!");
            return;
        }
        this._eventQueue.push(data);
    };
    /**
     * Returns the queue and clears it
     * @public
     * @returns {AnalyticsEventObject[]}
     * @memberOf AnalyticsEventQueue
     */
    AnalyticsEventQueue.prototype.clearEvents = function () {
        // Store array
        var tempArr = this._eventQueue;
        // Clear array
        this._eventQueue = [];
        // Return array
        return tempArr;
    };
    return AnalyticsEventQueue;
}());
exports.AnalyticsEventQueue = AnalyticsEventQueue;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Wrapper class for all analytics configurations
 *
 * @export
 * @class AnalyticsServiceSettings
 */
var AnalyticsServiceSettings = /** @class */ (function () {
    /**
     * Creates an instance of AnalyticsServiceSettings.
     * @param {string} userId The user id
     * @param {string} gameVersion The game version
     * @param {string} deviceModel The device model
     * @param {string} [locale] The locale
     *
     * @memberOf AnalyticsServiceSettings
     */
    function AnalyticsServiceSettings(userId, gameVersion, deviceModel, locale) {
        /**
         * If debug info is turned on (default false)
         *
         * @type {boolean}
         * @memberOf AnalyticsServiceSettings
         */
        this.debugInfo = false;
        this._userId = userId;
        this._gameVersion = gameVersion;
        this._deviceModel = deviceModel;
        this._locale = locale;
    }
    /**
     * Access method for the user id property
     *
     * @returns {string}
     *
     * @memberOf AnalyticsServiceSettings
     */
    AnalyticsServiceSettings.prototype.getUserId = function () {
        return this._userId;
    };
    /**
     * Access method for the game version property
     *
     * @returns {string} The game version
     *
     * @memberOf AnalyticsServiceSettings
     */
    AnalyticsServiceSettings.prototype.getGameVersion = function () {
        return this._gameVersion;
    };
    /**
     * Access method for the device model property
     *
     * @returns {string}
     *
     * @memberOf AnalyticsServiceSettings
     */
    AnalyticsServiceSettings.prototype.getDeviceModel = function () {
        return this._deviceModel;
    };
    /**
     * Access method for the locale property
     *
     * @returns {string}
     *
     * @memberOf AnalyticsServiceSettings
     */
    AnalyticsServiceSettings.prototype.getLocale = function () {
        return this._locale;
    };
    return AnalyticsServiceSettings;
}());
exports.AnalyticsServiceSettings = AnalyticsServiceSettings;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The error severity enumeration
 *
 * @export
 * @enum {number}
 */
var AnalyticsErrorSeverity;
(function (AnalyticsErrorSeverity) {
    AnalyticsErrorSeverity[AnalyticsErrorSeverity["Undefined"] = 0] = "Undefined";
    AnalyticsErrorSeverity[AnalyticsErrorSeverity["Debug"] = 1] = "Debug";
    AnalyticsErrorSeverity[AnalyticsErrorSeverity["Info"] = 2] = "Info";
    AnalyticsErrorSeverity[AnalyticsErrorSeverity["Warning"] = 3] = "Warning";
    AnalyticsErrorSeverity[AnalyticsErrorSeverity["Error"] = 4] = "Error";
    AnalyticsErrorSeverity[AnalyticsErrorSeverity["Critical"] = 5] = "Critical";
})(AnalyticsErrorSeverity = exports.AnalyticsErrorSeverity || (exports.AnalyticsErrorSeverity = {}));
/**
 * The progression status enumeration
 *
 * @export
 * @enum {number}
 */
var AnalyticsProgressionStatus;
(function (AnalyticsProgressionStatus) {
    AnalyticsProgressionStatus[AnalyticsProgressionStatus["Undefined"] = 0] = "Undefined";
    AnalyticsProgressionStatus[AnalyticsProgressionStatus["Start"] = 1] = "Start";
    AnalyticsProgressionStatus[AnalyticsProgressionStatus["Complete"] = 2] = "Complete";
    AnalyticsProgressionStatus[AnalyticsProgressionStatus["Fail"] = 3] = "Fail";
})(AnalyticsProgressionStatus = exports.AnalyticsProgressionStatus || (exports.AnalyticsProgressionStatus = {}));
/**
 * The gender enumeration
 *
 * @export
 * @enum {number}
 */
var AnalyticsGender;
(function (AnalyticsGender) {
    AnalyticsGender[AnalyticsGender["Undefined"] = 0] = "Undefined";
    AnalyticsGender[AnalyticsGender["Male"] = 1] = "Male";
    AnalyticsGender[AnalyticsGender["Female"] = 2] = "Female";
})(AnalyticsGender = exports.AnalyticsGender || (exports.AnalyticsGender = {}));
/**
 * The resource flow type enumeration
 *
 * @export
 * @enum {number}
 */
var AnalyticsResourceFlowType;
(function (AnalyticsResourceFlowType) {
    AnalyticsResourceFlowType[AnalyticsResourceFlowType["Undefined"] = 0] = "Undefined";
    AnalyticsResourceFlowType[AnalyticsResourceFlowType["Source"] = 1] = "Source";
    AnalyticsResourceFlowType[AnalyticsResourceFlowType["Sink"] = 2] = "Sink";
})(AnalyticsResourceFlowType = exports.AnalyticsResourceFlowType || (exports.AnalyticsResourceFlowType = {}));
/**
 * The type of event enumeration
 *
 * @export
 * @enum {number}
 */
var AnalyticsEventType;
(function (AnalyticsEventType) {
    AnalyticsEventType[AnalyticsEventType["Undefined"] = 0] = "Undefined";
    AnalyticsEventType[AnalyticsEventType["Design"] = 1] = "Design";
    AnalyticsEventType[AnalyticsEventType["Progression"] = 2] = "Progression";
    AnalyticsEventType[AnalyticsEventType["Error"] = 3] = "Error";
    AnalyticsEventType[AnalyticsEventType["AdClick"] = 4] = "AdClick";
    AnalyticsEventType[AnalyticsEventType["AdImpression"] = 5] = "AdImpression";
    AnalyticsEventType[AnalyticsEventType["AdRequest"] = 6] = "AdRequest";
})(AnalyticsEventType = exports.AnalyticsEventType || (exports.AnalyticsEventType = {}));

//******************************************************
//*****    Script Resource: coolgamesanalyticslochmessgen
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-analytics-lochmess (3.0.1-builder)
// ---------------------------------------------------------------------------------------
// Generated on Wed Mar 20 2019 14:55:23 GMT+0100 (W. Europe Standard Time)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
// DEPENDENCIES: 
// - coolgames-analytics-core (6.0.0-builder)
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_analytics_core_1 = require("@coolgames/coolgames-analytics-core");
var LochMessHelper_1 = require("./LochMessHelper");
var LochMessGameData_1 = require("./LochMessGameData");
var LochMessAnalyticsServiceKeys_1 = require("./LochMessAnalyticsServiceKeys");
// tslint:disable:no-string-literal
var LochMessAnalyticsService = /** @class */ (function () {
    function LochMessAnalyticsService(enableLogs) {
        this._initialized = false;
        this._settings = null;
        this._sessionId = null;
        this._isSessionPaused = true;
        this._isSessionStarted = false;
        this._eventNumber = 0;
        this._eventQueue = [];
        this._data = new LochMessGameData();
        // 
        this._postingHelper = LochMessHelper.postEvent;
        this._maxRetryCount = 3;
        this._retryDelay = 1000;
        this._enableLogs = enableLogs;
    }
    /**
     * Used to set custom data (user id, etc)
     * This should be called before initialization
     *
     * @param {object} settings
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.putSettings = function (settings) {
        this._settings = settings;
    };
    /**
     * Method to know if the service is initialized
     *
     * @returns {boolean} If the service is initialized
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.isInitialized = function () {
        return this._initialized;
    };
    /**
     * Initializes the Analytics service.
     *
     * @returns {Promise<void>} A promise that this service will be initialized
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.initialize = function () {
        var _this = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var promises, i, currentEvent;
            var _this = this;
            return __generator(this, function (_a) {
                if (this._initialized) {
                    this._error("Already initialized");
                    reject("Already initialized");
                    return [2 /*return*/];
                }
                if (!this._settings) {
                    this._error("Settings missing");
                    reject("Settings missing");
                    return [2 /*return*/];
                }
                this._sessionId = LochMessHelper.generateFakeUUID() + this._settings.userId;
                // add the init event to the queue
                this.reportEvent("system", "init", {});
                // send a first session length event
                this._onUpdateSessionLength();
                promises = [];
                for (i = 0; i < this._eventQueue.length; i++) {
                    currentEvent = this._eventQueue[i];
                    promises.push(this._sendEvent(currentEvent));
                }
                Promise.all(promises)
                    .then(function () {
                    _this._eventQueue = [];
                    _this._initialized = true;
                    _this._log("Initialized! sessionId: " + _this._sessionId);
                    // start the session length reporting interval
                    window.setInterval(_this._onUpdateSessionLength.bind(_this), _this._settings.sessionLengthUpdateInterval);
                    resolve();
                })
                    .catch(function (reason) {
                    var error = "Failed to initialize! " + reason;
                    _this._error(error);
                    reject(error);
                });
                return [2 /*return*/];
            });
        }); });
    };
    /**
     * Starts counting session length
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.startSession = function () {
        if (this._isSessionStarted) {
            this._error("startSession was already called for this session");
            return;
        }
        this._isSessionStarted = true;
        this._sessionLength = 0;
        this._lastSessionTs = Date.now();
        this._isSessionPaused = false;
    };
    /**
     * pause/unpause the counting of the session length
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.setSessionPause = function (isPaused) {
        if (isPaused === this._isSessionPaused) {
            this._error("Old session pause state (" + this._isSessionPaused + ") is the same as the new state (" + isPaused + ")");
            return;
        }
        this._isSessionPaused = isPaused;
        if (this._isSessionPaused) {
            // accumulate everything up to this point
            var now = Date.now();
            this._sessionLength += now - this._lastSessionTs;
            this._log("Session is paused.");
        }
        else {
            // reset the last timestamp
            this._lastSessionTs = Date.now();
            this._log("Session is unpaused.");
        }
    };
    /**
     * Used to send events.
     * When used before initializing it will queue the events and send them during the initialization
     *
     * @param {string} category
     * @param {string} name
     * @param {IAnalyticsEventParams} [parameters]
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.reportEvent = function (category, name, parameters) {
        // if (!parameters) {
        //     parameters = {};
        // }
        // LochMessHelper.checkForParameterErrors(parameters);
        // var mappedParams = LochMessHelper.mapKeys(parameters);
        // var ev = {};
        // ev[LochMessAnalyticsServiceKeys.EV_UUID] = "NESSIE_UUID";
        // ev[LochMessAnalyticsServiceKeys.EV_DETAIL] = this._buildEventDetailObject(this._eventNumber, category, name, mappedParams);
        // this._eventNumber++;
        // if (this._initialized) {
        //     this._sendEvent(ev)
        //         .catch(function (reason) {
        //         // alert listeners?
        //     });
        // }
        // else {
        //     this._log("reportEvent - Adding to queue: " + ev);
        //     this._eventQueue.push(ev);
        // }
    };
    /**
     * Used to set info about the current context.
     * This needs to be called everytime the context changes
     *
     * @param {string} type type / name of the context
     * @param {string} id
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.setContext = function (type, id) {
        this._data.contextType = type;
        this._data.contextId = id;
        this._log("Context set to: " + type + " - " + id);
    };
    /**
     * Used to set the game screen name or location in the game.
     * This needs to be called everytime the screen changes
     * It also sends a general_flow.screen event.
     *
     * @param {string} name
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.setScreenName = function (name) {
        if (!this._initialized && this._data.screenName) {
            this._error("Trying to set the screen name multiple times before initialization!: current: " + this._data.screenName + ", new: " + name);
        }
        this._data.screenName = name;
        this._log("ScreenName set to: " + name);
        if (this._initialized) {
            this.reportEvent("general_flow", "screen", {});
        }
    };
    /**
     * Register a callback to be called everytime there is an analytics error
     *
     * @param {(error: string) => void} func
     *
     * @memberOf IAnalyticsService
     */
    LochMessAnalyticsService.prototype.setOnErrorCallback = function (func) {
        if (this._errorCallback) {
            this._error("An error callback is already registered! Replacing it with the new one.");
        }
        this._errorCallback = func;
    };
    LochMessAnalyticsService.prototype.endSession = function () {
        throw new Error("Method is deprecated. Please use \"reportEvent\" for all your analytics needs!");
    };
    LochMessAnalyticsService.prototype.reportDesignEvent = function (eventIds, value) {
        throw new Error("Method is deprecated. Please use \"reportEvent\" for all your analytics needs!");
    };
    LochMessAnalyticsService.prototype.reportProgression = function (status, eventIds, score) {
        throw new Error("Method is deprecated. Please use \"reportEvent\" for all your analytics needs!");
    };
    LochMessAnalyticsService.prototype.reportError = function (severity, msg) {
        throw new Error("Method is deprecated. Please use \"reportEvent\" for all your analytics needs!");
    };
    LochMessAnalyticsService.prototype._getDebugState = function () {
        var obj = {
            isSessionPaused: this._isSessionPaused,
            sessionLength: this._sessionLength,
            queueLength: this._eventQueue.length
        };
        return obj;
    };
    LochMessAnalyticsService.prototype._buildEventDetailObject = function (index, category, name, parameters) {
        var obj = {};
        obj[LochMessAnalyticsServiceKeys.EV_DETAIL_CATEGORY] = category;
        obj[LochMessAnalyticsServiceKeys.EV_DETAIL_NAME] = name;
        Object.keys(parameters).forEach(function (key) {
            obj[key] = parameters[key];
        });
        obj[LochMessAnalyticsServiceKeys.EV_DETAIL_NUMBER] = index;
        return obj;
    };
    LochMessAnalyticsService.prototype._buildDefaultObject = function () {
        var obj = {
            "dt": "RECEIVE_TIMESTAMP",
            "device": {
                "br_sh": "DEVICE_BROWSER_SHORTHAND",
                "br_fam": "DEVICE_BROWSER_FAMILY",
                "br_maj": "DEVICE_BROWSER_MAJOR",
                "br_min": "DEVICE_BROWSER_MINOR",
                "os_sh": "DEVICE_OS_SHORTHAND",
                "os_fam": "DEVICE_OS_FAMILY",
                "os_maj": "DEVICE_OS_MAJOR",
                "os_min": "DEVICE_OS_MINOR",
                "fam": "DEVICE_FAMILY"
            },
            "game": {
                "g_id": this._settings.appId,
                "env_id": this._settings.environment,
                "genre": this._settings.appGenre,
                "g_n": this._settings.appName,
                "b_id": this._settings.buildVersion,
                "sdk_v": this._settings.sdkVersion,
                "pub_pl": this._settings.platform
            },
            "marketing": {
                "soc_ent": this._settings.entryPointName
            },
            "user": {
                "u_id": this._settings.userId,
                "session": {
                    "id": this._sessionId,
                    "loc": this._data.screenName
                },
                "c_c": "ORIGIN_COUNTRY",
                "ip": "ORIGIN_IP",
                "soc_con": {
                    "et": this._data.contextType,
                    "id": this._data.contextId
                }
            }
        };
        return obj;
    };
    LochMessAnalyticsService.prototype._onUpdateSessionLength = function () {
        if (!this._isSessionStarted) {
            this._log("Session is not started. Skipping length update.");
            return;
        }
        if (this._isSessionPaused) {
            this._log("Session is paused. Skipping length update.");
            return;
        }
        var now = Date.now();
        var delta = now - this._lastSessionTs;
        this._sessionLength += delta;
        this._lastSessionTs = now;
        this._log("Adding " + delta + " ms to the session length. Total = " + this._sessionLength + " ms");
        var params = { length: this._sessionLength };
        this.reportEvent("system", "session_length", params);
    };
    LochMessAnalyticsService.prototype._log = function (text) {
        if (this._enableLogs) {
            console.log("Analytics: " + text);
        }
    };
    LochMessAnalyticsService.prototype._error = function (text) {
        console.error("Analytics: " + text);
        if (this._errorCallback) {
            this._errorCallback(text);
        }
    };
    LochMessAnalyticsService.prototype._buildUrl = function () {
        var isProd = this._settings.environment === AnalyticsEnvironment.Prod;
        var url = isProd ? LochMessAnalyticsService.PROD_ENDPOINT : LochMessAnalyticsService.STAGING_ENDPOINT;
        url += this._settings.validationSchema;
        return url;
    };
    LochMessAnalyticsService.prototype._sendEvent = function (ev) {
        var _this = this;
    };
    LochMessAnalyticsService.PROD_ENDPOINT = "https://nessie.live.uno.one/v1/nessie/p/";
    LochMessAnalyticsService.STAGING_ENDPOINT = "https://nessie.stage.uno.one/v1/nessie/d/";
    return LochMessAnalyticsService;
}());
exports.LochMessAnalyticsService = LochMessAnalyticsService;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LochMessAnalyticsServiceKeys;
(function (LochMessAnalyticsServiceKeys) {
    LochMessAnalyticsServiceKeys["EV_UUID"] = "e_uuid";
    LochMessAnalyticsServiceKeys["EV_DEFAULT"] = "e_default";
    LochMessAnalyticsServiceKeys["EV_DETAIL"] = "e_detail";
    LochMessAnalyticsServiceKeys["EV_DETAIL_CATEGORY"] = "cat";
    LochMessAnalyticsServiceKeys["EV_DETAIL_NAME"] = "en";
    LochMessAnalyticsServiceKeys["EV_DETAIL_NUMBER"] = "enr";
})(LochMessAnalyticsServiceKeys = exports.LochMessAnalyticsServiceKeys || (exports.LochMessAnalyticsServiceKeys = {}));

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var coolgames_analytics_core_1 = require("@coolgames/coolgames-analytics-core");
var LochMessAnalyticsServiceSettings = /** @class */ (function () {
    function LochMessAnalyticsServiceSettings() {
        // The time interval in miliseconds between sending session length events
        this.sessionLengthUpdateInterval = 30000; // ms
        // The name of the schema used for validating the events
        this.validationSchema = "invalid";
        // Only AnalyticsEnvironment.Prod sends events to our production endpoint
        this.environment = AnalyticsEnvironment.Dev;
    }
    return LochMessAnalyticsServiceSettings;
}());
exports.LochMessAnalyticsServiceSettings = LochMessAnalyticsServiceSettings;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LochMessGameData = /** @class */ (function () {
    function LochMessGameData() {
        this.contextType = "";
        this.contextId = "";
        this.screenName = "";
    }
    return LochMessGameData;
}());
exports.LochMessGameData = LochMessGameData;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LochMessHelper = /** @class */ (function () {
    function LochMessHelper() {
    }
    /* istanbul ignore next */
    /**
     * Utility method for sending an event to the backend
     *
     * @static
     * @param {string} url
     * @param {object} body
     * @returns {Promise<{isSent: boolean, error: string}>}
     *
     * @memberOf LochMessHelper
     */
    LochMessHelper.postEvent = function (url, body) {
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, true);
            xhr.onload = function () {
                if (xhr.response && xhr.status === 200) {
                    var responseObject = JSON.parse(xhr.response);
                    if (responseObject.status === "OK") {
                        resolve({ isSent: true, error: "" });
                    }
                    else {
                        resolve({ isSent: true, error: xhr.responseText });
                    }
                }
                else {
                    resolve({ isSent: true, error: xhr.responseText });
                }
            };
            xhr.onerror = function (error) {
                resolve({ isSent: false, error: JSON.stringify(error) });
            };
            xhr.send(JSON.stringify(body));
        });
    };
    /**
     * Generates a v4 UUID
     * Reference: https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
     *
     * @static
     * @returns {string}
     *
     * @memberOf LochMessHelper
     */
    LochMessHelper.generateFakeUUID = function () {
        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            // tslint:disable-next-line:no-bitwise
            var r = Math.random() * 16 | 0;
            // tslint:disable-next-line:no-bitwise
            var v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };
    /**
     *
     *
     * @static
     * @param {IAnalyticsEventParams} original
     * @returns {({ [key: string]: number | string | boolean })}
     *
     * @memberOf LochMessHelper
     */
    LochMessHelper.mapKeys = function (original) {
        var result = {
            "et": original.eventType,
            "v": original.value,
            "v_b": original.valueBoolean,
            "v_x": original.valueX,
            "v_y": original.valueY,
            "l": original.length,
            "d": original.difficulty,
            "sc": original.score,
            "id": original.id,
            "loc": original.location,
            "dir": original.direction,
        };
        return result;
    };
    /**
     * Checks if the supplied parameter object is valid.
     * throws an error if not
     *
     * @static
     * @param {IAnalyticsEventParams} original
     *
     * @memberOf LochMessHelper
     */
    LochMessHelper.checkForParameterErrors = function (original) {
        var template = {
            eventType: undefined,
            value: undefined,
            valueBoolean: undefined,
            valueX: undefined,
            valueY: undefined,
            length: undefined,
            difficulty: undefined,
            score: undefined,
            id: undefined,
            location: undefined,
            direction: undefined,
        };
        var templateKeys = Object.keys(template);
        var originalKeys = Object.keys(original);
        var _loop_1 = function (i) {
            var currentKey = originalKeys[i];
            if (templateKeys.findIndex(function (value) { return value === currentKey; }) < 0) {
                throw new Error("Incorrect event parameter: \"" + currentKey + "\"");
            }
        };
        for (var i = 0; i < originalKeys.length; i++) {
            _loop_1(i);
        }
    };
    return LochMessHelper;
}());
exports.LochMessHelper = LochMessHelper;

//******************************************************
//*****    Script Resource: coolgamesabtestgen
//******************************************************

//////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------
// coolgames-abtest (1.0.1-builder)
// ---------------------------------------------------------------------------------------
// Generated on Wed May 29 2019 12:00:08 GMT+0200 (CEST)
// DO NOT MODIFY THIS FILE ! 
// ---------------------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////

var exports = exports || {};
var require = require || function(modulePath){
    return exports;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ABTest = /** @class */ (function () {
    function ABTest(testInfo) {
        this.setMetadata = function (metadata) {
            this._metadata = metadata;
        };
        this.getVersion = function () {
            return this._version;
        };
        this.getMetadata = function () {
            return this._metadata;
        };
        this.getSegmentation = function () {
            return this._segmentation;
        };
        this._version = testInfo.version;
        this._probability = testInfo.probability;
        this._features = testInfo.features || [];
        this._probabilityRange = [0, this._probability];
        this._metadata = testInfo.metadata || {};
        this._segmentationData = testInfo.segmentation;
        this._segmentation = null;
        this._releaseVersion = testInfo.releaseVersion || null;
        if (this._segmentationData) {
            this._segmentation = this._createSegmentation(this._segmentationData);
        }
    }
    ABTest.prototype.calculateProbabiltyRange = function (probabilityStep) {
        var startProbability = probabilityStep;
        var endProbability = this._probability + probabilityStep;
        if (Math.round(endProbability) > 100) {
            throw new Error("[ABTest Module] The probability of the tests exceeds 100%");
        }
        // This ensures that this test will never be picked.
        if (this._probability <= 0) {
            startProbability = -1;
            endProbability = -1;
        }
        this._probabilityRange[0] = startProbability;
        this._probabilityRange[1] = endProbability;
    };
    ABTest.prototype.isProbabilityInRange = function (probabilty) {
        var startProbability = this._probabilityRange[0];
        var endProbability = this._probabilityRange[1];
        return probabilty >= startProbability && probabilty <= endProbability;
    };
    ABTest.prototype.getFeature = function (featureName) {
        for (var iFeature = 0; iFeature < this._features.length; iFeature++) {
            var currentFeature = this._features[iFeature];
            if (currentFeature === featureName) {
                return currentFeature;
            }
        }
        return null;
    };
    ABTest.prototype._createSegmentation = function (segmentationTestData) {
        var segmentationTests = [];
        var probabilitySum = 0;
        for (var iTest = 0; iTest < segmentationTestData.tests.length; iTest++) {
            var currentSegmentData = segmentationTestData.tests[iTest];
            var newSegmentTest = new ABTest({
                version: currentSegmentData.version,
                probability: currentSegmentData.probability,
                features: currentSegmentData.features,
                metadata: currentSegmentData.metadata,
                releaseVersion: this._releaseVersion,
                segmentation: null,
            });
            newSegmentTest.calculateProbabiltyRange(probabilitySum);
            probabilitySum += currentSegmentData.probability;
            segmentationTests[iTest] = newSegmentTest;
        }
        if (Math.round(probabilitySum) < 100) {
            throw new Error("The sum of the probability for the tests is less than 100%");
        }
        return segmentationTests;
    };
    return ABTest;
}());
exports.ABTest = ABTest;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ABTest_1 = require("./ABTest");
var ABTestManager = /** @class */ (function () {
    function ABTestManager(testData, currentVersion, previousVersion) {
        this._currentGameVersion = this.decodeGameVersion(currentVersion);
        this._previousGameVersion = this.decodeGameVersion(previousVersion);
        this._initialize(testData);
        this._checkTestVersion();
    }
    ABTestManager.prototype.decodeGameVersion = function (versionString) {
        var versionRegex = /([0-9]{1,3})\.([0-9]{1,3})(?:\.([0-9]{1,3})\.?([0-9]{0,3})_?([0-9]{0,10})([A-Za-z]{0,2}))?/;
        var versionRegexMatch = versionString.match(versionRegex);
        var versionInfo = {
            full: versionString,
            major: versionRegexMatch[1],
            minor: versionRegexMatch[2],
            patch: versionRegexMatch[3],
            build: versionRegexMatch[4],
            test: versionRegexMatch[5],
            segment: versionRegexMatch[6]
        };
        return versionInfo;
    };
    ABTestManager.prototype.setTestsById = function (testVersionId, segmentVersionId) {
        var newTest = this._pickVersion(this._tests, testVersionId);
        if (newTest) {
            this._currentTest = newTest;
        }
        this._currentTestVersion = this._currentTest.getVersion();
        // When a segmentVersionId is not provided a random version will be picked if the current version has segmentation
        this._currentSegmentTest = this._pickRandomVersion(this._currentTest.getSegmentation());
        if (segmentVersionId) {
            this._currentSegmentTest = this._pickVersion(this._currentTest.getSegmentation(), segmentVersionId);
        }
        this._currentSegmentVersion = this._currentSegmentTest ? this._currentSegmentTest.getVersion() : null;
        this._mergeMetadata();
    };
    ABTestManager.prototype.reassignTest = function () {
        var decodedGameVersion = this._currentGameVersion;
        var previousGameVersion = this._previousGameVersion;
        var rawTestData = this._rawTestData;
        var reassignedRawTests = [];
        var probabilityTotal = 0;
        for (var iTest = 0; iTest < rawTestData.tests.length; iTest++) {
            var currentTest = rawTestData.tests[iTest];
            var currentTestRelease = currentTest.releaseVersion;
            if (currentTestRelease) {
                var currentDecodedReleaseVersion = this.decodeGameVersion(currentTestRelease);
                var isMajorGreater = currentDecodedReleaseVersion.major >= decodedGameVersion.major;
                var isMinorGreater = currentDecodedReleaseVersion.minor >= decodedGameVersion.minor;
                var comesFromGenpop = previousGameVersion.test === ABTestManager.GENERAL_POPULATION_ID;
                var testIsGenPop = currentTest.version === ABTestManager.GENERAL_POPULATION_ID;
                if ((isMajorGreater && isMinorGreater) || (comesFromGenpop && testIsGenPop)) {
                    probabilityTotal += currentTest.probability;
                    reassignedRawTests.push(currentTest);
                }
            }
        }
        var probabilityFactor = 100 / probabilityTotal;
        for (var iTest = 0; iTest < reassignedRawTests.length; iTest++) {
            var currentTest = reassignedRawTests[iTest];
            currentTest.probability = currentTest.probability * probabilityFactor;
        }
        this._currentTest = null;
        this._currentSegmentTest = null;
        this._initialize({ tests: reassignedRawTests });
    };
    ABTestManager.prototype.isTestPresent = function (testVersion) {
        for (var iTest = 0; iTest < this._tests.length; iTest++) {
            var currentTest = this._tests[iTest];
            if (currentTest.getVersion() === testVersion) {
                return true;
            }
        }
        return false;
    };
    ABTestManager.prototype.getFullVersionString = function () {
        var currentTestVersion = this._currentTestVersion;
        var currentSegmentVersion = this._currentSegmentVersion || "";
        var versionNumber = this._currentGameVersion.major + "." + this._currentGameVersion.minor + "." + this._currentGameVersion.patch + "." + this._currentGameVersion.build;
        return versionNumber + "_" + currentTestVersion + currentSegmentVersion;
    };
    ABTestManager.prototype.isFeatureSupported = function (featureName) {
        var featureTest = this._currentTest.getFeature(featureName);
        if (featureTest) {
            return true;
        }
        if (this._currentSegmentTest) {
            var featureSegment = this._currentSegmentTest.getFeature(featureName);
            if (featureSegment) {
                return true;
            }
        }
        return false;
    };
    ABTestManager.prototype.getMetadata = function () {
        return this._currentTest.getMetadata();
    };
    ABTestManager.prototype._initialize = function (testData) {
        this._rawTestData = testData;
        this._tests = this._createTests(this._rawTestData);
        this._currentTest = this._pickRandomVersion(this._tests);
        this._currentTestVersion = this._currentTest.getVersion();
        var segmentationData = this._currentTest.getSegmentation();
        if (segmentationData) {
            this._currentSegmentTest = this._pickRandomVersion(segmentationData);
        }
        this._currentSegmentVersion = this._currentSegmentTest ? this._currentSegmentTest.getVersion() : null;
        this._mergeMetadata();
        return true;
    };
    ABTestManager.prototype._checkTestVersion = function () {
        var isSameMajor = this._previousGameVersion.major === this._currentGameVersion.major;
        var isSameMinor = this._previousGameVersion.minor === this._currentGameVersion.minor;
        var isPartOfTest = this._previousGameVersion.test.length > 0;
        var testVersion = this._previousGameVersion.test;
        var segmentVersion = this._previousGameVersion.segment;
        // Major and Minor are matching, continue with the assigned test.
        if (isSameMajor && isSameMinor) {
            if (isPartOfTest) {
                this.setTestsById(testVersion, segmentVersion);
            }
            // Version doesn't match with the last seen version
        }
        else {
            if (isPartOfTest) {
                if (testVersion === ABTestManager.GENERAL_POPULATION_ID) {
                    // Reassign test
                    this.reassignTest();
                }
                else {
                    // Check if the user is still part of a test.
                    if (this.isTestPresent(testVersion)) {
                        // Continue with the test
                        this.setTestsById(testVersion, segmentVersion);
                    }
                }
            }
        }
    };
    ABTestManager.prototype._pickRandomVersion = function (testsList) {
        var randomRoll = Math.random() * 100;
        if (testsList) {
            for (var iTest = 0; iTest < testsList.length; iTest++) {
                var currentTest = testsList[iTest];
                if (currentTest.isProbabilityInRange(randomRoll)) {
                    return currentTest;
                }
            }
        }
    };
    ABTestManager.prototype._createTests = function (rawTestData) {
        var testData = rawTestData.tests;
        var tests = [];
        var probabilitySum = 0;
        for (var iTest = 0; iTest < testData.length; iTest++) {
            var currentTestData = testData[iTest];
            var newTest = new ABTest(currentTestData);
            newTest.calculateProbabiltyRange(probabilitySum);
            probabilitySum += currentTestData.probability;
            tests[iTest] = newTest;
        }
        if (Math.round(probabilitySum) < 100) {
            throw new Error("The sum of the probability for the tests is less than 100%");
        }
        return tests;
    };
    ABTestManager.prototype._mergeMetadata = function () {
        var currentSegment = this._currentSegmentTest;
        var currentTestMetadata = this._currentTest.getMetadata();
        if (currentSegment) {
            var segmentMetadata = currentSegment.getMetadata();
            for (var key in segmentMetadata) {
                if (segmentMetadata[key]) {
                    currentTestMetadata[key] = segmentMetadata[key];
                }
            }
        }
        this._currentTest.setMetadata(currentTestMetadata);
    };
    ABTestManager.prototype._pickVersion = function (testsList, versionId) {
        if (testsList) {
            for (var iTest = 0; iTest < testsList.length; iTest++) {
                var currentTest = testsList[iTest];
                if (currentTest.getVersion() === versionId) {
                    return currentTest;
                }
            }
        }
    };
    ABTestManager.GENERAL_POPULATION_ID = "0";
    return ABTestManager;
}());
exports.ABTestManager = ABTestManager;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

//******************************************************
//*****    Script Resource: UIEmpty
//******************************************************

// ***************************************
// tgfDialogs.UiEmpty
//
// This dialog displays an empty game user interface.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 9-11-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbKeyCodes */
/*global tgfFunctions, tgfDialogs, tgfComponents, tgfPlayer, tgfDictionary, tgfGraphics, tgfSettings, tgfScale, tgfEffects */
/*global s_ui_background */


tgfSettings.dialogDefaults.uiEmpty = {
	layer: -900,                                        // The layer, set to put it below other dialogs
	x: undefined,                                       // X-position. When undefined it is placed at the left of the safe zone
	y: undefined,                                       // Y-position. When undefined it is placed at the middle of the safe zone
	width: undefined,                                   // The width. When undefined the size of the background image
	height: undefined,                                  // The height. When undefined the size of the background image
	backgroundImage: typeof s_ui_background !== "undefined" ? s_ui_background : undefined,  // Background image
	autoPosition: false,                                // Whether to automatically position the dialog
	autoPositionHor: "left",                            // How to automatic position it with respect to visible area ("left", "right", "center")
	autoPositionVert: "middle",                         // How to automatic position it with respect to visible area ("top", "bottom", "middle")
	autoVisibleRegion: false,                           // Whether positioned with respect to visible region (or safe zone)
	marginHor: tgfScale(32),                            // Margin from the boundary (when auto-positioning)
	marginVert: tgfScale(32),                           // Margin from the boundary (when auto-positioning) 
	appearEffect: {effect: tgfEffects.scale, duration: 0.5, startScale: 0, ease: tbEase.easeOutOvershoot, easeArgument: 1.2},
	disappearEffect: {effect: tgfEffects.scale, duration: 0.5, endScale: 0, ease: tbEase.easeInOvershoot, easeArgument: 1.2},   
	components: [],                                     // The additional components to add
	// Additional properties for the components
	backgroundProperties: null,                         // Properties for the background image component
	timerProperties: null,                              // Properties for the timer component used to update the position
	drawDebug: false

};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.UiEmpty = function(properties) {
	"use strict";
	this.name = "UiEmpty";
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.uiEmpty);
	this.setProperties(tgfSettings.uiEmptyDialogProperties);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
	
	
	// console.log('custom UIEmpty');
	
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.UiEmpty, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************

// Make the dialog disappear now
tgfDialogs.UiEmpty.prototype.disappear = function() {
	"use strict";
	this.deactivate();
	this.container.startSubEffect(2);
};

// Add a ui component to the empty ui dialog
tgfDialogs.UiEmpty.prototype.addUiComponent = function(Component, properties, moreProperties, extraProperties) {
	"use strict";
	var comp = new Component(properties);
	if (moreProperties !== undefined) { comp.setProperties(moreProperties); }
	if (extraProperties !== undefined) { comp.setProperties(extraProperties); }
	if (this.container) {
		this.container.addComponent(comp);
		if (this.container.isVisible) { comp.show(); }
		if (this.container.isActive) { comp.activate(); }
	} else {
		this.components.push(comp);
	}
	return comp;
};


// ***************************************
// Internal methods
// ***************************************

// Adapt position
tgfDialogs.UiEmpty.prototype._adaptPosition = function() {
	"use strict";
	var ll, rr, tt, bb, newX, newY;
	if (!this.autoPosition) { return; }
	if (this.autoVisibleRegion) {
		ll = tgfGraphics.visibleLeft;
		rr = tgfGraphics.visibleLeft + tgfGraphics.visibleWidth;
		tt = tgfGraphics.visibleTop;
		bb = tgfGraphics.visibleTop + tgfGraphics.visibleHeight;
	} else {
		ll = tgfGraphics.safeZoneLeft;
		rr = tgfGraphics.safeZoneLeft + tgfGraphics.safeZoneWidth;
		tt = tgfGraphics.safeZoneTop;
		bb = tgfGraphics.safeZoneTop + tgfGraphics.safeZoneHeight;
	}
	switch (this.autoPositionHor) {
		case "left": newX = ll + Math.round(this.width/2) + this.marginHor; break;
		case "right": newX = rr - Math.round(this.width/2) - this.marginHor; break;
		case "center": newX = Math.round((ll + rr) / 2); break;
		default: newX = ll + Math.round(this.width/2) + this.marginHor;
	}
	switch (this.autoPositionVert) {
		case "top": newY = tt + Math.round(this.height/2) + this.marginVert; break;
		case "bottom": newY = bb - Math.round(this.height/2) - this.marginVert; break;
		case "middle": newY = Math.round((tt + bb) / 2); break;
		default: newX = newY = Math.round((tt + bb) / 2);
	}
	if (this.x !== newX || this.y !== newY) {
		this.x = newX;
		this.y = newY;
	}
};


// ***************************************
// Preparing and showing
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.UiEmpty.prototype.doPrepare = function() {
	"use strict";
	var self = this, i;
	// Fill in position and size
	if (this.width === undefined || this.width === 0) { 
		this.width = this.backgroundImage === undefined ? 0 : this.backgroundImage.width;
	}
	if (this.height === undefined || this.height === 0) { 
		this.height = this.backgroundImage === undefined ? 0 : this.backgroundImage.height;
	}
	if (this.x === undefined) { this.x = tgfGraphics.safeZoneLeft + Math.round(this.width/2) + this.marginHor; }
	if (this.y === undefined) { this.y = tgfGraphics.safeZoneTop + Math.round(tgfGraphics.safeZoneHeight/2); }
	// Create the background image container


	if (this.backgroundImage) {

		// console.log('UiEmpty, use backgroundImage');

		this.container = new tgfComponents.Picture( {
			image: this.backgroundImage, createFromSlices: true,
			width: this.width, height: this.height,
			effects: [ this.appearEffect, { effect: "show", duration: 9999999 }, this.disappearEffect ],
			onEffectEnd: function (component) { self.hide(); }
		} );
		this.container.setProperties(this.backgroundProperties);
		this.addComponent(this.container);
	}
	else {

		// console.log('UiEmpty, use container');

		this.container = new tgfComponents.Container({
			width: this.width,
			height: this.height
			// effects: [ this.appearEffect, { effect: "show", duration: 9999999 }, this.disappearEffect ],
			// onEffectEnd: function (component) { self.hide(); }
		});
		// this.container.setProperties(this.backgroundProperties);
		this.addComponent(this.container);
	}

	// Create the timer to adapt the position if required
	if (this.autoPosition) {
		this.timer = new tgfComponents.Timer( {
			enabled: true, interval: 0.05, repeat: 999999999,
			onTick: function (component) { tgfDialogs.UiEmpty.prototype._adaptPosition.call(self); }
		} );
		this.timer.setProperties(this.timerProperties);
		this.addComponent(this.timer);
	}

	// this.baseContainer['name'] = this.baseContainer['name'] || this.name;
	

	if (this.drawDebug) {

		var w = this.width;
		var h = this.height;

		var rect = tbGraphics.drawRectangle(0, 0, w, h, 0x0000ff, null, 0, 0.5);
		this.baseContainer.addChild(rect);
	}


	// Add the additional components, if any
	for (i = 0; i < this.components.length; i += 1) {
		this.container.addComponent(this.components[i]);
	}
};

// Processing required when freeing the dialog from use
tgfDialogs.UiEmpty.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();
	this.container = undefined;
	this.timer = undefined;
};

// Processing required when showing the dialog
tgfDialogs.UiEmpty.prototype.doShow = function() {
	"use strict";
	this._adaptPosition();
};



//******************************************************
//*****    Script Resource: gameSettings
//******************************************************

// ***************************************
// gameSettings
//
// This function returns the settings for the game.
// It is used in the constructor for the game controller.
//
// This version is just a template.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 12-10-2015
// ***************************************


var gameSettings = function () {
	"use strict";
	return {
		// Required game related settings
		game: {
			name: "<UNKNOWN>",                              // Name of the game
			id: "<UNKNOWN>",                                // Id of the game
			version: "1.0",                                 // Version of the game
			
			documentTitle: "Battleships",                        // Title of the web document
			
			hasModes: false,                                // Whether it has modes
			modeIds: [0, 1, 2],                             // The ids for the modes
			modeKeys: ["Easy", "Medium", "Difficult"],      // The dictionary keys for the modes
			
			hasLevels: true,                                // Whether it has levels
			levelsUnlocked: false,                          // Whether the levels are initially unlocked
			levelCount: 9,                                  // Total number of levels
			worldLevelCounts: [9],                          // Array of number of levels per world
			worldLevelKeys: ["World1"],                     // The dictionary keys for the names of the worlds
			
			hasStars: true,                                 // Whether there are stars
			
			scoreType: "numberUp",                          // Type of score (numberUp, numberDown, timeUp, timeDown)
			scorePerLevel: true,                            // Whether there is a separate score per level or only an overall score
			scorePerMode: false,                            // Whether there is a separate score per mode or only an overall score
			
			// TODO: add achievements
			
			tutorialData: [],                               // Array of tutorial object data, each with image, titleDictionaryKey, textDictionaryKey, animationSpeed
			
			dummy: null                                     // To avoid problems with missing comma
		},
		// Specific flow settings that override the default flow settings
		flow: {
		},

		test: {
			
			mock: {
				StartBotGameImmediately: false
			},
			dev: {
				StartBotGameImmediately: false
			},
			qa: {
				StartBotGameImmediately: false
			},
			demo: {
				StartBotGameImmediately: false
			},
			prod: {
				StartBotGameImmediately: false
			}
		},

		analytics: {

			mock: {
				gameAnalyticsGameKey: 'b1acab50268605e85f51c7d2c05e6f67',
				gameAnalyticsSecretKey: '8fd2dbd4682b22864689af714dcb9d550b05677b',
				analyticsEnvironment: AnalyticsEnvironment.Dev
			},
			dev: {
				gameAnalyticsGameKey: 'b1acab50268605e85f51c7d2c05e6f67',
				gameAnalyticsSecretKey: '8fd2dbd4682b22864689af714dcb9d550b05677b',
				analyticsEnvironment: AnalyticsEnvironment.Dev
			},
			qa: {
				gameAnalyticsGameKey: 'b1acab50268605e85f51c7d2c05e6f67',
				gameAnalyticsSecretKey: '8fd2dbd4682b22864689af714dcb9d550b05677b',
				analyticsEnvironment: AnalyticsEnvironment.Staging
			},
			demo: {
				gameAnalyticsGameKey: 'b1acab50268605e85f51c7d2c05e6f67',
				gameAnalyticsSecretKey: '8fd2dbd4682b22864689af714dcb9d550b05677b',
				analyticsEnvironment: AnalyticsEnvironment.Demo
			},
			prod: {
				gameAnalyticsGameKey: '6d2589ab8f8aa0de49f31450294b2a7b',
				gameAnalyticsSecretKey: '894a3cdfb1a9d25cbfa7479b4d66ed41643eb125',
				analyticsEnvironment: AnalyticsEnvironment.Prod
			},

			// Game Analytics settings
			gameAnalyticsGameKey: "6d2589ab8f8aa0de49f31450294b2a7b",                   // Game key as provided by game analytics
			gameAnalyticsSecretKey: "894a3cdfb1a9d25cbfa7479b4d66ed41643eb125",         // Secret key as provided by game analytics
			analyticsEnvironment: AnalyticsEnvironment.Dev
		},

		gamesparks: {

			mock: {
				apiKey: 'l320332uaE1e',
				apiSecret: 'dJudsWjM46y0GhNWs7gL8ipSVMlFdJnA',
				isProdVersion: false,
			},
			dev: {
				apiKey: 'l320332uaE1e',
				apiSecret: 'dJudsWjM46y0GhNWs7gL8ipSVMlFdJnA',
				isProdVersion: false,
			},
			qa: {
				apiKey: 'f320726S7Rqb',
				apiSecret: 'hDW3vwmcqB0SUmCDxsuDSG3A30MEPLTF',
				isProdVersion: false,
			},
			demo: {
				apiKey: 'M320727mWow4',
				apiSecret: 'rs0zbcN1x1b9kAy4N76VwYmonD2D0zjY',
				isProdVersion: false,
			},
			prod: {
				apiKey: 'c320728PEYjt',
				apiSecret: 'APek1B7tgGJ7BdqVYKYVPWfpJwrKcvmA',
				isProdVersion: true,
			},
			// DEV
			apiKey: 'l320332uaE1e',
			apiSecret: 'dJudsWjM46y0GhNWs7gL8ipSVMlFdJnA',
			isProdVersion: false,

			// QA
			//apiKey: 'f320726S7Rqb',
			//apiSecret: 'hDW3vwmcqB0SUmCDxsuDSG3A30MEPLTF',
			//isProdVersion: false,

			// DEMO
			//apiKey: 'M320727mWow4',
			//apiSecret: 'rs0zbcN1x1b9kAy4N76VwYmonD2D0zjY',
			//isProdVersion: false,

			// PROD
			//apiKey: 'c320728PEYjt',
			//apiSecret: 'APek1B7tgGJ7BdqVYKYVPWfpJwrKcvmA',
			//isProdVersion: true,
		},

		ads: {
			version_1: {
				rewardedID: "458224474553316_507224439653319",
				interstitialID: "458224474553316_588882528154176",
				webRewardedID: "458224474553316_754926868216407",
				webInterstitialID: "458224474553316_811667612542332"
			},
			version_2: {
				rewardedID: "458224474553316_521623731546723",
				interstitialID: "458224474553316_621833224859106",
				webRewardedID: "458224474553316_521623631546733",
				webInterstitialID: "458224474553316_622230261486069"
			},
			version_3: {
				rewardedID: "458224474553316_876586946050398",
				interstitialID: "458224474553316_876586129383813",
				webRewardedID: "458224474553316_876587386050354",
				webInterstitialID: "458224474553316_876586446050448"
			},
			version_4: {
				rewardedID: "458224474553316_876587142717045",
				interstitialID: "458224474553316_876586259383800",
				webRewardedID: "458224474553316_876587502717009",
				webInterstitialID: "458224474553316_876586622717097"
			},
			version_5: {
				rewardedID: "458224474553316_876603439382082",
				interstitialID: "458224474553316_876604109382015",
				webRewardedID: "458224474553316_876603809382045",
				webInterstitialID: "458224474553316_876604359381990"
			},
			version_6: {
				rewardedID: "458224474553316_876603712715388",
				interstitialID: "458224474553316_876604239382002",
				webRewardedID: "458224474553316_876603909382035",
				webInterstitialID: "458224474553316_876604436048649"
			},
			version_7: {
				rewardedID: "458224474553316_880475608994865",
				interstitialID: "458224474553316_880473652328394",
				webRewardedID: "458224474553316_880475975661495",
				webInterstitialID: "458224474553316_880474882328271"
			},
			version_8: {
				rewardedID: "458224474553316_880475752328184",
				interstitialID: "458224474553316_880474492328310",
				webRewardedID: "458224474553316_880476085661484",
				webInterstitialID: "458224474553316_880475242328235"
			},
			version_9: {
				rewardedID: "458224474553316_885994068443019",
				interstitialID: "458224474553316_885994895109603",
				webRewardedID: "458224474553316_885994421776317",
				webInterstitialID: "458224474553316_885995255109567"
			},
			version_10: {
				rewardedID: "458224474553316_885994225109670",
				interstitialID: "458224474553316_885995101776249",
				webRewardedID: "458224474553316_885994511776308",
				webInterstitialID: "458224474553316_885995361776223"
			}
		},

		gamebot: {
		
			mock : {
				appId: "1328406700605740",
				appToken: "EAAS4LcmBwS8BADBvm7kwZB0LAgDOmWjqHk2izfEQWV5Pw9VJjkSiEQFMWTg3owhPJo4BbQo7UzYIADZBsRxNvNLK6xfSUleZCIRE9pFjQGKSXQUST1KiZBOkkZBZCjumGSapoZAJdhq5qzbsL0uqZBf0b6WeT7a9tl9yCAnU9N4CPQZDZD",	
			},
			dev : {
				appId: "1328406700605740",
				appToken: "EAAS4LcmBwS8BADBvm7kwZB0LAgDOmWjqHk2izfEQWV5Pw9VJjkSiEQFMWTg3owhPJo4BbQo7UzYIADZBsRxNvNLK6xfSUleZCIRE9pFjQGKSXQUST1KiZBOkkZBZCjumGSapoZAJdhq5qzbsL0uqZBf0b6WeT7a9tl9yCAnU9N4CPQZDZD",	
			},
			qa : {
				appId: "639203462955604",
				appToken: "EAAJFWidZAQlQBAEzaRtp4DB1dZAVMmzmKS1ydIaTZB48r3OLZCrNyri3E6NYUfhpFiLBFpGoTQZCvf8PzvJDZBHTbrVgHFNhwZCtxsXSZCvqrZA43vgQZC5cW8ZBIwZCEpDEX0phrTe4ltiEn445mflz4ZAty0HMB8iIu5ZA8bWPflbv7ZCiAZDZD",
			},
			demo : {
				appId: "314656962330492",
				appToken: "EAAEeLch3P3wBAOwy0IX6oqsut1YYt9ZAyeVja3PghwZBZCFNWgtjaJRtYsFzJfDYE6JcwAQN4XZB8Rp5kzMATsV0evgf6JhZAWN9u3GPhkSPt6zmwO06QIWwevqQaZB0HEoGpcsirWWLi0oSTJ79dV8EZCQ9zXBOvHcwkPL9MskAgZDZD",
			},
			prod : {
				appId: "458224474553316",
				appToken: "EAAGgwLMIeZBQBAIryzgvGBzoeOEmSodZBTE67LOB3RLdMoE5vX2jZAHj5EDi6aaePitmKMpZBgQvcZAY8ZAK5cNStcSZAqAQ0ZBIfGub05CdbQKsOZAfKdKmY1yQLqUMBHgMc13j96bd1gA7FbpygtnKZBwCjJSgjcFSCXchlyPqM0agZDZD",
			},

			// DEV
			// appId: "1328406700605740",
			// appToken: "EAAS4LcmBwS8BADBvm7kwZB0LAgDOmWjqHk2izfEQWV5Pw9VJjkSiEQFMWTg3owhPJo4BbQo7UzYIADZBsRxNvNLK6xfSUleZCIRE9pFjQGKSXQUST1KiZBOkkZBZCjumGSapoZAJdhq5qzbsL0uqZBf0b6WeT7a9tl9yCAnU9N4CPQZDZD",

			// QA
			appId: "639203462955604",
			appToken: "EAAJFWidZAQlQBAEzaRtp4DB1dZAVMmzmKS1ydIaTZB48r3OLZCrNyri3E6NYUfhpFiLBFpGoTQZCvf8PzvJDZBHTbrVgHFNhwZCtxsXSZCvqrZA43vgQZC5cW8ZBIwZCEpDEX0phrTe4ltiEn445mflz4ZAty0HMB8iIu5ZA8bWPflbv7ZCiAZDZD",

			// DEMO
			// appId: "314656962330492",
			// appToken: "EAAEeLch3P3wBAOwy0IX6oqsut1YYt9ZAyeVja3PghwZBZCFNWgtjaJRtYsFzJfDYE6JcwAQN4XZB8Rp5kzMATsV0evgf6JhZAWN9u3GPhkSPt6zmwO06QIWwevqQaZB0HEoGpcsirWWLi0oSTJ79dV8EZCQ9zXBOvHcwkPL9MskAgZDZD",

			// PROD
			//appId: "458224474553316",
			//appToken: "EAAGgwLMIeZBQBAHIbDD9cZCw0bTcIoQ65dK32jS26jOfwbFaJ1I3uK4wKMPzVmveFUD66q0t2RbRALuufVrYpPApqlwNfLJ1YhkTZB1O2MYXKEdZB3RSwHWZAl7TZBpYeFlkJKPElOTlE7AvX1IaxqOm0LfpPhZB5enEBCBGs4URAZDZD",
		},

		abTests: {
			features: {
				ONBOARDING_HAND: "ONBOARDING_HAND",
				INSTANT_SHIP_PLACEMENT: "INSTANT_SHIP_PLACEMENT"
			},
			tests: [{
				version: ABTestManager.GENERAL_POPULATION_ID,
				releaseVersion: "1.20",
				features: [],
				probability: 70,
				metadata: {
					adPlacementIds: "version_1",
				},
			}, {
				version: "1",
				releaseVersion: "1.20",
				features: [],
				probability: 10,
				segmentation: {
					tests: [{
						version: "A",
						features: [],
						probability: 50,
						metadata: {
							adPlacementIds: "version_3",
						},
					}, {
						version: "B",
						features: ["ONBOARDING_HAND"],
						probability: 50,
						metadata: {
							adPlacementIds: "version_4",
						},
					}]
				}
			}, {
				version: "2",
				releaseVersion: "1.20",
				features: [],
				probability: 0,
				segmentation: {
					tests: [{
						version: "A",
						features: [],
						probability: 50,
						metadata: {
							adPlacementIds: "version_5",
						},
					}, {
						version: "B",
						features: ["INSTANT_SHIP_PLACEMENT"],
						probability: 50,
						metadata: {
							adPlacementIds: "version_6",
						},
					}]
				}
			}, {
				version: "4",
				releaseVersion: "1.23",
				features: [],
				probability: 20,
				segmentation: {
					tests: [{
						version: "A",
						features: [],
						probability: 25,
						metadata: {
							adPlacementIds: "version_7",
						},
					}, {
						version: "B",
						features: [],
						probability: 25,
						metadata: {
							adPlacementIds: "version_8",
						},
					}, {
						version: "C",
						features: ["ONBOARDING_HAND"],
						probability: 25,
						metadata: {
							adPlacementIds: "version_9",
						},
					}, {
						version: "D",
						features: ["INSTANT_SHIP_PLACEMENT"],
						probability: 25,
						metadata: {
							adPlacementIds: "version_10",
						},
					}]
				}
			}]
		},

		tileMapValues: {
			ROWS: 8,
			MAX_ROWS: 8,
			COLS: 8,
			MAX_COLS: 8,
			WIDTH: 74,
			HEIGHT: 74
		}
	};
};





//******************************************************
//*****    Script Resource: dictionary
//******************************************************

var dictionariesLoaded = {};

var s_logo = s_logo || s_logo_en;

var loadExternalDictionary = function(languageString, onSuccess) {

    // TODO: Auto-generate the following code
    switch (languageString) {
        case "en-us":
        case "nl-nl":
        case "fr-fr":
        case "it-it":
        case "de-de":
        case "es-es":
            break;
        default:
            if (languageString.startsWith("nl-"))
                languageString = "nl-nl";
            else if (languageString.startsWith("fr-"))
                languageString = "fr-fr";
            else if (languageString.startsWith("it-"))
                languageString = "it-it";
            else if (languageString.startsWith("de-"))
                languageString = "de-de";
            else if (languageString.startsWith("es-"))
                languageString = "es-es";
            else languageString = "en-us";
            break;
    }

    // Update logo

    // TODO auto-generate this too
    switch (languageString) {
        default:
        case "en-us":
            s_logo = s_logo_en;
            break;
        case "nl-nl":
            s_logo = s_logo_nl;
            break;
        case "fr-fr":
            s_logo = s_logo_fr;
            break;
        case "it-it":
            s_logo = s_logo_it;
            break;
        case "de-de":
            s_logo = s_logo_de;
            break;
        case "es-es":
            s_logo = s_logo_es;
            break;
    };

    // languageString = 'nl-nl';

    if(dictionariesLoaded[languageString])
        return;

    languageString = languageString.replace("-", "_");
    console.log("   LM::loading language " + languageString + " from `media/" + languageString + ".json`");
    var request = new XMLHttpRequest();
    request.onSuccess = onSuccess;

    request.addEventListener('error', function(e) {
        console.log("   LM::Error loading language '" + languageString + "': " + e);
    }, true);

    request.addEventListener("load", function (e) {
        if (e.currentTarget.status != 200)
            return;

        dictionariesLoaded[languageString] = true;
        tgfDictionary.addDictionary(JSON.parse(this.responseText));

        if (e.currentTarget.onSuccess)
            e.currentTarget.onSuccess(languageString);
    });
    request.open("GET", "media/" + languageString + ".json");
    request.send();
}

var getLocale = function() {
    var language;

    if (window.navigator.language) {
        if (window.navigator.language.length === 5) {
            language = window.navigator.language;
        } else {
            switch(window.navigator.language) {
                case 'en':
                    language = 'en-us';
                    break;
                case 'nl':
                    language = 'nl-nl';
                    break;
                case 'it':
                    language = 'it-it';
                    break;
                case 'de':
                    language = 'de-de';
                    break;
                case 'es':
                    language = 'es-es';
                    break;
                case 'fr':
                    language = 'fr-fr';
                    break;
                default:
                    language = 'en-us';
                    break;
            }
        }
    } else {
        language = window.navigator.userLanguage || window.navigator.language;
    }

    return language || tgfDictionary.currentLanguage;
};

var BattleshipDictionary = {
    overwriteLanguage: function (locale, onSuccess) {
        this.language = locale.toLowerCase();

        loadExternalDictionary(this.language, function (languageString) {
            console.log("   LM::Loaded external dictionary " + this.language);
            this.language = tgfDictionary.currentLanguage = languageString.replace("_", "-");

            if (onSuccess) {
                onSuccess();
            }
        }.bind(this));
    },

    updateDictionaryFromFacebook: function() {
        this.tries = 0;
        var updateDictionary = function() {
            try {
                this.facebookInstant = !!fbInstant;
            }
            catch (e) {
                if (this.tries > 60)
                    tbLoader.loadComplete("localisation");
                else {
                    this.tries++;
                    setTimeout(updateDictionary, 16);
                }
                return;
            }

            if (!fbInstant.locale || fbInstant.locale.length == 0) {
                setTimeout(updateDictionary, 16);
                return;
            }

            var newLanguage = fbInstant.locale.toLowerCase().replace("_", "-");
            // if (this.language == newLanguage) { // We already are using this language
            //     //tbLoader.loadComplete("localisation");
            //     return;
            // }

            loadExternalDictionary(newLanguage, function (languageString) {
                this.language = tgfDictionary.currentLanguage = languageString.replace("_", "-");
                console.log("   LM::Replaced language with " + this.language);
                tbLoader.loadComplete("localisation");
            }.bind(this));
        }.bind(this);

        setTimeout(updateDictionary, 16);
    },

    startLoading: function() {
        this.canUpdateFBLocale = true;
        //this.language = tgfDictionary.currentLanguage;
        this.language = getLocale();
        tgfDictionary.currentLanguage = "nvt-nvt";

        console.log("   LM::current language: " + this.language);
        overwriteLanguage(this.language, function () {
console.log("bla", this.onLoadDone)
            if (this.onLoadDone) {

                this.onLoadDone();
            }

            tbLoader.loadComplete("localisation");
            // Try getting facebook dictionary
            this.updateDictionaryFromFacebook();
        }.bind(this));
    }
};

// var oldGetText = tgfDictionary.getText;
// tgfDictionary.getText = function(key, defaultText, languageKey) {
//     var oldText = oldGetText.call(this, key, defaultText, languageKey);

//     if (FBInstant && FBInstant.player) {
//         // Enter variables here in the same format.

//         oldText = oldText.split("{username}").join(FBInstant.player.getName());
//     }
//     else console.warn("getText was called before facebook is initialised for '" + key + "'!");

//     return oldText;
// };

window["overwriteLanguage"] = BattleshipDictionary.overwriteLanguage.bind(BattleshipDictionary);
loadExternalDictionary("en-us");

//******************************************************
//*****    Script Resource: SpineAnimationComponent
//******************************************************

// ***************************************
// BattleshipComponents.SpineAnimation
//
// This component displays an animated picture
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 18-6-2015
// ***************************************
BattleshipComponents = {};

tgfSettings.componentDefaults.spineAnimation = {
	animation: null, 		// The spine resource to display
	animationName: "idle",	// The name of the animation to play
	animationLooping: true, // If the animation loops
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.Base
 */

BattleshipComponents.SpineAnimation = function(properties) {
	"use strict";
	this.name = "SpineAnimation";
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.spineAnimation);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(BattleshipComponents.SpineAnimation, tgfComponents.Base);

// Overriden to return the correct width
BattleshipComponents.SpineAnimation.prototype.getWidth = function() {
	"use strict";

};

// Overriden to return the correct width
BattleshipComponents.SpineAnimation.prototype.getHeight = function() {
	"use strict";
	
};

// Overriden to return the correct width
BattleshipComponents.SpineAnimation.prototype.playAnimation = function(animationName, loop, onComplete, onApply) {
	"use strict";

	if (!this.queuedAnimation || this.queuedAnimation.name != name) {

		this.queuedAnimation = { name: animationName, loop: loop, onComplete: onComplete, onApply: onApply };
	}
};

// ***************************************
// Preparing, showing and activating
// ***************************************

// Processing required when preparing the component for use
BattleshipComponents.SpineAnimation.prototype.doPrepare = function() {
	"use strict";
	
	if (this.animation && !this.animation.spineData) {
		this.animation.startLoading();
	}
	
	this.animator = null;
	this.currentAnimation = null;
	this.canPlayAnimation = true;
	this.container = new tbContainer();
	this.baseContainer.addChild(this.container);

	if (this.animationName && typeof this.animationLooping !== 'undefined')
		this.playAnimation(this.animationName, this.animationLooping);
};

BattleshipComponents.SpineAnimation.prototype.doShow = function() {
	"use strict";
	
};

BattleshipComponents.SpineAnimation.prototype.doHide =function() {
	"use strict";

};

// ***************************************
// Methods called when events must be processed
// ***************************************

// Called when a touch is started or if a mouse button is pressed
BattleshipComponents.SpineAnimation.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
	
};

// Called just before drawing (also when not active)
BattleshipComponents.SpineAnimation.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
	
};

// Called when the component must be drawn (relative to position 0, 0)
BattleshipComponents.SpineAnimation.prototype.doDraw = function() {
	"use strict";

	var animationLoaded = this.animation && this.animation.spineData;
	var animationShown = !!this.animator;

	if (animationLoaded && animationShown == false) {
		this.animator = this.animation.clone();

		if (this.onLoad)
			this.onLoad();

		var self = this;
		setTimeout(function() {
			self.animator.add(self.container);
		}, 0);
	}

	if (animationShown) {
		// We can play an animation and one is queued
		var isNotPlayingThisAnimation = (!this.currentAnimation || (this.queuedAnimation && this.currentAnimation.name != this.queuedAnimation.name));
		isNotPlayingThisAnimation = true;
		if (this.queuedAnimation && this.canPlayAnimation && isNotPlayingThisAnimation) {
			this.animator.animation["skeleton"].setSlotsToSetupPose();
			this.animator.setAnimation(this.queuedAnimation.name, this.queuedAnimation.loop);
			this.canPlayAnimation = this.queuedAnimation.loop; // You can override looping animations.

			var self = this;
			this.animator.setOnComplete(function () {
				self.canPlayAnimation = true;

				if (self.currentAnimation && self.currentAnimation.onComplete) { 
					self.currentAnimation.onComplete();
				}
			});

			if (this.queuedAnimation.onApply)
				this.queuedAnimation.onApply();

			this.currentAnimation = this.queuedAnimation;
			this.queuedAnimation = null;
		}

		this.animator.setPosition(this.x, this.y);
		if (this.xScale) this.animator.animation.scale.x = this.xScale;
		if (this.yScale) this.animator.animation.scale.y = this.yScale;
	}
};


//******************************************************
//*****    Script Resource: spine
//******************************************************

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Animation = (function () {
            function Animation(name, timelines, duration) {
                if (name == null)
                    throw new Error("name cannot be null.");
                if (timelines == null)
                    throw new Error("timelines cannot be null.");
                this.name = name;
                this.timelines = timelines;
                this.duration = duration;
            }
            Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, pose, direction) {
                if (skeleton == null)
                    throw new Error("skeleton cannot be null.");
                if (loop && this.duration != 0) {
                    time %= this.duration;
                    if (lastTime > 0)
                        lastTime %= this.duration;
                }
                var timelines = this.timelines;
                for (var i = 0, n = timelines.length; i < n; i++)
                    timelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction);
            };
            Animation.binarySearch = function (values, target, step) {
                if (step === void 0) { step = 1; }
                var low = 0;
                var high = values.length / step - 2;
                if (high == 0)
                    return step;
                var current = high >>> 1;
                while (true) {
                    if (values[(current + 1) * step] <= target)
                        low = current + 1;
                    else
                        high = current;
                    if (low == high)
                        return (low + 1) * step;
                    current = (low + high) >>> 1;
                }
            };
            Animation.linearSearch = function (values, target, step) {
                for (var i = 0, last = values.length - step; i <= last; i += step)
                    if (values[i] > target)
                        return i;
                return -1;
            };
            return Animation;
        }());
        core.Animation = Animation;
        var MixPose;
        (function (MixPose) {
            MixPose[MixPose["setup"] = 0] = "setup";
            MixPose[MixPose["current"] = 1] = "current";
            MixPose[MixPose["currentLayered"] = 2] = "currentLayered";
        })(MixPose = core.MixPose || (core.MixPose = {}));
        var MixDirection;
        (function (MixDirection) {
            MixDirection[MixDirection["in"] = 0] = "in";
            MixDirection[MixDirection["out"] = 1] = "out";
        })(MixDirection = core.MixDirection || (core.MixDirection = {}));
        var TimelineType;
        (function (TimelineType) {
            TimelineType[TimelineType["rotate"] = 0] = "rotate";
            TimelineType[TimelineType["translate"] = 1] = "translate";
            TimelineType[TimelineType["scale"] = 2] = "scale";
            TimelineType[TimelineType["shear"] = 3] = "shear";
            TimelineType[TimelineType["attachment"] = 4] = "attachment";
            TimelineType[TimelineType["color"] = 5] = "color";
            TimelineType[TimelineType["deform"] = 6] = "deform";
            TimelineType[TimelineType["event"] = 7] = "event";
            TimelineType[TimelineType["drawOrder"] = 8] = "drawOrder";
            TimelineType[TimelineType["ikConstraint"] = 9] = "ikConstraint";
            TimelineType[TimelineType["transformConstraint"] = 10] = "transformConstraint";
            TimelineType[TimelineType["pathConstraintPosition"] = 11] = "pathConstraintPosition";
            TimelineType[TimelineType["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
            TimelineType[TimelineType["pathConstraintMix"] = 13] = "pathConstraintMix";
            TimelineType[TimelineType["twoColor"] = 14] = "twoColor";
        })(TimelineType = core.TimelineType || (core.TimelineType = {}));
        var CurveTimeline = (function () {
            function CurveTimeline(frameCount) {
                if (frameCount <= 0)
                    throw new Error("frameCount must be > 0: " + frameCount);
                this.curves = core.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);
            }
            CurveTimeline.prototype.getFrameCount = function () {
                return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;
            };
            CurveTimeline.prototype.setLinear = function (frameIndex) {
                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;
            };
            CurveTimeline.prototype.setStepped = function (frameIndex) {
                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;
            };
            CurveTimeline.prototype.getCurveType = function (frameIndex) {
                var index = frameIndex * CurveTimeline.BEZIER_SIZE;
                if (index == this.curves.length)
                    return CurveTimeline.LINEAR;
                var type = this.curves[index];
                if (type == CurveTimeline.LINEAR)
                    return CurveTimeline.LINEAR;
                if (type == CurveTimeline.STEPPED)
                    return CurveTimeline.STEPPED;
                return CurveTimeline.BEZIER;
            };
            CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {
                var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
                var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;
                var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
                var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
                var i = frameIndex * CurveTimeline.BEZIER_SIZE;
                var curves = this.curves;
                curves[i++] = CurveTimeline.BEZIER;
                var x = dfx, y = dfy;
                for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
                    curves[i] = x;
                    curves[i + 1] = y;
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    x += dfx;
                    y += dfy;
                }
            };
            CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {
                percent = core.MathUtils.clamp(percent, 0, 1);
                var curves = this.curves;
                var i = frameIndex * CurveTimeline.BEZIER_SIZE;
                var type = curves[i];
                if (type == CurveTimeline.LINEAR)
                    return percent;
                if (type == CurveTimeline.STEPPED)
                    return 0;
                i++;
                var x = 0;
                for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
                    x = curves[i];
                    if (x >= percent) {
                        var prevX = void 0, prevY = void 0;
                        if (i == start) {
                            prevX = 0;
                            prevY = 0;
                        }
                        else {
                            prevX = curves[i - 2];
                            prevY = curves[i - 1];
                        }
                        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
                    }
                }
                var y = curves[i - 1];
                return y + (1 - y) * (percent - x) / (1 - x);
            };
            CurveTimeline.LINEAR = 0;
            CurveTimeline.STEPPED = 1;
            CurveTimeline.BEZIER = 2;
            CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
            return CurveTimeline;
        }());
        core.CurveTimeline = CurveTimeline;
        var RotateTimeline = (function (_super) {
            __extends(RotateTimeline, _super);
            function RotateTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount << 1);
                return _this;
            }
            RotateTimeline.prototype.getPropertyId = function () {
                return (TimelineType.rotate << 24) + this.boneIndex;
            };
            RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {
                frameIndex <<= 1;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;
            };
            RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
                var frames = this.frames;
                var bone = skeleton.bones[this.boneIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            bone.rotation = bone.data.rotation;
                            return;
                        case MixPose.current:
                            var r_1 = bone.data.rotation - bone.rotation;
                            r_1 -= (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360;
                            bone.rotation += r_1 * alpha;
                    }
                    return;
                }
                if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {
                    if (pose == MixPose.setup)
                        bone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;
                    else {
                        var r_2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;
                        r_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;
                        bone.rotation += r_2 * alpha;
                    }
                    return;
                }
                var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
                var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
                var frameTime = frames[frame];
                var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));
                var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;
                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
                r = prevRotation + r * percent;
                if (pose == MixPose.setup) {
                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
                    bone.rotation = bone.data.rotation + r * alpha;
                }
                else {
                    r = bone.data.rotation + r - bone.rotation;
                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
                    bone.rotation += r * alpha;
                }
            };
            RotateTimeline.ENTRIES = 2;
            RotateTimeline.PREV_TIME = -2;
            RotateTimeline.PREV_ROTATION = -1;
            RotateTimeline.ROTATION = 1;
            return RotateTimeline;
        }(CurveTimeline));
        core.RotateTimeline = RotateTimeline;
        var TranslateTimeline = (function (_super) {
            __extends(TranslateTimeline, _super);
            function TranslateTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);
                return _this;
            }
            TranslateTimeline.prototype.getPropertyId = function () {
                return (TimelineType.translate << 24) + this.boneIndex;
            };
            TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {
                frameIndex *= TranslateTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + TranslateTimeline.X] = x;
                this.frames[frameIndex + TranslateTimeline.Y] = y;
            };
            TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
                var frames = this.frames;
                var bone = skeleton.bones[this.boneIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                            return;
                        case MixPose.current:
                            bone.x += (bone.data.x - bone.x) * alpha;
                            bone.y += (bone.data.y - bone.y) * alpha;
                    }
                    return;
                }
                var x = 0, y = 0;
                if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {
                    x = frames[frames.length + TranslateTimeline.PREV_X];
                    y = frames[frames.length + TranslateTimeline.PREV_Y];
                }
                else {
                    var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);
                    x = frames[frame + TranslateTimeline.PREV_X];
                    y = frames[frame + TranslateTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));
                    x += (frames[frame + TranslateTimeline.X] - x) * percent;
                    y += (frames[frame + TranslateTimeline.Y] - y) * percent;
                }
                if (pose == MixPose.setup) {
                    bone.x = bone.data.x + x * alpha;
                    bone.y = bone.data.y + y * alpha;
                }
                else {
                    bone.x += (bone.data.x + x - bone.x) * alpha;
                    bone.y += (bone.data.y + y - bone.y) * alpha;
                }
            };
            TranslateTimeline.ENTRIES = 3;
            TranslateTimeline.PREV_TIME = -3;
            TranslateTimeline.PREV_X = -2;
            TranslateTimeline.PREV_Y = -1;
            TranslateTimeline.X = 1;
            TranslateTimeline.Y = 2;
            return TranslateTimeline;
        }(CurveTimeline));
        core.TranslateTimeline = TranslateTimeline;
        var ScaleTimeline = (function (_super) {
            __extends(ScaleTimeline, _super);
            function ScaleTimeline(frameCount) {
                return _super.call(this, frameCount) || this;
            }
            ScaleTimeline.prototype.getPropertyId = function () {
                return (TimelineType.scale << 24) + this.boneIndex;
            };
            ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
                var frames = this.frames;
                var bone = skeleton.bones[this.boneIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                            return;
                        case MixPose.current:
                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
                    }
                    return;
                }
                var x = 0, y = 0;
                if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
                    x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
                    y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
                }
                else {
                    var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
                    x = frames[frame + ScaleTimeline.PREV_X];
                    y = frames[frame + ScaleTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
                    x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
                    y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
                }
                if (alpha == 1) {
                    bone.scaleX = x;
                    bone.scaleY = y;
                }
                else {
                    var bx = 0, by = 0;
                    if (pose == MixPose.setup) {
                        bx = bone.data.scaleX;
                        by = bone.data.scaleY;
                    }
                    else {
                        bx = bone.scaleX;
                        by = bone.scaleY;
                    }
                    if (direction == MixDirection.out) {
                        x = Math.abs(x) * core.MathUtils.signum(bx);
                        y = Math.abs(y) * core.MathUtils.signum(by);
                    }
                    else {
                        bx = Math.abs(bx) * core.MathUtils.signum(x);
                        by = Math.abs(by) * core.MathUtils.signum(y);
                    }
                    bone.scaleX = bx + (x - bx) * alpha;
                    bone.scaleY = by + (y - by) * alpha;
                }
            };
            return ScaleTimeline;
        }(TranslateTimeline));
        core.ScaleTimeline = ScaleTimeline;
        var ShearTimeline = (function (_super) {
            __extends(ShearTimeline, _super);
            function ShearTimeline(frameCount) {
                return _super.call(this, frameCount) || this;
            }
            ShearTimeline.prototype.getPropertyId = function () {
                return (TimelineType.shear << 24) + this.boneIndex;
            };
            ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
                var frames = this.frames;
                var bone = skeleton.bones[this.boneIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            bone.shearX = bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                            return;
                        case MixPose.current:
                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
                    }
                    return;
                }
                var x = 0, y = 0;
                if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
                    x = frames[frames.length + ShearTimeline.PREV_X];
                    y = frames[frames.length + ShearTimeline.PREV_Y];
                }
                else {
                    var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
                    x = frames[frame + ShearTimeline.PREV_X];
                    y = frames[frame + ShearTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
                    x = x + (frames[frame + ShearTimeline.X] - x) * percent;
                    y = y + (frames[frame + ShearTimeline.Y] - y) * percent;
                }
                if (pose == MixPose.setup) {
                    bone.shearX = bone.data.shearX + x * alpha;
                    bone.shearY = bone.data.shearY + y * alpha;
                }
                else {
                    bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                    bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
                }
            };
            return ShearTimeline;
        }(TranslateTimeline));
        core.ShearTimeline = ShearTimeline;
        var ColorTimeline = (function (_super) {
            __extends(ColorTimeline, _super);
            function ColorTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);
                return _this;
            }
            ColorTimeline.prototype.getPropertyId = function () {
                return (TimelineType.color << 24) + this.slotIndex;
            };
            ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {
                frameIndex *= ColorTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + ColorTimeline.R] = r;
                this.frames[frameIndex + ColorTimeline.G] = g;
                this.frames[frameIndex + ColorTimeline.B] = b;
                this.frames[frameIndex + ColorTimeline.A] = a;
            };
            ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
                var slot = skeleton.slots[this.slotIndex];
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            slot.color.setFromColor(slot.data.color);
                            return;
                        case MixPose.current:
                            var color = slot.color, setup = slot.data.color;
                            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
                    }
                    return;
                }
                var r = 0, g = 0, b = 0, a = 0;
                if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {
                    var i = frames.length;
                    r = frames[i + ColorTimeline.PREV_R];
                    g = frames[i + ColorTimeline.PREV_G];
                    b = frames[i + ColorTimeline.PREV_B];
                    a = frames[i + ColorTimeline.PREV_A];
                }
                else {
                    var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);
                    r = frames[frame + ColorTimeline.PREV_R];
                    g = frames[frame + ColorTimeline.PREV_G];
                    b = frames[frame + ColorTimeline.PREV_B];
                    a = frames[frame + ColorTimeline.PREV_A];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));
                    r += (frames[frame + ColorTimeline.R] - r) * percent;
                    g += (frames[frame + ColorTimeline.G] - g) * percent;
                    b += (frames[frame + ColorTimeline.B] - b) * percent;
                    a += (frames[frame + ColorTimeline.A] - a) * percent;
                }
                if (alpha == 1)
                    slot.color.set(r, g, b, a);
                else {
                    var color = slot.color;
                    if (pose == MixPose.setup)
                        color.setFromColor(slot.data.color);
                    color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
                }
            };
            ColorTimeline.ENTRIES = 5;
            ColorTimeline.PREV_TIME = -5;
            ColorTimeline.PREV_R = -4;
            ColorTimeline.PREV_G = -3;
            ColorTimeline.PREV_B = -2;
            ColorTimeline.PREV_A = -1;
            ColorTimeline.R = 1;
            ColorTimeline.G = 2;
            ColorTimeline.B = 3;
            ColorTimeline.A = 4;
            return ColorTimeline;
        }(CurveTimeline));
        core.ColorTimeline = ColorTimeline;
        var TwoColorTimeline = (function (_super) {
            __extends(TwoColorTimeline, _super);
            function TwoColorTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);
                return _this;
            }
            TwoColorTimeline.prototype.getPropertyId = function () {
                return (TimelineType.twoColor << 24) + this.slotIndex;
            };
            TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {
                frameIndex *= TwoColorTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + TwoColorTimeline.R] = r;
                this.frames[frameIndex + TwoColorTimeline.G] = g;
                this.frames[frameIndex + TwoColorTimeline.B] = b;
                this.frames[frameIndex + TwoColorTimeline.A] = a;
                this.frames[frameIndex + TwoColorTimeline.R2] = r2;
                this.frames[frameIndex + TwoColorTimeline.G2] = g2;
                this.frames[frameIndex + TwoColorTimeline.B2] = b2;
            };
            TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
                var slot = skeleton.slots[this.slotIndex];
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            slot.color.setFromColor(slot.data.color);
                            slot.darkColor.setFromColor(slot.data.darkColor);
                            return;
                        case MixPose.current:
                            var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;
                            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
                            dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
                    }
                    return;
                }
                var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;
                if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {
                    var i = frames.length;
                    r = frames[i + TwoColorTimeline.PREV_R];
                    g = frames[i + TwoColorTimeline.PREV_G];
                    b = frames[i + TwoColorTimeline.PREV_B];
                    a = frames[i + TwoColorTimeline.PREV_A];
                    r2 = frames[i + TwoColorTimeline.PREV_R2];
                    g2 = frames[i + TwoColorTimeline.PREV_G2];
                    b2 = frames[i + TwoColorTimeline.PREV_B2];
                }
                else {
                    var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);
                    r = frames[frame + TwoColorTimeline.PREV_R];
                    g = frames[frame + TwoColorTimeline.PREV_G];
                    b = frames[frame + TwoColorTimeline.PREV_B];
                    a = frames[frame + TwoColorTimeline.PREV_A];
                    r2 = frames[frame + TwoColorTimeline.PREV_R2];
                    g2 = frames[frame + TwoColorTimeline.PREV_G2];
                    b2 = frames[frame + TwoColorTimeline.PREV_B2];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));
                    r += (frames[frame + TwoColorTimeline.R] - r) * percent;
                    g += (frames[frame + TwoColorTimeline.G] - g) * percent;
                    b += (frames[frame + TwoColorTimeline.B] - b) * percent;
                    a += (frames[frame + TwoColorTimeline.A] - a) * percent;
                    r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;
                    g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;
                    b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;
                }
                if (alpha == 1) {
                    slot.color.set(r, g, b, a);
                    slot.darkColor.set(r2, g2, b2, 1);
                }
                else {
                    var light = slot.color, dark = slot.darkColor;
                    if (pose == MixPose.setup) {
                        light.setFromColor(slot.data.color);
                        dark.setFromColor(slot.data.darkColor);
                    }
                    light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
                    dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
                }
            };
            TwoColorTimeline.ENTRIES = 8;
            TwoColorTimeline.PREV_TIME = -8;
            TwoColorTimeline.PREV_R = -7;
            TwoColorTimeline.PREV_G = -6;
            TwoColorTimeline.PREV_B = -5;
            TwoColorTimeline.PREV_A = -4;
            TwoColorTimeline.PREV_R2 = -3;
            TwoColorTimeline.PREV_G2 = -2;
            TwoColorTimeline.PREV_B2 = -1;
            TwoColorTimeline.R = 1;
            TwoColorTimeline.G = 2;
            TwoColorTimeline.B = 3;
            TwoColorTimeline.A = 4;
            TwoColorTimeline.R2 = 5;
            TwoColorTimeline.G2 = 6;
            TwoColorTimeline.B2 = 7;
            return TwoColorTimeline;
        }(CurveTimeline));
        core.TwoColorTimeline = TwoColorTimeline;
        var AttachmentTimeline = (function () {
            function AttachmentTimeline(frameCount) {
                this.frames = core.Utils.newFloatArray(frameCount);
                this.attachmentNames = new Array(frameCount);
            }
            AttachmentTimeline.prototype.getPropertyId = function () {
                return (TimelineType.attachment << 24) + this.slotIndex;
            };
            AttachmentTimeline.prototype.getFrameCount = function () {
                return this.frames.length;
            };
            AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {
                this.frames[frameIndex] = time;
                this.attachmentNames[frameIndex] = attachmentName;
            };
            AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {
                var slot = skeleton.slots[this.slotIndex];
                if (direction == MixDirection.out && pose == MixPose.setup) {
                    var attachmentName_1 = slot.data.attachmentName;
                    slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    if (pose == MixPose.setup) {
                        var attachmentName_2 = slot.data.attachmentName;
                        slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));
                    }
                    return;
                }
                var frameIndex = 0;
                if (time >= frames[frames.length - 1])
                    frameIndex = frames.length - 1;
                else
                    frameIndex = Animation.binarySearch(frames, time, 1) - 1;
                var attachmentName = this.attachmentNames[frameIndex];
                skeleton.slots[this.slotIndex]
                    .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
            };
            return AttachmentTimeline;
        }());
        core.AttachmentTimeline = AttachmentTimeline;
        var zeros = null;
        var DeformTimeline = (function (_super) {
            __extends(DeformTimeline, _super);
            function DeformTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount);
                _this.frameVertices = new Array(frameCount);
                if (zeros == null)
                    zeros = core.Utils.newFloatArray(64);
                return _this;
            }
            DeformTimeline.prototype.getPropertyId = function () {
                return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;
            };
            DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {
                this.frames[frameIndex] = time;
                this.frameVertices[frameIndex] = vertices;
            };
            DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var slot = skeleton.slots[this.slotIndex];
                var slotAttachment = slot.getAttachment();
                if (!(slotAttachment instanceof core.VertexAttachment) || !slotAttachment.applyDeform(this.attachment))
                    return;
                var verticesArray = slot.attachmentVertices;
                var frameVertices = this.frameVertices;
                var vertexCount = frameVertices[0].length;
                var vertices = core.Utils.setArraySize(verticesArray, vertexCount);
                var frames = this.frames;
                if (time < frames[0]) {
                    var vertexAttachment = slotAttachment;
                    switch (pose) {
                        case MixPose.setup:
                            var zeroVertices = void 0;
                            if (vertexAttachment.bones == null) {
                                zeroVertices = vertexAttachment.vertices;
                            }
                            else {
                                zeroVertices = zeros;
                                if (zeroVertices.length < vertexCount)
                                    zeros = zeroVertices = core.Utils.newFloatArray(vertexCount);
                            }
                            core.Utils.arrayCopy(zeroVertices, 0, vertices, 0, vertexCount);
                            return;
                        case MixPose.current:
                            if (alpha == 1)
                                break;
                            if (vertexAttachment.bones == null) {
                                var setupVertices = vertexAttachment.vertices;
                                for (var i_1 = 0; i_1 < vertexCount; i_1++)
                                    vertices[i_1] += (setupVertices[i_1] - vertices[i_1]) * alpha;
                            }
                            else {
                                alpha = 1 - alpha;
                                for (var i = 0; i < vertexCount; i++)
                                    vertices[i] *= alpha;
                            }
                    }
                    return;
                }
                if (time >= frames[frames.length - 1]) {
                    var lastVertices = frameVertices[frames.length - 1];
                    if (alpha == 1) {
                        core.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
                    }
                    else if (pose == MixPose.setup) {
                        var vertexAttachment = slotAttachment;
                        if (vertexAttachment.bones == null) {
                            var setupVertices = vertexAttachment.vertices;
                            for (var i_2 = 0; i_2 < vertexCount; i_2++) {
                                var setup = setupVertices[i_2];
                                vertices[i_2] = setup + (lastVertices[i_2] - setup) * alpha;
                            }
                        }
                        else {
                            for (var i_3 = 0; i_3 < vertexCount; i_3++)
                                vertices[i_3] = lastVertices[i_3] * alpha;
                        }
                    }
                    else {
                        for (var i_4 = 0; i_4 < vertexCount; i_4++)
                            vertices[i_4] += (lastVertices[i_4] - vertices[i_4]) * alpha;
                    }
                    return;
                }
                var frame = Animation.binarySearch(frames, time);
                var prevVertices = frameVertices[frame - 1];
                var nextVertices = frameVertices[frame];
                var frameTime = frames[frame];
                var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
                if (alpha == 1) {
                    for (var i_5 = 0; i_5 < vertexCount; i_5++) {
                        var prev = prevVertices[i_5];
                        vertices[i_5] = prev + (nextVertices[i_5] - prev) * percent;
                    }
                }
                else if (pose == MixPose.setup) {
                    var vertexAttachment = slotAttachment;
                    if (vertexAttachment.bones == null) {
                        var setupVertices = vertexAttachment.vertices;
                        for (var i_6 = 0; i_6 < vertexCount; i_6++) {
                            var prev = prevVertices[i_6], setup = setupVertices[i_6];
                            vertices[i_6] = setup + (prev + (nextVertices[i_6] - prev) * percent - setup) * alpha;
                        }
                    }
                    else {
                        for (var i_7 = 0; i_7 < vertexCount; i_7++) {
                            var prev = prevVertices[i_7];
                            vertices[i_7] = (prev + (nextVertices[i_7] - prev) * percent) * alpha;
                        }
                    }
                }
                else {
                    for (var i_8 = 0; i_8 < vertexCount; i_8++) {
                        var prev = prevVertices[i_8];
                        vertices[i_8] += (prev + (nextVertices[i_8] - prev) * percent - vertices[i_8]) * alpha;
                    }
                }
            };
            return DeformTimeline;
        }(CurveTimeline));
        core.DeformTimeline = DeformTimeline;
        var EventTimeline = (function () {
            function EventTimeline(frameCount) {
                this.frames = core.Utils.newFloatArray(frameCount);
                this.events = new Array(frameCount);
            }
            EventTimeline.prototype.getPropertyId = function () {
                return TimelineType.event << 24;
            };
            EventTimeline.prototype.getFrameCount = function () {
                return this.frames.length;
            };
            EventTimeline.prototype.setFrame = function (frameIndex, event) {
                this.frames[frameIndex] = event.time;
                this.events[frameIndex] = event;
            };
            EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                if (firedEvents == null)
                    return;
                var frames = this.frames;
                var frameCount = this.frames.length;
                if (lastTime > time) {
                    this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);
                    lastTime = -1;
                }
                else if (lastTime >= frames[frameCount - 1])
                    return;
                if (time < frames[0])
                    return;
                var frame = 0;
                if (lastTime < frames[0])
                    frame = 0;
                else {
                    frame = Animation.binarySearch(frames, lastTime);
                    var frameTime = frames[frame];
                    while (frame > 0) {
                        if (frames[frame - 1] != frameTime)
                            break;
                        frame--;
                    }
                }
                for (; frame < frameCount && time >= frames[frame]; frame++)
                    firedEvents.push(this.events[frame]);
            };
            return EventTimeline;
        }());
        core.EventTimeline = EventTimeline;
        var DrawOrderTimeline = (function () {
            function DrawOrderTimeline(frameCount) {
                this.frames = core.Utils.newFloatArray(frameCount);
                this.drawOrders = new Array(frameCount);
            }
            DrawOrderTimeline.prototype.getPropertyId = function () {
                return TimelineType.drawOrder << 24;
            };
            DrawOrderTimeline.prototype.getFrameCount = function () {
                return this.frames.length;
            };
            DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {
                this.frames[frameIndex] = time;
                this.drawOrders[frameIndex] = drawOrder;
            };
            DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var drawOrder = skeleton.drawOrder;
                var slots = skeleton.slots;
                if (direction == MixDirection.out && pose == MixPose.setup) {
                    core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    if (pose == MixPose.setup)
                        core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
                    return;
                }
                var frame = 0;
                if (time >= frames[frames.length - 1])
                    frame = frames.length - 1;
                else
                    frame = Animation.binarySearch(frames, time) - 1;
                var drawOrderToSetupIndex = this.drawOrders[frame];
                if (drawOrderToSetupIndex == null)
                    core.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
                else {
                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
                        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
                }
            };
            return DrawOrderTimeline;
        }());
        core.DrawOrderTimeline = DrawOrderTimeline;
        var IkConstraintTimeline = (function (_super) {
            __extends(IkConstraintTimeline, _super);
            function IkConstraintTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);
                return _this;
            }
            IkConstraintTimeline.prototype.getPropertyId = function () {
                return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
            };
            IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection) {
                frameIndex *= IkConstraintTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;
                this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
            };
            IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames = this.frames;
                var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            constraint.mix = constraint.data.mix;
                            constraint.bendDirection = constraint.data.bendDirection;
                            return;
                        case MixPose.current:
                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
                            constraint.bendDirection = constraint.data.bendDirection;
                    }
                    return;
                }
                if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {
                    if (pose == MixPose.setup) {
                        constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
                        constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection
                            : frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
                    }
                    else {
                        constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
                        if (direction == MixDirection.in)
                            constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
                    }
                    return;
                }
                var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);
                var mix = frames[frame + IkConstraintTimeline.PREV_MIX];
                var frameTime = frames[frame];
                var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));
                if (pose == MixPose.setup) {
                    constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
                    constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
                }
                else {
                    constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
                    if (direction == MixDirection.in)
                        constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
                }
            };
            IkConstraintTimeline.ENTRIES = 3;
            IkConstraintTimeline.PREV_TIME = -3;
            IkConstraintTimeline.PREV_MIX = -2;
            IkConstraintTimeline.PREV_BEND_DIRECTION = -1;
            IkConstraintTimeline.MIX = 1;
            IkConstraintTimeline.BEND_DIRECTION = 2;
            return IkConstraintTimeline;
        }(CurveTimeline));
        core.IkConstraintTimeline = IkConstraintTimeline;
        var TransformConstraintTimeline = (function (_super) {
            __extends(TransformConstraintTimeline, _super);
            function TransformConstraintTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);
                return _this;
            }
            TransformConstraintTimeline.prototype.getPropertyId = function () {
                return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
            };
            TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
                frameIndex *= TransformConstraintTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;
                this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;
                this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;
                this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;
            };
            TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames = this.frames;
                var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
                if (time < frames[0]) {
                    var data = constraint.data;
                    switch (pose) {
                        case MixPose.setup:
                            constraint.rotateMix = data.rotateMix;
                            constraint.translateMix = data.translateMix;
                            constraint.scaleMix = data.scaleMix;
                            constraint.shearMix = data.shearMix;
                            return;
                        case MixPose.current:
                            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
                            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
                            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
                            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
                    }
                    return;
                }
                var rotate = 0, translate = 0, scale = 0, shear = 0;
                if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {
                    var i = frames.length;
                    rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];
                    translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];
                    scale = frames[i + TransformConstraintTimeline.PREV_SCALE];
                    shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];
                }
                else {
                    var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);
                    rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];
                    translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];
                    scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];
                    shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));
                    rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;
                    translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;
                    scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;
                    shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;
                }
                if (pose == MixPose.setup) {
                    var data = constraint.data;
                    constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
                    constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
                    constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
                    constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
                }
                else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                    constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
                    constraint.shearMix += (shear - constraint.shearMix) * alpha;
                }
            };
            TransformConstraintTimeline.ENTRIES = 5;
            TransformConstraintTimeline.PREV_TIME = -5;
            TransformConstraintTimeline.PREV_ROTATE = -4;
            TransformConstraintTimeline.PREV_TRANSLATE = -3;
            TransformConstraintTimeline.PREV_SCALE = -2;
            TransformConstraintTimeline.PREV_SHEAR = -1;
            TransformConstraintTimeline.ROTATE = 1;
            TransformConstraintTimeline.TRANSLATE = 2;
            TransformConstraintTimeline.SCALE = 3;
            TransformConstraintTimeline.SHEAR = 4;
            return TransformConstraintTimeline;
        }(CurveTimeline));
        core.TransformConstraintTimeline = TransformConstraintTimeline;
        var PathConstraintPositionTimeline = (function (_super) {
            __extends(PathConstraintPositionTimeline, _super);
            function PathConstraintPositionTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);
                return _this;
            }
            PathConstraintPositionTimeline.prototype.getPropertyId = function () {
                return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
            };
            PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {
                frameIndex *= PathConstraintPositionTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;
            };
            PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames = this.frames;
                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            constraint.position = constraint.data.position;
                            return;
                        case MixPose.current:
                            constraint.position += (constraint.data.position - constraint.position) * alpha;
                    }
                    return;
                }
                var position = 0;
                if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])
                    position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];
                else {
                    var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);
                    position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));
                    position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;
                }
                if (pose == MixPose.setup)
                    constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
                else
                    constraint.position += (position - constraint.position) * alpha;
            };
            PathConstraintPositionTimeline.ENTRIES = 2;
            PathConstraintPositionTimeline.PREV_TIME = -2;
            PathConstraintPositionTimeline.PREV_VALUE = -1;
            PathConstraintPositionTimeline.VALUE = 1;
            return PathConstraintPositionTimeline;
        }(CurveTimeline));
        core.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
        var PathConstraintSpacingTimeline = (function (_super) {
            __extends(PathConstraintSpacingTimeline, _super);
            function PathConstraintSpacingTimeline(frameCount) {
                return _super.call(this, frameCount) || this;
            }
            PathConstraintSpacingTimeline.prototype.getPropertyId = function () {
                return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
            };
            PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames = this.frames;
                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            constraint.spacing = constraint.data.spacing;
                            return;
                        case MixPose.current:
                            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
                    }
                    return;
                }
                var spacing = 0;
                if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])
                    spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
                else {
                    var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
                    spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));
                    spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
                }
                if (pose == MixPose.setup)
                    constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
                else
                    constraint.spacing += (spacing - constraint.spacing) * alpha;
            };
            return PathConstraintSpacingTimeline;
        }(PathConstraintPositionTimeline));
        core.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
        var PathConstraintMixTimeline = (function (_super) {
            __extends(PathConstraintMixTimeline, _super);
            function PathConstraintMixTimeline(frameCount) {
                var _this = _super.call(this, frameCount) || this;
                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);
                return _this;
            }
            PathConstraintMixTimeline.prototype.getPropertyId = function () {
                return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
            };
            PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {
                frameIndex *= PathConstraintMixTimeline.ENTRIES;
                this.frames[frameIndex] = time;
                this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;
                this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;
            };
            PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {
                var frames = this.frames;
                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                if (time < frames[0]) {
                    switch (pose) {
                        case MixPose.setup:
                            constraint.rotateMix = constraint.data.rotateMix;
                            constraint.translateMix = constraint.data.translateMix;
                            return;
                        case MixPose.current:
                            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
                            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
                    }
                    return;
                }
                var rotate = 0, translate = 0;
                if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {
                    rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];
                    translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];
                }
                else {
                    var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);
                    rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];
                    translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));
                    rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;
                    translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
                }
                if (pose == MixPose.setup) {
                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
                }
                else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                }
            };
            PathConstraintMixTimeline.ENTRIES = 3;
            PathConstraintMixTimeline.PREV_TIME = -3;
            PathConstraintMixTimeline.PREV_ROTATE = -2;
            PathConstraintMixTimeline.PREV_TRANSLATE = -1;
            PathConstraintMixTimeline.ROTATE = 1;
            PathConstraintMixTimeline.TRANSLATE = 2;
            return PathConstraintMixTimeline;
        }(CurveTimeline));
        core.PathConstraintMixTimeline = PathConstraintMixTimeline;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var AnimationState = (function () {
            function AnimationState(data) {
                this.tracks = new Array();
                this.events = new Array();
                this.listeners = new Array();
                this.queue = new EventQueue(this);
                this.propertyIDs = new core.IntSet();
                this.mixingTo = new Array();
                this.animationsChanged = false;
                this.timeScale = 1;
                this.trackEntryPool = new core.Pool(function () { return new TrackEntry(); });
                this.data = data;
            }
            AnimationState.prototype.update = function (delta) {
                delta *= this.timeScale;
                var tracks = this.tracks;
                for (var i = 0, n = tracks.length; i < n; i++) {
                    var current = tracks[i];
                    if (current == null)
                        continue;
                    current.animationLast = current.nextAnimationLast;
                    current.trackLast = current.nextTrackLast;
                    var currentDelta = delta * current.timeScale;
                    if (current.delay > 0) {
                        current.delay -= currentDelta;
                        if (current.delay > 0)
                            continue;
                        currentDelta = -current.delay;
                        current.delay = 0;
                    }
                    var next = current.next;
                    if (next != null) {
                        var nextTime = current.trackLast - next.delay;
                        if (nextTime >= 0) {
                            next.delay = 0;
                            next.trackTime = nextTime + delta * next.timeScale;
                            current.trackTime += currentDelta;
                            this.setCurrent(i, next, true);
                            while (next.mixingFrom != null) {
                                next.mixTime += currentDelta;
                                next = next.mixingFrom;
                            }
                            continue;
                        }
                    }
                    else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
                        tracks[i] = null;
                        this.queue.end(current);
                        this.disposeNext(current);
                        continue;
                    }
                    if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
                        var from = current.mixingFrom;
                        current.mixingFrom = null;
                        while (from != null) {
                            this.queue.end(from);
                            from = from.mixingFrom;
                        }
                    }
                    current.trackTime += currentDelta;
                }
                this.queue.drain();
            };
            AnimationState.prototype.updateMixingFrom = function (to, delta) {
                var from = to.mixingFrom;
                if (from == null)
                    return true;
                var finished = this.updateMixingFrom(from, delta);
                if (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {
                    if (from.totalAlpha == 0) {
                        to.mixingFrom = from.mixingFrom;
                        to.interruptAlpha = from.interruptAlpha;
                        this.queue.end(from);
                    }
                    return finished;
                }
                from.animationLast = from.nextAnimationLast;
                from.trackLast = from.nextTrackLast;
                from.trackTime += delta * from.timeScale;
                to.mixTime += delta * to.timeScale;
                return false;
            };
            AnimationState.prototype.apply = function (skeleton) {
                if (skeleton == null)
                    throw new Error("skeleton cannot be null.");
                if (this.animationsChanged)
                    this._animationsChanged();
                var events = this.events;
                var tracks = this.tracks;
                var applied = false;
                for (var i = 0, n = tracks.length; i < n; i++) {
                    var current = tracks[i];
                    if (current == null || current.delay > 0)
                        continue;
                    applied = true;
                    var currentPose = i == 0 ? core.MixPose.current : core.MixPose.currentLayered;
                    var mix = current.alpha;
                    if (current.mixingFrom != null)
                        mix *= this.applyMixingFrom(current, skeleton, currentPose);
                    else if (current.trackTime >= current.trackEnd && current.next == null)
                        mix = 0;
                    var animationLast = current.animationLast, animationTime = current.getAnimationTime();
                    var timelineCount = current.animation.timelines.length;
                    var timelines = current.animation.timelines;
                    if (mix == 1) {
                        for (var ii = 0; ii < timelineCount; ii++)
                            timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, core.MixPose.setup, core.MixDirection.in);
                    }
                    else {
                        var timelineData = current.timelineData;
                        var firstFrame = current.timelinesRotation.length == 0;
                        if (firstFrame)
                            core.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
                        var timelinesRotation = current.timelinesRotation;
                        for (var ii = 0; ii < timelineCount; ii++) {
                            var timeline = timelines[ii];
                            var pose = timelineData[ii] >= AnimationState.FIRST ? core.MixPose.setup : currentPose;
                            if (timeline instanceof core.RotateTimeline) {
                                this.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);
                            }
                            else
                                timeline.apply(skeleton, animationLast, animationTime, events, mix, pose, core.MixDirection.in);
                        }
                    }
                    this.queueEvents(current, animationTime);
                    events.length = 0;
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }
                this.queue.drain();
                return applied;
            };
            AnimationState.prototype.applyMixingFrom = function (to, skeleton, currentPose) {
                var from = to.mixingFrom;
                if (from.mixingFrom != null)
                    this.applyMixingFrom(from, skeleton, currentPose);
                var mix = 0;
                if (to.mixDuration == 0)
                    mix = 1;
                else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1)
                        mix = 1;
                }
                var events = mix < from.eventThreshold ? this.events : null;
                var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
                var animationLast = from.animationLast, animationTime = from.getAnimationTime();
                var timelineCount = from.animation.timelines.length;
                var timelines = from.animation.timelines;
                var timelineData = from.timelineData;
                var timelineDipMix = from.timelineDipMix;
                var firstFrame = from.timelinesRotation.length == 0;
                if (firstFrame)
                    core.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
                var timelinesRotation = from.timelinesRotation;
                var pose;
                var alphaDip = from.alpha * to.interruptAlpha, alphaMix = alphaDip * (1 - mix), alpha = 0;
                from.totalAlpha = 0;
                for (var i = 0; i < timelineCount; i++) {
                    var timeline = timelines[i];
                    switch (timelineData[i]) {
                        case AnimationState.SUBSEQUENT:
                            if (!attachments && timeline instanceof core.AttachmentTimeline)
                                continue;
                            if (!drawOrder && timeline instanceof core.DrawOrderTimeline)
                                continue;
                            pose = currentPose;
                            alpha = alphaMix;
                            break;
                        case AnimationState.FIRST:
                            pose = core.MixPose.setup;
                            alpha = alphaMix;
                            break;
                        case AnimationState.DIP:
                            pose = core.MixPose.setup;
                            alpha = alphaDip;
                            break;
                        default:
                            pose = core.MixPose.setup;
                            alpha = alphaDip;
                            var dipMix = timelineDipMix[i];
                            alpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);
                            break;
                    }
                    from.totalAlpha += alpha;
                    if (timeline instanceof core.RotateTimeline)
                        this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);
                    else {
                        timeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, core.MixDirection.out);
                    }
                }
                if (to.mixDuration > 0)
                    this.queueEvents(from, animationTime);
                this.events.length = 0;
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;
                return mix;
            };
            AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, pose, timelinesRotation, i, firstFrame) {
                if (firstFrame)
                    timelinesRotation[i] = 0;
                if (alpha == 1) {
                    timeline.apply(skeleton, 0, time, null, 1, pose, core.MixDirection.in);
                    return;
                }
                var rotateTimeline = timeline;
                var frames = rotateTimeline.frames;
                var bone = skeleton.bones[rotateTimeline.boneIndex];
                if (time < frames[0]) {
                    if (pose == core.MixPose.setup)
                        bone.rotation = bone.data.rotation;
                    return;
                }
                var r2 = 0;
                if (time >= frames[frames.length - core.RotateTimeline.ENTRIES])
                    r2 = bone.data.rotation + frames[frames.length + core.RotateTimeline.PREV_ROTATION];
                else {
                    var frame = core.Animation.binarySearch(frames, time, core.RotateTimeline.ENTRIES);
                    var prevRotation = frames[frame + core.RotateTimeline.PREV_ROTATION];
                    var frameTime = frames[frame];
                    var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + core.RotateTimeline.PREV_TIME] - frameTime));
                    r2 = frames[frame + core.RotateTimeline.ROTATION] - prevRotation;
                    r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;
                    r2 = prevRotation + r2 * percent + bone.data.rotation;
                    r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;
                }
                var r1 = pose == core.MixPose.setup ? bone.data.rotation : bone.rotation;
                var total = 0, diff = r2 - r1;
                if (diff == 0) {
                    total = timelinesRotation[i];
                }
                else {
                    diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;
                    var lastTotal = 0, lastDiff = 0;
                    if (firstFrame) {
                        lastTotal = 0;
                        lastDiff = diff;
                    }
                    else {
                        lastTotal = timelinesRotation[i];
                        lastDiff = timelinesRotation[i + 1];
                    }
                    var current = diff > 0, dir = lastTotal >= 0;
                    if (core.MathUtils.signum(lastDiff) != core.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
                        if (Math.abs(lastTotal) > 180)
                            lastTotal += 360 * core.MathUtils.signum(lastTotal);
                        dir = current;
                    }
                    total = diff + lastTotal - lastTotal % 360;
                    if (dir != current)
                        total += 360 * core.MathUtils.signum(lastTotal);
                    timelinesRotation[i] = total;
                }
                timelinesRotation[i + 1] = diff;
                r1 += total * alpha;
                bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;
            };
            AnimationState.prototype.queueEvents = function (entry, animationTime) {
                var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
                var duration = animationEnd - animationStart;
                var trackLastWrapped = entry.trackLast % duration;
                var events = this.events;
                var i = 0, n = events.length;
                for (; i < n; i++) {
                    var event_1 = events[i];
                    if (event_1.time < trackLastWrapped)
                        break;
                    if (event_1.time > animationEnd)
                        continue;
                    this.queue.event(entry, event_1);
                }
                if (entry.loop ? (trackLastWrapped > entry.trackTime % duration)
                    : (animationTime >= animationEnd && entry.animationLast < animationEnd)) {
                    this.queue.complete(entry);
                }
                for (; i < n; i++) {
                    var event_2 = events[i];
                    if (event_2.time < animationStart)
                        continue;
                    this.queue.event(entry, events[i]);
                }
            };
            AnimationState.prototype.clearTracks = function () {
                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.length; i < n; i++)
                    this.clearTrack(i);
                this.tracks.length = 0;
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.drain();
            };
            AnimationState.prototype.clearTrack = function (trackIndex) {
                if (trackIndex >= this.tracks.length)
                    return;
                var current = this.tracks[trackIndex];
                if (current == null)
                    return;
                this.queue.end(current);
                this.disposeNext(current);
                var entry = current;
                while (true) {
                    var from = entry.mixingFrom;
                    if (from == null)
                        break;
                    this.queue.end(from);
                    entry.mixingFrom = null;
                    entry = from;
                }
                this.tracks[current.trackIndex] = null;
                this.queue.drain();
            };
            AnimationState.prototype.setCurrent = function (index, current, interrupt) {
                var from = this.expandToIndex(index);
                this.tracks[index] = current;
                if (from != null) {
                    if (interrupt)
                        this.queue.interrupt(from);
                    current.mixingFrom = from;
                    current.mixTime = 0;
                    if (from.mixingFrom != null && from.mixDuration > 0)
                        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
                    from.timelinesRotation.length = 0;
                }
                this.queue.start(current);
            };
            AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {
                var animation = this.data.skeletonData.findAnimation(animationName);
                if (animation == null)
                    throw new Error("Animation not found: " + animationName);
                return this.setAnimationWith(trackIndex, animation, loop);
            };
            AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {
                if (animation == null)
                    throw new Error("animation cannot be null.");
                var interrupt = true;
                var current = this.expandToIndex(trackIndex);
                if (current != null) {
                    if (current.nextTrackLast == -1) {
                        this.tracks[trackIndex] = current.mixingFrom;
                        this.queue.interrupt(current);
                        this.queue.end(current);
                        this.disposeNext(current);
                        current = current.mixingFrom;
                        interrupt = false;
                    }
                    else
                        this.disposeNext(current);
                }
                var entry = this.trackEntry(trackIndex, animation, loop, current);
                this.setCurrent(trackIndex, entry, interrupt);
                this.queue.drain();
                return entry;
            };
            AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {
                var animation = this.data.skeletonData.findAnimation(animationName);
                if (animation == null)
                    throw new Error("Animation not found: " + animationName);
                return this.addAnimationWith(trackIndex, animation, loop, delay);
            };
            AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {
                if (animation == null)
                    throw new Error("animation cannot be null.");
                var last = this.expandToIndex(trackIndex);
                if (last != null) {
                    while (last.next != null)
                        last = last.next;
                }
                var entry = this.trackEntry(trackIndex, animation, loop, last);
                if (last == null) {
                    this.setCurrent(trackIndex, entry, true);
                    this.queue.drain();
                }
                else {
                    last.next = entry;
                    if (delay <= 0) {
                        var duration = last.animationEnd - last.animationStart;
                        if (duration != 0)
                            delay += duration * (1 + ((last.trackTime / duration) | 0)) - this.data.getMix(last.animation, animation);
                        else
                            delay = 0;
                    }
                }
                entry.delay = delay;
                return entry;
            };
            AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {
                var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            };
            AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {
                if (delay <= 0)
                    delay -= mixDuration;
                var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            };
            AnimationState.prototype.setEmptyAnimations = function (mixDuration) {
                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                for (var i = 0, n = this.tracks.length; i < n; i++) {
                    var current = this.tracks[i];
                    if (current != null)
                        this.setEmptyAnimation(current.trackIndex, mixDuration);
                }
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.drain();
            };
            AnimationState.prototype.expandToIndex = function (index) {
                if (index < this.tracks.length)
                    return this.tracks[index];
                core.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
                this.tracks.length = index + 1;
                return null;
            };
            AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {
                var entry = this.trackEntryPool.obtain();
                entry.trackIndex = trackIndex;
                entry.animation = animation;
                entry.loop = loop;
                entry.eventThreshold = 0;
                entry.attachmentThreshold = 0;
                entry.drawOrderThreshold = 0;
                entry.animationStart = 0;
                entry.animationEnd = animation.duration;
                entry.animationLast = -1;
                entry.nextAnimationLast = -1;
                entry.delay = 0;
                entry.trackTime = 0;
                entry.trackLast = -1;
                entry.nextTrackLast = -1;
                entry.trackEnd = Number.MAX_VALUE;
                entry.timeScale = 1;
                entry.alpha = 1;
                entry.interruptAlpha = 1;
                entry.mixTime = 0;
                entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
                return entry;
            };
            AnimationState.prototype.disposeNext = function (entry) {
                var next = entry.next;
                while (next != null) {
                    this.queue.dispose(next);
                    next = next.next;
                }
                entry.next = null;
            };
            AnimationState.prototype._animationsChanged = function () {
                this.animationsChanged = false;
                var propertyIDs = this.propertyIDs;
                propertyIDs.clear();
                var mixingTo = this.mixingTo;
                var lastEntry = null;
                for (var i = 0, n = this.tracks.length; i < n; i++) {
                    var entry = this.tracks[i];
                    if (entry != null)
                        entry.setTimelineData(null, mixingTo, propertyIDs);
                }
            };
            AnimationState.prototype.getCurrent = function (trackIndex) {
                if (trackIndex >= this.tracks.length)
                    return null;
                return this.tracks[trackIndex];
            };
            AnimationState.prototype.addListener = function (listener) {
                if (listener == null)
                    throw new Error("listener cannot be null.");
                this.listeners.push(listener);
            };
            AnimationState.prototype.removeListener = function (listener) {
                var index = this.listeners.indexOf(listener);
                if (index >= 0)
                    this.listeners.splice(index, 1);
            };
            AnimationState.prototype.clearListeners = function () {
                this.listeners.length = 0;
            };
            AnimationState.prototype.clearListenerNotifications = function () {
                this.queue.clear();
            };
            AnimationState.prototype.setAnimationByName = function (trackIndex, animationName, loop) {
                if (!AnimationState.deprecatedWarning1) {
                    AnimationState.deprecatedWarning1 = true;
                    console.warn("Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
                }
                this.setAnimation(trackIndex, animationName, loop);
            };
            AnimationState.prototype.addAnimationByName = function (trackIndex, animationName, loop, delay) {
                if (!AnimationState.deprecatedWarning2) {
                    AnimationState.deprecatedWarning2 = true;
                    console.warn("Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
                }
                this.addAnimation(trackIndex, animationName, loop, delay);
            };
            AnimationState.prototype.hasAnimation = function (animationName) {
                var animation = this.data.skeletonData.findAnimation(animationName);
                return animation !== null;
            };
            AnimationState.prototype.hasAnimationByName = function (animationName) {
                if (!AnimationState.deprecatedWarning3) {
                    AnimationState.deprecatedWarning3 = true;
                    console.warn("Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
                }
                return this.hasAnimation(animationName);
            };
            AnimationState.emptyAnimation = new core.Animation("<empty>", [], 0);
            AnimationState.SUBSEQUENT = 0;
            AnimationState.FIRST = 1;
            AnimationState.DIP = 2;
            AnimationState.DIP_MIX = 3;
            AnimationState.deprecatedWarning1 = false;
            AnimationState.deprecatedWarning2 = false;
            AnimationState.deprecatedWarning3 = false;
            return AnimationState;
        }());
        core.AnimationState = AnimationState;
        var TrackEntry = (function () {
            function TrackEntry() {
                this.timelineData = new Array();
                this.timelineDipMix = new Array();
                this.timelinesRotation = new Array();
            }
            TrackEntry.prototype.reset = function () {
                this.next = null;
                this.mixingFrom = null;
                this.animation = null;
                this.listener = null;
                this.timelineData.length = 0;
                this.timelineDipMix.length = 0;
                this.timelinesRotation.length = 0;
            };
            TrackEntry.prototype.setTimelineData = function (to, mixingToArray, propertyIDs) {
                if (to != null)
                    mixingToArray.push(to);
                var lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;
                if (to != null)
                    mixingToArray.pop();
                var mixingTo = mixingToArray;
                var mixingToLast = mixingToArray.length - 1;
                var timelines = this.animation.timelines;
                var timelinesCount = this.animation.timelines.length;
                var timelineData = core.Utils.setArraySize(this.timelineData, timelinesCount);
                this.timelineDipMix.length = 0;
                var timelineDipMix = core.Utils.setArraySize(this.timelineDipMix, timelinesCount);
                outer: for (var i = 0; i < timelinesCount; i++) {
                    var id = timelines[i].getPropertyId();
                    if (!propertyIDs.add(id))
                        timelineData[i] = AnimationState.SUBSEQUENT;
                    else if (to == null || !to.hasTimeline(id))
                        timelineData[i] = AnimationState.FIRST;
                    else {
                        for (var ii = mixingToLast; ii >= 0; ii--) {
                            var entry = mixingTo[ii];
                            if (!entry.hasTimeline(id)) {
                                if (entry.mixDuration > 0) {
                                    timelineData[i] = AnimationState.DIP_MIX;
                                    timelineDipMix[i] = entry;
                                    continue outer;
                                }
                            }
                        }
                        timelineData[i] = AnimationState.DIP;
                    }
                }
                return lastEntry;
            };
            TrackEntry.prototype.hasTimeline = function (id) {
                var timelines = this.animation.timelines;
                for (var i = 0, n = timelines.length; i < n; i++)
                    if (timelines[i].getPropertyId() == id)
                        return true;
                return false;
            };
            TrackEntry.prototype.getAnimationTime = function () {
                if (this.loop) {
                    var duration = this.animationEnd - this.animationStart;
                    if (duration == 0)
                        return this.animationStart;
                    return (this.trackTime % duration) + this.animationStart;
                }
                return Math.min(this.trackTime + this.animationStart, this.animationEnd);
            };
            TrackEntry.prototype.setAnimationLast = function (animationLast) {
                this.animationLast = animationLast;
                this.nextAnimationLast = animationLast;
            };
            TrackEntry.prototype.isComplete = function () {
                return this.trackTime >= this.animationEnd - this.animationStart;
            };
            TrackEntry.prototype.resetRotationDirections = function () {
                this.timelinesRotation.length = 0;
            };
            Object.defineProperty(TrackEntry.prototype, "time", {
                get: function () {
                    if (!TrackEntry.deprecatedWarning1) {
                        TrackEntry.deprecatedWarning1 = true;
                        console.warn("Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
                    }
                    return this.trackTime;
                },
                set: function (value) {
                    if (!TrackEntry.deprecatedWarning1) {
                        TrackEntry.deprecatedWarning1 = true;
                        console.warn("Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
                    }
                    this.trackTime = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TrackEntry.prototype, "endTime", {
                get: function () {
                    if (!TrackEntry.deprecatedWarning2) {
                        TrackEntry.deprecatedWarning2 = true;
                        console.warn("Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
                    }
                    return this.trackTime;
                },
                set: function (value) {
                    if (!TrackEntry.deprecatedWarning2) {
                        TrackEntry.deprecatedWarning2 = true;
                        console.warn("Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
                    }
                    this.trackTime = value;
                },
                enumerable: true,
                configurable: true
            });
            TrackEntry.prototype.loopsCount = function () {
                return Math.floor(this.trackTime / this.trackEnd);
            };
            TrackEntry.deprecatedWarning1 = false;
            TrackEntry.deprecatedWarning2 = false;
            return TrackEntry;
        }());
        core.TrackEntry = TrackEntry;
        var EventQueue = (function () {
            function EventQueue(animState) {
                this.objects = [];
                this.drainDisabled = false;
                this.animState = animState;
            }
            EventQueue.prototype.start = function (entry) {
                this.objects.push(EventType.start);
                this.objects.push(entry);
                this.animState.animationsChanged = true;
            };
            EventQueue.prototype.interrupt = function (entry) {
                this.objects.push(EventType.interrupt);
                this.objects.push(entry);
            };
            EventQueue.prototype.end = function (entry) {
                this.objects.push(EventType.end);
                this.objects.push(entry);
                this.animState.animationsChanged = true;
            };
            EventQueue.prototype.dispose = function (entry) {
                this.objects.push(EventType.dispose);
                this.objects.push(entry);
            };
            EventQueue.prototype.complete = function (entry) {
                this.objects.push(EventType.complete);
                this.objects.push(entry);
            };
            EventQueue.prototype.event = function (entry, event) {
                this.objects.push(EventType.event);
                this.objects.push(entry);
                this.objects.push(event);
            };
            EventQueue.prototype.deprecateStuff = function () {
                if (!EventQueue.deprecatedWarning1) {
                    EventQueue.deprecatedWarning1 = true;
                    console.warn("Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'");
                }
                return true;
            };
            EventQueue.prototype.drain = function () {
                if (this.drainDisabled)
                    return;
                this.drainDisabled = true;
                var objects = this.objects;
                var listeners = this.animState.listeners;
                for (var i = 0; i < objects.length; i += 2) {
                    var type = objects[i];
                    var entry = objects[i + 1];
                    switch (type) {
                        case EventType.start:
                            if (entry.listener != null && entry.listener.start)
                                entry.listener.start(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].start)
                                    listeners[ii].start(entry);
                            entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
                            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
                            break;
                        case EventType.interrupt:
                            if (entry.listener != null && entry.listener.interrupt)
                                entry.listener.interrupt(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].interrupt)
                                    listeners[ii].interrupt(entry);
                            break;
                        case EventType.end:
                            if (entry.listener != null && entry.listener.end)
                                entry.listener.end(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].end)
                                    listeners[ii].end(entry);
                            entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
                            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
                        case EventType.dispose:
                            if (entry.listener != null && entry.listener.dispose)
                                entry.listener.dispose(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].dispose)
                                    listeners[ii].dispose(entry);
                            this.animState.trackEntryPool.free(entry);
                            break;
                        case EventType.complete:
                            if (entry.listener != null && entry.listener.complete)
                                entry.listener.complete(entry);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].complete)
                                    listeners[ii].complete(entry);
                            var count = core.MathUtils.toInt(entry.loopsCount());
                            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
                            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
                            break;
                        case EventType.event:
                            var event_3 = objects[i++ + 2];
                            if (entry.listener != null && entry.listener.event)
                                entry.listener.event(entry, event_3);
                            for (var ii = 0; ii < listeners.length; ii++)
                                if (listeners[ii].event)
                                    listeners[ii].event(entry, event_3);
                            entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);
                            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);
                            break;
                    }
                }
                this.clear();
                this.drainDisabled = false;
            };
            EventQueue.prototype.clear = function () {
                this.objects.length = 0;
            };
            EventQueue.deprecatedWarning1 = false;
            return EventQueue;
        }());
        core.EventQueue = EventQueue;
        var EventType;
        (function (EventType) {
            EventType[EventType["start"] = 0] = "start";
            EventType[EventType["interrupt"] = 1] = "interrupt";
            EventType[EventType["end"] = 2] = "end";
            EventType[EventType["dispose"] = 3] = "dispose";
            EventType[EventType["complete"] = 4] = "complete";
            EventType[EventType["event"] = 5] = "event";
        })(EventType = core.EventType || (core.EventType = {}));
        var AnimationStateAdapter2 = (function () {
            function AnimationStateAdapter2() {
            }
            AnimationStateAdapter2.prototype.start = function (entry) {
            };
            AnimationStateAdapter2.prototype.interrupt = function (entry) {
            };
            AnimationStateAdapter2.prototype.end = function (entry) {
            };
            AnimationStateAdapter2.prototype.dispose = function (entry) {
            };
            AnimationStateAdapter2.prototype.complete = function (entry) {
            };
            AnimationStateAdapter2.prototype.event = function (entry, event) {
            };
            return AnimationStateAdapter2;
        }());
        core.AnimationStateAdapter2 = AnimationStateAdapter2;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var AnimationStateData = (function () {
            function AnimationStateData(skeletonData) {
                this.animationToMixTime = {};
                this.defaultMix = 0;
                if (skeletonData == null)
                    throw new Error("skeletonData cannot be null.");
                this.skeletonData = skeletonData;
            }
            AnimationStateData.prototype.setMix = function (fromName, toName, duration) {
                var from = this.skeletonData.findAnimation(fromName);
                if (from == null)
                    throw new Error("Animation not found: " + fromName);
                var to = this.skeletonData.findAnimation(toName);
                if (to == null)
                    throw new Error("Animation not found: " + toName);
                this.setMixWith(from, to, duration);
            };
            AnimationStateData.prototype.setMixByName = function (fromName, toName, duration) {
                if (!AnimationStateData.deprecatedWarning1) {
                    AnimationStateData.deprecatedWarning1 = true;
                    console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
                }
                this.setMix(fromName, toName, duration);
            };
            AnimationStateData.prototype.setMixWith = function (from, to, duration) {
                if (from == null)
                    throw new Error("from cannot be null.");
                if (to == null)
                    throw new Error("to cannot be null.");
                var key = from.name + to.name;
                this.animationToMixTime[key] = duration;
            };
            AnimationStateData.prototype.getMix = function (from, to) {
                var key = from.name + to.name;
                var value = this.animationToMixTime[key];
                return value === undefined ? this.defaultMix : value;
            };
            AnimationStateData.deprecatedWarning1 = false;
            return AnimationStateData;
        }());
        core.AnimationStateData = AnimationStateData;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var AtlasAttachmentLoader = (function () {
            function AtlasAttachmentLoader(atlas) {
                this.atlas = atlas;
            }
            AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {
                var region = this.atlas.findRegion(path);
                if (region == null)
                    throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
                var attachment = new core.RegionAttachment(name);
                attachment.region = region;
                return attachment;
            };
            AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {
                var region = this.atlas.findRegion(path);
                if (region == null)
                    throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
                var attachment = new core.MeshAttachment(name);
                attachment.region = region;
                return attachment;
            };
            AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {
                return new core.BoundingBoxAttachment(name);
            };
            AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {
                return new core.PathAttachment(name);
            };
            AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {
                return new core.PointAttachment(name);
            };
            AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {
                return new core.ClippingAttachment(name);
            };
            return AtlasAttachmentLoader;
        }());
        core.AtlasAttachmentLoader = AtlasAttachmentLoader;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var BlendMode;
        (function (BlendMode) {
            BlendMode[BlendMode["Normal"] = 0] = "Normal";
            BlendMode[BlendMode["Additive"] = 1] = "Additive";
            BlendMode[BlendMode["Multiply"] = 2] = "Multiply";
            BlendMode[BlendMode["Screen"] = 3] = "Screen";
        })(BlendMode = core.BlendMode || (core.BlendMode = {}));
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Bone = (function () {
            function Bone(data, skeleton, parent) {
                this.matrix = new PIXI.Matrix();
                this.children = new Array();
                this.x = 0;
                this.y = 0;
                this.rotation = 0;
                this.scaleX = 0;
                this.scaleY = 0;
                this.shearX = 0;
                this.shearY = 0;
                this.ax = 0;
                this.ay = 0;
                this.arotation = 0;
                this.ascaleX = 0;
                this.ascaleY = 0;
                this.ashearX = 0;
                this.ashearY = 0;
                this.appliedValid = false;
                this.sorted = false;
                if (data == null)
                    throw new Error("data cannot be null.");
                if (skeleton == null)
                    throw new Error("skeleton cannot be null.");
                this.data = data;
                this.skeleton = skeleton;
                this.parent = parent;
                this.setToSetupPose();
            }
            Object.defineProperty(Bone.prototype, "worldX", {
                get: function () {
                    return this.matrix.tx;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Bone.prototype, "worldY", {
                get: function () {
                    return this.matrix.ty;
                },
                enumerable: true,
                configurable: true
            });
            Bone.prototype.update = function () {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            };
            Bone.prototype.updateWorldTransform = function () {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            };
            Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {
                this.ax = x;
                this.ay = y;
                this.arotation = rotation;
                this.ascaleX = scaleX;
                this.ascaleY = scaleY;
                this.ashearX = shearX;
                this.ashearY = shearY;
                this.appliedValid = true;
                var parent = this.parent;
                var m = this.matrix;
                if (parent == null) {
                    var rotationY = rotation + 90 + shearY;
                    var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;
                    var lb = core.MathUtils.cosDeg(rotationY) * scaleY;
                    var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;
                    var ld = core.MathUtils.sinDeg(rotationY) * scaleY;
                    var skeleton = this.skeleton;
                    if (skeleton.flipX) {
                        x = -x;
                        la = -la;
                        lb = -lb;
                    }
                    if (skeleton.flipY !== Bone.yDown) {
                        y = -y;
                        lc = -lc;
                        ld = -ld;
                    }
                    m.a = la;
                    m.c = lb;
                    m.b = lc;
                    m.d = ld;
                    m.tx = x + skeleton.x;
                    m.ty = y + skeleton.y;
                    return;
                }
                var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;
                m.tx = pa * x + pb * y + parent.matrix.tx;
                m.ty = pc * x + pd * y + parent.matrix.ty;
                switch (this.data.transformMode) {
                    case core.TransformMode.Normal: {
                        var rotationY = rotation + 90 + shearY;
                        var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        var lb = core.MathUtils.cosDeg(rotationY) * scaleY;
                        var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        var ld = core.MathUtils.sinDeg(rotationY) * scaleY;
                        m.a = pa * la + pb * lc;
                        m.c = pa * lb + pb * ld;
                        m.b = pc * la + pd * lc;
                        m.d = pc * lb + pd * ld;
                        return;
                    }
                    case core.TransformMode.OnlyTranslation: {
                        var rotationY = rotation + 90 + shearY;
                        m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        m.c = core.MathUtils.cosDeg(rotationY) * scaleY;
                        m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        m.d = core.MathUtils.sinDeg(rotationY) * scaleY;
                        break;
                    }
                    case core.TransformMode.NoRotationOrReflection: {
                        var s = pa * pa + pc * pc;
                        var prx = 0;
                        if (s > 0.0001) {
                            s = Math.abs(pa * pd - pb * pc) / s;
                            pb = pc * s;
                            pd = pa * s;
                            prx = Math.atan2(pc, pa) * core.MathUtils.radDeg;
                        }
                        else {
                            pa = 0;
                            pc = 0;
                            prx = 90 - Math.atan2(pd, pb) * core.MathUtils.radDeg;
                        }
                        var rx = rotation + shearX - prx;
                        var ry = rotation + shearY - prx + 90;
                        var la = core.MathUtils.cosDeg(rx) * scaleX;
                        var lb = core.MathUtils.cosDeg(ry) * scaleY;
                        var lc = core.MathUtils.sinDeg(rx) * scaleX;
                        var ld = core.MathUtils.sinDeg(ry) * scaleY;
                        m.a = pa * la - pb * lc;
                        m.c = pa * lb - pb * ld;
                        m.b = pc * la + pd * lc;
                        m.d = pc * lb + pd * ld;
                        break;
                    }
                    case core.TransformMode.NoScale:
                    case core.TransformMode.NoScaleOrReflection: {
                        var cos = core.MathUtils.cosDeg(rotation);
                        var sin = core.MathUtils.sinDeg(rotation);
                        var za = pa * cos + pb * sin;
                        var zc = pc * cos + pd * sin;
                        var s = Math.sqrt(za * za + zc * zc);
                        if (s > 0.00001)
                            s = 1 / s;
                        za *= s;
                        zc *= s;
                        s = Math.sqrt(za * za + zc * zc);
                        var r = Math.PI / 2 + Math.atan2(zc, za);
                        var zb = Math.cos(r) * s;
                        var zd = Math.sin(r) * s;
                        var la = core.MathUtils.cosDeg(shearX) * scaleX;
                        var lb = core.MathUtils.cosDeg(90 + shearY) * scaleY;
                        var lc = core.MathUtils.sinDeg(shearX) * scaleX;
                        var ld = core.MathUtils.sinDeg(90 + shearY) * scaleY;
                        m.a = za * la + zb * lc;
                        m.c = za * lb + zb * ld;
                        m.b = zc * la + zd * lc;
                        m.d = zc * lb + zd * ld;
                        if (this.data.transformMode != core.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : ((this.skeleton.flipX != this.skeleton.flipY) != Bone.yDown)) {
                            m.c = -m.c;
                            m.d = -m.d;
                        }
                        return;
                    }
                }
                if (this.skeleton.flipX) {
                    m.a = -m.a;
                    m.c = -m.c;
                }
                if (this.skeleton.flipY != Bone.yDown) {
                    m.b = -m.b;
                    m.d = -m.d;
                }
            };
            Bone.prototype.setToSetupPose = function () {
                var data = this.data;
                this.x = data.x;
                this.y = data.y;
                this.rotation = data.rotation;
                this.scaleX = data.scaleX;
                this.scaleY = data.scaleY;
                this.shearX = data.shearX;
                this.shearY = data.shearY;
            };
            Bone.prototype.getWorldRotationX = function () {
                return Math.atan2(this.matrix.b, this.matrix.a) * core.MathUtils.radDeg;
            };
            Bone.prototype.getWorldRotationY = function () {
                return Math.atan2(this.matrix.d, this.matrix.c) * core.MathUtils.radDeg;
            };
            Bone.prototype.getWorldScaleX = function () {
                var m = this.matrix;
                return Math.sqrt(m.a * m.a + m.c * m.c);
            };
            Bone.prototype.getWorldScaleY = function () {
                var m = this.matrix;
                return Math.sqrt(m.b * m.b + m.d * m.d);
            };
            Bone.prototype.updateAppliedTransform = function () {
                this.appliedValid = true;
                var parent = this.parent;
                var m = this.matrix;
                if (parent == null) {
                    this.ax = m.tx;
                    this.ay = m.ty;
                    this.arotation = Math.atan2(m.b, m.a) * core.MathUtils.radDeg;
                    this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
                    this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
                    this.ashearX = 0;
                    this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * core.MathUtils.radDeg;
                    return;
                }
                var pm = parent.matrix;
                var pid = 1 / (pm.a * pm.d - pm.b * pm.c);
                var dx = m.tx - pm.tx, dy = m.ty - pm.ty;
                this.ax = (dx * pm.d * pid - dy * pm.c * pid);
                this.ay = (dy * pm.a * pid - dx * pm.b * pid);
                var ia = pid * pm.d;
                var id = pid * pm.a;
                var ib = pid * pm.c;
                var ic = pid * pm.b;
                var ra = ia * m.a - ib * m.b;
                var rb = ia * m.c - ib * m.d;
                var rc = id * m.b - ic * m.a;
                var rd = id * m.d - ic * m.c;
                this.ashearX = 0;
                this.ascaleX = Math.sqrt(ra * ra + rc * rc);
                if (this.ascaleX > 0.0001) {
                    var det = ra * rd - rb * rc;
                    this.ascaleY = det / this.ascaleX;
                    this.ashearY = Math.atan2(ra * rb + rc * rd, det) * core.MathUtils.radDeg;
                    this.arotation = Math.atan2(rc, ra) * core.MathUtils.radDeg;
                }
                else {
                    this.ascaleX = 0;
                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);
                    this.ashearY = 0;
                    this.arotation = 90 - Math.atan2(rd, rb) * core.MathUtils.radDeg;
                }
            };
            Bone.prototype.worldToLocal = function (world) {
                var m = this.matrix;
                var a = m.a, b = m.c, c = m.b, d = m.d;
                var invDet = 1 / (a * d - b * c);
                var x = world.x - m.tx, y = world.y - m.ty;
                world.x = (x * d * invDet - y * b * invDet);
                world.y = (y * a * invDet - x * c * invDet);
                return world;
            };
            Bone.prototype.localToWorld = function (local) {
                var m = this.matrix;
                var x = local.x, y = local.y;
                local.x = x * m.a + y * m.c + m.tx;
                local.y = x * m.b + y * m.d + m.ty;
                return local;
            };
            Bone.prototype.worldToLocalRotation = function (worldRotation) {
                var sin = core.MathUtils.sinDeg(worldRotation), cos = core.MathUtils.cosDeg(worldRotation);
                var mat = this.matrix;
                return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * core.MathUtils.radDeg;
            };
            Bone.prototype.localToWorldRotation = function (localRotation) {
                var sin = core.MathUtils.sinDeg(localRotation), cos = core.MathUtils.cosDeg(localRotation);
                var mat = this.matrix;
                return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * core.MathUtils.radDeg;
            };
            Bone.prototype.rotateWorld = function (degrees) {
                var mat = this.matrix;
                var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
                var cos = core.MathUtils.cosDeg(degrees), sin = core.MathUtils.sinDeg(degrees);
                mat.a = cos * a - sin * c;
                mat.c = cos * b - sin * d;
                mat.b = sin * a + cos * c;
                mat.d = sin * b + cos * d;
                this.appliedValid = false;
            };
            Bone.yDown = false;
            return Bone;
        }());
        core.Bone = Bone;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var BoneData = (function () {
            function BoneData(index, name, parent) {
                this.x = 0;
                this.y = 0;
                this.rotation = 0;
                this.scaleX = 1;
                this.scaleY = 1;
                this.shearX = 0;
                this.shearY = 0;
                this.transformMode = TransformMode.Normal;
                if (index < 0)
                    throw new Error("index must be >= 0.");
                if (name == null)
                    throw new Error("name cannot be null.");
                this.index = index;
                this.name = name;
                this.parent = parent;
            }
            return BoneData;
        }());
        core.BoneData = BoneData;
        var TransformMode;
        (function (TransformMode) {
            TransformMode[TransformMode["Normal"] = 0] = "Normal";
            TransformMode[TransformMode["OnlyTranslation"] = 1] = "OnlyTranslation";
            TransformMode[TransformMode["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
            TransformMode[TransformMode["NoScale"] = 3] = "NoScale";
            TransformMode[TransformMode["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
        })(TransformMode = core.TransformMode || (core.TransformMode = {}));
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Event = (function () {
            function Event(time, data) {
                if (data == null)
                    throw new Error("data cannot be null.");
                this.time = time;
                this.data = data;
            }
            return Event;
        }());
        core.Event = Event;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var EventData = (function () {
            function EventData(name) {
                this.name = name;
            }
            return EventData;
        }());
        core.EventData = EventData;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var IkConstraint = (function () {
            function IkConstraint(data, skeleton) {
                this.mix = 1;
                this.bendDirection = 0;
                if (data == null)
                    throw new Error("data cannot be null.");
                if (skeleton == null)
                    throw new Error("skeleton cannot be null.");
                this.data = data;
                this.mix = data.mix;
                this.bendDirection = data.bendDirection;
                this.bones = new Array();
                for (var i = 0; i < data.bones.length; i++)
                    this.bones.push(skeleton.findBone(data.bones[i].name));
                this.target = skeleton.findBone(data.target.name);
            }
            IkConstraint.prototype.getOrder = function () {
                return this.data.order;
            };
            IkConstraint.prototype.apply = function () {
                this.update();
            };
            IkConstraint.prototype.update = function () {
                var target = this.target;
                var bones = this.bones;
                switch (bones.length) {
                    case 1:
                        this.apply1(bones[0], target.worldX, target.worldY, this.mix);
                        break;
                    case 2:
                        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);
                        break;
                }
            };
            IkConstraint.prototype.apply1 = function (bone, targetX, targetY, alpha) {
                if (!bone.appliedValid)
                    bone.updateAppliedTransform();
                var p = bone.parent.matrix;
                var id = 1 / (p.a * p.d - p.b * p.c);
                var x = targetX - p.tx, y = targetY - p.ty;
                var tx = (x * p.d - y * p.c) * id - bone.ax, ty = (y * p.a - x * p.b) * id - bone.ay;
                var rotationIK = Math.atan2(ty, tx) * core.MathUtils.radDeg - bone.ashearX - bone.arotation;
                if (bone.ascaleX < 0)
                    rotationIK += 180;
                if (rotationIK > 180)
                    rotationIK -= 360;
                else if (rotationIK < -180)
                    rotationIK += 360;
                bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY);
            };
            IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, alpha) {
                if (alpha == 0) {
                    child.updateWorldTransform();
                    return;
                }
                if (!parent.appliedValid)
                    parent.updateAppliedTransform();
                if (!child.appliedValid)
                    child.updateAppliedTransform();
                var px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;
                var pmat = parent.matrix;
                var os1 = 0, os2 = 0, s2 = 0;
                if (psx < 0) {
                    psx = -psx;
                    os1 = 180;
                    s2 = -1;
                }
                else {
                    os1 = 0;
                    s2 = 1;
                }
                if (psy < 0) {
                    psy = -psy;
                    s2 = -s2;
                }
                if (csx < 0) {
                    csx = -csx;
                    os2 = 180;
                }
                else
                    os2 = 0;
                var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;
                var u = Math.abs(psx - psy) <= 0.0001;
                if (!u) {
                    cy = 0;
                    cwx = a * cx + pmat.tx;
                    cwy = c * cx + pmat.ty;
                }
                else {
                    cy = child.ay;
                    cwx = a * cx + b * cy + pmat.tx;
                    cwy = c * cx + d * cy + pmat.ty;
                }
                var pp = parent.parent.matrix;
                a = pp.a;
                b = pp.c;
                c = pp.b;
                d = pp.d;
                var id = 1 / (a * d - b * c), x = targetX - pp.tx, y = targetY - pp.ty;
                var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;
                x = cwx - pp.tx;
                y = cwy - pp.ty;
                var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;
                var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;
                outer: if (u) {
                    l2 *= psx;
                    var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                    if (cos < -1)
                        cos = -1;
                    else if (cos > 1)
                        cos = 1;
                    a2 = Math.acos(cos) * bendDir;
                    a = l1 + l2 * cos;
                    b = l2 * Math.sin(a2);
                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
                }
                else {
                    a = psx * l2;
                    b = psy * l2;
                    var aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);
                    c = bb * l1 * l1 + aa * dd - aa * bb;
                    var c1 = -2 * bb * l1, c2 = bb - aa;
                    d = c1 * c1 - 4 * c2 * c;
                    if (d >= 0) {
                        var q = Math.sqrt(d);
                        if (c1 < 0)
                            q = -q;
                        q = -(c1 + q) / 2;
                        var r0 = q / c2, r1 = c / q;
                        var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                        if (r * r <= dd) {
                            y = Math.sqrt(dd - r * r) * bendDir;
                            a1 = ta - Math.atan2(y, r);
                            a2 = Math.atan2(y / psy, (r - l1) / psx);
                            break outer;
                        }
                    }
                    var minAngle = core.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;
                    var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;
                    c = -a * l1 / (aa - bb);
                    if (c >= -1 && c <= 1) {
                        c = Math.acos(c);
                        x = a * Math.cos(c) + l1;
                        y = b * Math.sin(c);
                        d = x * x + y * y;
                        if (d < minDist) {
                            minAngle = c;
                            minDist = d;
                            minX = x;
                            minY = y;
                        }
                        if (d > maxDist) {
                            maxAngle = c;
                            maxDist = d;
                            maxX = x;
                            maxY = y;
                        }
                    }
                    if (dd <= (minDist + maxDist) / 2) {
                        a1 = ta - Math.atan2(minY * bendDir, minX);
                        a2 = minAngle * bendDir;
                    }
                    else {
                        a1 = ta - Math.atan2(maxY * bendDir, maxX);
                        a2 = maxAngle * bendDir;
                    }
                }
                var os = Math.atan2(cy, cx) * s2;
                var rotation = parent.arotation;
                a1 = (a1 - os) * core.MathUtils.radDeg + os1 - rotation;
                if (a1 > 180)
                    a1 -= 360;
                else if (a1 < -180)
                    a1 += 360;
                parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);
                rotation = child.arotation;
                a2 = ((a2 + os) * core.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
                if (a2 > 180)
                    a2 -= 360;
                else if (a2 < -180)
                    a2 += 360;
                child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
            };
            return IkConstraint;
        }());
        core.IkConstraint = IkConstraint;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var IkConstraintData = (function () {
            function IkConstraintData(name) {
                this.order = 0;
                this.bones = new Array();
                this.bendDirection = 1;
                this.mix = 1;
                this.name = name;
            }
            return IkConstraintData;
        }());
        core.IkConstraintData = IkConstraintData;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var PathConstraint = (function () {
            function PathConstraint(data, skeleton) {
                this.position = 0;
                this.spacing = 0;
                this.rotateMix = 0;
                this.translateMix = 0;
                this.spaces = new Array();
                this.positions = new Array();
                this.world = new Array();
                this.curves = new Array();
                this.lengths = new Array();
                this.segments = new Array();
                if (data == null)
                    throw new Error("data cannot be null.");
                if (skeleton == null)
                    throw new Error("skeleton cannot be null.");
                this.data = data;
                this.bones = new Array();
                for (var i = 0, n = data.bones.length; i < n; i++)
                    this.bones.push(skeleton.findBone(data.bones[i].name));
                this.target = skeleton.findSlot(data.target.name);
                this.position = data.position;
                this.spacing = data.spacing;
                this.rotateMix = data.rotateMix;
                this.translateMix = data.translateMix;
            }
            PathConstraint.prototype.apply = function () {
                this.update();
            };
            PathConstraint.prototype.update = function () {
                var attachment = this.target.getAttachment();
                if (!(attachment instanceof core.PathAttachment))
                    return;
                var rotateMix = this.rotateMix, translateMix = this.translateMix;
                var translate = translateMix > 0, rotate = rotateMix > 0;
                if (!translate && !rotate)
                    return;
                var data = this.data;
                var spacingMode = data.spacingMode;
                var lengthSpacing = spacingMode == core.SpacingMode.Length;
                var rotateMode = data.rotateMode;
                var tangents = rotateMode == core.RotateMode.Tangent, scale = rotateMode == core.RotateMode.ChainScale;
                var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
                var bones = this.bones;
                var spaces = core.Utils.setArraySize(this.spaces, spacesCount), lengths = null;
                var spacing = this.spacing;
                if (scale || lengthSpacing) {
                    if (scale)
                        lengths = core.Utils.setArraySize(this.lengths, boneCount);
                    for (var i = 0, n = spacesCount - 1; i < n;) {
                        var bone = bones[i];
                        var setupLength = bone.data.length, x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;
                        var length_1 = Math.sqrt(x * x + y * y);
                        if (scale)
                            lengths[i] = length_1;
                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;
                    }
                }
                else {
                    for (var i = 1; i < spacesCount; i++)
                        spaces[i] = spacing;
                }
                var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == core.PositionMode.Percent, spacingMode == core.SpacingMode.Percent);
                var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
                var tip = false;
                if (offsetRotation == 0)
                    tip = rotateMode == core.RotateMode.Chain;
                else {
                    tip = false;
                    var p = this.target.bone.matrix;
                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;
                }
                for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
                    var bone = bones[i];
                    var mat = bone.matrix;
                    mat.tx += (boneX - mat.tx) * translateMix;
                    mat.ty += (boneY - mat.ty) * translateMix;
                    var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;
                    if (scale) {
                        var length_2 = lengths[i];
                        if (length_2 != 0) {
                            var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
                            mat.a *= s;
                            mat.b *= s;
                        }
                    }
                    boneX = x;
                    boneY = y;
                    if (rotate) {
                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;
                        if (tangents)
                            r = positions[p - 1];
                        else if (spaces[i + 1] == 0)
                            r = positions[p + 2];
                        else
                            r = Math.atan2(dy, dx);
                        r -= Math.atan2(c, a);
                        if (tip) {
                            cos = Math.cos(r);
                            sin = Math.sin(r);
                            var length_3 = bone.data.length;
                            boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;
                            boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;
                        }
                        else {
                            r += offsetRotation;
                        }
                        if (r > core.MathUtils.PI)
                            r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI)
                            r += core.MathUtils.PI2;
                        r *= rotateMix;
                        cos = Math.cos(r);
                        sin = Math.sin(r);
                        mat.a = cos * a - sin * c;
                        mat.c = cos * b - sin * d;
                        mat.b = sin * a + cos * c;
                        mat.d = sin * b + cos * d;
                    }
                    bone.appliedValid = false;
                }
            };
            PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {
                var target = this.target;
                var position = this.position;
                var spaces = this.spaces, out = core.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;
                var closed = path.closed;
                var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;
                if (!path.constantSpeed) {
                    var lengths = path.lengths;
                    curveCount -= closed ? 1 : 2;
                    var pathLength_1 = lengths[curveCount];
                    if (percentPosition)
                        position *= pathLength_1;
                    if (percentSpacing) {
                        for (var i = 0; i < spacesCount; i++)
                            spaces[i] *= pathLength_1;
                    }
                    world = core.Utils.setArraySize(this.world, 8);
                    for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
                        var space = spaces[i];
                        position += space;
                        var p = position;
                        if (closed) {
                            p %= pathLength_1;
                            if (p < 0)
                                p += pathLength_1;
                            curve = 0;
                        }
                        else if (p < 0) {
                            if (prevCurve != PathConstraint.BEFORE) {
                                prevCurve = PathConstraint.BEFORE;
                                path.computeWorldVertices(target, 2, 4, world, 0, 2);
                            }
                            this.addBeforePosition(p, world, 0, out, o);
                            continue;
                        }
                        else if (p > pathLength_1) {
                            if (prevCurve != PathConstraint.AFTER) {
                                prevCurve = PathConstraint.AFTER;
                                path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
                            }
                            this.addAfterPosition(p - pathLength_1, world, 0, out, o);
                            continue;
                        }
                        for (;; curve++) {
                            var length_4 = lengths[curve];
                            if (p > length_4)
                                continue;
                            if (curve == 0)
                                p /= length_4;
                            else {
                                var prev = lengths[curve - 1];
                                p = (p - prev) / (length_4 - prev);
                            }
                            break;
                        }
                        if (curve != prevCurve) {
                            prevCurve = curve;
                            if (closed && curve == curveCount) {
                                path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
                                path.computeWorldVertices(target, 0, 4, world, 4, 2);
                            }
                            else
                                path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
                        }
                        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));
                    }
                    return out;
                }
                if (closed) {
                    verticesLength += 2;
                    world = core.Utils.setArraySize(this.world, verticesLength);
                    path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
                    path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
                    world[verticesLength - 2] = world[0];
                    world[verticesLength - 1] = world[1];
                }
                else {
                    curveCount--;
                    verticesLength -= 4;
                    world = core.Utils.setArraySize(this.world, verticesLength);
                    path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
                }
                var curves = core.Utils.setArraySize(this.curves, curveCount);
                var pathLength = 0;
                var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
                var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
                for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
                    cx1 = world[w];
                    cy1 = world[w + 1];
                    cx2 = world[w + 2];
                    cy2 = world[w + 3];
                    x2 = world[w + 4];
                    y2 = world[w + 5];
                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    curves[i] = pathLength;
                    x1 = x2;
                    y1 = y2;
                }
                if (percentPosition)
                    position *= pathLength;
                if (percentSpacing) {
                    for (var i = 0; i < spacesCount; i++)
                        spaces[i] *= pathLength;
                }
                var segments = this.segments;
                var curveLength = 0;
                for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
                    var space = spaces[i];
                    position += space;
                    var p = position;
                    if (closed) {
                        p %= pathLength;
                        if (p < 0)
                            p += pathLength;
                        curve = 0;
                    }
                    else if (p < 0) {
                        this.addBeforePosition(p, world, 0, out, o);
                        continue;
                    }
                    else if (p > pathLength) {
                        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
                        continue;
                    }
                    for (;; curve++) {
                        var length_5 = curves[curve];
                        if (p > length_5)
                            continue;
                        if (curve == 0)
                            p /= length_5;
                        else {
                            var prev = curves[curve - 1];
                            p = (p - prev) / (length_5 - prev);
                        }
                        break;
                    }
                    if (curve != prevCurve) {
                        prevCurve = curve;
                        var ii = curve * 6;
                        x1 = world[ii];
                        y1 = world[ii + 1];
                        cx1 = world[ii + 2];
                        cy1 = world[ii + 3];
                        cx2 = world[ii + 4];
                        cy2 = world[ii + 5];
                        x2 = world[ii + 6];
                        y2 = world[ii + 7];
                        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
                        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
                        ddfx = tmpx * 2 + dddfx;
                        ddfy = tmpy * 2 + dddfy;
                        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
                        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[0] = curveLength;
                        for (ii = 1; ii < 8; ii++) {
                            dfx += ddfx;
                            dfy += ddfy;
                            ddfx += dddfx;
                            ddfy += dddfy;
                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                            segments[ii] = curveLength;
                        }
                        dfx += ddfx;
                        dfy += ddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[8] = curveLength;
                        dfx += ddfx + dddfx;
                        dfy += ddfy + dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[9] = curveLength;
                        segment = 0;
                    }
                    p *= curveLength;
                    for (;; segment++) {
                        var length_6 = segments[segment];
                        if (p > length_6)
                            continue;
                        if (segment == 0)
                            p /= length_6;
                        else {
                            var prev = segments[segment - 1];
                            p = segment + (p - prev) / (length_6 - prev);
                        }
                        break;
                    }
                    this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));
                }
                return out;
            };
            PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {
                var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
                out[o] = x1 + p * Math.cos(r);
                out[o + 1] = y1 + p * Math.sin(r);
                out[o + 2] = r;
            };
            PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {
                var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
                out[o] = x1 + p * Math.cos(r);
                out[o + 1] = y1 + p * Math.sin(r);
                out[o + 2] = r;
            };
            PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
                if (p == 0 || isNaN(p))
                    p = 0.0001;
                var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
                var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
                var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
                out[o] = x;
                out[o + 1] = y;
                if (tangents)
                    out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
            };
            PathConstraint.prototype.getOrder = function () {
                return this.data.order;
            };
            PathConstraint.NONE = -1;
            PathConstraint.BEFORE = -2;
            PathConstraint.AFTER = -3;
            return PathConstraint;
        }());
        core.PathConstraint = PathConstraint;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var PathConstraintData = (function () {
            function PathConstraintData(name) {
                this.order = 0;
                this.bones = new Array();
                this.name = name;
            }
            return PathConstraintData;
        }());
        core.PathConstraintData = PathConstraintData;
        var PositionMode;
        (function (PositionMode) {
            PositionMode[PositionMode["Fixed"] = 0] = "Fixed";
            PositionMode[PositionMode["Percent"] = 1] = "Percent";
        })(PositionMode = core.PositionMode || (core.PositionMode = {}));
        var SpacingMode;
        (function (SpacingMode) {
            SpacingMode[SpacingMode["Length"] = 0] = "Length";
            SpacingMode[SpacingMode["Fixed"] = 1] = "Fixed";
            SpacingMode[SpacingMode["Percent"] = 2] = "Percent";
        })(SpacingMode = core.SpacingMode || (core.SpacingMode = {}));
        var RotateMode;
        (function (RotateMode) {
            RotateMode[RotateMode["Tangent"] = 0] = "Tangent";
            RotateMode[RotateMode["Chain"] = 1] = "Chain";
            RotateMode[RotateMode["ChainScale"] = 2] = "ChainScale";
        })(RotateMode = core.RotateMode || (core.RotateMode = {}));
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Skeleton = (function () {
            function Skeleton(data) {
                this._updateCache = new Array();
                this.updateCacheReset = new Array();
                this.time = 0;
                this.flipX = false;
                this.flipY = false;
                this.x = 0;
                this.y = 0;
                if (data == null)
                    throw new Error("data cannot be null.");
                this.data = data;
                this.bones = new Array();
                for (var i = 0; i < data.bones.length; i++) {
                    var boneData = data.bones[i];
                    var bone = void 0;
                    if (boneData.parent == null)
                        bone = new core.Bone(boneData, this, null);
                    else {
                        var parent_1 = this.bones[boneData.parent.index];
                        bone = new core.Bone(boneData, this, parent_1);
                        parent_1.children.push(bone);
                    }
                    this.bones.push(bone);
                }
                this.slots = new Array();
                this.drawOrder = new Array();
                for (var i = 0; i < data.slots.length; i++) {
                    var slotData = data.slots[i];
                    var bone = this.bones[slotData.boneData.index];
                    var slot = new core.Slot(slotData, bone);
                    this.slots.push(slot);
                    this.drawOrder.push(slot);
                }
                this.ikConstraints = new Array();
                for (var i = 0; i < data.ikConstraints.length; i++) {
                    var ikConstraintData = data.ikConstraints[i];
                    this.ikConstraints.push(new core.IkConstraint(ikConstraintData, this));
                }
                this.transformConstraints = new Array();
                for (var i = 0; i < data.transformConstraints.length; i++) {
                    var transformConstraintData = data.transformConstraints[i];
                    this.transformConstraints.push(new core.TransformConstraint(transformConstraintData, this));
                }
                this.pathConstraints = new Array();
                for (var i = 0; i < data.pathConstraints.length; i++) {
                    var pathConstraintData = data.pathConstraints[i];
                    this.pathConstraints.push(new core.PathConstraint(pathConstraintData, this));
                }
                this.color = new core.Color(1, 1, 1, 1);
                this.updateCache();
            }
            Skeleton.prototype.updateCache = function () {
                var updateCache = this._updateCache;
                updateCache.length = 0;
                this.updateCacheReset.length = 0;
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++)
                    bones[i].sorted = false;
                var ikConstraints = this.ikConstraints;
                var transformConstraints = this.transformConstraints;
                var pathConstraints = this.pathConstraints;
                var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
                var constraintCount = ikCount + transformCount + pathCount;
                outer: for (var i = 0; i < constraintCount; i++) {
                    for (var ii = 0; ii < ikCount; ii++) {
                        var constraint = ikConstraints[ii];
                        if (constraint.data.order == i) {
                            this.sortIkConstraint(constraint);
                            continue outer;
                        }
                    }
                    for (var ii = 0; ii < transformCount; ii++) {
                        var constraint = transformConstraints[ii];
                        if (constraint.data.order == i) {
                            this.sortTransformConstraint(constraint);
                            continue outer;
                        }
                    }
                    for (var ii = 0; ii < pathCount; ii++) {
                        var constraint = pathConstraints[ii];
                        if (constraint.data.order == i) {
                            this.sortPathConstraint(constraint);
                            continue outer;
                        }
                    }
                }
                for (var i = 0, n = bones.length; i < n; i++)
                    this.sortBone(bones[i]);
            };
            Skeleton.prototype.sortIkConstraint = function (constraint) {
                var target = constraint.target;
                this.sortBone(target);
                var constrained = constraint.bones;
                var parent = constrained[0];
                this.sortBone(parent);
                if (constrained.length > 1) {
                    var child = constrained[constrained.length - 1];
                    if (!(this._updateCache.indexOf(child) > -1))
                        this.updateCacheReset.push(child);
                }
                this._updateCache.push(constraint);
                this.sortReset(parent.children);
                constrained[constrained.length - 1].sorted = true;
            };
            Skeleton.prototype.sortPathConstraint = function (constraint) {
                var slot = constraint.target;
                var slotIndex = slot.data.index;
                var slotBone = slot.bone;
                if (this.skin != null)
                    this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
                if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
                    this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
                for (var i = 0, n = this.data.skins.length; i < n; i++)
                    this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
                var attachment = slot.getAttachment();
                if (attachment instanceof core.PathAttachment)
                    this.sortPathConstraintAttachmentWith(attachment, slotBone);
                var constrained = constraint.bones;
                var boneCount = constrained.length;
                for (var i = 0; i < boneCount; i++)
                    this.sortBone(constrained[i]);
                this._updateCache.push(constraint);
                for (var i = 0; i < boneCount; i++)
                    this.sortReset(constrained[i].children);
                for (var i = 0; i < boneCount; i++)
                    constrained[i].sorted = true;
            };
            Skeleton.prototype.sortTransformConstraint = function (constraint) {
                this.sortBone(constraint.target);
                var constrained = constraint.bones;
                var boneCount = constrained.length;
                if (constraint.data.local) {
                    for (var i = 0; i < boneCount; i++) {
                        var child = constrained[i];
                        this.sortBone(child.parent);
                        if (!(this._updateCache.indexOf(child) > -1))
                            this.updateCacheReset.push(child);
                    }
                }
                else {
                    for (var i = 0; i < boneCount; i++) {
                        this.sortBone(constrained[i]);
                    }
                }
                this._updateCache.push(constraint);
                for (var ii = 0; ii < boneCount; ii++)
                    this.sortReset(constrained[ii].children);
                for (var ii = 0; ii < boneCount; ii++)
                    constrained[ii].sorted = true;
            };
            Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {
                var attachments = skin.attachments[slotIndex];
                if (!attachments)
                    return;
                for (var key in attachments) {
                    this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
                }
            };
            Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {
                if (!(attachment instanceof core.PathAttachment))
                    return;
                var pathBones = attachment.bones;
                if (pathBones == null)
                    this.sortBone(slotBone);
                else {
                    var bones = this.bones;
                    var i = 0;
                    while (i < pathBones.length) {
                        var boneCount = pathBones[i++];
                        for (var n = i + boneCount; i < n; i++) {
                            var boneIndex = pathBones[i];
                            this.sortBone(bones[boneIndex]);
                        }
                    }
                }
            };
            Skeleton.prototype.sortBone = function (bone) {
                if (bone.sorted)
                    return;
                var parent = bone.parent;
                if (parent != null)
                    this.sortBone(parent);
                bone.sorted = true;
                this._updateCache.push(bone);
            };
            Skeleton.prototype.sortReset = function (bones) {
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (bone.sorted)
                        this.sortReset(bone.children);
                    bone.sorted = false;
                }
            };
            Skeleton.prototype.updateWorldTransform = function () {
                var updateCacheReset = this.updateCacheReset;
                for (var i = 0, n = updateCacheReset.length; i < n; i++) {
                    var bone = updateCacheReset[i];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY = bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                    bone.appliedValid = true;
                }
                var updateCache = this._updateCache;
                for (var i = 0, n = updateCache.length; i < n; i++)
                    updateCache[i].update();
            };
            Skeleton.prototype.setToSetupPose = function () {
                this.setBonesToSetupPose();
                this.setSlotsToSetupPose();
            };
            Skeleton.prototype.setBonesToSetupPose = function () {
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++)
                    bones[i].setToSetupPose();
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.length; i < n; i++) {
                    var constraint = ikConstraints[i];
                    constraint.bendDirection = constraint.data.bendDirection;
                    constraint.mix = constraint.data.mix;
                }
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.length; i < n; i++) {
                    var constraint = transformConstraints[i];
                    var data = constraint.data;
                    constraint.rotateMix = data.rotateMix;
                    constraint.translateMix = data.translateMix;
                    constraint.scaleMix = data.scaleMix;
                    constraint.shearMix = data.shearMix;
                }
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint = pathConstraints[i];
                    var data = constraint.data;
                    constraint.position = data.position;
                    constraint.spacing = data.spacing;
                    constraint.rotateMix = data.rotateMix;
                    constraint.translateMix = data.translateMix;
                }
            };
            Skeleton.prototype.setSlotsToSetupPose = function () {
                var slots = this.slots;
                core.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
                for (var i = 0, n = slots.length; i < n; i++)
                    slots[i].setToSetupPose();
            };
            Skeleton.prototype.getRootBone = function () {
                if (this.bones.length == 0)
                    return null;
                return this.bones[0];
            };
            Skeleton.prototype.findBone = function (boneName) {
                if (boneName == null)
                    throw new Error("boneName cannot be null.");
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (bone.data.name == boneName)
                        return bone;
                }
                return null;
            };
            Skeleton.prototype.findBoneIndex = function (boneName) {
                if (boneName == null)
                    throw new Error("boneName cannot be null.");
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++)
                    if (bones[i].data.name == boneName)
                        return i;
                return -1;
            };
            Skeleton.prototype.findSlot = function (slotName) {
                if (slotName == null)
                    throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];
                    if (slot.data.name == slotName)
                        return slot;
                }
                return null;
            };
            Skeleton.prototype.findSlotIndex = function (slotName) {
                if (slotName == null)
                    throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++)
                    if (slots[i].data.name == slotName)
                        return i;
                return -1;
            };
            Skeleton.prototype.setSkinByName = function (skinName) {
                var skin = this.data.findSkin(skinName);
                if (skin == null)
                    throw new Error("Skin not found: " + skinName);
                this.setSkin(skin);
            };
            Skeleton.prototype.setSkin = function (newSkin) {
                if (newSkin != null) {
                    if (this.skin != null)
                        newSkin.attachAll(this, this.skin);
                    else {
                        var slots = this.slots;
                        for (var i = 0, n = slots.length; i < n; i++) {
                            var slot = slots[i];
                            var name_1 = slot.data.attachmentName;
                            if (name_1 != null) {
                                var attachment = newSkin.getAttachment(i, name_1);
                                if (attachment != null)
                                    slot.setAttachment(attachment);
                            }
                        }
                    }
                }
                this.skin = newSkin;
            };
            Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {
                return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
            };
            Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {
                if (attachmentName == null)
                    throw new Error("attachmentName cannot be null.");
                if (this.skin != null) {
                    var attachment = this.skin.getAttachment(slotIndex, attachmentName);
                    if (attachment != null)
                        return attachment;
                }
                if (this.data.defaultSkin != null)
                    return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
                return null;
            };
            Skeleton.prototype.setAttachment = function (slotName, attachmentName) {
                if (slotName == null)
                    throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];
                    if (slot.data.name == slotName) {
                        var attachment = null;
                        if (attachmentName != null) {
                            attachment = this.getAttachment(i, attachmentName);
                            if (attachment == null)
                                throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
                        }
                        slot.setAttachment(attachment);
                        return;
                    }
                }
                throw new Error("Slot not found: " + slotName);
            };
            Skeleton.prototype.findIkConstraint = function (constraintName) {
                if (constraintName == null)
                    throw new Error("constraintName cannot be null.");
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.length; i < n; i++) {
                    var ikConstraint = ikConstraints[i];
                    if (ikConstraint.data.name == constraintName)
                        return ikConstraint;
                }
                return null;
            };
            Skeleton.prototype.findTransformConstraint = function (constraintName) {
                if (constraintName == null)
                    throw new Error("constraintName cannot be null.");
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.length; i < n; i++) {
                    var constraint = transformConstraints[i];
                    if (constraint.data.name == constraintName)
                        return constraint;
                }
                return null;
            };
            Skeleton.prototype.findPathConstraint = function (constraintName) {
                if (constraintName == null)
                    throw new Error("constraintName cannot be null.");
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint = pathConstraints[i];
                    if (constraint.data.name == constraintName)
                        return constraint;
                }
                return null;
            };
            Skeleton.prototype.getBounds = function (offset, size, temp) {
                if (offset == null)
                    throw new Error("offset cannot be null.");
                if (size == null)
                    throw new Error("size cannot be null.");
                var drawOrder = this.drawOrder;
                var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
                for (var i = 0, n = drawOrder.length; i < n; i++) {
                    var slot = drawOrder[i];
                    var verticesLength = 0;
                    var vertices = null;
                    var attachment = slot.getAttachment();
                    if (attachment instanceof core.RegionAttachment) {
                        verticesLength = 8;
                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);
                        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
                    }
                    else if (attachment instanceof core.MeshAttachment) {
                        var mesh = attachment;
                        verticesLength = mesh.worldVerticesLength;
                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);
                        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
                    }
                    if (vertices != null) {
                        for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
                            var x = vertices[ii], y = vertices[ii + 1];
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                offset.set(minX, minY);
                size.set(maxX - minX, maxY - minY);
            };
            Skeleton.prototype.update = function (delta) {
                this.time += delta;
            };
            return Skeleton;
        }());
        core.Skeleton = Skeleton;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var SkeletonBounds = (function () {
            function SkeletonBounds() {
                this.minX = 0;
                this.minY = 0;
                this.maxX = 0;
                this.maxY = 0;
                this.boundingBoxes = new Array();
                this.polygons = new Array();
                this.polygonPool = new core.Pool(function () {
                    return core.Utils.newFloatArray(16);
                });
            }
            SkeletonBounds.prototype.update = function (skeleton, updateAabb) {
                if (skeleton == null)
                    throw new Error("skeleton cannot be null.");
                var boundingBoxes = this.boundingBoxes;
                var polygons = this.polygons;
                var polygonPool = this.polygonPool;
                var slots = skeleton.slots;
                var slotCount = slots.length;
                boundingBoxes.length = 0;
                polygonPool.freeAll(polygons);
                polygons.length = 0;
                for (var i = 0; i < slotCount; i++) {
                    var slot = slots[i];
                    var attachment = slot.getAttachment();
                    if (attachment instanceof core.BoundingBoxAttachment) {
                        var boundingBox = attachment;
                        boundingBoxes.push(boundingBox);
                        var polygon = polygonPool.obtain();
                        if (polygon.length != boundingBox.worldVerticesLength) {
                            polygon = core.Utils.newFloatArray(boundingBox.worldVerticesLength);
                        }
                        polygons.push(polygon);
                        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
                    }
                }
                if (updateAabb) {
                    this.aabbCompute();
                }
                else {
                    this.minX = Number.POSITIVE_INFINITY;
                    this.minY = Number.POSITIVE_INFINITY;
                    this.maxX = Number.NEGATIVE_INFINITY;
                    this.maxY = Number.NEGATIVE_INFINITY;
                }
            };
            SkeletonBounds.prototype.aabbCompute = function () {
                var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
                var polygons = this.polygons;
                for (var i = 0, n = polygons.length; i < n; i++) {
                    var polygon = polygons[i];
                    var vertices = polygon;
                    for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {
                        var x = vertices[ii];
                        var y = vertices[ii + 1];
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
                this.minX = minX;
                this.minY = minY;
                this.maxX = maxX;
                this.maxY = maxY;
            };
            SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {
                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
            };
            SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {
                var minX = this.minX;
                var minY = this.minY;
                var maxX = this.maxX;
                var maxY = this.maxY;
                if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))
                    return false;
                var m = (y2 - y1) / (x2 - x1);
                var y = m * (minX - x1) + y1;
                if (y > minY && y < maxY)
                    return true;
                y = m * (maxX - x1) + y1;
                if (y > minY && y < maxY)
                    return true;
                var x = (minY - y1) / m + x1;
                if (x > minX && x < maxX)
                    return true;
                x = (maxY - y1) / m + x1;
                if (x > minX && x < maxX)
                    return true;
                return false;
            };
            SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {
                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
            };
            SkeletonBounds.prototype.containsPoint = function (x, y) {
                var polygons = this.polygons;
                for (var i = 0, n = polygons.length; i < n; i++)
                    if (this.containsPointPolygon(polygons[i], x, y))
                        return this.boundingBoxes[i];
                return null;
            };
            SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {
                var vertices = polygon;
                var nn = polygon.length;
                var prevIndex = nn - 2;
                var inside = false;
                for (var ii = 0; ii < nn; ii += 2) {
                    var vertexY = vertices[ii + 1];
                    var prevY = vertices[prevIndex + 1];
                    if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
                        var vertexX = vertices[ii];
                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
                            inside = !inside;
                    }
                    prevIndex = ii;
                }
                return inside;
            };
            SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {
                var polygons = this.polygons;
                for (var i = 0, n = polygons.length; i < n; i++)
                    if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))
                        return this.boundingBoxes[i];
                return null;
            };
            SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {
                var vertices = polygon;
                var nn = polygon.length;
                var width12 = x1 - x2, height12 = y1 - y2;
                var det1 = x1 * y2 - y1 * x2;
                var x3 = vertices[nn - 2], y3 = vertices[nn - 1];
                for (var ii = 0; ii < nn; ii += 2) {
                    var x4 = vertices[ii], y4 = vertices[ii + 1];
                    var det2 = x3 * y4 - y3 * x4;
                    var width34 = x3 - x4, height34 = y3 - y4;
                    var det3 = width12 * height34 - height12 * width34;
                    var x = (det1 * width34 - width12 * det2) / det3;
                    if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {
                        var y = (det1 * height34 - height12 * det2) / det3;
                        if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))
                            return true;
                    }
                    x3 = x4;
                    y3 = y4;
                }
                return false;
            };
            SkeletonBounds.prototype.getPolygon = function (boundingBox) {
                if (boundingBox == null)
                    throw new Error("boundingBox cannot be null.");
                var index = this.boundingBoxes.indexOf(boundingBox);
                return index == -1 ? null : this.polygons[index];
            };
            SkeletonBounds.prototype.getWidth = function () {
                return this.maxX - this.minX;
            };
            SkeletonBounds.prototype.getHeight = function () {
                return this.maxY - this.minY;
            };
            return SkeletonBounds;
        }());
        core.SkeletonBounds = SkeletonBounds;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var SkeletonClipping = (function () {
            function SkeletonClipping() {
                this.triangulator = new core.Triangulator();
                this.clippingPolygon = new Array();
                this.clipOutput = new Array();
                this.clippedVertices = new Array();
                this.clippedTriangles = new Array();
                this.scratch = new Array();
            }
            SkeletonClipping.prototype.clipStart = function (slot, clip) {
                if (this.clipAttachment != null)
                    return 0;
                this.clipAttachment = clip;
                var n = clip.worldVerticesLength;
                var vertices = core.Utils.setArraySize(this.clippingPolygon, n);
                clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
                var clippingPolygon = this.clippingPolygon;
                SkeletonClipping.makeClockwise(clippingPolygon);
                var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));
                for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {
                    var polygon = clippingPolygons[i];
                    SkeletonClipping.makeClockwise(polygon);
                    polygon.push(polygon[0]);
                    polygon.push(polygon[1]);
                }
                return clippingPolygons.length;
            };
            SkeletonClipping.prototype.clipEndWithSlot = function (slot) {
                if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)
                    this.clipEnd();
            };
            SkeletonClipping.prototype.clipEnd = function () {
                if (this.clipAttachment == null)
                    return;
                this.clipAttachment = null;
                this.clippingPolygons = null;
                this.clippedVertices.length = 0;
                this.clippedTriangles.length = 0;
                this.clippingPolygon.length = 0;
            };
            SkeletonClipping.prototype.isClipping = function () {
                return this.clipAttachment != null;
            };
            SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {
                var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
                var clippedTriangles = this.clippedTriangles;
                var polygons = this.clippingPolygons;
                var polygonsCount = this.clippingPolygons.length;
                var vertexSize = twoColor ? 12 : 8;
                var index = 0;
                clippedVertices.length = 0;
                clippedTriangles.length = 0;
                outer: for (var i = 0; i < trianglesLength; i += 3) {
                    var vertexOffset = triangles[i] << 1;
                    var x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];
                    var u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];
                    vertexOffset = triangles[i + 1] << 1;
                    var x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];
                    var u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];
                    vertexOffset = triangles[i + 2] << 1;
                    var x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];
                    var u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];
                    for (var p = 0; p < polygonsCount; p++) {
                        var s = clippedVertices.length;
                        if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
                            var clipOutputLength = clipOutput.length;
                            if (clipOutputLength == 0)
                                continue;
                            var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;
                            var d = 1 / (d0 * d2 + d1 * (y1 - y3));
                            var clipOutputCount = clipOutputLength >> 1;
                            var clipOutputItems = this.clipOutput;
                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);
                            for (var ii = 0; ii < clipOutputLength; ii += 2) {
                                var x = clipOutputItems[ii], y = clipOutputItems[ii + 1];
                                clippedVerticesItems[s] = x;
                                clippedVerticesItems[s + 1] = y;
                                clippedVerticesItems[s + 2] = light.r;
                                clippedVerticesItems[s + 3] = light.g;
                                clippedVerticesItems[s + 4] = light.b;
                                clippedVerticesItems[s + 5] = light.a;
                                var c0 = x - x3, c1 = y - y3;
                                var a = (d0 * c0 + d1 * c1) * d;
                                var b = (d4 * c0 + d2 * c1) * d;
                                var c = 1 - a - b;
                                clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;
                                clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;
                                if (twoColor) {
                                    clippedVerticesItems[s + 8] = dark.r;
                                    clippedVerticesItems[s + 9] = dark.g;
                                    clippedVerticesItems[s + 10] = dark.b;
                                    clippedVerticesItems[s + 11] = dark.a;
                                }
                                s += vertexSize;
                            }
                            s = clippedTriangles.length;
                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));
                            clipOutputCount--;
                            for (var ii = 1; ii < clipOutputCount; ii++) {
                                clippedTrianglesItems[s] = index;
                                clippedTrianglesItems[s + 1] = (index + ii);
                                clippedTrianglesItems[s + 2] = (index + ii + 1);
                                s += 3;
                            }
                            index += clipOutputCount + 1;
                        }
                        else {
                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);
                            clippedVerticesItems[s] = x1;
                            clippedVerticesItems[s + 1] = y1;
                            clippedVerticesItems[s + 2] = light.r;
                            clippedVerticesItems[s + 3] = light.g;
                            clippedVerticesItems[s + 4] = light.b;
                            clippedVerticesItems[s + 5] = light.a;
                            if (!twoColor) {
                                clippedVerticesItems[s + 6] = u1;
                                clippedVerticesItems[s + 7] = v1;
                                clippedVerticesItems[s + 8] = x2;
                                clippedVerticesItems[s + 9] = y2;
                                clippedVerticesItems[s + 10] = light.r;
                                clippedVerticesItems[s + 11] = light.g;
                                clippedVerticesItems[s + 12] = light.b;
                                clippedVerticesItems[s + 13] = light.a;
                                clippedVerticesItems[s + 14] = u2;
                                clippedVerticesItems[s + 15] = v2;
                                clippedVerticesItems[s + 16] = x3;
                                clippedVerticesItems[s + 17] = y3;
                                clippedVerticesItems[s + 18] = light.r;
                                clippedVerticesItems[s + 19] = light.g;
                                clippedVerticesItems[s + 20] = light.b;
                                clippedVerticesItems[s + 21] = light.a;
                                clippedVerticesItems[s + 22] = u3;
                                clippedVerticesItems[s + 23] = v3;
                            }
                            else {
                                clippedVerticesItems[s + 6] = u1;
                                clippedVerticesItems[s + 7] = v1;
                                clippedVerticesItems[s + 8] = dark.r;
                                clippedVerticesItems[s + 9] = dark.g;
                                clippedVerticesItems[s + 10] = dark.b;
                                clippedVerticesItems[s + 11] = dark.a;
                                clippedVerticesItems[s + 12] = x2;
                                clippedVerticesItems[s + 13] = y2;
                                clippedVerticesItems[s + 14] = light.r;
                                clippedVerticesItems[s + 15] = light.g;
                                clippedVerticesItems[s + 16] = light.b;
                                clippedVerticesItems[s + 17] = light.a;
                                clippedVerticesItems[s + 18] = u2;
                                clippedVerticesItems[s + 19] = v2;
                                clippedVerticesItems[s + 20] = dark.r;
                                clippedVerticesItems[s + 21] = dark.g;
                                clippedVerticesItems[s + 22] = dark.b;
                                clippedVerticesItems[s + 23] = dark.a;
                                clippedVerticesItems[s + 24] = x3;
                                clippedVerticesItems[s + 25] = y3;
                                clippedVerticesItems[s + 26] = light.r;
                                clippedVerticesItems[s + 27] = light.g;
                                clippedVerticesItems[s + 28] = light.b;
                                clippedVerticesItems[s + 29] = light.a;
                                clippedVerticesItems[s + 30] = u3;
                                clippedVerticesItems[s + 31] = v3;
                                clippedVerticesItems[s + 32] = dark.r;
                                clippedVerticesItems[s + 33] = dark.g;
                                clippedVerticesItems[s + 34] = dark.b;
                                clippedVerticesItems[s + 35] = dark.a;
                            }
                            s = clippedTriangles.length;
                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3);
                            clippedTrianglesItems[s] = index;
                            clippedTrianglesItems[s + 1] = (index + 1);
                            clippedTrianglesItems[s + 2] = (index + 2);
                            index += 3;
                            continue outer;
                        }
                    }
                }
            };
            SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {
                var originalOutput = output;
                var clipped = false;
                var input = null;
                if (clippingArea.length % 4 >= 2) {
                    input = output;
                    output = this.scratch;
                }
                else
                    input = this.scratch;
                input.length = 0;
                input.push(x1);
                input.push(y1);
                input.push(x2);
                input.push(y2);
                input.push(x3);
                input.push(y3);
                input.push(x1);
                input.push(y1);
                output.length = 0;
                var clippingVertices = clippingArea;
                var clippingVerticesLast = clippingArea.length - 4;
                for (var i = 0;; i += 2) {
                    var edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];
                    var edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];
                    var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;
                    var inputVertices = input;
                    var inputVerticesLength = input.length - 2, outputStart = output.length;
                    for (var ii = 0; ii < inputVerticesLength; ii += 2) {
                        var inputX = inputVertices[ii], inputY = inputVertices[ii + 1];
                        var inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];
                        var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;
                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {
                            if (side2) {
                                output.push(inputX2);
                                output.push(inputY2);
                                continue;
                            }
                            var c0 = inputY2 - inputY, c2 = inputX2 - inputX;
                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));
                            output.push(edgeX + (edgeX2 - edgeX) * ua);
                            output.push(edgeY + (edgeY2 - edgeY) * ua);
                        }
                        else if (side2) {
                            var c0 = inputY2 - inputY, c2 = inputX2 - inputX;
                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));
                            output.push(edgeX + (edgeX2 - edgeX) * ua);
                            output.push(edgeY + (edgeY2 - edgeY) * ua);
                            output.push(inputX2);
                            output.push(inputY2);
                        }
                        clipped = true;
                    }
                    if (outputStart == output.length) {
                        originalOutput.length = 0;
                        return true;
                    }
                    output.push(output[0]);
                    output.push(output[1]);
                    if (i == clippingVerticesLast)
                        break;
                    var temp = output;
                    output = input;
                    output.length = 0;
                    input = temp;
                }
                if (originalOutput != output) {
                    originalOutput.length = 0;
                    for (var i = 0, n = output.length - 2; i < n; i++)
                        originalOutput[i] = output[i];
                }
                else
                    originalOutput.length = originalOutput.length - 2;
                return clipped;
            };
            SkeletonClipping.makeClockwise = function (polygon) {
                var vertices = polygon;
                var verticeslength = polygon.length;
                var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;
                for (var i = 0, n = verticeslength - 3; i < n; i += 2) {
                    p1x = vertices[i];
                    p1y = vertices[i + 1];
                    p2x = vertices[i + 2];
                    p2y = vertices[i + 3];
                    area += p1x * p2y - p2x * p1y;
                }
                if (area < 0)
                    return;
                for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {
                    var x = vertices[i], y = vertices[i + 1];
                    var other = lastX - i;
                    vertices[i] = vertices[other];
                    vertices[i + 1] = vertices[other + 1];
                    vertices[other] = x;
                    vertices[other + 1] = y;
                }
            };
            return SkeletonClipping;
        }());
        core.SkeletonClipping = SkeletonClipping;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var SkeletonData = (function () {
            function SkeletonData() {
                this.bones = new Array();
                this.slots = new Array();
                this.skins = new Array();
                this.events = new Array();
                this.animations = new Array();
                this.ikConstraints = new Array();
                this.transformConstraints = new Array();
                this.pathConstraints = new Array();
                this.fps = 0;
            }
            SkeletonData.prototype.findBone = function (boneName) {
                if (boneName == null)
                    throw new Error("boneName cannot be null.");
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (bone.name == boneName)
                        return bone;
                }
                return null;
            };
            SkeletonData.prototype.findBoneIndex = function (boneName) {
                if (boneName == null)
                    throw new Error("boneName cannot be null.");
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++)
                    if (bones[i].name == boneName)
                        return i;
                return -1;
            };
            SkeletonData.prototype.findSlot = function (slotName) {
                if (slotName == null)
                    throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];
                    if (slot.name == slotName)
                        return slot;
                }
                return null;
            };
            SkeletonData.prototype.findSlotIndex = function (slotName) {
                if (slotName == null)
                    throw new Error("slotName cannot be null.");
                var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++)
                    if (slots[i].name == slotName)
                        return i;
                return -1;
            };
            SkeletonData.prototype.findSkin = function (skinName) {
                if (skinName == null)
                    throw new Error("skinName cannot be null.");
                var skins = this.skins;
                for (var i = 0, n = skins.length; i < n; i++) {
                    var skin = skins[i];
                    if (skin.name == skinName)
                        return skin;
                }
                return null;
            };
            SkeletonData.prototype.findEvent = function (eventDataName) {
                if (eventDataName == null)
                    throw new Error("eventDataName cannot be null.");
                var events = this.events;
                for (var i = 0, n = events.length; i < n; i++) {
                    var event_4 = events[i];
                    if (event_4.name == eventDataName)
                        return event_4;
                }
                return null;
            };
            SkeletonData.prototype.findAnimation = function (animationName) {
                if (animationName == null)
                    throw new Error("animationName cannot be null.");
                var animations = this.animations;
                for (var i = 0, n = animations.length; i < n; i++) {
                    var animation = animations[i];
                    if (animation.name == animationName)
                        return animation;
                }
                return null;
            };
            SkeletonData.prototype.findIkConstraint = function (constraintName) {
                if (constraintName == null)
                    throw new Error("constraintName cannot be null.");
                var ikConstraints = this.ikConstraints;
                for (var i = 0, n = ikConstraints.length; i < n; i++) {
                    var constraint = ikConstraints[i];
                    if (constraint.name == constraintName)
                        return constraint;
                }
                return null;
            };
            SkeletonData.prototype.findTransformConstraint = function (constraintName) {
                if (constraintName == null)
                    throw new Error("constraintName cannot be null.");
                var transformConstraints = this.transformConstraints;
                for (var i = 0, n = transformConstraints.length; i < n; i++) {
                    var constraint = transformConstraints[i];
                    if (constraint.name == constraintName)
                        return constraint;
                }
                return null;
            };
            SkeletonData.prototype.findPathConstraint = function (constraintName) {
                if (constraintName == null)
                    throw new Error("constraintName cannot be null.");
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint = pathConstraints[i];
                    if (constraint.name == constraintName)
                        return constraint;
                }
                return null;
            };
            SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {
                if (pathConstraintName == null)
                    throw new Error("pathConstraintName cannot be null.");
                var pathConstraints = this.pathConstraints;
                for (var i = 0, n = pathConstraints.length; i < n; i++)
                    if (pathConstraints[i].name == pathConstraintName)
                        return i;
                return -1;
            };
            return SkeletonData;
        }());
        core.SkeletonData = SkeletonData;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var SkeletonJson = (function () {
            function SkeletonJson(attachmentLoader) {
                this.scale = 1;
                this.linkedMeshes = new Array();
                this.attachmentLoader = attachmentLoader;
            }
            SkeletonJson.prototype.readSkeletonData = function (json) {
                var scale = this.scale;
                var skeletonData = new core.SkeletonData();
                var root = typeof (json) === "string" ? JSON.parse(json) : json;
                var skeletonMap = root.skeleton;
                if (skeletonMap != null) {
                    skeletonData.hash = skeletonMap.hash;
                    skeletonData.version = skeletonMap.spine;
                    skeletonData.width = skeletonMap.width;
                    skeletonData.height = skeletonMap.height;
                    skeletonData.fps = skeletonMap.fps;
                    skeletonData.imagesPath = skeletonMap.images;
                }
                if (root.bones) {
                    for (var i = 0; i < root.bones.length; i++) {
                        var boneMap = root.bones[i];
                        var parent_2 = null;
                        var parentName = this.getValue(boneMap, "parent", null);
                        if (parentName != null) {
                            parent_2 = skeletonData.findBone(parentName);
                            if (parent_2 == null)
                                throw new Error("Parent bone not found: " + parentName);
                        }
                        var data = new core.BoneData(skeletonData.bones.length, boneMap.name, parent_2);
                        data.length = this.getValue(boneMap, "length", 0) * scale;
                        data.x = this.getValue(boneMap, "x", 0) * scale;
                        data.y = this.getValue(boneMap, "y", 0) * scale;
                        data.rotation = this.getValue(boneMap, "rotation", 0);
                        data.scaleX = this.getValue(boneMap, "scaleX", 1);
                        data.scaleY = this.getValue(boneMap, "scaleY", 1);
                        data.shearX = this.getValue(boneMap, "shearX", 0);
                        data.shearY = this.getValue(boneMap, "shearY", 0);
                        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
                        skeletonData.bones.push(data);
                    }
                }
                if (root.slots) {
                    for (var i = 0; i < root.slots.length; i++) {
                        var slotMap = root.slots[i];
                        var slotName = slotMap.name;
                        var boneName = slotMap.bone;
                        var boneData = skeletonData.findBone(boneName);
                        if (boneData == null)
                            throw new Error("Slot bone not found: " + boneName);
                        var data = new core.SlotData(skeletonData.slots.length, slotName, boneData);
                        var color = this.getValue(slotMap, "color", null);
                        if (color != null)
                            data.color.setFromString(color);
                        var dark = this.getValue(slotMap, "dark", null);
                        if (dark != null) {
                            data.darkColor = new core.Color(1, 1, 1, 1);
                            data.darkColor.setFromString(dark);
                        }
                        data.attachmentName = this.getValue(slotMap, "attachment", null);
                        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
                        skeletonData.slots.push(data);
                    }
                }
                if (root.ik) {
                    for (var i = 0; i < root.ik.length; i++) {
                        var constraintMap = root.ik[i];
                        var data = new core.IkConstraintData(constraintMap.name);
                        data.order = this.getValue(constraintMap, "order", 0);
                        for (var j = 0; j < constraintMap.bones.length; j++) {
                            var boneName = constraintMap.bones[j];
                            var bone = skeletonData.findBone(boneName);
                            if (bone == null)
                                throw new Error("IK bone not found: " + boneName);
                            data.bones.push(bone);
                        }
                        var targetName = constraintMap.target;
                        data.target = skeletonData.findBone(targetName);
                        if (data.target == null)
                            throw new Error("IK target bone not found: " + targetName);
                        data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
                        data.mix = this.getValue(constraintMap, "mix", 1);
                        skeletonData.ikConstraints.push(data);
                    }
                }
                if (root.transform) {
                    for (var i = 0; i < root.transform.length; i++) {
                        var constraintMap = root.transform[i];
                        var data = new core.TransformConstraintData(constraintMap.name);
                        data.order = this.getValue(constraintMap, "order", 0);
                        for (var j = 0; j < constraintMap.bones.length; j++) {
                            var boneName = constraintMap.bones[j];
                            var bone = skeletonData.findBone(boneName);
                            if (bone == null)
                                throw new Error("Transform constraint bone not found: " + boneName);
                            data.bones.push(bone);
                        }
                        var targetName = constraintMap.target;
                        data.target = skeletonData.findBone(targetName);
                        if (data.target == null)
                            throw new Error("Transform constraint target bone not found: " + targetName);
                        data.local = this.getValue(constraintMap, "local", false);
                        data.relative = this.getValue(constraintMap, "relative", false);
                        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
                        data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
                        data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
                        data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
                        data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
                        data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
                        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
                        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
                        data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
                        data.shearMix = this.getValue(constraintMap, "shearMix", 1);
                        skeletonData.transformConstraints.push(data);
                    }
                }
                if (root.path) {
                    for (var i = 0; i < root.path.length; i++) {
                        var constraintMap = root.path[i];
                        var data = new core.PathConstraintData(constraintMap.name);
                        data.order = this.getValue(constraintMap, "order", 0);
                        for (var j = 0; j < constraintMap.bones.length; j++) {
                            var boneName = constraintMap.bones[j];
                            var bone = skeletonData.findBone(boneName);
                            if (bone == null)
                                throw new Error("Transform constraint bone not found: " + boneName);
                            data.bones.push(bone);
                        }
                        var targetName = constraintMap.target;
                        data.target = skeletonData.findSlot(targetName);
                        if (data.target == null)
                            throw new Error("Path target slot not found: " + targetName);
                        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
                        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
                        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
                        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
                        data.position = this.getValue(constraintMap, "position", 0);
                        if (data.positionMode == core.PositionMode.Fixed)
                            data.position *= scale;
                        data.spacing = this.getValue(constraintMap, "spacing", 0);
                        if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)
                            data.spacing *= scale;
                        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
                        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
                        skeletonData.pathConstraints.push(data);
                    }
                }
                if (root.skins) {
                    for (var skinName in root.skins) {
                        var skinMap = root.skins[skinName];
                        var skin = new core.Skin(skinName);
                        for (var slotName in skinMap) {
                            var slotIndex = skeletonData.findSlotIndex(slotName);
                            if (slotIndex == -1)
                                throw new Error("Slot not found: " + slotName);
                            var slotMap = skinMap[slotName];
                            for (var entryName in slotMap) {
                                var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);
                                if (attachment != null)
                                    skin.addAttachment(slotIndex, entryName, attachment);
                            }
                        }
                        skeletonData.skins.push(skin);
                        if (skin.name == "default")
                            skeletonData.defaultSkin = skin;
                    }
                }
                for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
                    var linkedMesh = this.linkedMeshes[i];
                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
                    if (skin == null)
                        throw new Error("Skin not found: " + linkedMesh.skin);
                    var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent_3 == null)
                        throw new Error("Parent mesh not found: " + linkedMesh.parent);
                    linkedMesh.mesh.setParentMesh(parent_3);
                }
                this.linkedMeshes.length = 0;
                if (root.events) {
                    for (var eventName in root.events) {
                        var eventMap = root.events[eventName];
                        var data = new core.EventData(eventName);
                        data.intValue = this.getValue(eventMap, "int", 0);
                        data.floatValue = this.getValue(eventMap, "float", 0);
                        data.stringValue = this.getValue(eventMap, "string", "");
                        skeletonData.events.push(data);
                    }
                }
                if (root.animations) {
                    for (var animationName in root.animations) {
                        var animationMap = root.animations[animationName];
                        this.readAnimation(animationMap, animationName, skeletonData);
                    }
                }
                return skeletonData;
            };
            SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {
                var scale = this.scale;
                name = this.getValue(map, "name", name);
                var type = this.getValue(map, "type", "region");
                switch (type) {
                    case "region": {
                        var path = this.getValue(map, "path", name);
                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
                        if (region == null)
                            return null;
                        region.path = path;
                        region.x = this.getValue(map, "x", 0) * scale;
                        region.y = this.getValue(map, "y", 0) * scale;
                        region.scaleX = this.getValue(map, "scaleX", 1);
                        region.scaleY = this.getValue(map, "scaleY", 1);
                        region.rotation = this.getValue(map, "rotation", 0);
                        region.width = map.width * scale;
                        region.height = map.height * scale;
                        var color = this.getValue(map, "color", null);
                        if (color != null)
                            region.color.setFromString(color);
                        return region;
                    }
                    case "boundingbox": {
                        var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
                        if (box == null)
                            return null;
                        this.readVertices(map, box, map.vertexCount << 1);
                        var color = this.getValue(map, "color", null);
                        if (color != null)
                            box.color.setFromString(color);
                        return box;
                    }
                    case "mesh":
                    case "linkedmesh": {
                        var path = this.getValue(map, "path", name);
                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
                        if (mesh == null)
                            return null;
                        mesh.path = path;
                        var color = this.getValue(map, "color", null);
                        if (color != null)
                            mesh.color.setFromString(color);
                        var parent_4 = this.getValue(map, "parent", null);
                        if (parent_4 != null) {
                            mesh.inheritDeform = this.getValue(map, "deform", true);
                            this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_4));
                            return mesh;
                        }
                        var uvs = map.uvs;
                        this.readVertices(map, mesh, uvs.length);
                        mesh.triangles = map.triangles;
                        mesh.regionUVs = uvs;
                        mesh.hullLength = this.getValue(map, "hull", 0) * 2;
                        return mesh;
                    }
                    case "path": {
                        var path = this.attachmentLoader.newPathAttachment(skin, name);
                        if (path == null)
                            return null;
                        path.closed = this.getValue(map, "closed", false);
                        path.constantSpeed = this.getValue(map, "constantSpeed", true);
                        var vertexCount = map.vertexCount;
                        this.readVertices(map, path, vertexCount << 1);
                        var lengths = core.Utils.newArray(vertexCount / 3, 0);
                        for (var i = 0; i < map.lengths.length; i++)
                            lengths[i] = map.lengths[i] * scale;
                        path.lengths = lengths;
                        var color = this.getValue(map, "color", null);
                        if (color != null)
                            path.color.setFromString(color);
                        return path;
                    }
                    case "point": {
                        var point = this.attachmentLoader.newPointAttachment(skin, name);
                        if (point == null)
                            return null;
                        point.x = this.getValue(map, "x", 0) * scale;
                        point.y = this.getValue(map, "y", 0) * scale;
                        point.rotation = this.getValue(map, "rotation", 0);
                        var color = this.getValue(map, "color", null);
                        if (color != null)
                            point.color.setFromString(color);
                        return point;
                    }
                    case "clipping": {
                        var clip = this.attachmentLoader.newClippingAttachment(skin, name);
                        if (clip == null)
                            return null;
                        var end = this.getValue(map, "end", null);
                        if (end != null) {
                            var slot = skeletonData.findSlot(end);
                            if (slot == null)
                                throw new Error("Clipping end slot not found: " + end);
                            if (clip.name != slot.name)
                                clip.endSlot = slot;
                        }
                        var vertexCount = map.vertexCount;
                        this.readVertices(map, clip, vertexCount << 1);
                        var color = this.getValue(map, "color", null);
                        if (color != null)
                            clip.color.setFromString(color);
                        return clip;
                    }
                }
                return null;
            };
            SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {
                var scale = this.scale;
                attachment.worldVerticesLength = verticesLength;
                var vertices = map.vertices;
                if (verticesLength == vertices.length) {
                    var scaledVertices = core.Utils.toFloatArray(vertices);
                    if (scale != 1) {
                        for (var i = 0, n = vertices.length; i < n; i++)
                            scaledVertices[i] *= scale;
                    }
                    attachment.vertices = scaledVertices;
                    return;
                }
                var weights = new Array();
                var bones = new Array();
                for (var i = 0, n = vertices.length; i < n;) {
                    var boneCount = vertices[i++];
                    bones.push(boneCount);
                    for (var nn = i + boneCount * 4; i < nn; i += 4) {
                        bones.push(vertices[i]);
                        weights.push(vertices[i + 1] * scale);
                        weights.push(vertices[i + 2] * scale);
                        weights.push(vertices[i + 3]);
                    }
                }
                attachment.bones = bones;
                attachment.vertices = core.Utils.toFloatArray(weights);
            };
            SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {
                var scale = this.scale;
                var timelines = new Array();
                var duration = 0;
                if (map.slots) {
                    for (var slotName in map.slots) {
                        var slotMap = map.slots[slotName];
                        var slotIndex = skeletonData.findSlotIndex(slotName);
                        if (slotIndex == -1)
                            throw new Error("Slot not found: " + slotName);
                        for (var timelineName in slotMap) {
                            var timelineMap = slotMap[timelineName];
                            if (timelineName == "attachment") {
                                var timeline = new core.AttachmentTimeline(timelineMap.length);
                                timeline.slotIndex = slotIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                            }
                            else if (timelineName == "color") {
                                var timeline = new core.ColorTimeline(timelineMap.length);
                                timeline.slotIndex = slotIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    var color = new core.Color();
                                    color.setFromString(valueMap.color || "ffffffff");
                                    timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.ColorTimeline.ENTRIES]);
                            }
                            else if (timelineName == "twoColor") {
                                var timeline = new core.TwoColorTimeline(timelineMap.length);
                                timeline.slotIndex = slotIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    var light = new core.Color();
                                    var dark = new core.Color();
                                    light.setFromString(valueMap.light);
                                    dark.setFromString(valueMap.dark);
                                    timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TwoColorTimeline.ENTRIES]);
                            }
                            else
                                throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
                        }
                    }
                }
                if (map.bones) {
                    for (var boneName in map.bones) {
                        var boneMap = map.bones[boneName];
                        var boneIndex = skeletonData.findBoneIndex(boneName);
                        if (boneIndex == -1)
                            throw new Error("Bone not found: " + boneName);
                        for (var timelineName in boneMap) {
                            var timelineMap = boneMap[timelineName];
                            if (timelineName === "rotate") {
                                var timeline = new core.RotateTimeline(timelineMap.length);
                                timeline.boneIndex = boneIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.RotateTimeline.ENTRIES]);
                            }
                            else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
                                var timeline = null;
                                var timelineScale = 1;
                                if (timelineName === "scale")
                                    timeline = new core.ScaleTimeline(timelineMap.length);
                                else if (timelineName === "shear")
                                    timeline = new core.ShearTimeline(timelineMap.length);
                                else {
                                    timeline = new core.TranslateTimeline(timelineMap.length);
                                    timelineScale = scale;
                                }
                                timeline.boneIndex = boneIndex;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    var x = this.getValue(valueMap, "x", 0), y = this.getValue(valueMap, "y", 0);
                                    timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TranslateTimeline.ENTRIES]);
                            }
                            else
                                throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
                        }
                    }
                }
                if (map.ik) {
                    for (var constraintName in map.ik) {
                        var constraintMap = map.ik[constraintName];
                        var constraint = skeletonData.findIkConstraint(constraintName);
                        var timeline = new core.IkConstraintTimeline(constraintMap.length);
                        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
                        var frameIndex = 0;
                        for (var i = 0; i < constraintMap.length; i++) {
                            var valueMap = constraintMap[i];
                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "bendPositive", true) ? 1 : -1);
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.IkConstraintTimeline.ENTRIES]);
                    }
                }
                if (map.transform) {
                    for (var constraintName in map.transform) {
                        var constraintMap = map.transform[constraintName];
                        var constraint = skeletonData.findTransformConstraint(constraintName);
                        var timeline = new core.TransformConstraintTimeline(constraintMap.length);
                        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
                        var frameIndex = 0;
                        for (var i = 0; i < constraintMap.length; i++) {
                            var valueMap = constraintMap[i];
                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TransformConstraintTimeline.ENTRIES]);
                    }
                }
                if (map.paths) {
                    for (var constraintName in map.paths) {
                        var constraintMap = map.paths[constraintName];
                        var index = skeletonData.findPathConstraintIndex(constraintName);
                        if (index == -1)
                            throw new Error("Path constraint not found: " + constraintName);
                        var data = skeletonData.pathConstraints[index];
                        for (var timelineName in constraintMap) {
                            var timelineMap = constraintMap[timelineName];
                            if (timelineName === "position" || timelineName === "spacing") {
                                var timeline = null;
                                var timelineScale = 1;
                                if (timelineName === "spacing") {
                                    timeline = new core.PathConstraintSpacingTimeline(timelineMap.length);
                                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed)
                                        timelineScale = scale;
                                }
                                else {
                                    timeline = new core.PathConstraintPositionTimeline(timelineMap.length);
                                    if (data.positionMode == core.PositionMode.Fixed)
                                        timelineScale = scale;
                                }
                                timeline.pathConstraintIndex = index;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintPositionTimeline.ENTRIES]);
                            }
                            else if (timelineName === "mix") {
                                var timeline = new core.PathConstraintMixTimeline(timelineMap.length);
                                timeline.pathConstraintIndex = index;
                                var frameIndex = 0;
                                for (var i = 0; i < timelineMap.length; i++) {
                                    var valueMap = timelineMap[i];
                                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintMixTimeline.ENTRIES]);
                            }
                        }
                    }
                }
                if (map.deform) {
                    for (var deformName in map.deform) {
                        var deformMap = map.deform[deformName];
                        var skin = skeletonData.findSkin(deformName);
                        if (skin == null)
                            throw new Error("Skin not found: " + deformName);
                        for (var slotName in deformMap) {
                            var slotMap = deformMap[slotName];
                            var slotIndex = skeletonData.findSlotIndex(slotName);
                            if (slotIndex == -1)
                                throw new Error("Slot not found: " + slotMap.name);
                            for (var timelineName in slotMap) {
                                var timelineMap = slotMap[timelineName];
                                var attachment = skin.getAttachment(slotIndex, timelineName);
                                if (attachment == null)
                                    throw new Error("Deform attachment not found: " + timelineMap.name);
                                var weighted = attachment.bones != null;
                                var vertices = attachment.vertices;
                                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                                var timeline = new core.DeformTimeline(timelineMap.length);
                                timeline.slotIndex = slotIndex;
                                timeline.attachment = attachment;
                                var frameIndex = 0;
                                for (var j = 0; j < timelineMap.length; j++) {
                                    var valueMap = timelineMap[j];
                                    var deform = void 0;
                                    var verticesValue = this.getValue(valueMap, "vertices", null);
                                    if (verticesValue == null)
                                        deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;
                                    else {
                                        deform = core.Utils.newFloatArray(deformLength);
                                        var start = this.getValue(valueMap, "offset", 0);
                                        core.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                                        if (scale != 1) {
                                            for (var i = start, n = i + verticesValue.length; i < n; i++)
                                                deform[i] *= scale;
                                        }
                                        if (!weighted) {
                                            for (var i = 0; i < deformLength; i++)
                                                deform[i] += vertices[i];
                                        }
                                    }
                                    timeline.setFrame(frameIndex, valueMap.time, deform);
                                    this.readCurve(valueMap, timeline, frameIndex);
                                    frameIndex++;
                                }
                                timelines.push(timeline);
                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                            }
                        }
                    }
                }
                var drawOrderNode = map.drawOrder;
                if (drawOrderNode == null)
                    drawOrderNode = map.draworder;
                if (drawOrderNode != null) {
                    var timeline = new core.DrawOrderTimeline(drawOrderNode.length);
                    var slotCount = skeletonData.slots.length;
                    var frameIndex = 0;
                    for (var j = 0; j < drawOrderNode.length; j++) {
                        var drawOrderMap = drawOrderNode[j];
                        var drawOrder = null;
                        var offsets = this.getValue(drawOrderMap, "offsets", null);
                        if (offsets != null) {
                            drawOrder = core.Utils.newArray(slotCount, -1);
                            var unchanged = core.Utils.newArray(slotCount - offsets.length, 0);
                            var originalIndex = 0, unchangedIndex = 0;
                            for (var i = 0; i < offsets.length; i++) {
                                var offsetMap = offsets[i];
                                var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
                                if (slotIndex == -1)
                                    throw new Error("Slot not found: " + offsetMap.slot);
                                while (originalIndex != slotIndex)
                                    unchanged[unchangedIndex++] = originalIndex++;
                                drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
                            }
                            while (originalIndex < slotCount)
                                unchanged[unchangedIndex++] = originalIndex++;
                            for (var i = slotCount - 1; i >= 0; i--)
                                if (drawOrder[i] == -1)
                                    drawOrder[i] = unchanged[--unchangedIndex];
                        }
                        timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                }
                if (map.events) {
                    var timeline = new core.EventTimeline(map.events.length);
                    var frameIndex = 0;
                    for (var i = 0; i < map.events.length; i++) {
                        var eventMap = map.events[i];
                        var eventData = skeletonData.findEvent(eventMap.name);
                        if (eventData == null)
                            throw new Error("Event not found: " + eventMap.name);
                        var event_5 = new core.Event(core.Utils.toSinglePrecision(eventMap.time), eventData);
                        event_5.intValue = this.getValue(eventMap, "int", eventData.intValue);
                        event_5.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
                        event_5.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
                        timeline.setFrame(frameIndex++, event_5);
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                }
                if (isNaN(duration)) {
                    throw new Error("Error while parsing animation, duration is NaN");
                }
                skeletonData.animations.push(new core.Animation(name, timelines, duration));
            };
            SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {
                if (!map.curve)
                    return;
                if (map.curve === "stepped")
                    timeline.setStepped(frameIndex);
                else if (Object.prototype.toString.call(map.curve) === '[object Array]') {
                    var curve = map.curve;
                    timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
                }
            };
            SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {
                return map[prop] !== undefined ? map[prop] : defaultValue;
            };
            SkeletonJson.blendModeFromString = function (str) {
                str = str.toLowerCase();
                if (str == "normal")
                    return core.BlendMode.Normal;
                if (str == "additive")
                    return core.BlendMode.Additive;
                if (str == "multiply")
                    return core.BlendMode.Multiply;
                if (str == "screen")
                    return core.BlendMode.Screen;
                throw new Error("Unknown blend mode: " + str);
            };
            SkeletonJson.positionModeFromString = function (str) {
                str = str.toLowerCase();
                if (str == "fixed")
                    return core.PositionMode.Fixed;
                if (str == "percent")
                    return core.PositionMode.Percent;
                throw new Error("Unknown position mode: " + str);
            };
            SkeletonJson.spacingModeFromString = function (str) {
                str = str.toLowerCase();
                if (str == "length")
                    return core.SpacingMode.Length;
                if (str == "fixed")
                    return core.SpacingMode.Fixed;
                if (str == "percent")
                    return core.SpacingMode.Percent;
                throw new Error("Unknown position mode: " + str);
            };
            SkeletonJson.rotateModeFromString = function (str) {
                str = str.toLowerCase();
                if (str == "tangent")
                    return core.RotateMode.Tangent;
                if (str == "chain")
                    return core.RotateMode.Chain;
                if (str == "chainscale")
                    return core.RotateMode.ChainScale;
                throw new Error("Unknown rotate mode: " + str);
            };
            SkeletonJson.transformModeFromString = function (str) {
                str = str.toLowerCase();
                if (str == "normal")
                    return core.TransformMode.Normal;
                if (str == "onlytranslation")
                    return core.TransformMode.OnlyTranslation;
                if (str == "norotationorreflection")
                    return core.TransformMode.NoRotationOrReflection;
                if (str == "noscale")
                    return core.TransformMode.NoScale;
                if (str == "noscaleorreflection")
                    return core.TransformMode.NoScaleOrReflection;
                throw new Error("Unknown transform mode: " + str);
            };
            return SkeletonJson;
        }());
        core.SkeletonJson = SkeletonJson;
        var LinkedMesh = (function () {
            function LinkedMesh(mesh, skin, slotIndex, parent) {
                this.mesh = mesh;
                this.skin = skin;
                this.slotIndex = slotIndex;
                this.parent = parent;
            }
            return LinkedMesh;
        }());
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Skin = (function () {
            function Skin(name) {
                this.attachments = new Array();
                if (name == null)
                    throw new Error("name cannot be null.");
                this.name = name;
            }
            Skin.prototype.addAttachment = function (slotIndex, name, attachment) {
                if (attachment == null)
                    throw new Error("attachment cannot be null.");
                var attachments = this.attachments;
                if (slotIndex >= attachments.length)
                    attachments.length = slotIndex + 1;
                if (!attachments[slotIndex])
                    attachments[slotIndex] = {};
                attachments[slotIndex][name] = attachment;
            };
            Skin.prototype.getAttachment = function (slotIndex, name) {
                var dictionary = this.attachments[slotIndex];
                return dictionary ? dictionary[name] : null;
            };
            Skin.prototype.attachAll = function (skeleton, oldSkin) {
                var slotIndex = 0;
                for (var i = 0; i < skeleton.slots.length; i++) {
                    var slot = skeleton.slots[i];
                    var slotAttachment = slot.getAttachment();
                    if (slotAttachment && slotIndex < oldSkin.attachments.length) {
                        var dictionary = oldSkin.attachments[slotIndex];
                        for (var key in dictionary) {
                            var skinAttachment = dictionary[key];
                            if (slotAttachment == skinAttachment) {
                                var attachment = this.getAttachment(slotIndex, name);
                                if (attachment != null)
                                    slot.setAttachment(attachment);
                                break;
                            }
                        }
                    }
                    slotIndex++;
                }
            };
            return Skin;
        }());
        core.Skin = Skin;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Slot = (function () {
            function Slot(data, bone) {
                this.attachmentVertices = new Array();
                if (data == null)
                    throw new Error("data cannot be null.");
                if (bone == null)
                    throw new Error("bone cannot be null.");
                this.data = data;
                this.bone = bone;
                this.color = new core.Color();
                this.darkColor = data.darkColor == null ? null : new core.Color();
                this.setToSetupPose();
                this.blendMode = this.data.blendMode;
            }
            Slot.prototype.getAttachment = function () {
                return this.attachment;
            };
            Slot.prototype.setAttachment = function (attachment) {
                if (this.attachment == attachment)
                    return;
                this.attachment = attachment;
                this.attachmentTime = this.bone.skeleton.time;
                this.attachmentVertices.length = 0;
            };
            Slot.prototype.setAttachmentTime = function (time) {
                this.attachmentTime = this.bone.skeleton.time - time;
            };
            Slot.prototype.getAttachmentTime = function () {
                return this.bone.skeleton.time - this.attachmentTime;
            };
            Slot.prototype.setToSetupPose = function () {
                this.color.setFromColor(this.data.color);
                if (this.darkColor != null)
                    this.darkColor.setFromColor(this.data.darkColor);
                if (this.data.attachmentName == null)
                    this.attachment = null;
                else {
                    this.attachment = null;
                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
                }
            };
            return Slot;
        }());
        core.Slot = Slot;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var SlotData = (function () {
            function SlotData(index, name, boneData) {
                this.color = new core.Color(1, 1, 1, 1);
                if (index < 0)
                    throw new Error("index must be >= 0.");
                if (name == null)
                    throw new Error("name cannot be null.");
                if (boneData == null)
                    throw new Error("boneData cannot be null.");
                this.index = index;
                this.name = name;
                this.boneData = boneData;
            }
            return SlotData;
        }());
        core.SlotData = SlotData;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Texture = (function () {
            function Texture(image) {
                this._image = image;
            }
            Texture.prototype.getImage = function () {
                return this._image;
            };
            Texture.filterFromString = function (text) {
                switch (text.toLowerCase()) {
                    case "nearest": return TextureFilter.Nearest;
                    case "linear": return TextureFilter.Linear;
                    case "mipmap": return TextureFilter.MipMap;
                    case "mipmapnearestnearest": return TextureFilter.MipMapNearestNearest;
                    case "mipmaplinearnearest": return TextureFilter.MipMapLinearNearest;
                    case "mipmapnearestlinear": return TextureFilter.MipMapNearestLinear;
                    case "mipmaplinearlinear": return TextureFilter.MipMapLinearLinear;
                    default: throw new Error("Unknown texture filter " + text);
                }
            };
            Texture.wrapFromString = function (text) {
                switch (text.toLowerCase()) {
                    case "mirroredtepeat": return TextureWrap.MirroredRepeat;
                    case "clamptoedge": return TextureWrap.ClampToEdge;
                    case "repeat": return TextureWrap.Repeat;
                    default: throw new Error("Unknown texture wrap " + text);
                }
            };
            return Texture;
        }());
        core.Texture = Texture;
        var TextureFilter;
        (function (TextureFilter) {
            TextureFilter[TextureFilter["Nearest"] = 9728] = "Nearest";
            TextureFilter[TextureFilter["Linear"] = 9729] = "Linear";
            TextureFilter[TextureFilter["MipMap"] = 9987] = "MipMap";
            TextureFilter[TextureFilter["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
            TextureFilter[TextureFilter["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
            TextureFilter[TextureFilter["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
            TextureFilter[TextureFilter["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
        })(TextureFilter = core.TextureFilter || (core.TextureFilter = {}));
        var TextureWrap;
        (function (TextureWrap) {
            TextureWrap[TextureWrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
            TextureWrap[TextureWrap["ClampToEdge"] = 33071] = "ClampToEdge";
            TextureWrap[TextureWrap["Repeat"] = 10497] = "Repeat";
        })(TextureWrap = core.TextureWrap || (core.TextureWrap = {}));
        var TextureRegion = (function () {
            function TextureRegion() {
                this.size = null;
            }
            Object.defineProperty(TextureRegion.prototype, "width", {
                get: function () {
                    var tex = this.texture;
                    if (PIXI.VERSION[0] == '3') {
                        return tex.crop.width;
                    }
                    if (tex.trim) {
                        return tex.trim.width;
                    }
                    return tex.orig.width;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "height", {
                get: function () {
                    var tex = this.texture;
                    if (PIXI.VERSION[0] == '3') {
                        return tex.crop.height;
                    }
                    if (tex.trim) {
                        return tex.trim.height;
                    }
                    return tex.orig.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "u", {
                get: function () {
                    return this.texture._uvs.x0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "v", {
                get: function () {
                    return this.texture._uvs.y0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "u2", {
                get: function () {
                    return this.texture._uvs.x2;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "v2", {
                get: function () {
                    return this.texture._uvs.y2;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "offsetX", {
                get: function () {
                    var tex = this.texture;
                    return tex.trim ? tex.trim.x : 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "offsetY", {
                get: function () {
                    console.warn("Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.");
                    return this.spineOffsetY;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "pixiOffsetY", {
                get: function () {
                    var tex = this.texture;
                    return tex.trim ? tex.trim.y : 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "spineOffsetY", {
                get: function () {
                    var tex = this.texture;
                    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "originalWidth", {
                get: function () {
                    var tex = this.texture;
                    if (PIXI.VERSION[0] == '3') {
                        if (tex.trim) {
                            return tex.trim.width;
                        }
                        return tex.crop.width;
                    }
                    return tex.orig.width;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "originalHeight", {
                get: function () {
                    var tex = this.texture;
                    if (PIXI.VERSION[0] == '3') {
                        if (tex.trim) {
                            return tex.trim.height;
                        }
                        return tex.crop.height;
                    }
                    return tex.orig.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "x", {
                get: function () {
                    return this.texture.frame.x;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "y", {
                get: function () {
                    return this.texture.frame.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureRegion.prototype, "rotate", {
                get: function () {
                    return this.texture.rotate !== 0;
                },
                enumerable: true,
                configurable: true
            });
            return TextureRegion;
        }());
        core.TextureRegion = TextureRegion;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var TextureAtlas = (function () {
            function TextureAtlas(atlasText, textureLoader, callback) {
                this.pages = new Array();
                this.regions = new Array();
                if (atlasText) {
                    this.addSpineAtlas(atlasText, textureLoader, callback);
                }
            }
            TextureAtlas.prototype.addTexture = function (name, texture) {
                var pages = this.pages;
                var page = null;
                for (var i = 0; i < pages.length; i++) {
                    if (pages[i].baseTexture === texture.baseTexture) {
                        page = pages[i];
                        break;
                    }
                }
                if (page === null) {
                    page = new TextureAtlasPage();
                    page.name = 'texturePage';
                    var baseTexture = texture.baseTexture;
                    page.width = baseTexture.realWidth;
                    page.height = baseTexture.realHeight;
                    page.baseTexture = baseTexture;
                    page.minFilter = page.magFilter = core.TextureFilter.Nearest;
                    page.uWrap = core.TextureWrap.ClampToEdge;
                    page.vWrap = core.TextureWrap.ClampToEdge;
                    pages.push(page);
                }
                var region = new TextureAtlasRegion();
                region.name = name;
                region.page = page;
                region.texture = texture;
                region.index = -1;
                this.regions.push(region);
                return region;
            };
            TextureAtlas.prototype.addTextureHash = function (textures, stripExtension) {
                for (var key in textures) {
                    if (textures.hasOwnProperty(key)) {
                        this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);
                    }
                }
            };
            TextureAtlas.prototype.addSpineAtlas = function (atlasText, textureLoader, callback) {
                return this.load(atlasText, textureLoader, callback);
            };
            TextureAtlas.prototype.load = function (atlasText, textureLoader, callback) {
                var _this = this;
                if (textureLoader == null)
                    throw new Error("textureLoader cannot be null.");
                var reader = new TextureAtlasReader(atlasText);
                var tuple = new Array(4);
                var page = null;
                var iterateParser = function () {
                    while (true) {
                        var line = reader.readLine();
                        if (line == null) {
                            return callback && callback(_this);
                        }
                        line = line.trim();
                        if (line.length == 0)
                            page = null;
                        else if (!page) {
                            page = new TextureAtlasPage();
                            page.name = line;
                            if (reader.readTuple(tuple) == 2) {
                                page.width = parseInt(tuple[0]);
                                page.height = parseInt(tuple[1]);
                                reader.readTuple(tuple);
                            }
                            reader.readTuple(tuple);
                            page.minFilter = core.Texture.filterFromString(tuple[0]);
                            page.magFilter = core.Texture.filterFromString(tuple[1]);
                            var direction = reader.readValue();
                            page.uWrap = core.TextureWrap.ClampToEdge;
                            page.vWrap = core.TextureWrap.ClampToEdge;
                            if (direction == "x")
                                page.uWrap = core.TextureWrap.Repeat;
                            else if (direction == "y")
                                page.vWrap = core.TextureWrap.Repeat;
                            else if (direction == "xy")
                                page.uWrap = page.vWrap = core.TextureWrap.Repeat;
                            textureLoader(line, function (texture) {
                                page.baseTexture = texture;
                                if (!texture.hasLoaded) {
                                    texture.width = page.width;
                                    texture.height = page.height;
                                }
                                _this.pages.push(page);
                                page.setFilters();
                                if (!page.width || !page.height) {
                                    page.width = texture.realWidth;
                                    page.height = texture.realHeight;
                                    if (!page.width || !page.height) {
                                        console.log("ERROR spine atlas page " + page.name + ": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)");
                                    }
                                }
                                iterateParser();
                            });
                            _this.pages.push(page);
                            break;
                        }
                        else {
                            var region = new TextureAtlasRegion();
                            region.name = line;
                            region.page = page;
                            var rotate = reader.readValue() == "true" ? 6 : 0;
                            reader.readTuple(tuple);
                            var x = parseInt(tuple[0]);
                            var y = parseInt(tuple[1]);
                            reader.readTuple(tuple);
                            var width = parseInt(tuple[0]);
                            var height = parseInt(tuple[1]);
                            var resolution = page.baseTexture.resolution;
                            x /= resolution;
                            y /= resolution;
                            width /= resolution;
                            height /= resolution;
                            var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);
                            if (reader.readTuple(tuple) == 4) {
                                if (reader.readTuple(tuple) == 4) {
                                    reader.readTuple(tuple);
                                }
                            }
                            var originalWidth = parseInt(tuple[0]) / resolution;
                            var originalHeight = parseInt(tuple[1]) / resolution;
                            reader.readTuple(tuple);
                            var offsetX = parseInt(tuple[0]) / resolution;
                            var offsetY = parseInt(tuple[1]) / resolution;
                            var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);
                            var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);
                            if (PIXI.VERSION[0] != '3') {
                                region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);
                            }
                            else {
                                var frame2 = new PIXI.Rectangle(x, y, width, height);
                                var crop = frame2.clone();
                                trim.width = originalWidth;
                                trim.height = originalHeight;
                                region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);
                            }
                            region.index = parseInt(reader.readValue());
                            region.texture._updateUvs();
                            _this.regions.push(region);
                        }
                    }
                };
                iterateParser();
            };
            TextureAtlas.prototype.findRegion = function (name) {
                for (var i = 0; i < this.regions.length; i++) {
                    if (this.regions[i].name == name) {
                        return this.regions[i];
                    }
                }
                return null;
            };
            TextureAtlas.prototype.dispose = function () {
                for (var i = 0; i < this.pages.length; i++) {
                    this.pages[i].baseTexture.dispose();
                }
            };
            return TextureAtlas;
        }());
        core.TextureAtlas = TextureAtlas;
        var TextureAtlasReader = (function () {
            function TextureAtlasReader(text) {
                this.index = 0;
                this.lines = text.split(/\r\n|\r|\n/);
            }
            TextureAtlasReader.prototype.readLine = function () {
                if (this.index >= this.lines.length)
                    return null;
                return this.lines[this.index++];
            };
            TextureAtlasReader.prototype.readValue = function () {
                var line = this.readLine();
                var colon = line.indexOf(":");
                if (colon == -1)
                    throw new Error("Invalid line: " + line);
                return line.substring(colon + 1).trim();
            };
            TextureAtlasReader.prototype.readTuple = function (tuple) {
                var line = this.readLine();
                var colon = line.indexOf(":");
                if (colon == -1)
                    throw new Error("Invalid line: " + line);
                var i = 0, lastMatch = colon + 1;
                for (; i < 3; i++) {
                    var comma = line.indexOf(",", lastMatch);
                    if (comma == -1)
                        break;
                    tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();
                    lastMatch = comma + 1;
                }
                tuple[i] = line.substring(lastMatch).trim();
                return i + 1;
            };
            return TextureAtlasReader;
        }());
        var TextureAtlasPage = (function () {
            function TextureAtlasPage() {
            }
            TextureAtlasPage.prototype.setFilters = function () {
                var tex = this.baseTexture;
                var filter = this.minFilter;
                if (filter == core.TextureFilter.Linear) {
                    tex.scaleMode = PIXI.SCALE_MODES.LINEAR;
                }
                else if (this.minFilter == core.TextureFilter.Nearest) {
                    tex.scaleMode = PIXI.SCALE_MODES.NEAREST;
                }
                else {
                    tex.mipmap = true;
                    if (filter == core.TextureFilter.MipMapNearestNearest) {
                        tex.scaleMode = PIXI.SCALE_MODES.NEAREST;
                    }
                    else {
                        tex.scaleMode = PIXI.SCALE_MODES.LINEAR;
                    }
                }
            };
            return TextureAtlasPage;
        }());
        core.TextureAtlasPage = TextureAtlasPage;
        var TextureAtlasRegion = (function (_super) {
            __extends(TextureAtlasRegion, _super);
            function TextureAtlasRegion() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return TextureAtlasRegion;
        }(core.TextureRegion));
        core.TextureAtlasRegion = TextureAtlasRegion;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var TransformConstraint = (function () {
            function TransformConstraint(data, skeleton) {
                this.rotateMix = 0;
                this.translateMix = 0;
                this.scaleMix = 0;
                this.shearMix = 0;
                this.temp = new core.Vector2();
                if (data == null)
                    throw new Error("data cannot be null.");
                if (skeleton == null)
                    throw new Error("skeleton cannot be null.");
                this.data = data;
                this.rotateMix = data.rotateMix;
                this.translateMix = data.translateMix;
                this.scaleMix = data.scaleMix;
                this.shearMix = data.shearMix;
                this.bones = new Array();
                for (var i = 0; i < data.bones.length; i++)
                    this.bones.push(skeleton.findBone(data.bones[i].name));
                this.target = skeleton.findBone(data.target.name);
            }
            TransformConstraint.prototype.apply = function () {
                this.update();
            };
            TransformConstraint.prototype.update = function () {
                if (this.data.local) {
                    if (this.data.relative)
                        this.applyRelativeLocal();
                    else
                        this.applyAbsoluteLocal();
                }
                else {
                    if (this.data.relative)
                        this.applyRelativeWorld();
                    else
                        this.applyAbsoluteWorld();
                }
            };
            TransformConstraint.prototype.applyAbsoluteWorld = function () {
                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                var targetMat = target.matrix;
                var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;
                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;
                var offsetRotation = this.data.offsetRotation * degRadReflect;
                var offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    var modified = false;
                    var mat = bone.matrix;
                    if (rotateMix != 0) {
                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
                        var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
                        if (r > core.MathUtils.PI)
                            r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI)
                            r += core.MathUtils.PI2;
                        r *= rotateMix;
                        var cos = Math.cos(r), sin = Math.sin(r);
                        mat.a = cos * a - sin * c;
                        mat.c = cos * b - sin * d;
                        mat.b = sin * a + cos * c;
                        mat.d = sin * b + cos * d;
                        modified = true;
                    }
                    if (translateMix != 0) {
                        var temp = this.temp;
                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
                        mat.tx += (temp.x - mat.tx) * translateMix;
                        mat.ty += (temp.y - mat.ty) * translateMix;
                        modified = true;
                    }
                    if (scaleMix > 0) {
                        var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
                        var ts = Math.sqrt(ta * ta + tc * tc);
                        if (s > 0.00001)
                            s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
                        mat.a *= s;
                        mat.b *= s;
                        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
                        ts = Math.sqrt(tb * tb + td * td);
                        if (s > 0.00001)
                            s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
                        mat.c *= s;
                        mat.d *= s;
                        modified = true;
                    }
                    if (shearMix > 0) {
                        var b = mat.c, d = mat.d;
                        var by = Math.atan2(d, b);
                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
                        if (r > core.MathUtils.PI)
                            r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI)
                            r += core.MathUtils.PI2;
                        r = by + (r + offsetShearY) * shearMix;
                        var s = Math.sqrt(b * b + d * d);
                        mat.c = Math.cos(r) * s;
                        mat.d = Math.sin(r) * s;
                        modified = true;
                    }
                    if (modified)
                        bone.appliedValid = false;
                }
            };
            TransformConstraint.prototype.applyRelativeWorld = function () {
                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                var targetMat = target.matrix;
                var ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;
                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;
                var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    var modified = false;
                    var mat = bone.matrix;
                    if (rotateMix != 0) {
                        var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
                        var r = Math.atan2(tc, ta) + offsetRotation;
                        if (r > core.MathUtils.PI)
                            r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI)
                            r += core.MathUtils.PI2;
                        r *= rotateMix;
                        var cos = Math.cos(r), sin = Math.sin(r);
                        mat.a = cos * a - sin * c;
                        mat.c = cos * b - sin * d;
                        mat.b = sin * a + cos * c;
                        mat.d = sin * b + cos * d;
                        modified = true;
                    }
                    if (translateMix != 0) {
                        var temp = this.temp;
                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
                        mat.tx += temp.x * translateMix;
                        mat.ty += temp.y * translateMix;
                        modified = true;
                    }
                    if (scaleMix > 0) {
                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
                        mat.a *= s;
                        mat.b *= s;
                        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
                        mat.c *= s;
                        mat.d *= s;
                        modified = true;
                    }
                    if (shearMix > 0) {
                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta);
                        if (r > core.MathUtils.PI)
                            r -= core.MathUtils.PI2;
                        else if (r < -core.MathUtils.PI)
                            r += core.MathUtils.PI2;
                        var b = mat.c, d = mat.d;
                        r = Math.atan2(d, b) + (r - core.MathUtils.PI / 2 + offsetShearY) * shearMix;
                        var s = Math.sqrt(b * b + d * d);
                        mat.c = Math.cos(r) * s;
                        mat.d = Math.sin(r) * s;
                        modified = true;
                    }
                    if (modified)
                        bone.appliedValid = false;
                }
            };
            TransformConstraint.prototype.applyAbsoluteLocal = function () {
                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                if (!target.appliedValid)
                    target.updateAppliedTransform();
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (!bone.appliedValid)
                        bone.updateAppliedTransform();
                    var rotation = bone.arotation;
                    if (rotateMix != 0) {
                        var r = target.arotation - rotation + this.data.offsetRotation;
                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
                        rotation += r * rotateMix;
                    }
                    var x = bone.ax, y = bone.ay;
                    if (translateMix != 0) {
                        x += (target.ax - x + this.data.offsetX) * translateMix;
                        y += (target.ay - y + this.data.offsetY) * translateMix;
                    }
                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
                    if (scaleMix > 0) {
                        if (scaleX > 0.00001)
                            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
                        if (scaleY > 0.00001)
                            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
                    }
                    var shearY = bone.ashearY;
                    if (shearMix > 0) {
                        var r = target.ashearY - shearY + this.data.offsetShearY;
                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
                        bone.shearY += r * shearMix;
                    }
                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            };
            TransformConstraint.prototype.applyRelativeLocal = function () {
                var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                var target = this.target;
                if (!target.appliedValid)
                    target.updateAppliedTransform();
                var bones = this.bones;
                for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (!bone.appliedValid)
                        bone.updateAppliedTransform();
                    var rotation = bone.arotation;
                    if (rotateMix != 0)
                        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
                    var x = bone.ax, y = bone.ay;
                    if (translateMix != 0) {
                        x += (target.ax + this.data.offsetX) * translateMix;
                        y += (target.ay + this.data.offsetY) * translateMix;
                    }
                    var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
                    if (scaleMix > 0) {
                        if (scaleX > 0.00001)
                            scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;
                        if (scaleY > 0.00001)
                            scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;
                    }
                    var shearY = bone.ashearY;
                    if (shearMix > 0)
                        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            };
            TransformConstraint.prototype.getOrder = function () {
                return this.data.order;
            };
            return TransformConstraint;
        }());
        core.TransformConstraint = TransformConstraint;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var TransformConstraintData = (function () {
            function TransformConstraintData(name) {
                this.order = 0;
                this.bones = new Array();
                this.rotateMix = 0;
                this.translateMix = 0;
                this.scaleMix = 0;
                this.shearMix = 0;
                this.offsetRotation = 0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.offsetScaleX = 0;
                this.offsetScaleY = 0;
                this.offsetShearY = 0;
                this.relative = false;
                this.local = false;
                if (name == null)
                    throw new Error("name cannot be null.");
                this.name = name;
            }
            return TransformConstraintData;
        }());
        core.TransformConstraintData = TransformConstraintData;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Triangulator = (function () {
            function Triangulator() {
                this.convexPolygons = new Array();
                this.convexPolygonsIndices = new Array();
                this.indicesArray = new Array();
                this.isConcaveArray = new Array();
                this.triangles = new Array();
                this.polygonPool = new core.Pool(function () {
                    return new Array();
                });
                this.polygonIndicesPool = new core.Pool(function () {
                    return new Array();
                });
            }
            Triangulator.prototype.triangulate = function (verticesArray) {
                var vertices = verticesArray;
                var vertexCount = verticesArray.length >> 1;
                var indices = this.indicesArray;
                indices.length = 0;
                for (var i = 0; i < vertexCount; i++)
                    indices[i] = i;
                var isConcave = this.isConcaveArray;
                isConcave.length = 0;
                for (var i = 0, n = vertexCount; i < n; ++i)
                    isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);
                var triangles = this.triangles;
                triangles.length = 0;
                while (vertexCount > 3) {
                    var previous = vertexCount - 1, i = 0, next = 1;
                    while (true) {
                        outer: if (!isConcave[i]) {
                            var p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;
                            var p1x = vertices[p1], p1y = vertices[p1 + 1];
                            var p2x = vertices[p2], p2y = vertices[p2 + 1];
                            var p3x = vertices[p3], p3y = vertices[p3 + 1];
                            for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {
                                if (!isConcave[ii])
                                    continue;
                                var v = indices[ii] << 1;
                                var vx = vertices[v], vy = vertices[v + 1];
                                if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {
                                    if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {
                                        if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))
                                            break outer;
                                    }
                                }
                            }
                            break;
                        }
                        if (next == 0) {
                            do {
                                if (!isConcave[i])
                                    break;
                                i--;
                            } while (i > 0);
                            break;
                        }
                        previous = i;
                        i = next;
                        next = (next + 1) % vertexCount;
                    }
                    triangles.push(indices[(vertexCount + i - 1) % vertexCount]);
                    triangles.push(indices[i]);
                    triangles.push(indices[(i + 1) % vertexCount]);
                    indices.splice(i, 1);
                    isConcave.splice(i, 1);
                    vertexCount--;
                    var previousIndex = (vertexCount + i - 1) % vertexCount;
                    var nextIndex = i == vertexCount ? 0 : i;
                    isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);
                    isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);
                }
                if (vertexCount == 3) {
                    triangles.push(indices[2]);
                    triangles.push(indices[0]);
                    triangles.push(indices[1]);
                }
                return triangles;
            };
            Triangulator.prototype.decompose = function (verticesArray, triangles) {
                var vertices = verticesArray;
                var convexPolygons = this.convexPolygons;
                this.polygonPool.freeAll(convexPolygons);
                convexPolygons.length = 0;
                var convexPolygonsIndices = this.convexPolygonsIndices;
                this.polygonIndicesPool.freeAll(convexPolygonsIndices);
                convexPolygonsIndices.length = 0;
                var polygonIndices = this.polygonIndicesPool.obtain();
                polygonIndices.length = 0;
                var polygon = this.polygonPool.obtain();
                polygon.length = 0;
                var fanBaseIndex = -1, lastWinding = 0;
                for (var i = 0, n = triangles.length; i < n; i += 3) {
                    var t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;
                    var x1 = vertices[t1], y1 = vertices[t1 + 1];
                    var x2 = vertices[t2], y2 = vertices[t2 + 1];
                    var x3 = vertices[t3], y3 = vertices[t3 + 1];
                    var merged = false;
                    if (fanBaseIndex == t1) {
                        var o = polygon.length - 4;
                        var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);
                        var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);
                        if (winding1 == lastWinding && winding2 == lastWinding) {
                            polygon.push(x3);
                            polygon.push(y3);
                            polygonIndices.push(t3);
                            merged = true;
                        }
                    }
                    if (!merged) {
                        if (polygon.length > 0) {
                            convexPolygons.push(polygon);
                            convexPolygonsIndices.push(polygonIndices);
                        }
                        else {
                            this.polygonPool.free(polygon);
                            this.polygonIndicesPool.free(polygonIndices);
                        }
                        polygon = this.polygonPool.obtain();
                        polygon.length = 0;
                        polygon.push(x1);
                        polygon.push(y1);
                        polygon.push(x2);
                        polygon.push(y2);
                        polygon.push(x3);
                        polygon.push(y3);
                        polygonIndices = this.polygonIndicesPool.obtain();
                        polygonIndices.length = 0;
                        polygonIndices.push(t1);
                        polygonIndices.push(t2);
                        polygonIndices.push(t3);
                        lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);
                        fanBaseIndex = t1;
                    }
                }
                if (polygon.length > 0) {
                    convexPolygons.push(polygon);
                    convexPolygonsIndices.push(polygonIndices);
                }
                for (var i = 0, n = convexPolygons.length; i < n; i++) {
                    polygonIndices = convexPolygonsIndices[i];
                    if (polygonIndices.length == 0)
                        continue;
                    var firstIndex = polygonIndices[0];
                    var lastIndex = polygonIndices[polygonIndices.length - 1];
                    polygon = convexPolygons[i];
                    var o = polygon.length - 4;
                    var prevPrevX = polygon[o], prevPrevY = polygon[o + 1];
                    var prevX = polygon[o + 2], prevY = polygon[o + 3];
                    var firstX = polygon[0], firstY = polygon[1];
                    var secondX = polygon[2], secondY = polygon[3];
                    var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);
                    for (var ii = 0; ii < n; ii++) {
                        if (ii == i)
                            continue;
                        var otherIndices = convexPolygonsIndices[ii];
                        if (otherIndices.length != 3)
                            continue;
                        var otherFirstIndex = otherIndices[0];
                        var otherSecondIndex = otherIndices[1];
                        var otherLastIndex = otherIndices[2];
                        var otherPoly = convexPolygons[ii];
                        var x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];
                        if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)
                            continue;
                        var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);
                        var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);
                        if (winding1 == winding && winding2 == winding) {
                            otherPoly.length = 0;
                            otherIndices.length = 0;
                            polygon.push(x3);
                            polygon.push(y3);
                            polygonIndices.push(otherLastIndex);
                            prevPrevX = prevX;
                            prevPrevY = prevY;
                            prevX = x3;
                            prevY = y3;
                            ii = 0;
                        }
                    }
                }
                for (var i = convexPolygons.length - 1; i >= 0; i--) {
                    polygon = convexPolygons[i];
                    if (polygon.length == 0) {
                        convexPolygons.splice(i, 1);
                        this.polygonPool.free(polygon);
                        polygonIndices = convexPolygonsIndices[i];
                        convexPolygonsIndices.splice(i, 1);
                        this.polygonIndicesPool.free(polygonIndices);
                    }
                }
                return convexPolygons;
            };
            Triangulator.isConcave = function (index, vertexCount, vertices, indices) {
                var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;
                var current = indices[index] << 1;
                var next = indices[(index + 1) % vertexCount] << 1;
                return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);
            };
            Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {
                return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
            };
            Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {
                var px = p2x - p1x, py = p2y - p1y;
                return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
            };
            return Triangulator;
        }());
        core.Triangulator = Triangulator;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var IntSet = (function () {
            function IntSet() {
                this.array = new Array();
            }
            IntSet.prototype.add = function (value) {
                var contains = this.contains(value);
                this.array[value | 0] = value | 0;
                return !contains;
            };
            IntSet.prototype.contains = function (value) {
                return this.array[value | 0] != undefined;
            };
            IntSet.prototype.remove = function (value) {
                this.array[value | 0] = undefined;
            };
            IntSet.prototype.clear = function () {
                this.array.length = 0;
            };
            return IntSet;
        }());
        core.IntSet = IntSet;
        var Color = (function () {
            function Color(r, g, b, a) {
                if (r === void 0) { r = 0; }
                if (g === void 0) { g = 0; }
                if (b === void 0) { b = 0; }
                if (a === void 0) { a = 0; }
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;
            }
            Color.prototype.set = function (r, g, b, a) {
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;
                this.clamp();
                return this;
            };
            Color.prototype.setFromColor = function (c) {
                this.r = c.r;
                this.g = c.g;
                this.b = c.b;
                this.a = c.a;
                return this;
            };
            Color.prototype.setFromString = function (hex) {
                hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;
                this.r = parseInt(hex.substr(0, 2), 16) / 255.0;
                this.g = parseInt(hex.substr(2, 2), 16) / 255.0;
                this.b = parseInt(hex.substr(4, 2), 16) / 255.0;
                this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;
                return this;
            };
            Color.prototype.add = function (r, g, b, a) {
                this.r += r;
                this.g += g;
                this.b += b;
                this.a += a;
                this.clamp();
                return this;
            };
            Color.prototype.clamp = function () {
                if (this.r < 0)
                    this.r = 0;
                else if (this.r > 1)
                    this.r = 1;
                if (this.g < 0)
                    this.g = 0;
                else if (this.g > 1)
                    this.g = 1;
                if (this.b < 0)
                    this.b = 0;
                else if (this.b > 1)
                    this.b = 1;
                if (this.a < 0)
                    this.a = 0;
                else if (this.a > 1)
                    this.a = 1;
                return this;
            };
            Color.WHITE = new Color(1, 1, 1, 1);
            Color.RED = new Color(1, 0, 0, 1);
            Color.GREEN = new Color(0, 1, 0, 1);
            Color.BLUE = new Color(0, 0, 1, 1);
            Color.MAGENTA = new Color(1, 0, 1, 1);
            return Color;
        }());
        core.Color = Color;
        var MathUtils = (function () {
            function MathUtils() {
            }
            MathUtils.clamp = function (value, min, max) {
                if (value < min)
                    return min;
                if (value > max)
                    return max;
                return value;
            };
            MathUtils.cosDeg = function (degrees) {
                return Math.cos(degrees * MathUtils.degRad);
            };
            MathUtils.sinDeg = function (degrees) {
                return Math.sin(degrees * MathUtils.degRad);
            };
            MathUtils.signum = function (value) {
                return value > 0 ? 1 : value < 0 ? -1 : 0;
            };
            MathUtils.toInt = function (x) {
                return x > 0 ? Math.floor(x) : Math.ceil(x);
            };
            MathUtils.cbrt = function (x) {
                var y = Math.pow(Math.abs(x), 1 / 3);
                return x < 0 ? -y : y;
            };
            MathUtils.randomTriangular = function (min, max) {
                return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
            };
            MathUtils.randomTriangularWith = function (min, max, mode) {
                var u = Math.random();
                var d = max - min;
                if (u <= (mode - min) / d)
                    return min + Math.sqrt(u * d * (mode - min));
                return max - Math.sqrt((1 - u) * d * (max - mode));
            };
            MathUtils.PI = 3.1415927;
            MathUtils.PI2 = MathUtils.PI * 2;
            MathUtils.radiansToDegrees = 180 / MathUtils.PI;
            MathUtils.radDeg = MathUtils.radiansToDegrees;
            MathUtils.degreesToRadians = MathUtils.PI / 180;
            MathUtils.degRad = MathUtils.degreesToRadians;
            return MathUtils;
        }());
        core.MathUtils = MathUtils;
        var Interpolation = (function () {
            function Interpolation() {
            }
            Interpolation.prototype.apply = function (start, end, a) {
                return start + (end - start) * this.applyInternal(a);
            };
            return Interpolation;
        }());
        core.Interpolation = Interpolation;
        var Pow = (function (_super) {
            __extends(Pow, _super);
            function Pow(power) {
                var _this = _super.call(this) || this;
                _this.power = 2;
                _this.power = power;
                return _this;
            }
            Pow.prototype.applyInternal = function (a) {
                if (a <= 0.5)
                    return Math.pow(a * 2, this.power) / 2;
                return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
            };
            return Pow;
        }(Interpolation));
        core.Pow = Pow;
        var PowOut = (function (_super) {
            __extends(PowOut, _super);
            function PowOut(power) {
                return _super.call(this, power) || this;
            }
            PowOut.prototype.applyInternal = function (a) {
                return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
            };
            return PowOut;
        }(Pow));
        core.PowOut = PowOut;
        var Utils = (function () {
            function Utils() {
            }
            Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {
                for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
                    dest[j] = source[i];
                }
            };
            Utils.setArraySize = function (array, size, value) {
                if (value === void 0) { value = 0; }
                var oldSize = array.length;
                if (oldSize == size)
                    return array;
                array.length = size;
                if (oldSize < size) {
                    for (var i = oldSize; i < size; i++)
                        array[i] = value;
                }
                return array;
            };
            Utils.ensureArrayCapacity = function (array, size, value) {
                if (value === void 0) { value = 0; }
                if (array.length >= size)
                    return array;
                return Utils.setArraySize(array, size, value);
            };
            Utils.newArray = function (size, defaultValue) {
                var array = new Array(size);
                for (var i = 0; i < size; i++)
                    array[i] = defaultValue;
                return array;
            };
            Utils.newFloatArray = function (size) {
                if (Utils.SUPPORTS_TYPED_ARRAYS) {
                    return new Float32Array(size);
                }
                else {
                    var array = new Array(size);
                    for (var i = 0; i < array.length; i++)
                        array[i] = 0;
                    return array;
                }
            };
            Utils.newShortArray = function (size) {
                if (Utils.SUPPORTS_TYPED_ARRAYS) {
                    return new Int16Array(size);
                }
                else {
                    var array = new Array(size);
                    for (var i = 0; i < array.length; i++)
                        array[i] = 0;
                    return array;
                }
            };
            Utils.toFloatArray = function (array) {
                return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
            };
            Utils.toSinglePrecision = function (value) {
                return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
            };
            Utils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== "undefined";
            return Utils;
        }());
        core.Utils = Utils;
        var DebugUtils = (function () {
            function DebugUtils() {
            }
            DebugUtils.logBones = function (skeleton) {
                for (var i = 0; i < skeleton.bones.length; i++) {
                    var bone = skeleton.bones[i];
                    var mat = bone.matrix;
                    console.log(bone.data.name + ", " + mat.a + ", " + mat.b + ", " + mat.c + ", " + mat.d + ", " + mat.tx + ", " + mat.ty);
                }
            };
            return DebugUtils;
        }());
        core.DebugUtils = DebugUtils;
        var Pool = (function () {
            function Pool(instantiator) {
                this.items = new Array();
                this.instantiator = instantiator;
            }
            Pool.prototype.obtain = function () {
                return this.items.length > 0 ? this.items.pop() : this.instantiator();
            };
            Pool.prototype.free = function (item) {
                if (item.reset)
                    item.reset();
                this.items.push(item);
            };
            Pool.prototype.freeAll = function (items) {
                for (var i = 0; i < items.length; i++) {
                    if (items[i].reset)
                        items[i].reset();
                    this.items[i] = items[i];
                }
            };
            Pool.prototype.clear = function () {
                this.items.length = 0;
            };
            return Pool;
        }());
        core.Pool = Pool;
        var Vector2 = (function () {
            function Vector2(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.x = x;
                this.y = y;
            }
            Vector2.prototype.set = function (x, y) {
                this.x = x;
                this.y = y;
                return this;
            };
            Vector2.prototype.length = function () {
                var x = this.x;
                var y = this.y;
                return Math.sqrt(x * x + y * y);
            };
            Vector2.prototype.normalize = function () {
                var len = this.length();
                if (len != 0) {
                    this.x /= len;
                    this.y /= len;
                }
                return this;
            };
            return Vector2;
        }());
        core.Vector2 = Vector2;
        var TimeKeeper = (function () {
            function TimeKeeper() {
                this.maxDelta = 0.064;
                this.framesPerSecond = 0;
                this.delta = 0;
                this.totalTime = 0;
                this.lastTime = Date.now() / 1000;
                this.frameCount = 0;
                this.frameTime = 0;
            }
            TimeKeeper.prototype.update = function () {
                var now = Date.now() / 1000;
                this.delta = now - this.lastTime;
                this.frameTime += this.delta;
                this.totalTime += this.delta;
                if (this.delta > this.maxDelta)
                    this.delta = this.maxDelta;
                this.lastTime = now;
                this.frameCount++;
                if (this.frameTime > 1) {
                    this.framesPerSecond = this.frameCount / this.frameTime;
                    this.frameTime = 0;
                    this.frameCount = 0;
                }
            };
            return TimeKeeper;
        }());
        core.TimeKeeper = TimeKeeper;
        var WindowedMean = (function () {
            function WindowedMean(windowSize) {
                if (windowSize === void 0) { windowSize = 32; }
                this.addedValues = 0;
                this.lastValue = 0;
                this.mean = 0;
                this.dirty = true;
                this.values = new Array(windowSize);
            }
            WindowedMean.prototype.hasEnoughData = function () {
                return this.addedValues >= this.values.length;
            };
            WindowedMean.prototype.addValue = function (value) {
                if (this.addedValues < this.values.length)
                    this.addedValues++;
                this.values[this.lastValue++] = value;
                if (this.lastValue > this.values.length - 1)
                    this.lastValue = 0;
                this.dirty = true;
            };
            WindowedMean.prototype.getMean = function () {
                if (this.hasEnoughData()) {
                    if (this.dirty) {
                        var mean = 0;
                        for (var i = 0; i < this.values.length; i++) {
                            mean += this.values[i];
                        }
                        this.mean = mean / this.values.length;
                        this.dirty = false;
                    }
                    return this.mean;
                }
                else {
                    return 0;
                }
            };
            return WindowedMean;
        }());
        core.WindowedMean = WindowedMean;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var Attachment = (function () {
            function Attachment(name) {
                if (name == null)
                    throw new Error("name cannot be null.");
                this.name = name;
            }
            return Attachment;
        }());
        core.Attachment = Attachment;
        var VertexAttachment = (function (_super) {
            __extends(VertexAttachment, _super);
            function VertexAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.id = (VertexAttachment.nextID++ & 65535) << 11;
                _this.worldVerticesLength = 0;
                return _this;
            }
            VertexAttachment.prototype.computeWorldVerticesOld = function (slot, worldVertices) {
                this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
            };
            VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {
                count = offset + (count >> 1) * stride;
                var skeleton = slot.bone.skeleton;
                var deformArray = slot.attachmentVertices;
                var vertices = this.vertices;
                var bones = this.bones;
                if (bones == null) {
                    if (deformArray.length > 0)
                        vertices = deformArray;
                    var mat = slot.bone.matrix;
                    var x = mat.tx;
                    var y = mat.ty;
                    var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
                    for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {
                        var vx = vertices[v_1], vy = vertices[v_1 + 1];
                        worldVertices[w] = vx * a + vy * b + x;
                        worldVertices[w + 1] = vx * c + vy * d + y;
                    }
                    return;
                }
                var v = 0, skip = 0;
                for (var i = 0; i < start; i += 2) {
                    var n = bones[v];
                    v += n + 1;
                    skip += n;
                }
                var skeletonBones = skeleton.bones;
                if (deformArray.length == 0) {
                    for (var w = offset, b = skip * 3; w < count; w += stride) {
                        var wx = 0, wy = 0;
                        var n = bones[v++];
                        n += v;
                        for (; v < n; v++, b += 3) {
                            var mat = skeletonBones[bones[v]].matrix;
                            var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
                        }
                        worldVertices[w] = wx;
                        worldVertices[w + 1] = wy;
                    }
                }
                else {
                    var deform = deformArray;
                    for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
                        var wx = 0, wy = 0;
                        var n = bones[v++];
                        n += v;
                        for (; v < n; v++, b += 3, f += 2) {
                            var mat = skeletonBones[bones[v]].matrix;
                            var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
                        }
                        worldVertices[w] = wx;
                        worldVertices[w + 1] = wy;
                    }
                }
            };
            VertexAttachment.prototype.applyDeform = function (sourceAttachment) {
                return this == sourceAttachment;
            };
            VertexAttachment.nextID = 0;
            return VertexAttachment;
        }(Attachment));
        core.VertexAttachment = VertexAttachment;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var AttachmentType;
        (function (AttachmentType) {
            AttachmentType[AttachmentType["Region"] = 0] = "Region";
            AttachmentType[AttachmentType["BoundingBox"] = 1] = "BoundingBox";
            AttachmentType[AttachmentType["Mesh"] = 2] = "Mesh";
            AttachmentType[AttachmentType["LinkedMesh"] = 3] = "LinkedMesh";
            AttachmentType[AttachmentType["Path"] = 4] = "Path";
            AttachmentType[AttachmentType["Point"] = 5] = "Point";
        })(AttachmentType = core.AttachmentType || (core.AttachmentType = {}));
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var BoundingBoxAttachment = (function (_super) {
            __extends(BoundingBoxAttachment, _super);
            function BoundingBoxAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.color = new core.Color(1, 1, 1, 1);
                return _this;
            }
            return BoundingBoxAttachment;
        }(core.VertexAttachment));
        core.BoundingBoxAttachment = BoundingBoxAttachment;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var ClippingAttachment = (function (_super) {
            __extends(ClippingAttachment, _super);
            function ClippingAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.color = new core.Color(0.2275, 0.2275, 0.8078, 1);
                return _this;
            }
            return ClippingAttachment;
        }(core.VertexAttachment));
        core.ClippingAttachment = ClippingAttachment;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var MeshAttachment = (function (_super) {
            __extends(MeshAttachment, _super);
            function MeshAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.color = new core.Color(1, 1, 1, 1);
                _this.inheritDeform = false;
                _this.tempColor = new core.Color(0, 0, 0, 0);
                return _this;
            }
            MeshAttachment.prototype.updateUVs = function (region, uvs) {
                var regionUVs = this.regionUVs;
                var n = regionUVs.length;
                if (!uvs || uvs.length != n) {
                    uvs = core.Utils.newFloatArray(n);
                }
                if (region == null) {
                    return;
                }
                var texture = region.texture;
                var r = texture._uvs;
                var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;
                var x = region.offsetX, y = region.pixiOffsetY;
                for (var i = 0; i < n; i += 2) {
                    var u = this.regionUVs[i], v = this.regionUVs[i + 1];
                    u = (u * w2 - x) / w1;
                    v = (v * h2 - y) / h1;
                    uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;
                    uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;
                }
                return uvs;
            };
            MeshAttachment.prototype.applyDeform = function (sourceAttachment) {
                return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);
            };
            MeshAttachment.prototype.getParentMesh = function () {
                return this.parentMesh;
            };
            MeshAttachment.prototype.setParentMesh = function (parentMesh) {
                this.parentMesh = parentMesh;
                if (parentMesh != null) {
                    this.bones = parentMesh.bones;
                    this.vertices = parentMesh.vertices;
                    this.worldVerticesLength = parentMesh.worldVerticesLength;
                    this.regionUVs = parentMesh.regionUVs;
                    this.triangles = parentMesh.triangles;
                    this.hullLength = parentMesh.hullLength;
                    this.worldVerticesLength = parentMesh.worldVerticesLength;
                }
            };
            return MeshAttachment;
        }(core.VertexAttachment));
        core.MeshAttachment = MeshAttachment;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var PathAttachment = (function (_super) {
            __extends(PathAttachment, _super);
            function PathAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.closed = false;
                _this.constantSpeed = false;
                _this.color = new core.Color(1, 1, 1, 1);
                return _this;
            }
            return PathAttachment;
        }(core.VertexAttachment));
        core.PathAttachment = PathAttachment;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var PointAttachment = (function (_super) {
            __extends(PointAttachment, _super);
            function PointAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.color = new core.Color(0.38, 0.94, 0, 1);
                return _this;
            }
            PointAttachment.prototype.computeWorldPosition = function (bone, point) {
                var mat = bone.matrix;
                point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
                point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
                return point;
            };
            PointAttachment.prototype.computeWorldRotation = function (bone) {
                var mat = bone.matrix;
                var cos = core.MathUtils.cosDeg(this.rotation), sin = core.MathUtils.sinDeg(this.rotation);
                var x = cos * mat.a + sin * mat.c;
                var y = cos * mat.b + sin * mat.d;
                return Math.atan2(y, x) * core.MathUtils.radDeg;
            };
            return PointAttachment;
        }(core.VertexAttachment));
        core.PointAttachment = PointAttachment;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var RegionAttachment = (function (_super) {
            __extends(RegionAttachment, _super);
            function RegionAttachment(name) {
                var _this = _super.call(this, name) || this;
                _this.x = 0;
                _this.y = 0;
                _this.scaleX = 1;
                _this.scaleY = 1;
                _this.rotation = 0;
                _this.width = 0;
                _this.height = 0;
                _this.color = new core.Color(1, 1, 1, 1);
                _this.offset = core.Utils.newFloatArray(8);
                _this.uvs = core.Utils.newFloatArray(8);
                _this.tempColor = new core.Color(1, 1, 1, 1);
                return _this;
            }
            RegionAttachment.prototype.updateOffset = function () {
                var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
                var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
                var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
                var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
                var localX2 = localX + this.region.width * regionScaleX;
                var localY2 = localY + this.region.height * regionScaleY;
                var radians = this.rotation * Math.PI / 180;
                var cos = Math.cos(radians);
                var sin = Math.sin(radians);
                var localXCos = localX * cos + this.x;
                var localXSin = localX * sin;
                var localYCos = localY * cos + this.y;
                var localYSin = localY * sin;
                var localX2Cos = localX2 * cos + this.x;
                var localX2Sin = localX2 * sin;
                var localY2Cos = localY2 * cos + this.y;
                var localY2Sin = localY2 * sin;
                var offset = this.offset;
                offset[RegionAttachment.OX1] = localXCos - localYSin;
                offset[RegionAttachment.OY1] = localYCos + localXSin;
                offset[RegionAttachment.OX2] = localXCos - localY2Sin;
                offset[RegionAttachment.OY2] = localY2Cos + localXSin;
                offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;
                offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;
                offset[RegionAttachment.OX4] = localX2Cos - localYSin;
                offset[RegionAttachment.OY4] = localYCos + localX2Sin;
            };
            RegionAttachment.prototype.setRegion = function (region) {
                this.region = region;
                var uvs = this.uvs;
                if (region.rotate) {
                    uvs[2] = region.u;
                    uvs[3] = region.v2;
                    uvs[4] = region.u;
                    uvs[5] = region.v;
                    uvs[6] = region.u2;
                    uvs[7] = region.v;
                    uvs[0] = region.u2;
                    uvs[1] = region.v2;
                }
                else {
                    uvs[0] = region.u;
                    uvs[1] = region.v2;
                    uvs[2] = region.u;
                    uvs[3] = region.v;
                    uvs[4] = region.u2;
                    uvs[5] = region.v;
                    uvs[6] = region.u2;
                    uvs[7] = region.v2;
                }
            };
            RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {
                var vertexOffset = this.offset;
                var mat = bone.matrix;
                var x = mat.tx, y = mat.ty;
                var a = mat.a, b = mat.c, c = mat.b, d = mat.d;
                var offsetX = 0, offsetY = 0;
                offsetX = vertexOffset[RegionAttachment.OX1];
                offsetY = vertexOffset[RegionAttachment.OY1];
                worldVertices[offset] = offsetX * a + offsetY * b + x;
                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                offset += stride;
                offsetX = vertexOffset[RegionAttachment.OX2];
                offsetY = vertexOffset[RegionAttachment.OY2];
                worldVertices[offset] = offsetX * a + offsetY * b + x;
                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                offset += stride;
                offsetX = vertexOffset[RegionAttachment.OX3];
                offsetY = vertexOffset[RegionAttachment.OY3];
                worldVertices[offset] = offsetX * a + offsetY * b + x;
                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                offset += stride;
                offsetX = vertexOffset[RegionAttachment.OX4];
                offsetY = vertexOffset[RegionAttachment.OY4];
                worldVertices[offset] = offsetX * a + offsetY * b + x;
                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
            };
            RegionAttachment.OX1 = 0;
            RegionAttachment.OY1 = 1;
            RegionAttachment.OX2 = 2;
            RegionAttachment.OY2 = 3;
            RegionAttachment.OX3 = 4;
            RegionAttachment.OY3 = 5;
            RegionAttachment.OX4 = 6;
            RegionAttachment.OY4 = 7;
            RegionAttachment.X1 = 0;
            RegionAttachment.Y1 = 1;
            RegionAttachment.C1R = 2;
            RegionAttachment.C1G = 3;
            RegionAttachment.C1B = 4;
            RegionAttachment.C1A = 5;
            RegionAttachment.U1 = 6;
            RegionAttachment.V1 = 7;
            RegionAttachment.X2 = 8;
            RegionAttachment.Y2 = 9;
            RegionAttachment.C2R = 10;
            RegionAttachment.C2G = 11;
            RegionAttachment.C2B = 12;
            RegionAttachment.C2A = 13;
            RegionAttachment.U2 = 14;
            RegionAttachment.V2 = 15;
            RegionAttachment.X3 = 16;
            RegionAttachment.Y3 = 17;
            RegionAttachment.C3R = 18;
            RegionAttachment.C3G = 19;
            RegionAttachment.C3B = 20;
            RegionAttachment.C3A = 21;
            RegionAttachment.U3 = 22;
            RegionAttachment.V3 = 23;
            RegionAttachment.X4 = 24;
            RegionAttachment.Y4 = 25;
            RegionAttachment.C4R = 26;
            RegionAttachment.C4G = 27;
            RegionAttachment.C4B = 28;
            RegionAttachment.C4A = 29;
            RegionAttachment.U4 = 30;
            RegionAttachment.V4 = 31;
            return RegionAttachment;
        }(core.Attachment));
        core.RegionAttachment = RegionAttachment;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var JitterEffect = (function () {
            function JitterEffect(jitterX, jitterY) {
                this.jitterX = 0;
                this.jitterY = 0;
                this.jitterX = jitterX;
                this.jitterY = jitterY;
            }
            JitterEffect.prototype.begin = function (skeleton) {
            };
            JitterEffect.prototype.transform = function (position, uv, light, dark) {
                position.x += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
                position.y += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
            };
            JitterEffect.prototype.end = function () {
            };
            return JitterEffect;
        }());
        core.JitterEffect = JitterEffect;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    var core;
    (function (core) {
        var SwirlEffect = (function () {
            function SwirlEffect(radius) {
                this.centerX = 0;
                this.centerY = 0;
                this.radius = 0;
                this.angle = 0;
                this.worldX = 0;
                this.worldY = 0;
                this.radius = radius;
            }
            SwirlEffect.prototype.begin = function (skeleton) {
                this.worldX = skeleton.x + this.centerX;
                this.worldY = skeleton.y + this.centerY;
            };
            SwirlEffect.prototype.transform = function (position, uv, light, dark) {
                var radAngle = this.angle * core.MathUtils.degreesToRadians;
                var x = position.x - this.worldX;
                var y = position.y - this.worldY;
                var dist = Math.sqrt(x * x + y * y);
                if (dist < this.radius) {
                    var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
                    var cos = Math.cos(theta);
                    var sin = Math.sin(theta);
                    position.x = cos * x - sin * y + this.worldX;
                    position.y = sin * x + cos * y + this.worldY;
                }
            };
            SwirlEffect.prototype.end = function () {
            };
            SwirlEffect.interpolation = new core.PowOut(2);
            return SwirlEffect;
        }());
        core.SwirlEffect = SwirlEffect;
    })(core = pixi_spine.core || (pixi_spine.core = {}));
})(pixi_spine || (pixi_spine = {}));
var pixi_spine;
(function (pixi_spine) {
    function isJson(resource) {
        return resource.type === PIXI.loaders.Resource.TYPE.JSON;
    }
    function atlasParser() {
        return function (resource, next) {
            if (!resource.data ||
                !isJson(resource) ||
                !resource.data.bones) {
                return next();
            }
            var metadata = resource.metadata || {};
            var metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;
            var metadataAtlas = metadata ? resource.metadata.spineAtlas : null;
            if (metadataAtlas === false) {
                return next();
            }
            if (metadataAtlas && metadataAtlas.pages) {
                var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(metadataAtlas));
                var skeletonData = spineJsonParser.readSkeletonData(resource.data);
                resource.spineData = skeletonData;
                resource.spineAtlas = metadataAtlas;
                return next();
            }
            var metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';
            var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;
            atlasPath = atlasPath.replace(this.baseUrl, '');
            var atlasOptions = {
                crossOrigin: resource.crossOrigin,
                xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,
                metadata: metadata.spineMetadata || null,
                parentResource: resource
            };
            var imageOptions = {
                crossOrigin: resource.crossOrigin,
                metadata: metadata.imageMetadata || null,
                parentResource: resource
            };
            var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);
            baseUrl = baseUrl.replace(this.baseUrl, '');
            var adapter = metadata.images ? staticImageLoader(metadata.images)
                : metadata.image ? staticImageLoader({ 'default': metadata.image })
                    : metadata.imageLoader ? metadata.imageLoader(this, resource.name + '_atlas_page_', baseUrl, imageOptions)
                        : imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);
            this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {
                new pixi_spine.core.TextureAtlas(atlasResource.xhr.responseText, adapter, function (spineAtlas) {
                    var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(spineAtlas));
                    if (metadataSkeletonScale) {
                        spineJsonParser.scale = metadataSkeletonScale;
                    }
                    resource.spineData = spineJsonParser.readSkeletonData(resource.data);
                    resource.spineAtlas = spineAtlas;
                    next();
                });
            });
        };
    }
    pixi_spine.atlasParser = atlasParser;
    function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {
        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {
            baseUrl += '/';
        }
        return function (line, callback) {
            var name = namePrefix + line;
            var url = baseUrl + line;
            loader.add(name, url, imageOptions, function (resource) {
                callback(resource.texture.baseTexture);
            });
        };
    }
    pixi_spine.imageLoaderAdapter = imageLoaderAdapter;
    function syncImageLoaderAdapter(baseUrl, crossOrigin) {
        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {
            baseUrl += '/';
        }
        return function (line, callback) {
            callback(PIXI.BaseTexture.fromImage(line, crossOrigin));
        };
    }
    pixi_spine.syncImageLoaderAdapter = syncImageLoaderAdapter;
    function staticImageLoader(pages) {
        return function (line, callback) {
            var page = pages[line] || pages['default'];
            if (page && page.baseTexture)
                callback(page.baseTexture);
            else
                callback(page);
        };
    }
    pixi_spine.staticImageLoader = staticImageLoader;
    PIXI.loaders.Loader.addPixiMiddleware(atlasParser);
    PIXI.loader.use(atlasParser());
})(pixi_spine || (pixi_spine = {}));
(function () {
    if (!Math.fround) {
        Math.fround = Math.fround = (function (array) {
            return function (x) {
                return array[0] = x, array[0];
            };
        })(new Float32Array(1));
    }
})();
var pixi_spine;
(function (pixi_spine) {
    pixi_spine.core.Bone.yDown = true;
    var tempRgb = [0, 0, 0];
    var SpineSprite = (function (_super) {
        __extends(SpineSprite, _super);
        function SpineSprite() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.region = null;
            return _this;
        }
        return SpineSprite;
    }(PIXI.Sprite));
    pixi_spine.SpineSprite = SpineSprite;
    var SpineMesh = (function (_super) {
        __extends(SpineMesh, _super);
        function SpineMesh(texture, vertices, uvs, indices, drawMode) {
            return _super.call(this, texture, vertices, uvs, indices, drawMode) || this;
        }
        return SpineMesh;
    }(PIXI.mesh.Mesh));
    pixi_spine.SpineMesh = SpineMesh;
    var Spine = (function (_super) {
        __extends(Spine, _super);
        function Spine(spineData) {
            var _this = _super.call(this) || this;
            if (!spineData) {
                throw new Error('The spineData param is required.');
            }
            if ((typeof spineData) === "string") {
                throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
            }
            _this.spineData = spineData;
            _this.skeleton = new pixi_spine.core.Skeleton(spineData);
            _this.skeleton.updateWorldTransform();
            _this.stateData = new pixi_spine.core.AnimationStateData(spineData);
            _this.state = new pixi_spine.core.AnimationState(_this.stateData);
            _this.slotContainers = [];
            _this.tempClipContainers = [];
            for (var i = 0, n = _this.skeleton.slots.length; i < n; i++) {
                var slot = _this.skeleton.slots[i];
                var attachment = slot.attachment;
                var slotContainer = _this.newContainer();
                _this.slotContainers.push(slotContainer);
                _this.addChild(slotContainer);
                _this.tempClipContainers.push(null);
                if (attachment instanceof pixi_spine.core.RegionAttachment) {
                    var spriteName = attachment.region.name;
                    var sprite = _this.createSprite(slot, attachment, spriteName);
                    slot.currentSprite = sprite;
                    slot.currentSpriteName = spriteName;
                    slotContainer.addChild(sprite);
                }
                else if (attachment instanceof pixi_spine.core.MeshAttachment) {
                    var mesh = _this.createMesh(slot, attachment);
                    slot.currentMesh = mesh;
                    slot.currentMeshName = attachment.name;
                    slotContainer.addChild(mesh);
                }
                else if (attachment instanceof pixi_spine.core.ClippingAttachment) {
                    _this.createGraphics(slot, attachment);
                    slotContainer.addChild(slot.clippingContainer);
                    slotContainer.addChild(slot.currentGraphics);
                }
                else {
                    continue;
                }
            }
            _this.autoUpdate = true;
            _this.tintRgb = new Float32Array([1, 1, 1]);
            return _this;
        }
        Object.defineProperty(Spine.prototype, "autoUpdate", {
            get: function () {
                return (this.updateTransform === Spine.prototype.autoUpdateTransform);
            },
            set: function (value) {
                this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Spine.prototype, "tint", {
            get: function () {
                return PIXI.utils.rgb2hex(this.tintRgb);
            },
            set: function (value) {
                this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);
            },
            enumerable: true,
            configurable: true
        });
        Spine.prototype.update = function (dt) {
            this.state.update(dt);
            this.state.apply(this.skeleton);
            this.skeleton.updateWorldTransform();
            var slots = this.skeleton.slots;
            var globalClr = this.color;
            var light = null, dark = null;
            if (globalClr) {
                light = globalClr.light;
                dark = globalClr.dark;
            }
            else {
                light = this.tintRgb;
            }
            var thack = PIXI.TransformBase && (this.transformHack() == 1);
            for (var i = 0, n = slots.length; i < n; i++) {
                var slot = slots[i];
                var attachment = slot.attachment;
                var slotContainer = this.slotContainers[i];
                if (!attachment) {
                    slotContainer.visible = false;
                    continue;
                }
                var spriteColor = null;
                var attColor = attachment.color;
                if (attachment instanceof pixi_spine.core.RegionAttachment) {
                    var region = attachment.region;
                    if (region) {
                        if (slot.currentMesh) {
                            slot.currentMesh.visible = false;
                            slot.currentMesh = null;
                            slot.currentMeshName = undefined;
                        }
                        var ar = region;
                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {
                            var spriteName = ar.name;
                            if (slot.currentSprite) {
                                slot.currentSprite.visible = false;
                            }
                            slot.sprites = slot.sprites || {};
                            if (slot.sprites[spriteName] !== undefined) {
                                slot.sprites[spriteName].visible = true;
                            }
                            else {
                                var sprite = this.createSprite(slot, attachment, spriteName);
                                slotContainer.addChild(sprite);
                            }
                            slot.currentSprite = slot.sprites[spriteName];
                            slot.currentSpriteName = spriteName;
                        }
                    }
                    if (slotContainer.transform) {
                        var transform = slotContainer.transform;
                        var transAny = transform;
                        var lt = null;
                        if (transAny.matrix2d) {
                            lt = transAny.matrix2d;
                            transAny._dirtyVersion++;
                            transAny.version = transAny._dirtyVersion;
                            transAny.isStatic = true;
                            transAny.operMode = 0;
                        }
                        else {
                            if (thack) {
                                if (transAny.position) {
                                    transform = new PIXI.TransformBase();
                                    slotContainer.transform = transform;
                                }
                                lt = transform.localTransform;
                            }
                            else {
                                transAny.setFromMatrix(slot.bone.matrix);
                            }
                        }
                        if (lt) {
                            slot.bone.matrix.copy(lt);
                        }
                    }
                    else {
                        var lt = slotContainer.localTransform || new PIXI.Matrix();
                        slot.bone.matrix.copy(lt);
                        slotContainer.localTransform = lt;
                        slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;
                    }
                    if (slot.currentSprite.color) {
                        spriteColor = slot.currentSprite.color;
                    }
                    else {
                        tempRgb[0] = light[0] * slot.color.r * attColor.r;
                        tempRgb[1] = light[1] * slot.color.g * attColor.g;
                        tempRgb[2] = light[2] * slot.color.b * attColor.b;
                        slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);
                    }
                    slot.currentSprite.blendMode = slot.blendMode;
                }
                else if (attachment instanceof pixi_spine.core.MeshAttachment) {
                    if (slot.currentSprite) {
                        slot.currentSprite.visible = false;
                        slot.currentSprite = null;
                        slot.currentSpriteName = undefined;
                        if (slotContainer.transform) {
                            slotContainer.transform = new PIXI.TransformStatic();
                        }
                        else {
                            slotContainer.localTransform = new PIXI.Matrix();
                            slotContainer.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;
                        }
                    }
                    if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {
                        var meshName = attachment.name;
                        if (slot.currentMesh) {
                            slot.currentMesh.visible = false;
                        }
                        slot.meshes = slot.meshes || {};
                        if (slot.meshes[meshName] !== undefined) {
                            slot.meshes[meshName].visible = true;
                        }
                        else {
                            var mesh = this.createMesh(slot, attachment);
                            slotContainer.addChild(mesh);
                        }
                        slot.currentMesh = slot.meshes[meshName];
                        slot.currentMeshName = meshName;
                    }
                    attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);
                    if (slot.currentMesh.color) {
                        spriteColor = slot.currentMesh.color;
                    }
                    else if (PIXI.VERSION[0] !== '3') {
                        var tintRgb = slot.currentMesh.tintRgb;
                        tintRgb[0] = light[0] * slot.color.r * attColor.r;
                        tintRgb[1] = light[1] * slot.color.g * attColor.g;
                        tintRgb[2] = light[2] * slot.color.b * attColor.b;
                    }
                    slot.currentMesh.blendMode = slot.blendMode;
                }
                else if (attachment instanceof pixi_spine.core.ClippingAttachment) {
                    if (!slot.currentGraphics) {
                        this.createGraphics(slot, attachment);
                        slotContainer.addChild(slot.clippingContainer);
                        slotContainer.addChild(slot.currentGraphics);
                    }
                    this.updateGraphics(slot, attachment);
                }
                else {
                    slotContainer.visible = false;
                    continue;
                }
                slotContainer.visible = true;
                if (spriteColor) {
                    var r0 = slot.color.r * attColor.r;
                    var g0 = slot.color.g * attColor.g;
                    var b0 = slot.color.b * attColor.b;
                    spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));
                    if (slot.darkColor) {
                        r0 = slot.darkColor.r;
                        g0 = slot.darkColor.g;
                        b0 = slot.darkColor.b;
                    }
                    else {
                        r0 = 0.0;
                        g0 = 0.0;
                        b0 = 0.0;
                    }
                    spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
                }
                slotContainer.alpha = slot.color.a;
            }
            var drawOrder = this.skeleton.drawOrder;
            var clippingAttachment = null;
            var clippingContainer = null;
            for (var i = 0, n = drawOrder.length; i < n; i++) {
                var slot = slots[drawOrder[i].data.index];
                var slotContainer = this.slotContainers[drawOrder[i].data.index];
                if (!clippingContainer) {
                    if (slotContainer.parent !== this) {
                        slotContainer.parent.removeChild(slotContainer);
                        slotContainer.parent = this;
                    }
                }
                if (slot.currentGraphics && slot.attachment) {
                    clippingContainer = slot.clippingContainer;
                    clippingAttachment = slot.attachment;
                    clippingContainer.children.length = 0;
                    this.children[i] = slotContainer;
                    if (clippingAttachment.endSlot == slot.data) {
                        clippingContainer.renderable = false;
                        clippingContainer = null;
                        clippingAttachment = null;
                    }
                }
                else {
                    if (clippingContainer) {
                        var c = this.tempClipContainers[i];
                        if (!c) {
                            c = this.tempClipContainers[i] = this.newContainer();
                            c.visible = false;
                        }
                        this.children[i] = c;
                        slotContainer.parent = null;
                        clippingContainer.addChild(slotContainer);
                        if (clippingAttachment.endSlot == slot.data) {
                            clippingContainer.renderable = true;
                            clippingContainer = null;
                            clippingAttachment = null;
                        }
                    }
                    else {
                        this.children[i] = slotContainer;
                    }
                }
            }
        };
        ;
        Spine.prototype.setSpriteRegion = function (attachment, sprite, region) {
            sprite.region = region;
            sprite.texture = region.texture;
            if (!region.size) {
                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;
                sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;
            }
            else {
                sprite.scale.x = region.size.width / region.originalWidth;
                sprite.scale.y = -region.size.height / region.originalHeight;
            }
        };
        Spine.prototype.setMeshRegion = function (attachment, mesh, region) {
            mesh.region = region;
            mesh.texture = region.texture;
            region.texture._updateUvs();
            attachment.updateUVs(region, mesh.uvs);
            mesh.dirty++;
        };
        Spine.prototype.autoUpdateTransform = function () {
            if (Spine.globalAutoUpdate) {
                this.lastTime = this.lastTime || Date.now();
                var timeDelta = (Date.now() - this.lastTime) * 0.001;
                this.lastTime = Date.now();
                this.update(timeDelta);
            }
            else {
                this.lastTime = 0;
            }
            PIXI.Container.prototype.updateTransform.call(this);
        };
        ;
        Spine.prototype.createSprite = function (slot, attachment, defName) {
            var region = attachment.region;
            if (slot.tempAttachment === attachment) {
                region = slot.tempRegion;
                slot.tempAttachment = null;
                slot.tempRegion = null;
            }
            var texture = region.texture;
            var sprite = this.newSprite(texture);
            sprite.rotation = attachment.rotation * pixi_spine.core.MathUtils.degRad;
            sprite.anchor.x = 0.5;
            sprite.anchor.y = 0.5;
            sprite.position.x = attachment.x;
            sprite.position.y = attachment.y;
            sprite.alpha = attachment.color.a;
            sprite.region = attachment.region;
            this.setSpriteRegion(attachment, sprite, attachment.region);
            slot.sprites = slot.sprites || {};
            slot.sprites[defName] = sprite;
            return sprite;
        };
        ;
        Spine.prototype.createMesh = function (slot, attachment) {
            var region = attachment.region;
            if (slot.tempAttachment === attachment) {
                region = slot.tempRegion;
                slot.tempAttachment = null;
                slot.tempRegion = null;
            }
            var strip = this.newMesh(region.texture, new Float32Array(attachment.regionUVs.length), new Float32Array(attachment.regionUVs.length), new Uint16Array(attachment.triangles), PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);
            strip.canvasPadding = 1.5;
            strip.alpha = attachment.color.a;
            strip.region = attachment.region;
            this.setMeshRegion(attachment, strip, region);
            slot.meshes = slot.meshes || {};
            slot.meshes[attachment.name] = strip;
            return strip;
        };
        ;
        Spine.prototype.createGraphics = function (slot, clip) {
            var graphics = this.newGraphics();
            var poly = new PIXI.Polygon([]);
            graphics.clear();
            graphics.beginFill(0xffffff, 1);
            graphics.drawPolygon(poly);
            graphics.renderable = false;
            slot.currentGraphics = graphics;
            slot.clippingContainer = this.newContainer();
            slot.clippingContainer.mask = slot.currentGraphics;
            return graphics;
        };
        Spine.prototype.updateGraphics = function (slot, clip) {
            var vertices = slot.currentGraphics.graphicsData[0].shape.points;
            var n = clip.worldVerticesLength;
            vertices.length = n;
            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
            slot.currentGraphics.dirty++;
            slot.currentGraphics.clearDirty++;
        };
        Spine.prototype.hackTextureBySlotIndex = function (slotIndex, texture, size) {
            if (texture === void 0) { texture = null; }
            if (size === void 0) { size = null; }
            var slot = this.skeleton.slots[slotIndex];
            if (!slot) {
                return false;
            }
            var attachment = slot.attachment;
            var region = attachment.region;
            if (texture) {
                region = new pixi_spine.core.TextureRegion();
                region.texture = texture;
                region.size = size;
            }
            if (slot.currentSprite && slot.currentSprite.region != region) {
                this.setSpriteRegion(attachment, slot.currentSprite, region);
                slot.currentSprite.region = region;
            }
            else if (slot.currentMesh && slot.currentMesh.region != region) {
                this.setMeshRegion(attachment, slot.currentMesh, region);
            }
            else {
                slot.tempRegion = region;
                slot.tempAttachment = attachment;
            }
            return true;
        };
        Spine.prototype.hackTextureBySlotName = function (slotName, texture, size) {
            if (texture === void 0) { texture = null; }
            if (size === void 0) { size = null; }
            var index = this.skeleton.findSlotIndex(slotName);
            if (index == -1) {
                return false;
            }
            return this.hackTextureBySlotIndex(index, texture, size);
        };
        Spine.prototype.newContainer = function () {
            return new PIXI.Container();
        };
        Spine.prototype.newSprite = function (tex) {
            return new SpineSprite(tex);
        };
        Spine.prototype.newGraphics = function () {
            return new PIXI.Graphics();
        };
        Spine.prototype.newMesh = function (texture, vertices, uvs, indices, drawMode) {
            return new SpineMesh(texture, vertices, uvs, indices, drawMode);
        };
        Spine.prototype.transformHack = function () {
            return 1;
        };
        Spine.globalAutoUpdate = true;
        Spine.clippingPolygon = [];
        return Spine;
    }(PIXI.Container));
    pixi_spine.Spine = Spine;
    function SlotContainerUpdateTransformV3() {
        var pt = this.parent.worldTransform;
        var wt = this.worldTransform;
        var lt = this.localTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this._currentBounds = null;
    }
})(pixi_spine || (pixi_spine = {}));
PIXI.spine = pixi_spine;
//# sourceMappingURL=pixi-spine.js.map
//******************************************************
//*****    Script Resource: FontExtension
//******************************************************

var defaultFontPadding = 10;

f_babas_regular.padding = defaultFontPadding;
f_babas_bold.padding = defaultFontPadding;
bitdust.padding = defaultFontPadding;

var oldDefaultSetter = tbVectorFont.prototype.setDefault;
tbVectorFont.prototype.setDefault = function() {
	oldDefaultSetter.call(this);

	this.padding = defaultFontPadding;
};

tbVectorFont.prototype.setShadow = function(obj, color, offsetX, offsetY, blur) {
    "use strict";
    if (obj === undefined) {
        this.shadow = { active: false, color: 'rgba(10, 10, 10, 0.3)', offsetX: 3, offsetY: 3, blur: 1, angle: Math.PI/6};
    } else if (obj instanceof Object)
    {
        this.shadow = { active: obj.active, color: obj.color, offsetX: obj.offsetX, offsetY: obj.offsetY, blur: obj.blur, angle: obj.angle};
    } else if (color === undefined) {
        this.shadow.active = obj;
    } else {
        this.shadow = { active: obj, color: color, offsetX: offsetX, offsetY: offsetY, blur: blur , angle: Math.PI/6};
    }

    this.setStyle();
};

tbVectorFont.prototype.setPadding = function(padding) {
	"use strict";
	
    this.padding = padding;
    this.setStyle();
};

var oldSetProperties = tbVectorFont.prototype.setProperties;
tbVectorFont.prototype.setProperties = function(properties) {

	if (!properties) properties = {};

	if (!properties.padding) { 
		properties.padding = defaultFontPadding;
	}

	oldSetProperties.call(this, properties);
};

var oldTextStyle = tbVectorFont.prototype.textStyle;
tbVectorFont.prototype.textStyle = function() {

	var style = oldTextStyle.call(this);
	style.align = this.align;

	return style;
};

var f_babas_regular_no_shadow = f_babas_regular.clone();
var f_babas_bold_no_shadow = f_babas_bold.clone();

var dropShadowFonts = [f_babas_regular, f_babas_bold];

for(var i = 0; i < dropShadowFonts.length; i++) {
	dropShadowFonts[i].setShadow({
		active: true,
		blur: 2,
		color: '#00264a',
		offsetX: 0,
		offsetY: 3
	});
}

// Hack to overwrite text to be always uppercase (required for new font)
var oldSetText = tbVectorFont.prototype.setText;
tbVectorFont.prototype.setText = function (text) {
	"use strict";

	if (text) {

		oldSetText.bind(this, text.toUpperCase())();
	}	
};

// Ne quitte pas
var f_lobby_title = f_babas_regular.clone();
f_lobby_title.fontSize = 40;
f_lobby_title.fillColor = "#FFFFCC";
f_lobby_title.stroke = "#001c35";
f_lobby_title.strokeWidth = 4;
f_lobby_title.setShadow(true, "#001c35", 0, 3, 0);

var f_lobby_header = f_babas_bold.clone();
f_lobby_header.fontSize = 38;
f_lobby_header.fillColor = "#FFFFCC";
f_lobby_header.stroke = "#002d57";
f_lobby_header.strokeWidth = 4;
f_lobby_header.setShadow(true, "#002d57", 0, 3, 0);
f_lobby_header.align = "center";
f_lobby_header.baseline = 'middle';

var f_lobby_playername = f_babas_bold_no_shadow.clone();
f_lobby_playername.fontSize = 40;
f_lobby_playername.fillColor = "#001c35";
//******************************************************
//*****    Script Resource: gameController
//******************************************************

// ***************************************
// gameController
//
// Each game must include a game controller that handle the running of
// the game. It must contain some methods that are called by the flow controller.
// The object is created by the flow controller.
//
// This version is just a template, although many games would not need more than just this.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 12-10-2015
// ***************************************

// Directives for jslint
/*global tbGame */
/*global tgfSettings */
/*global gameSettings, PlayController */


var playController = null;                  // Object controlling the play of the game

var gamesBackendService = null;

// The constructor 
var GameController = function() {
	"use strict";
	// Merge the settings into the total settings
	// When required settings can also be computed here and other initialization can take place
	tgfSettings.mergeSettings(gameSettings());
	TileMapValues.reset();

	console.log('GC::gameSettings are merged!!');
	console.log('	GC::', Environment.get() );
		
	tgfSettings.gamebot = tgfSettings.gamebot[Environment.get()];
	tgfSettings.gamesparks = tgfSettings.gamesparks[Environment.get()];

	// console.log('GA.before', tgfSettings.analytics);

	tgfSettings.analytics = tgfSettings.analytics[Environment.get()];
	
	tgfSettings.test = tgfSettings.test[Environment.get()];
	

	console.log('	GC::ANALYTICS::');
	console.log('	GC::analytics.gameAnalyticsGameKey ->', tgfSettings.analytics.gameAnalyticsGameKey);
	console.log('	GC::analytics.gameAnalyticsSecretKey ->', tgfSettings.analytics.gameAnalyticsSecretKey);
	
	console.log('	GC::GAMEBOT::');
	console.log('	GC::appId -> ', tgfSettings.gamebot.appId );
	console.log('	GC::appToken -> ', tgfSettings.gamebot.appToken );
	
	console.log('	GC::ADS::');
	console.log('	GC::placementID -> ', tgfSettings.ads.placementID );
	
	console.log('	GC::GAMESPARKS::');
	console.log('	GC::gamesparks.apiKey -> ', tgfSettings.gamesparks.apiKey );
	console.log('	GC::gamesparks.apiSecret -> ', tgfSettings.gamesparks.apiSecret );
	console.log('	GC::gamesparks.isProdVersion -> ', tgfSettings.gamesparks.isProdVersion );

};


// ***************************************
// Required methods
// ***************************************

// Start playing an instance (level) of the game
GameController.prototype.startPlay = function() {
	"use strict";

	// You normally create a play controller token here that controls the game play
	playController = new PlayController();
	// Only add it after it has been assigned to the variable!
	tbGame.addToken(playController);
	tbGame.addTokenTags(playController, ["play", "playcontroller"]);
};

// Stop playing an instance (level) the game, cleaning it up, should take care of removing all tokens
GameController.prototype.stopPlay = function() {
	"use strict";

	console.log('GC::GC.stopPlay');

	tbGame.removeToken(playController);	
};

// Pause playing (called e.g. when the options screen shows up) It should stack!
GameController.prototype.pausePlay = function() {
	"use strict";
	// tbGame.pauseTokens("play");
	
	if (this._canPause()) {

		tbGame.pauseTokens("timer");
		tbGame.pauseTokens("token");
	}
};

// Resumes playing (called e.g. when the options screen disappears) It should stack!
GameController.prototype.resumePlay = function() {
	"use strict";
	// tbGame.resumeTokens("play");
	
	if (this._canPause()) {

		tbGame.resumeTokens("timer");
		tbGame.resumeTokens("token");
	}
};

GameController.prototype.pauseUI = function() {
	"use strict";

	if (this._canPause()) {

		tbGame.pauseToken(playController.ui);
	}
};

GameController.prototype.resumeUI = function() {
	"use strict";

	if (this._canPause()) {

		tbGame.resumeToken(playController.ui);
	}
};

GameController.prototype._canPause = function() {

	var canPause = true;

	var md = UserDataController.getMatchData();

	if (md && md.isTimed) {
		canPause = false;
	}

	return canPause;
}

// ***************************************
// Optional methods
// ***************************************






//******************************************************
//*****    Token Resource: PlayController
//******************************************************

// ***************************************
// Definition of game token PlayController
// ***************************************

// The constructor for the PlayController game token.
var PlayController = function(x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth;
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;

	this.isPortraitMode = true;
	this._settingsOnTop = true;

	this.__isPlacing = null;
	Object.defineProperty(this, '_isPlacing', {
		get: function() {
			return this.__isPlacing
		}.bind(this),
		set: function(value) {
			this.__isPlacing = value;

			if (value) {
				AnalyticsService.setScreenName("setup_ships");
			} else {
				AnalyticsService.setScreenName("game");
			}
		}.bind(this)
	});
	this._isPlacing = false;
	this._isBotBattle = false;
	this._isRematch = false;

	this._isShowingIngameMenu = false;

	this.GameStatus = {
		win: true,
		loss: false,
		reason: {
			normal: 'normal',
			disconnect: 'disconnect',
			surrender: 'surrender'
		}
	};

	this._onboardingManager = new OnboardingManager();
};

// handleAdd is called when the token is (re-) added to the game.
PlayController.prototype.handleAdd = function() {
	"use strict";
	TileMapValues.reset();

	this._initialize({}, false)
};

PlayController.prototype._initialize = function(data, shouldShowMatchCompleteMessage) {
	console.log("data", data)
	var matchId = UserDataController.getCurrentMatchId();
	var shouldShowNotFriendsMessage = false;

	backgrounds = [s_ingame_background, s_background_tropicalbeach, s_background_artic];
	backgroundLoadMoment = "backgrounds_8x8"

	this._backgroundImage = backgrounds[Math.round(Math.random() * (backgrounds.length-1))];
	Sequencer.require([backgroundLoadMoment]).then(function() {
		tgfGraphics.addChild(this._backgroundImage.sprite);

		this._pauseManager = new PauseManager();

		//Init Game
		this._setupBoard();

		this._setupRadar();

		this._addIngameMenuButton();

		this._serverSetup(data);

		this.initUi(shouldShowNotFriendsMessage, shouldShowMatchCompleteMessage);

		this._isInitialized = true;
	}.bind(this))
};

PlayController.prototype._serverSetup = function(preFetchedData) {

	"use strict";

	var self = this;

	var matchId = UserDataController.getCurrentMatchId();

	this._creatingNewGame = false;
	if (null == matchId) {
		this._creatingNewGame = true;
	}

	this._gameConnection = new GameConnectionController({board: this._board, radar: this._radar});
	this._gameConnection.requestShipPlacement = function () {

		this._requestShipPlacementHandler();
	}.bind(this);

	this._gameConnection.onDone = function(argObject) {

		var md = UserDataController.getMatchData();

		console.log('PC.onDone -> argObject', argObject);
		if (argObject != null) {

			self._startGameOptions = argObject;
		}

		AdManager.showInterstitialAd(null, function()
		{

			flowController.startPlay("", {  width: tgfScale(384), height: tgfScale(184), backgroundImage: s_overlay_assignment}, self.startGame);
			self.showIngameMenuButton();

		}.bind(this));
	}

	this._gameConnection.setup(preFetchedData);
}

PlayController.prototype._matchMakingDoneHandler = function(data) {

	console.log('_matchMakingDoneHandler', data);

	BattleshipsAnalytics.reportMatchMakingOutcomeState('handshake_success');

	this._gameConnection.setMatchMade(data);
}

PlayController.prototype.isPlacing = function() {
	return this._isPlacing;
}

PlayController.prototype._requestShipPlacementHandler = function() {

	console.log('PC.requestShipPlacement');

	this.showIngameMenuButton();

	this._isPlacing = true;
	this._addShipPlacement();

	BattleshipAudioManager.playMusic(a_lobby_music);
}


PlayController.prototype._challengeTypeSelectHandler = function(challengeType) {

	// challengeType = 'fbmatchmaking'

	var self = this;
	var userData = UserDataController.getData();

	// Don't accept a game when the ships are being dragged
	if (ShipPlacementController.draggingShip != 0)
		return;

	if (!this._isPlacing) // If we already selected something, don't continue
		return;

	this._isBotBattle = true;
	this._gameConnection.setBotBattle();

	this._finishPlacement();
}

PlayController.prototype._finishPlacement = function() {

	this._isPlacing = false;
	ShipPlacementController.copyPlacementToNewTileMap(this._board);

	// hide ship placement + disable ship interaction
	if (this.uiPlacementComplete) this.uiPlacementComplete.hide(false);

	ShipPlacementController.hide();

	this._gameConnection.completeShipPlacement();
}

PlayController.prototype._selectFriend = function() {

	// console.log('PlayController._selectFriend');

	var self = this;

	var friendSucces = function() {

		self._challengedAFriend = true;

		var id = tgfHooks.getContextID() || "0";
		var type = tgfHooks.getContextType();
		AnalyticsService.setContext(type, id);

		self._finishPlacement();
	};

	tgfHooks.chooseContext(function() {

		self._pauseManager.setState(PauseManager.pauseStates.PAUSE_ENABLED);

		friendSucces();

	},
	function(reason) {
		console.log('failed, did not chooseContext', reason);

		self._pauseManager.setState(PauseManager.pauseStates.PAUSE_ENABLED);

		if (reason.code == "SAME_CONTEXT") {

			console.log('failed, but --> SAME CONTEXT, PROCEED!');

			friendSucces();
		}
		else {
			self._isPlacing = true;
		}

	}, {maxSize: 20, filters: ["NEW_CONTEXT_ONLY"] });
	// }, {maxSize:2});
	// }, {filters: ["NEW_CONTEXT_ONLY"], maxSize:2});
	// }, {filters: ["NEW_CONTEXT_ONLY"], maxSize:2});
}


PlayController.prototype.startTurnFlow = function() {

	"use strict";

	var self = this;


	// game over before starting?

	var resultBoard = null;
	var resultRadar = null;

	if (this._board && this._board.getTileMap() ) {

		resultBoard = this._board.getTileMap().getResult();
	}
	if (this._radar && this._radar.getTileMap() ) {

		resultRadar = this._radar.getTileMap().getResult();
	}

	console.log('BOOT::RESULT_BOARD -> ', resultBoard);
	console.log('BOOT::RESULT_RADAR -> ', resultRadar);


	var match = UserMatches.getMatchById( UserDataController.getCurrentMatchId() );

	var rd = null;
	if (match) {

		rd = match.rematch;
	}

	console.log('BOOT::rematch', rd);

	if (resultBoard && (resultBoard.hits >= WinConditions.HITS_REQUIRED) ) {

		console.log('BOOT 	:: lose on boot!!');

		tbGame.addSpecial('game-complete-lose', resultBoard);
	}
	else if (resultRadar && (resultRadar.hits >= WinConditions.HITS_REQUIRED) ) {

		console.log('BOOT 	:: win on boot!!');

		tbGame.addSpecial('game-complete-win', resultRadar);
	}
	else {

		console.log('BOOT 	:: continue normally..');

		var gameData = UserDataController.getMatchData();

		this._turnController = TurnController;
		this._turnController.initialize(gameData);
		this._turnController.addTurnListener(this._onTurnUpdate, this);


		var state = this._turnController.getState();
		// console.log('PlayController.startTurnFlow at state', state);
	}
}

// handleRemove is called when the token is removed from the game.
PlayController.prototype.handleRemove = function() {
	"use strict";

	// TimedRandomOpponentController.stop();

	if (this._pauseManager) {
		this._pauseManager.destroy();
		this._pauseManager = null;
	}

	// if (this._timerNext) {
	// 	tbGame.removeToken(this._timerNext);
	// 	this._timerNext = null;
	// }

	if (this.loseScreenTimeout) {
		clearTimeout(this.loseScreenTimeout);
		this.loseScreenTimeout = undefined;
	}

	if (this._turnController) {

		this._turnController.removeTurnListener(this._onTurnUpdate, this);
		this._turnController = null;
	}


	if (this._gameConnection) {

		this._gameConnection.destroy();
		this._gameConnection = null;
	}


	if (this._turnIndicator){

		tgfGraphics.removeChild(this._turnIndicator.container.container);
		this._turnIndicator.container.container.destroy({children:true});
		this._turnIndicator.container.container = null;
		this._turnIndicator.remove();
		this._turnIndicator = null;
	}

	if (this._radar) {

		if (this._radar && this._radar._containerClickToFire && this._radar._containerClickToFire.container) {

			console.log('killing container click to fire');
			tgfGraphics.removeChild(this._radar._containerClickToFire.container);
			this._radar._containerClickToFire.container.destroy({children: true});
			this._radar._containerClickToFire.container = null;
			this._radar._containerClickToFire = null;
		}

		tbGame.removeToken(this._radar);
		this._radar = null;
	}

	if (this._board) {
		tbGame.removeToken(this._board);
		this._board = null;
	}

	if (this.uiIngameMenu) {
		this.uiIngameMenu.free();
		this.uiIngameMenu = null;
	}

	if (this.uiExtraShot) {
		this.uiExtraShot.setButtonCallback(null);
		this.uiExtraShot.onExit = null;
		this.uiExtraShot.free();
		this.uiExtraShot = null;
	}

	// if (this.uiNextBattle) {
	// 	this.uiNextBattle.free();
	// 	this.uiNextBattle = null;
	// }

	if (this.uiPlacementComplete) {
		this.uiPlacementComplete.free();
		this.uiPlacementComplete = null;
	}

	if (this.uiResultScreen) {
		this.uiResultScreen.free();
		this.uiResultScreen = null;
	}

	if (this.nextBattlePopup) {
		this.nextBattlePopup.free();
		this.nextBattlePopup = null;
	}

	if (this.endOfTurnPopup) {
		this.endOfTurnPopup.free();
		this.endOfTurnPopup = null;
	}

	if (this.buttonMenuContainer) {
		tgfGraphics.removeChild(this.buttonMenuContainer.container);
		this.buttonMenuContainer.container.destroy({children: true});
		this.buttonMenuContainer.container = null;
		this.buttonMenuContainer = null;
	}

	if (this._backgroundImage) {

		tgfGraphics.removeChild(this._backgroundImage.sprite);
		this._backgroundImage = null;
	}

	if (this._onboardingManager) {
		tbGame.removeToken(this._onboardingManager);
		this._onboardingManager = null;
	}

	tbGame.removeTokens('timer');
	tbGame.removeTokens('token');

	UserDataController.clearMatch();

	// garbage collection
	ShipPlacementController.hide();
	TurnController.clearListeners();
	TurnController.reset();
};


PlayController.prototype.initUi = function(shouldShowNotFriendsMessage, shouldShowMatchCompleteMessage){
	"use strict";

	var self = this;

	// create ship placement completion panel
	this._createPlacementPanel();


	this.uiExtraShot = new tgfDialogs.BattleshipExtraShotPopup({
		x: 0,
		y: 10 - 80,
		positionX: tgfGraphics.areaWidth/2,
		positionY: tgfGraphics.areaHeight * 0.75,
		height: 580,
        big: true
	});

	this.uiExtraShot.setButtonCallback( function() {

		console.log('extra shot ad please');

		AnalyticsService.reportEvent("interaction", "interaction", {
			eventType: "button_open_rewarded"
		});
		AnalyticsService.reportEvent("interaction", "interaction", {
			eventType: "extra_shot"
		});

		AdManager.setTrackingData('extra_shot', null);
    	AdManager.playAd(self, function(e) {
    		if (e === -1) {
				TurnController.advanceTo(TurnController._TURN_STATES.TURN_OVER);
				return;
			}
    		console.log('AM::ExtraShotPopup.playAdCallback');

    		var extraShotData = UserDataController.getExtraShotData();
			extraShotData.usePowerup(TimeManager.getTime().serverTime + AdSettings.REWARD_COOLDOWN_EXTRA_SHOT);

			BattleshipsAnalytics.reportExtraShotUsed();

			TurnController.advanceFrom(TurnController._TURN_STATES.FIRE_X_POPUP);
    	});
	});

	this.uiExtraShot.onExit = function() {

		AnalyticsService.reportEvent("interaction", "interaction", {
			eventType: "button_decline",
			id: "extra_shot"
		});

		console.log('extra shot skip ad');
		TurnController.advanceTo(TurnController._TURN_STATES.TURN_OVER);

	};


	setTimeout(function() {

		if (this._showExtraShotPopupWhenReady) {
			this._showExtraShotPopupWhenReady = false;
			this._handleExtraShotPhase();
		}

	}.bind(this), 0);

	// create ingameMenu (panel)
	this.uiIngameMenu = new tgfDialogs.BattleshipNewBattlePopup({
		x: 0,
		y: 0,
		width: 846 + 100,//640,
		height: 542//502
	});

	this.uiIngameMenu.onNext = this._gotoNextBattle.bind(this);
	this.uiIngameMenu.onNew = this._gotoNewBattle.bind(this);
	this.uiIngameMenu.onExit = this.showIngameMenuButton.bind(this);
}

PlayController.prototype._gotoNewBattle = function() {

	if (this.nextBattlePopup) {
		this.nextBattlePopup.free();
		this.nextBattlePopup = null;
	}

	UserDataController.setEntryMatchId('NEW');
	flowController.endPlay();
	BattleshipsAnalytics.reportClickedNewBattleDuringMatch();
	AnalyticsHelper.reportButtonClick("new");
}


PlayController.prototype._gotoNextBattle = function() {

	if (this.nextBattlePopup) {
		this.nextBattlePopup.free();
		this.nextBattlePopup = null;
	}

	var nextMatch = UserMatches.getNextActiveMatch();

	if (nextMatch) {

		var state = nextMatch.data.state;

		var roomContext = nextMatch.data.state.contextID;

		var self = this;

		// enter random match
		if (nextMatch.data.state.isRandom == true) {

			UserDataController.setEntryMatchId(nextMatch.id);
			flowController.endPlay();
		}
		// request change context to new one
		else if (nextMatch.data.state.contextID != tgfHooks.getContextID()) {
			tgfHooks.switchContext(roomContext, function() {
		  		// console.log('changed context, _gotoRoom ::', tgfHooks.getContextID(), FBInstant.context.getID());
				var id = tgfHooks.getContextID() || "0";
				var type = tgfHooks.getContextType();
				AnalyticsService.setContext(type, id);

				UserDataController.setEntryMatchId(nextMatch.id);
				flowController.endPlay();

		  	}, function(e) {
		  		// console.log('fail context switch');
		  	});
		}
		// leave context as is, should be correct one already
		else {

			// same context, goto found match
			UserDataController.setEntryMatchId(nextMatch.id);
			flowController.endPlay();
		}

		BattleshipsAnalytics.reportClickedNextBattleDuringMatch();
		AnalyticsHelper.reportButtonClick("existing");
	}
	else {

		// start new match
		this._gotoNewBattle();
	}
}

PlayController.prototype.isCreatingNewGame = function() {

	var isNew = this._creatingNewGame;

	if (this._startGameOptions) {

		console.log('PC::isCreatingNewGame -> startGameOptions :: ', this._startGameOptions);

		var swd = UserDataController.getSpecialWeaponData();
		swd.clearCooldowns();

		if (this._startGameOptions.type) {

			switch (this._startGameOptions.type) {
				case 'random' :
				case 'rematch' : {

					if (this._startGameOptions.player && this._startGameOptions.player == 'player-2') {
						isNew = false;
					}
					break;
				}
			}
		}
	}

	return isNew;
	// return this._creatingNewGame;
}

PlayController.prototype._createPlacementPanel = function() {

	var self = this;

	var placementHeight = 480; // 480 - 86 - 22;
	if (!this._creatingNewGame) {

		placementHeight = 240;
	}

	if (this.uiPlacementComplete) {

		this.uiPlacementComplete.free();
		this.uiPlacementComplete = null;
	}

	this.uiPlacementComplete = new tgfDialogs.BattleshipPlacementPopup({
		x: -20,
		y: -50,
		positionX: tgfGraphics.areaWidth/2,
		positionY: tgfGraphics.areaHeight/4,
		width: 538,
		height: 541,
		newGame: this._creatingNewGame,
		customBackground: s_popup_tobattle
	});

	// rematch check - should be cleaner
	var match = UserMatches.getMatchById(this._matchId);
	var isRematch = false;

	if (match && match.state && match.state.matchDone ) {

    	var matchDone = match.state.matchDone;
    	isRematch = (matchDone.indexOf(userData['id'] >= 0) ? true : false);
	}


	this.uiPlacementComplete.setAsRematch(isRematch);
	this.uiPlacementComplete.setButtonCallback(this._challengeTypeSelectHandler.bind(this));
}

PlayController.prototype._handleExtraShotPhase = function() {

	console.log('TRO::PC._handleExtraShotPhase');

	if (UserDataController.getMatchData().isTimed) {

		// this._showExtraShotPopupWhenReady = false;
		// TurnController.advanceTo(TurnController._TURN_STATES.TURN_OVER);
	}
	else {
		TurnController.advanceTo(TurnController._TURN_STATES.TURN_OVER);
		//this.uiExtraShot.show();
	}
}

PlayController.prototype._addIngameMenuButton = function() {

	// button Menu + container
	// this._ingameMenuButton = new IngameMenuButton();

	var self = this;

	this.buttonMenuContainer = new tbContainer();
	this.buttonMenuContainer.setPosition(100,0);
	this.buttonMenuContainer.setAlpha(0);
	tgfGraphics.addChild(this.buttonMenuContainer.container, 'buttonMenuContainer');

	this.buttonMenu = s_next_battle_button_pannel.clone();
	this.buttonMenuOpen = s_button_next_battle.clone();
	this.buttonMenuOpen.setPosition(1,3);


	this.buttonMenu.sprite.on('pointerdown', function() {

		this.uiIngameMenu.show(true, this._isPlacing, false);
		// this.buttonMenu.gotoAndStop(1);
		this.buttonMenuOpen.gotoAndStop(1);
		this.hideIngameMenuButton();

	}.bind(this));


	this.buttonMenu.sprite.on('pointerup', function() {

		// console.log('ever triggered??');

		// this.buttonMenu.gotoAndStop(0);
		this.buttonMenuOpen.gotoAndStop(0);

		// hide next battle popup
		// if (this.uiNextBattle) {
		// 	this.uiNextBattle.hide(false);

		// 	if (this._timerNext) {
		// 		this._timerNext.reset();
		// 	}
		// }

	}.bind(this));


	this.buttonMenu.sprite.on('pointerupoutside', function() {

		// this.buttonMenu.gotoAndStop(0);
		this.buttonMenuOpen.gotoAndStop(0);

	}.bind(this));

	this.buttonMenu.sprite.interactive = true;
	this.buttonMenu.sprite.buttonMode = true;

	this.buttonMenuContainer.container.addChild(this.buttonMenu.sprite);
	this.buttonMenu.sprite.addChild(this.buttonMenuOpen.sprite);

	this._animatorButtonMenu = new tbAnimator(this.buttonMenuContainer.container);
	this._animatorButtonMenuTrackX = this._animatorButtonMenu.addTrack('x');

	var self = this;
	if (this._pauseManager) {

		this._pauseManager.addListener(this, function(state) {

			switch (state) {
				case PauseManager.pauseStates.PAUSE_DISABLED : {
					self.hideIngameMenuButton();
					break;
				}
				case PauseManager.pauseStates.PAUSE_ENABLED : {
					self.showIngameMenuButton();
					break;
				}
			}
		});
	}
}

PlayController.prototype.showIngameMenuButton = function() {

	// console.log('IM:showIngameMenuButton');

	if (this.buttonMenuContainer.container) {

		tgfGraphics.addChild(this.buttonMenuContainer.container, 'buttonMenuContainer');
	}

	this._settingsOnTop = true;

	if (this._isShowingIngameMenu) return;

	this._isShowingIngameMenu = true;

	this.buttonMenuContainer.setAlpha(1);

	this._animatorButtonMenu.removeAllKeys();//this._animatorButtonMenuTrackX, 0, 0);
	this._animatorButtonMenu.setTime(0);//this._animatorButtonMenuTrackX, 0, 0);

	this._animatorButtonMenu.addKey(this._animatorButtonMenuTrackX, 0, 100, tbEase.easeOutOvershoot, 1);
	this._animatorButtonMenu.addKey(this._animatorButtonMenuTrackX, 400, 100, tbEase.easeOutOvershoot, 1);
	this._animatorButtonMenu.addKey(this._animatorButtonMenuTrackX, 750, 0, tbEase.easeOutOvershoot, 1);
}

PlayController.prototype.hideIngameMenuButton = function() {

	// console.log('IM:hideIngameMenuButton');

	if (!this._isShowingIngameMenu) return;

	this._isShowingIngameMenu = false;
	this._settingsOnTop = false;

	if (this._animatorButtonMenu && this._animatorButtonMenuTrackX) {

		this._animatorButtonMenu.removeAllKeys();//this._animatorButtonMenuTrackX, 0, 0);
		this._animatorButtonMenu.setTime(0);//this._animatorButtonMenuTrackX, 0, 0);

		this._animatorButtonMenu.addKey(this._animatorButtonMenuTrackX, 0, 0, tbEase.easeInOvershoot);
		this._animatorButtonMenu.addKey(this._animatorButtonMenuTrackX, 350, 100, tbEase.easeInOvershoot, 1);
	}

}

PlayController.prototype._onTurnUpdate = function(state) {

	// console.log('PlayController._onTurnUpdate', state);
	console.log('TC.dispatching::_onTurnUpdate', state);

	switch (state) {
		case TurnController._TURN_STATES.WAITING : {

			// Only continue when playing against friends
			if (this._isBotBattle || UserDataController.isTimedMatch()) {
				break;
			}

			break;
		};
		 case TurnController._TURN_STATES.FIRE_X_POPUP : {
			//console.log("what1");
			if (this.uiExtraShot) {
				console.log('FIRE-BALLLLLZZZ - if' );
				this._handleExtraShotPhase();
			}
			else {
				console.log('FIRE-BALLLLLZZZ - else' );
				console.warn('uiExtraShot does not exist yet');
				this._showExtraShotPopupWhenReady = true;
			}

			break;
		}; 
		case TurnController._TURN_STATES.FEEDBACK_READY :
		case TurnController._TURN_STATES.TURN_START :
		case TurnController._TURN_STATES.GAME_ENDED : {
			//console.log("what2");
			/* if (this.uiExtraShot) {

				this.uiExtraShot.hide(false);
			} */
			break;
		};
		// case TurnController._TURN_STATES.TURN_OVER : {

		// 	console.log('EOT::TURN_OVER');

		// 	break;
		// };
	}
}


PlayController.prototype._setupBoard = function() {

	this._board = new BoardToken();

	var self = this;

	this._board.tileSelected = function(index) {

		// console.log('selected Tile', index);
		self._board._selectedTile = index;

		// console.log('board selected Tile', index);
	};

	this._board.tileDeselected = function(index) {

		// console.log('board deselected Tile');
	};

	// add board
	tbGame.addTokenTags(this._board, ['token', 'play']);
	tbGame.addToken(this._board);
}

PlayController.prototype._setupRadar = function() {

	this._radar = new RadarToken();
	this._fireUnit = new FireUnit(this._radar);
	this._radar.fireUnit = this._fireUnit;

	// add board
	tbGame.addTokenTags(this._radar, ['token', 'play']);
	tbGame.addToken(this._radar);

	// add fire button
	tbGame.addTokenTags(this._fireUnit, ['token', 'play']);
	tbGame.addToken(this._fireUnit);


	tgfGraphics.addChild(this._radar._containerClickToFire.container, 'clicktofire');
}

PlayController.prototype._addShipPlacement = function(){

	this._isNewGame = true;
    var self = this;

	var onComplete = function() {
		self.uiPlacementComplete.show();
	}

	var onUnComplete = function() {
		self.uiPlacementComplete.hide(false);
	}

	ShipPlacementController.show(this._board, this, this._board.getTileMap().getContainer(), onComplete, onUnComplete);
}

PlayController.prototype.beforeStartGame = function(){

	// sync roomData before actually starting

	console.log('SPM.specialWeaponData', specialWeaponData);
	var specialWeaponData = UserDataController.getSpecialWeaponData();
    if (specialWeaponData) {
        specialWeaponData.clearWeapons();
    }
	console.log('SPM.specialWeaponData', specialWeaponData);
}

PlayController.prototype.startGame = function(){
	"use strict";

	// this.beforeStartGame();

	console.log("Game Started");

	var self = this;


	var specialWeaponData = UserDataController.getSpecialWeaponData();

	// If we're playing no effects, don't try to play the stinger, fade to new music instantly
	var muted = StorageManager.get('sfxMute');
	if (muted) {
		BattleshipAudioManager.playMusic(a_ingame_music);
	}
	else {
		BattleshipAudioManager.stopMusic();
		tgfAudio.play(a_battle_start);
		BattleshipAudioManager.playMusic(a_ingame_music, 3000);
	}

	// BoardStrike.comboCount = 0;
	// RadarStrike.comboCount = 0;

	if (!this._isNewGame) {

		// console.log('PC.startGame -> continue game');
		this._board.parseFleet();
		this._board.parseBoard();
	}

	// RADAR SHOULD BE INITIALIZED
	this._radar.setOpponentMap();

	if (!this._isNewGame) {
		this._radar._buildFleet();
	}


	// add turn-indicator
	this._turnIndicator = new TurnIndicatorController();
	this._turnIndicator.initAvatars(this._isBotBattle);
	tgfGraphics.addChild(this._turnIndicator.container.container, '_turnIndicator.container');


	// TODO - add lastAction shots when -> my-turn + fire1, fire2, fire3, turn_over
	var userData = UserDataController.getData();
	var md = UserDataController.getMatchData();
	var bd = UserDataController.getBattleData();
	var currentPlayer = md.getCurrentPlayer();

	if (currentPlayer) {

		if (currentPlayer == userData.id) {

			console.log('PC --> my turn on startup', md.playerState);

			switch (md.playerState) {
				case TurnController._TURN_STATES.FIRE1 :
				case TurnController._TURN_STATES.FIRE2 :
				case TurnController._TURN_STATES.FIRE3 :
				case TurnController._TURN_STATES.FIRE_X_POPUP :
				case TurnController._TURN_STATES.FIRE_X_SHOT : {


					for (var i = 0; i < bd.lastAction.length; i++) {

						var action = bd.lastAction[i];

						// convert if needed
						if (Number.isInteger(action)) action = BattleData.patchToActionElement(action);

						// TODO: at the moment I don't care about the possibility of scattering tiles
						// Needs to be added, but a rework of strikes is necessary for that.

						var ty = Math.floor(action.center / TileMapValues.COLS);
						var tx = action.center - (ty * TileMapValues.COLS);

						var tile = {
							x: tx,
							y: ty,
							index: action.center
						};


						var actionTile = null;
						var actionTiles = [];
						var actionIndex;

						console.log('BS:action', action);

						for (var t = 0; t < action.tiles.length; t++) {

							actionIndex = action.tiles[t];
							ty = Math.floor(actionIndex / TileMapValues.COLS),
							tx = actionIndex - (ty * TileMapValues.COLS);

							actionTile = {
								x: tx,
								y: ty,
								index: actionIndex
							}

							actionTiles.push(actionTile);
						}
						console.log('BS:actionTiles', actionTiles);


						// var shotTiles = [{ x: tile.tx, y: tile.ty, index: tile.index }];
						// if (specialWeapon !== null) {
						// 	// Get all the tiles that are going to be shot by the special weapon
						// 	shotTiles = specialWeapon.generateShotTiles(tile.tx, tile.ty);

						// 	// Store the Special Weapon Type
						// 	specialWeaponType = specialWeapon.weaponID;
						// }

						// centerIndex, strikeElements, onDone

						var specialWeapon = specialWeaponData.generateSpecialWeapon(action.strikeID);
						if (action.rotateID == 1) {
							specialWeapon.rotate();
						}
						actionTiles = specialWeapon.generateShotTiles(tile.x, tile.y);
						console.log(specialWeapon, specialWeapon.weaponID, action.rotateID);



						console.log('SW::2', action.strikeID);
						this._radar.addStrike(action.center, actionTiles, function() {
							// done
							console.log('	SW::2 - addStrike.done', action.center);
						}, specialWeapon, true);

					}
					break;
				}
				default : {
					// nothing
				}
			}
		}
		else {
			console.log('PC --> not my turn on startup?state=', md.playerState);

			// console.log('md.playerState', md.playerState);
			// console.log('md.maxTargetState', TurnController._TURN_STATES.FIRE1);
			// console.log('resultState', (md.playerState < TurnController._TURN_STATES.FIRE1) );

			if (md.playerState < TurnController._TURN_STATES.FIRE1 || md.playerState == TurnController._TURN_STATES.TURN_OVER) {

				console.log('	firing my previous turn shots', bd.lastAction.length);

				// opponent not firing yet - show lastAction as there are my shots
				for (var i = 0; i < bd.lastAction.length; i++) {

					var action = bd.lastAction[i];

					// convert if needed
					if (Number.isInteger(action)) action = BattleData.patchToActionElement(action);

					// TODO: at the moment I don't care about the possibility of scattering tiles
					// Needs to be added, but a rework of strikes is necessary for that.

					var ty = Math.floor(action.center / TileMapValues.COLS);
					var tx = action.center - (ty * TileMapValues.COLS);

					var tile = {
						x: tx,
						y: ty,
						index: action.center
					};

					var actionTile = null;
					var actionTiles = [];
					var actionIndex;

					console.log('BS:action', action);

					for (var t = 0; t < action.tiles.length; t++) {

						actionIndex = action.tiles[t];
						ty = Math.floor(actionIndex / TileMapValues.COLS),
						tx = actionIndex - (ty * TileMapValues.COLS);

						actionTile = {
							x: tx,
							y: ty,
							index: actionIndex
						}

						actionTiles.push(actionTile);
					}
					console.log('BS:actionTiles', actionTiles);



					// var shotTiles = [{ x: tile.tx, y: tile.ty, index: tile.index }];
					// if (specialWeapon !== null) {
					// 	// Get all the tiles that are going to be shot by the special weapon
					// 	shotTiles = specialWeapon.generateShotTiles(tile.tx, tile.ty);

					// 	// Store the Special Weapon Type
					// 	specialWeaponType = specialWeapon.weaponID;
					// }

					// centerIndex, strikeElements, onDone

					console.log('SW::1', action.strikeID);


					var specialWeapon = specialWeaponData.generateSpecialWeapon(action.strikeID);
					if (action.rotateID == 1) {
						specialWeapon.rotate();
					}
					actionTiles = specialWeapon.generateShotTiles(tile.x, tile.y);
					console.log(specialWeapon, specialWeapon.weaponID, action.rotateID);



					console.log('SW::2', action.strikeID);
					this._radar.addStrike(action.center, actionTiles, function() {
						// done
						console.log('	SW::2 - addStrike.done', action.center);
					}, specialWeapon, true);
				}
			}
		}
	}


	if (!this._isNewGame) {
		this._radar._buildFleet();
	}

	var gameType = "challenge";
	if (this._gameConnection.getBotBattle() ) {

		this._gameConnection.addBot();
		gameType = "practice";
	}

	// console.log('startGameOptions?', this._startGameOptions);

	// console.log(this.isCreatingNewGame() );
	// this._startGameOptions.player = 'player-1'
	// console.log(this.isCreatingNewGame() );
	// this._startGameOptions.player = 'player-2'
	// console.log(this.isCreatingNewGame() );

	BattleshipsAnalytics.reportStartGame();

	// this._gameType = BattleshipsAnalytics.getGameType();
	// console.log('PC::_gameType', this._gameType);

	ShipPlacementController.hide();

		this.startTurnFlow();
};

PlayController.prototype.revealShipsAndLose = function(args, score) {

	args = args || {};

	if (this._revealedOnce) {
		return;
	}
	else {
		console.log('PC::revealShipsAndLose');
	}
	this._revealedOnce = true;




	if (this.uiResultScreen) {
		this.uiResultScreen.free();
		this.uiResultScreen = null;
	}


	this.uiResultScreen = new tgfDialogs.MatchResultDialog(false, function() {
		this.uiResultScreen.fadeInTopBackground(0);
		setTimeout(function() {
			this._radar.showAllShips(/* onDone: */ resumeAnimation);
		}.bind(this), 500);

		// Make sure that the game reveals the endscreen
		timeOutReveal = setTimeout(resumeAnimation, 2500);
	}.bind(this), this._radar, args);

	this.uiResultScreen.setScore(score);

	var timeOutReveal = 0;
	// This function resumes the animation and speeds up to result screen
	var resumeAnimation = function() {
		this.uiResultScreen.resumeAnimation(this.uiResultScreen);

		if (timeOutReveal) {
			clearTimeout(timeOutReveal);
		}
	}.bind(this);


	this.uiResultScreen.fadeInBackground(0.5);
	this.uiResultScreen.show();
}

// handleBeginStep is called each step before processing other events.
PlayController.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	if (!this._isInitialized) {
		return;
	}

	if (this.buttonMenu) {
		this.buttonMenu.setPosition(1366/2 + (tgfGraphics.visibleWidth/2) - s_next_battle_button_pannel.width + 30, tgfGraphics.areaHeight / 2 - s_next_battle_button_pannel.height);
		// this.buttonMenu.setPosition(1366/2 + ((1366/2) * tgfGraphics.ratio) - s_next_battle_button_pannel.width + 30, tgfGraphics.areaHeight / 2 - s_next_battle_button_pannel.height);
	}

	if (this._animatorButtonMenu) {
		this._animatorButtonMenu.updateTime(timePassed);
	}

	if (this._turnIndicator) this._turnIndicator.update(timePassed);

	if (this.buttonMenuContainer.container && this._settingsOnTop) {

		tgfGraphics.addChild(this.buttonMenuContainer.container, 'buttonMenuContainer');
	}
};


// handleSpecial is called if a special or user-defined event happens.
PlayController.prototype.handleSpecial = function(id, args) {
	"use strict";

	var md = UserDataController.getMatchData();
	var userId = UserDataController.getData().id;

	this._gameFinished = this._gameFinished || false;

	console.log('PlayController.handleSpecial', id, args);

	var self = this;

	// result wrapper
	var results = {};
	if (this._radar) results.radar = this._radar.getTileMap().getResult();
	if (this._board) results.board = this._board.getTileMap().getResult();


	switch (id) {
		case 'opponent-status': {

			console.log('PC.handleSpecial::', id, args);

			if (TurnController.getState() != TurnController._TURN_STATES.WAITING) {
				break;
			}
			if (UserDataController.isTimedMatch()) {
				break;
			}

			if (this.nextBattlePopup) {
				if (args && (args.online != true || args.currentMatchId !== UserDataController.getCurrentMatchId())) {
					this.nextBattlePopup.show();
				} else {
					this.nextBattlePopup.showRenewPopup();
				}
			}

			break;
		};
		case 'network-disconnected': {

			this.hideIngameMenuButton();

			if (UserDataController.isTimedMatch() ) {

				// TimedRandomOpponentController.stop();
			}

			break;
		};
		case 'game-complete-win': {

			if (this._gameFinished) return;
			this._gameFinished = true;

			BattleshipsAnalytics.reportGameStatus(this.GameStatus.win, this.GameStatus.reason.normal, results);

			this.hideIngameMenuButton();

			console.log('PC.showResult - win');

			UserDataController.setRadarResult( this._radar.getTileMap().getResult() );
			UserDataController.setBoardResult( this._board.getTileMap().getResult() );


			// AdManager.setTrackingData('gameend', null);
			// AdManager.forceInterstitialAd(null, function() {

			if (self.uiResultScreen) {
				self.uiResultScreen.free();
				self.uiResultScreen = null;
			}
			self.uiResultScreen = new tgfDialogs.MatchResultDialog(true);
			self.uiResultScreen.setScore(this.calculateTotalScore(this.GameStatus.win, this.GameStatus.reason.normal, results));
			self.uiResultScreen.fadeInBackground(0.5);
			self.uiResultScreen.show();
			// });

			this._gameConnection.saveEndGame([userId]);

			break;
		};
		case 'game-complete-lose': {

			if (this._gameFinished) return;
			this._gameFinished = true;

			BattleshipsAnalytics.reportGameStatus(this.GameStatus.loss, this.GameStatus.reason.normal, results);

			this.hideIngameMenuButton();

			console.log('PC.showResult - lose');

			UserDataController.setRadarResult( this._radar.getTileMap().getResult() );
			UserDataController.setBoardResult( this._board.getTileMap().getResult() );

			this.revealShipsAndLose(null, this.calculateTotalScore(this.GameStatus.loss, this.GameStatus.reason.normal, results));

			this._gameConnection.saveEndGame([md.getOpponentData(userId).id, userId]);

			break;
		};
		case 'game-win-timeout':
		case 'game-win-surrender': {

			if (this._gameFinished) return;
			this._gameFinished = true;


			this.hideIngameMenuButton();


			UserDataController.setRadarResult( this._radar.getTileMap().getResult() );
			UserDataController.setBoardResult( this._board.getTileMap().getResult() );

			self._popupSurrender = new tgfDialogs.BattleshipSurrenderPopup({
				x: tgfGraphics.areaWidth / 2,
				y: tgfGraphics.areaHeight / 2,
				shadow: true
			});
			self._popupSurrender.show();

			self._popupSurrender.onComplete = function() {

				if (self.uiResultScreen) {

					// dont show again!!
				}
				else {

					self.uiResultScreen = new tgfDialogs.MatchResultDialog(true);
					self.uiResultScreen.fadeInBackground(0.5);
					self.uiResultScreen.show();
				}
			}

			if (id == 'game-win-timeout') {

				console.log('PC.showResult - win-timeout');
				BattleshipsAnalytics.reportGameStatus(this.GameStatus.win, this.GameStatus.reason.disconnect, results);
				self._gameConnection.saveEndGame([userId]);
			}
			else {

				console.log('PC.showResult - win-surrender');
				BattleshipsAnalytics.reportGameStatus(this.GameStatus.win, this.GameStatus.reason.surrender, results);
				self._gameConnection.saveEndGame([userId, md.getOpponentData(userId).id]);
			}

			break;
		};
		case 'game-forfeit': {

			if (this._gameFinished) return;
			this._gameFinished = true;

			BattleshipsAnalytics.reportGameStatus(this.GameStatus.loss, this.GameStatus.reason.surrender, results);

			this.hideIngameMenuButton();

			console.log('PC.showResult - forfeit');

			UserDataController.setRadarResult( this._radar.getTileMap().getResult() );
			UserDataController.setBoardResult( this._board.getTileMap().getResult() );

			this.revealShipsAndLose({playerForfeit: true});

			this._gameConnection.saveEndGame([md.getOpponentData(userId).id, userId]);

			break;
		};
	}
};


PlayController.prototype.calculateTotalScore = function(hasWon, reason, results) {
	var score = BattleshipsAnalytics._calculateGameExp(hasWon, reason, results);
	var rankData = StorageManager.get("rank");

	if (rankData) {
		score += rankData.score;
	}

	return score;
}

PlayController.prototype.getFireUnit = function() {
	return this._fireUnit;
}

//******************************************************
//*****    Script Resource: AdManager
//******************************************************

var AdManager = (function () {


  var _AdManager = function () {

    this._playingAd = false;
    this._adInstance = null;

    this._interstitialCount = 2;//2;
    this._interstitialCountMax = 3;//5;
    this._interstitialRewardedCooldown = 5;//11;

    this._interstitialTimer = null;
    this._interstitialBetweenTime = 60000;
    // ad-banner
    this._banner = null;
  }

  _AdManager.prototype.constructor = _AdManager;

  _AdManager.prototype.initialize = function (messagingService) {

    if (this._initialized) return;

    this._initialized = true;

  }

  _AdManager.prototype.startedNewGame = function () {

    this._interstitialCount = this._interstitialCountMax;
  }

  _AdManager.prototype.showAdBanner = function () {

    if (this.supportsAdbanner()) {

      this._banner = this._banner || new window.Booster.AdBanner();
      this._banner.show();

      console.info("Ads::window.Booster.AdBanner created");


    } else {
      console.warn("Ads::window.Booster.AdBanner not available");
    }
  }

  _AdManager.prototype.forceInterstitialAd = function (beforeStart, callback) {

    this._interstitialCount = 0;

    this.showInterstitialAd(beforeStart, callback);
  }

  _AdManager.prototype.showInterstitialAd = function (beforeStart, callback) {

    var self = this;

    // temp hack to not crash game on calling ads -> TODO

    if (this.isInterstitialAdsSupported()) {

      var interstitialDone = false;

      var now = TimeManager.getTime().server;
      var diff = now - ((this._interstitialTimer) ? this._interstitialTimer : 0);

      if (diff < this._interstitialBetweenTime) {
        console.log("ADS::showInterstitialAd - skip", diff);
        callback(0);
        return;
      }
      this._interstitialTimer = now;

      console.log("ADS::showInterstitialAd - play");
      adSense.showAdvertising({
        callback: function () {

          if (!interstitialDone) {
            interstitialDone = true;
            console.log("ADS::showInterstitialAd - done");
            callback(0);
          } else {
            console.log("ADS::showInterstitialAd - done ignore callback");
          }
        }
      });
    } else {
      console.log("ADS::showInterstitialAd - notSupported");
      callback(-1);
    }
  }


  _AdManager.prototype.showRewardedAd = function (beforeStart, callback) {

    var self = this;

    // temp hack to not crash game on calling ads -> TODO

    if (this.supportsRewarded()) {
      var rewardedDone = false
      console.log("ADS::showRewardedAd - play");

      window.Booster.RewardedVideo.play(function () {

        if (!rewardedDone) {
          rewardedDone = true;
          console.log("ADS::showRewardedAd - done");
          callback(0);
        } else {
          console.log("ADS::showRewardedAd - done ignore callback");
        }

      }, this);
    } else {
      console.log("ADS::showRewardedAd - notSupported");
      callback(-1);
    }
  }


  _AdManager.prototype.isInterstitialAdsSupported = function () {

    return this.supportsInterstitial();
  }

  _AdManager.prototype.isRewardedAdsSupported = function () {

    return this.supportsRewarded();
  }


  _AdManager.prototype.debug = function (code, message) {

    code = code || 'NO_CODE';
    message = message || 'NO_MESSAGE';

    if (this._game_container && this._game_container.innerText) {

      this._game_container.innerText = this._game_container.innerText + '\n' + code + '::' + message;
    } else {
      console.log('CANT DEBUG');
    }
  },

    _AdManager.prototype.setAdStartCallback = function (callback, context) {

      this._adStartCallback = callback;
      this._adStartContext = context;
    },


    _AdManager.prototype.setAdCompleteCallback = function (callback, context) {

      this._adCompleteCallback = callback;
      this._adCompleteContext = context;
    },


    _AdManager.prototype.setTrackingData = function (type, extra) {

      this._trackingType = type || null;
      this._trackingExtra = extra || null;
    },


    _AdManager.prototype.playAd = function (context, callback) {

      var self = this;


      if (this.isRewardedAdsSupported()) {

        this.showRewardedAd(self._adStartCallback, callback);
      } else {

        setTimeout(function () {

          if (callback) {

            callback(true, context);
          }

        }.bind(self), self._timeoutFakeTime);
      }
    }


  _AdManager.prototype.supportsRewarded = function () {
    if (!enableAds) {
      return false;
    }

    var support = false;

    if (window.Booster) support = true;

    return support;
    // return this._adsService.isRewardedAdsSupported();
  }

  _AdManager.prototype.supportsInterstitial = function () {
    if (!enableAds) {
      return false;
    }

    var support = false;

    if (window.Booster && window.adSense) support = true;

    return support;
  }

  _AdManager.prototype.supportsAdbanner = function () {
    if (!enableAds) {
      return false;
    }

    var support = false;

    if (window.Booster && window.Booster.AdBanner) {
      support = true;
    }

    return support
  }

  return new _AdManager();
}());

//******************************************************
//*****    Token Resource: ScreenShakeEffect
//******************************************************

// ***************************************
// Definition of game token ScreenShakeEffect
// ***************************************

// The constructor for the ScreenShakeEffect game token. 
var ScreenShakeEffect = function(power, duration, powerEase) {
	"use strict";
	// Properties used by the engine
	this.depth = 0;	
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties

	this.x = tgfGraphics.pixiContainer.x;
	this.y = tgfGraphics.pixiContainer.y;

	if(typeof power == "number")
		this.power = {
			x: power,
			y: power
		}
	else this.power = power;

	this.duration = duration ? duration : 1000;
	this.time = 0;
	this.running = true;

	this.powerEase = powerEase ? powerEase : null;

	// Add it to the game engine
	tbGame.addToken(this);
};

// handleAdd is called when the token is (re-) added to the game. 
ScreenShakeEffect.prototype.handleAdd = function() {
	"use strict";
};

// handleRemove is called when the token is removed from the game.
ScreenShakeEffect.prototype.handleRemove = function() {
	"use strict";

	if (this.power) {
		this.power = null;
	}
};

// handleBeginStep is called each step before processing other events.
ScreenShakeEffect.prototype.handleBeginStep = function(timePassed) {
	"use strict";
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
ScreenShakeEffect.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
ScreenShakeEffect.prototype.handleTouchUp = function(finger, x, y) { 
	"use strict";
};

// handleKeyDown is called if the key with the given keyCode is pressed.
ScreenShakeEffect.prototype.handleKeyDown = function(keyCode) { 
	"use strict";
};

// handleKeyUp is called if the key with the given keyCode is released.
ScreenShakeEffect.prototype.handleKeyUp = function(keyCode) { 
	"use strict";
};

// handleAlarm is called if a global alarm is reached.
ScreenShakeEffect.prototype.handleAlarm = function(alarm) { 
	"use strict";
};

// handleSpecial is called if a special or user-defined event happens.
ScreenShakeEffect.prototype.handleSpecial = function(id, args) { 
	"use strict";
};

// handleEndStep is called each step after processing other events (before draw).
ScreenShakeEffect.prototype.handleEndStep = function(timePassed) { 
	"use strict";
	
	this.time += timePassed;
	if (this.time > this.duration)
	{
		if (this.running)
		{
			tgfGraphics.pixiContainer.x = this.x;
			tgfGraphics.pixiContainer.y = this.y;
			this.running = false;
		}
		return;
	}

	var powerX = this.power.x;
	var powerY = this.power.y;
	if (this.powerEase) {
		powerX = this.powerEase(this.time, 0, this.power.x, this.duration);
		powerY = this.powerEase(this.time, 0, this.power.y, this.duration);
	}

	tgfGraphics.pixiContainer.x = this.x + (Math.random() - 0.5) * 2 * powerX;
	tgfGraphics.pixiContainer.y = this.y + (Math.random() - 0.5) * 2 * powerY;
};

// handleDraw is called at the end of a step to draw the token.
ScreenShakeEffect.prototype.handleDraw = function() {
	"use strict";
};

ScreenShakeEffect.prototype.destroy = function() {
	"use strict";

	tbGame.removeToken(this);
}
//******************************************************
//*****    Script Resource: BattleshipAudioManager
//******************************************************

var BattleshipAudioManager = {
    
    musicName: "",
    music: -1,

    _delayTimeouts:{},
    
    playMusic: function(audioFile, delay) {

        if(!delay) delay = 0;

        var retryDelay = 50;
        var shouldFadeInAfter = 2000;

        if(!audioFile || this.musicName === audioFile.name)
            return;

        var shouldFadeIn = false;
        if (this.music >= 0) {
            tgfAudio.stop(BattleshipAudioManager.music, 1000);
            shouldFadeIn = true;
        }

        var currentMusic = tgfAudio.play(audioFile, delay, shouldFadeIn ? 1000 : 0);
        if (currentMusic) {
            this.musicName = audioFile.name;
            this.music = currentMusic;
        
            this._delayTimeouts[currentMusic] = setTimeout(function () { 
                tgfAudio.setLooping(currentMusic, true);
            }, delay + 10);
        }
        else {
            this.musicName = "";
            this.music = -1;
        }
    },

    stopMusic: function() {
        
        tgfAudio.stop(BattleshipAudioManager.music, 0);
        if (this.music) {
            if (this._delayTimeouts[this.music]) {
                clearTimeout(this._delayTimeouts[this.music]);
                this._delayTimeouts[this.music] = null;
            }
        }
        this.music = -1;
        this.musicName = "";
    }
};
//******************************************************
//*****    Script Resource: Analytics
//******************************************************

var BattleshipsAnalytics = {
    getGameType: function() {
        var playController = this.getPlayController();
        if (!playController) {
            console.warn("Unable to get game type: Missing PlayController!");
            return "unknown_gametype";
        }

        if (playController._gameConnection.getBotBattle()) {
            return "practice";
        }
        else {
            var matchData = UserDataController.getMatchData();
            if (matchData && matchData.isRandomOpponent()) {
                return "instant_play";
                // return "random";
            }
        }

        return "challenge";
    },

    getContextType: function() {
        // if (this.getGameType() == "random")
        //     return "random_opponent";
        return tgfHooks.getContextType();
    },

    reportEntryPoint : function(entryPoint) {

        OldAnalyticsService.reportDesignEvent(["entry_point", entryPoint]);
    },

    reportCrossPromoEntry: function(concept, location, origin_game_id) {

        var myGameId = String(tgfSettings.gamebot.appId);

        OldAnalyticsService.reportDesignEvent(["crosspromotion", concept, location, String(origin_game_id), myGameId]);
    },

    getPlayController: function() {
        var playControllers = tbGame.findTokens("playcontroller");
        return playControllers.length != 0 ? playControllers[0] : null;
    },

    reportStartGame: function() {
        var playController = this.getPlayController();
        if (!playController) {
            console.warn("Unable to report start of game: Missing PlayController!");
            return;
        }

        var newGameString = playController.isCreatingNewGame() ? "new" : "continue";

        if (newGameString == "new") this.reportClearTurnTime();

        OldAnalyticsService.reportProgression(AnalyticsProgressionStatus.Start, [this.getGameType(), newGameString]);
    },

    reportGameStatus: function(hasWon, reason, results) {
        var status = hasWon ? AnalyticsProgressionStatus.Complete : AnalyticsProgressionStatus.Fail;
        reason = reason || false;

        var xp = this._calculateGameExp(hasWon, reason, results);

        if (reason) {

            OldAnalyticsService.reportProgression(status, [this.getGameType(), reason], xp);
        }
        else {

            OldAnalyticsService.reportProgression(status, [this.getGameType()], xp);
        }
    },

    _calculateGameExp: function(hasWon, reason, results) {

        var xp = 0;

        var md = UserDataController.getMatchData();

        console.log('XP::', hasWon, reason, results);


        var radarResults = results.radar || {};
        var boardResults = results.board || {};

        if (hasWon == false && reason != 'normal') {
            // no xp for you
            console.log('XP::edge-case');
            xp = 0;
        }
        else {

            console.log('XP::else');
            if (hasWon) {

                xp += (RewardTypes.getScoreByType(RewardTypes.VICTORY) * 1);
            }
            else {

                xp += (RewardTypes.getScoreByType(RewardTypes.LOST) * 1);
            }

            if (md) {

                // survived
                var shipsSurvived = 5 - boardResults.ships.destroyed.length;

                if (shipsSurvived > 0) {

                    xp += (RewardTypes.getScoreByType(RewardTypes.SURVIVED) * shipsSurvived);
                }
                console.log('XP::survived:', shipsSurvived, xp);

                // destroyed
                var shipsDestroyed = radarResults.ships.destroyed.length;

                if (shipsDestroyed > 0) {

                    xp += (RewardTypes.getScoreByType(RewardTypes.DESTROYED) * shipsDestroyed);
                }

                console.log('XP::destroyed:', shipsDestroyed, xp);

                // specials
                var swUsed = md.getSpecialWeaponUsages();
                if (swUsed > 0) {

                    xp += (RewardTypes.getScoreByType(RewardTypes.SPECIAL_WEAPON) * swUsed);
                }
                console.log('XP::sw:', swUsed, xp);
            }
        }
        console.log('XP::xp:', xp);

        return xp;
    },


    reportContext: function() {

        var ctxId = 0;
        if (ctxId) ctxId = parseInt(ctxId);
        else ctxId = 0;

        // OldAnalyticsService.reportDesignEvent([this.getContextType()], ctxId);
        OldAnalyticsService.reportDesignEvent([tgfHooks.getContextType()], ctxId);
    },

    _validateRewardedAdType: function(type) {

        type = type || '';

        switch (type) {
            case 'extra_shot' :
            case 'gameend' :
            case 'double_reward' :
            case 'special_weapon' :
            case 'special_weapon_popup' : {

                type = type;

                break;
            };

            default : {

                console.warn(String('_validateRewardedAdType, unknown type passed::' + type) );
                type = type;
                break;
            };
        }

        return type;
    },

    _validateInterstitialAdType: function(type) {

        type = type || '';

        switch (type) {
            case 'gameend' :
            case 'turnend' : {

                type = type;

                break;
            };

            default : {

                throw new Error('_validateInterstitialAdType, unknown type passed::', type);
                type = null;
            };
        }

        return type;
    },

    _getPlacementInterstitial: function() {

        var placementID = tgfSettings.ads['interstitialID'];
        var intPlacement = 1;

        if (placementID) {

            var arrPlacement = placementID.split('_');

            if (arrPlacement.length > 1) {

                intPlacement = parseInt(arrPlacement[1]);
            }
        }

        return intPlacement;
    },

    _getPlacementRewarded: function() {

        var placementID = tgfSettings.ads['rewardedID'];
        var intPlacement = 1;

        if (placementID) {

            var arrPlacement = placementID.split('_');

            if (arrPlacement.length > 1) {

                intPlacement = parseInt(arrPlacement[1]);
            }
        }

        return intPlacement;
    },

    // when you click to watch the extra shot ad
    reportRewardedAdImpression: function(type, extra) {

        type = this._validateRewardedAdType(type);

        if (type) {

            if (extra) {

                // OldAnalyticsService.reportDesignEvent(["impression", "rewarded_ad", type, this.getGameType() ], this._getPlacementRewarded() );
                OldAnalyticsService.reportDesignEvent(["impression", "rewarded_ad", type, this.getGameType(), extra ], this._getPlacementRewarded() );
            }
            else {

                OldAnalyticsService.reportDesignEvent(["impression", "rewarded_ad", type, this.getGameType() ], this._getPlacementRewarded() );
            }
        }
    },


    reportInterstitialAdImpression: function(type, extra) {

        type = this._validateInterstitialAdType(type);

        if (type) {

            if (extra) {

                // OldAnalyticsService.reportDesignEvent(["impression", "interstitial_ad", type, extra, this.getGameType()], this._getPlacementInterstitial() );
                OldAnalyticsService.reportDesignEvent(["impression", "interstitial_ad", type, this.getGameType()], this._getPlacementInterstitial() );
            }
            else {

                OldAnalyticsService.reportDesignEvent(["impression", "interstitial_ad", type, this.getGameType()], this._getPlacementInterstitial());
            }
        }
    },

    // when you click to watch the extra shot ad
    reportRewardedAdRequest: function(type, extra) {

        type = this._validateRewardedAdType(type);

        if (type) {

            if (extra) {

                OldAnalyticsService.reportDesignEvent(["request", "rewarded_ad", type, this.getGameType(), extra ], this._getPlacementRewarded()  );
                // OldAnalyticsService.reportDesignEvent(["request", "rewarded_ad", type, this.getGameType() ], this._getPlacementRewarded()  );
            }
            else {

                OldAnalyticsService.reportDesignEvent(["request", "rewarded_ad", type, this.getGameType() ], this._getPlacementRewarded());
            }
        }
    },


    reportInterstitialAdRequest: function(type, extra) {

        type = this._validateInterstitialAdType(type);

        if (type) {

            if (extra) {

                OldAnalyticsService.reportDesignEvent(["request", "interstitial_ad", type, this.getGameType()], this._getPlacementInterstitial());
            }
            else {

                OldAnalyticsService.reportDesignEvent(["request", "interstitial_ad", type, this.getGameType()], this._getPlacementInterstitial());
            }
        }
    },


    reportRewardedAdWatched: function(success, type, extra) {

        // extre cant be added, too long

        type = this._validateRewardedAdType(type);

        var watched = success ? "yes" : "no";

        if (type) {

            OldAnalyticsService.reportDesignEvent(["rewarded_ad", "fb_ads_watched", watched, type, this.getGameType()], this._getPlacementRewarded());
        }
    },


    reportInterstitialAdWatched: function(success, type, extra) {

        // extre cant be added, too long

        type = this._validateInterstitialAdType(type);

        var watched = success ? "yes" : "no";

        if (type) {

           OldAnalyticsService.reportDesignEvent(["interstitial_ad", "fb_ads_watched", watched, type, this.getGameType()], this._getPlacementInterstitial());

        }
    },


    reportAdvertismentSupport: function(hasRewardedSupport, hasInterstitialSupport) {


        // design  supported_ads   interstitial_ad yes
        // design  supported_ads   rewarded_ad no

        var resultRewarded      = hasRewardedSupport ? "yes" : "no";
        var resultInterstitial  = hasInterstitialSupport ? "yes" : "no";

        OldAnalyticsService.reportDesignEvent(["supported_ads", "rewarded_ad", resultRewarded]);
        OldAnalyticsService.reportDesignEvent(["supported_ads", "interstitial_ad", resultInterstitial]);
    },


    reportOpenRenewPopup: function() {

        OldAnalyticsService.reportDesignEvent(["interaction", "open_rewarded_popup"]);
    },

    // changed this
    reportHasShared: function() {

        // OldAnalyticsService.reportDesignEvent(["share"], 1);
        var ctxId = tgfHooks.getContextID();
        if (ctxId) ctxId = parseInt(ctxId);
        else ctxId = 0;

        OldAnalyticsService.reportDesignEvent(["custom_share", "match_end"], ctxId);
    },

    reportClickedRematchInLobby: function(lobbySelectGameType) {

        this.reportClearTurnTime();

        if (lobbySelectGameType) {

            OldAnalyticsService.reportDesignEvent(["lobby", "rematch", lobbySelectGameType]);
        }
        else {

            OldAnalyticsService.reportDesignEvent(["lobby", "rematch"]);
        }

    },

    reportClickedRematchInResultScreen: function() {

        this.reportClearTurnTime();

        OldAnalyticsService.reportDesignEvent(["endscreen", "rematch"]);
    },

    reportClickedBackToLobbyInResultScreen: function() {

        OldAnalyticsService.reportDesignEvent(["endscreen", "lobby"]);
    },

    reportClearTurnTime: function() {

        this._turnTimeStarted = null;
    },

    reportStartedTurn: function() {

        if (!this._turnTimeStarted) {

            this._turnTimeStarted = Date.now();
        }
    },

    reportEndedTurn: function() {

        var turnDurationMs = 0;
        if (this._turnTimeStarted) {

            turnDurationMs = Date.now() - this._turnTimeStarted;
            this._turnTimeStarted = null;
        }

        if (UserDataController.getMatchData()) {

            OldAnalyticsService.reportDesignEvent(["turn", this.getGameType(), UserDataController.getMatchData().playerTurn], turnDurationMs);
        }
        else {

            OldAnalyticsService.reportDesignEvent(["turn", this.getGameType()], turnDurationMs);
        }
    },

    reportShotTaken: function() {

        if (UserDataController.getMatchData()) {

            OldAnalyticsService.reportDesignEvent(["shot", this.getGameType(), UserDataController.getMatchData().playerTurn]);
        }
        else {

            OldAnalyticsService.reportDesignEvent(["shot", this.getGameType()]);
        }
    },

    reportExtraShotUsed: function() {

        OldAnalyticsService.reportDesignEvent(["extra_shot", this.getGameType()]);
    },

    reportSpecialWeaponUsed: function(specialWeaponType) {

        var specialWeaponTypeString = SpecialWeaponData.getSpecialWeaponTypeString(specialWeaponType);
        OldAnalyticsService.reportDesignEvent(["special_weapon", specialWeaponTypeString, this.getGameType() ]);
    },

    reportMatchDuration: function(duration) {

        // duration in ms
        OldAnalyticsService.reportDesignEvent(["match_duration"], duration);
    },

    // removed this
    // reportInviteSent: function() {

    //     var ctxId = tgfHooks.getContextID();
    //     if (ctxId) ctxId = parseInt(ctxId);
    //     else ctxId = 0;

    //     OldAnalyticsService.reportDesignEvent(["invite_to_play"], ctxId);
    // },

    reportClickedNextBattleDuringMatch: function() {

        this.reportClearTurnTime();

        OldAnalyticsService.reportDesignEvent(["end_of_turn", "existing_game", this.getGameType()]);
    },

    reportClickedNewBattleDuringMatch: function() {

        this.reportClearTurnTime();

        OldAnalyticsService.reportDesignEvent(["end_of_turn", "new_game", this.getGameType()]);
    },

    reportClickedContinueMatchInLobby: function(lobbySelectGameType) {

        this.reportClearTurnTime();

        if (lobbySelectGameType) {

            OldAnalyticsService.reportDesignEvent(["lobby", "existing_game", lobbySelectGameType]);
        }
        else {

            OldAnalyticsService.reportDesignEvent(["lobby", "existing_game"]);
        }
    },

    reportClickedSuggestedFriend: function (newOrExisting) {
        OldAnalyticsService.reportDesignEvent(['lobby', newOrExisting, 'challenge', 'suggested_friends']);
    },

    reportClickedNewGameInLobby: function() {

        this.reportClearTurnTime();

        OldAnalyticsService.reportDesignEvent(["lobby", "new_game"]);
    },

    reportClickedFacebookMessage: function(type, messageType, lobbyLoadedGameType) {

        type = type || '';
        messageType = messageType || null;

        switch (type) {
            case 'custom_update' :
            case 'custom_share' :
            case 'gamebot' : {

                // good!
                break;
            };
            default : {
                type = 'unknown_type';
                break;
            };
        }

        var ctxId = tgfHooks.getContextID();
        if (ctxId) ctxId = parseInt(ctxId);
        else ctxId = 0;

        if (messageType) {
            var sizeBetween = FBInstant.context.isSizeBetween(1,2);
            var isGroupMatch = (sizeBetween && sizeBetween.answer != undefined && !sizeBetween.answer);

            if (lobbyLoadedGameType) {

                if (messageType === 'invite') {
                    OldAnalyticsService.reportDesignEvent(["click", type, messageType, lobbyLoadedGameType, isGroupMatch.toString()], ctxId );
                } else {
                    OldAnalyticsService.reportDesignEvent(["click", type, messageType, lobbyLoadedGameType], ctxId );
                }
            }
            else {

                OldAnalyticsService.reportDesignEvent(["click", type, messageType], ctxId );
            }
        }
        else {

            if (lobbyLoadedGameType) {

                OldAnalyticsService.reportDesignEvent(["click", type, "no_message_type", lobbyLoadedGameType], ctxId );
            }

            OldAnalyticsService.reportDesignEvent(["click", type], ctxId );
        }
    },

    reportTorpedoGamebotClicked: function(messageType) {
        OldAnalyticsService.reportDesignEvent(["click", "gamebot", "special_weapons", messageType] );
    },

    // custom_update:invite|turn|end_of_game
    reportCustomUpdateSent: function(type, isGamebot) {

        var updateType = isGamebot ? "gamebot" : "custom_update";
        type = type || '';

        switch (type) {
            case 'invite' :
            case 'poke' :
            case 'turn' :
            case 'match_end' :
            case 'suggested_friends' :
            case 'match_reminder' : {

                // do nothing
                break;
            };
            default : {

                type = 'type:not_recognized';
                break;
            };
        }

        var ctxId = tgfHooks.getContextID();
        if (ctxId) ctxId = parseInt(ctxId);
        else ctxId = 0;

        if (isGamebot) {

            OldAnalyticsService.reportDesignEvent([updateType, type]);
        }
        else if (type === 'invite') {
            var sizeBetween = FBInstant.context.isSizeBetween(1,2);
            var isGroupMatch = (sizeBetween && sizeBetween.answer != undefined && !sizeBetween.answer);

            OldAnalyticsService.reportDesignEvent([updateType, type, this.getGameType(), isGroupMatch.toString()], ctxId);
        }
        else {

            OldAnalyticsService.reportDesignEvent([updateType, type, this.getGameType()], ctxId);
        }

    },

    reportCustomUpdateSentError: function(type, isGamebot) {

        var updateType = isGamebot ? "gamebot" : "custom_update";
        type = type || '';

        switch (type) {
            case 'invite' :
            case 'poke' :
            case 'turn' :
            case 'match_end' :
            case 'suggested_friends' :
            case 'match_reminder' : {

                type = String(updateType + ':' + type);
                break;
            }
            default : {

                type = 'type:not_recognized';
                break;
            }
        }

        BattleshipsAnalytics.reportConsoleMessage(AnalyticsErrorSeverity.Error, type);
    },

    reportDisconnect: function(value) {

        OldAnalyticsService.reportDesignEvent(["connection"], 0);
    },

    reportReconnect: function(value) {

        OldAnalyticsService.reportDesignEvent(["connection"], 1);
    },


    // SCREENS


    // design  fbLoader_done   -   -   -
    reportFBLoaderDone: function() {

        OldAnalyticsService.reportDesignEvent(["fbLoader_done"]);
    },

    // design  screen  cg_logo -   -
    reportScreenLogo: function() {

        OldAnalyticsService.reportDesignEvent(["screen", "cg_logo"]);
    },

    // design  screen  legalscreen -   -
    reportScreenLegal: function() {

        OldAnalyticsService.reportDesignEvent(["screen", "legalscreen"]);
    },

    reportScreenGameEnd: function() {
        OldAnalyticsService.reportDesignEvent(["screen", "gameend"]);
    },

    reportEndTurnScreen: function() {
        OldAnalyticsService.reportDesignEvent(["screen", "popup", "end_of_turn"]);
    },

    // design  asset_loading_done  -   -   [length]
    reportQueuedDesignEvents: function() {

        if (!this._queuedDesignEvents) return;

        for (var i = 0; i < this._queuedDesignEvents.length; i++) {

            var de = this._queuedDesignEvents[i];
            var actions = de.actions;
            var value = de.value || 0;

            OldAnalyticsService.reportDesignEvent(actions, value);
        }

        this._queuedDesignEvents = null;
    },

    reportLoadDoneSDK: function(stamp) {

        if (!stamp) return;
        var timeMs = Date.now() - stamp;

        if (!this._loadDoneSDK) {

            this._loadDoneSDK = true;
            this._queuedDesignEvents = this._queuedDesignEvents || [];
            this._queuedDesignEvents.push({actions: ["loading", "sdk_initialized"], value: timeMs});
            // OldAnalyticsService.reportDesignEvent(["loading", "sdk_initialized"], timeMs);
        }

    },

    reportLoadDoneGamesparks: function(stamp) {

        if (!stamp) return;
        var timeMs = Date.now() - stamp;

        if (!this._loadDoneGamesparks) {

            this._loadDoneGamesparks = true;
            OldAnalyticsService.reportDesignEvent(["loading", "gbackend_initialized"], timeMs);
        }
    },

    reportLoadDoneLobby: function(stamp) {

        if (!stamp) return;
        var timeMs = Date.now() - stamp;


        OldAnalyticsService.reportDesignEvent(["loading", "lobby"], timeMs);

    },

    reportLoadDoneAssets: function(stamp) {

        if (!stamp) return;
        var timeMs = Date.now() - stamp;

        if (!this._loadDoneAssets) {

            this._loadDoneAssets = true;
            OldAnalyticsService.reportDesignEvent(["loading", "asset_loading_done"], timeMs);
        }
    },

    reportLoadDoneLoading: function(stamp) {

        if (!stamp) return;
        var timeMs = Date.now() - stamp;

        if (!this._loadDoneLoading) {

            this._loadDoneLoading = true;
            OldAnalyticsService.reportDesignEvent(["loading", "loader_done"], timeMs);
        }
    },

    // design  screen  lobby   -   -
    reportScreenLobby: function() {

        OldAnalyticsService.reportDesignEvent(["screen", "lobby"]);
    },

    // design  screen  setup_ships -   -
    reportScreenShipSetup: function() {

        OldAnalyticsService.reportDesignEvent(["screen", "setup_ships"]);
    },

    // design  screen  options click:setup_ships   -
    reportScreenOptionsClickShipSetup: function() {

        OldAnalyticsService.reportDesignEvent(["screen", "options", "click", "setup_ships"]);
    },

    // design  screen  options click   -
    reportScreenOptionsClick: function() {

        var gametype = BattleshipsAnalytics.getGameType();
        OldAnalyticsService.reportDesignEvent(["screen", "options", "click", gametype]);  // challenge | random | practice
    },


    // design  screen  options end_of_turn -
    reportScreenOptionsEndOfTurn: function() {

        var gametype = BattleshipsAnalytics.getGameType();
        OldAnalyticsService.reportDesignEvent(["screen", "options", "end_of_turn", gametype]); // challenge | random
    },

    reportScreenSpecialWeaponStart: function() {

        this._specialWeaponTimeStart = Date.now();

        OldAnalyticsService.reportDesignEvent(["screen", "popup", "special_weapon", "start"]);
    },

    reportScreenSpecialWeaponEnd: function(timeMax) {

        if (!this._specialWeaponTimeStart) {
            return;
        }

        var timeMs = Date.now() - this._specialWeaponTimeStart;
        this._specialWeaponTimeStart = null;

        if (timeMs > timeMax) timeMs = timeMax;

        OldAnalyticsService.reportDesignEvent(["screen", "popup", "special_weapon", "end"], timeMs);
    },

    reportUxPopupSpecialWeaponActivate: function() {

        OldAnalyticsService.reportDesignEvent(["ux", "popup", "special_weapon", "activate"]);
    },

    reportUxPopupSpecialWeaponClose: function() {

        OldAnalyticsService.reportDesignEvent(["ux", "popup", "special_weapon", "close"]);
    },

    reportUxPopupSpecialWeaponCancel: function() {

        OldAnalyticsService.reportDesignEvent(["ux", "tro_search", "cancel"]);
    },

    reportUxShuffleButtonClick: function() {

        OldAnalyticsService.reportDesignEvent(["ux", "ship_shuffle"]);
    },

    reportRVSpecialWeaponError: function(message) {

        var msg = message || 'NO_MESSAGE';
        // error   rv_ad   popup   special_weapon  [msg]
        OldAnalyticsService.reportDesignEvent(["error", "rv_ad", "popup", "special_weapon", msg]);
    },

    reportMatchMakingOutcomeState: function(state, message) {

        // error               popup   special_weapon  [msg]
        // handshake_success   popup   special_weapon
        // time_out            popup   special_weapon

        if (message) {

            OldAnalyticsService.reportDesignEvent([state, "popup", "special_weapon", msg]);
        }
        else {

            OldAnalyticsService.reportDesignEvent([state, "popup", "special_weapon"]);
        }

    },
    // END -> SCREENS


    // NEW NEXT BATTLE SETTINGS

    // design  options:setup_ships click   lobby   -
    // design  options:setup_ships click   close   -
    // design  options:battle_available    click   lobby   -
    // design  options:battle_available    click   close   -
    // design  options:battle_available    click   new_game    -
    // design  options:battle_available    click   existing_game   -
    // design  options:battle_available    end_of_turn lobby   -
    // design  options:battle_available    end_of_turn close   -
    // design  options:battle_available    end_of_turn new_game    -
    // design  options:battle_available    end_of_turn existing_game   -
    // design  options:battle_not_available    click   lobby   -
    // design  options:battle_not_available    click   close   -
    // design  options:battle_not_available    click   new_game    -
    // design  options:battle_not_available    click   existing_game   -
    // design  options:battle_not_available    end_of_turn lobby   -
    // design  options:battle_not_available    end_of_turn close   -
    // design  options:battle_not_available    end_of_turn new_game    -
    // design  options:battle_not_available    end_of_turn existing_game   -


    // challenge
    // random
    // practice
    reportNewNextPopupActionShipSetup: function(action) {

        state = 'setup_ships';
        method = 'click';

        switch (action) {
            case 'lobby' :
            case 'close' :
            case 'terms' :
            case 'privacy' : {

                action = action;
                break;
            }
            default : {
                action = null;
            }
        }

        if (state && method && action) {

            // options:battle_available:click:lobby
            OldAnalyticsService.reportDesignEvent([ 'options', state, method, action ]);
        }
        else {
            console.warn('reportNewNextPopupActionShipSetup invalid');
        }
    },

    reportNewNextPopupAction: function(state, method, action) {

        switch (state) {
            case 'tro' :
            case 'battle_available' :
            case 'battle_not_available' : {

                state = state;
                break;
            };
            default: {
                state = null;
            };
        }

        switch (method) {
            case 'click' :
            case 'end_of_turn' : {
                method = method;
                break;
            };
            default : {
                method = null;
            };
        }

        switch (action) {
            case 'lobby' :
            case 'close' :
            case 'new_game' :
            case 'existing_game' :
            case 'terms' :
            case 'privacy' : {
                action = action;
                break;
            };
            default : {
                action = null;
            };
        }

        var gametype = BattleshipsAnalytics.getGameType();
        switch (gametype) {
            case 'challenge' :
            case 'random' :
            case 'instant_play' :
            case 'practice' : {
                gametype = gametype;
                break;
            };
            default : {
                gametype = null;
            };
        }

        if (state && method && action && gametype) {

            // options:battle_available:click:lobby
            OldAnalyticsService.reportDesignEvent([ 'options', state, method, action, gametype ]);
        }
        else {
            console.warn('reportNewNextPopupAction invalid', state, method, action, gametype);
        }
    },
    // END -> NEW NEXT BATTLE SETTINGS

    reportHandshakeSuccess: function(type) {

        OldAnalyticsService.reportDesignEvent([ "handshake_success", type ]);
    },

    reportHandshakeFailed: function(type) {

        OldAnalyticsService.reportDesignEvent([ "handshake_failed", type ]);
    },

    reportDisconnectionTimerStarted: function(reason) {

        OldAnalyticsService.reportDesignEvent([ "disconnection_timer", "start", reason ]);
    },

    reportDisconnectionTimerStopped: function(reason, duration) {

        OldAnalyticsService.reportDesignEvent([ "disconnection_timer", "stop", reason ], duration);
    },

    reportDisconnectionTimerFinished: function(reason, duration) {

        OldAnalyticsService.reportDesignEvent([ "disconnection_timer", "finished", reason ], duration);
    },

    reportScreenGamebotOptin: function() {

        OldAnalyticsService.reportDesignEvent([ "screen", "gamebot_optin" ]);
    },

    reportPopup: function(popupName, openOrClose) {
        OldAnalyticsService.reportDesignEvent([ "screen", "popup", popupName, openOrClose ]);
    },

    reportGamebotOptinState: function(success) {

        if (success) {

            OldAnalyticsService.reportDesignEvent([ "ux", "gamebot_optin", 'accept' ]);
        }
        else {

            OldAnalyticsService.reportDesignEvent([ "ux", "gamebot_optin", 'decline' ]);
        }
    },

    reportWeaponUnlock: function(type) {
        OldAnalyticsService.reportDesignEvent([ "unlock", "special_weapon", type ]);
    },

    reportOnPause: function() {
        OldAnalyticsService.reportDesignEvent([ "dev", "pause" ]);
    },

    reportDeclineDoubleReward: function() {
        OldAnalyticsService.reportDesignEvent([ "decline", "double_reward_offer" ]);
    },

    reportRankUp: function(rank) {
        OldAnalyticsService.reportDesignEvent([ "rankup" ], rank);
    },

    reportConsoleMessage: function(severity, message) {

        OldAnalyticsService.reportError(severity, message);
    },

    reportError: function(type, error) {

        var code = error.code || 'NO_CODE';
        var message = error.message || 'NO_MESSAGE';

        var msg = type + ": code: " + code + " message: " + message;

        OldAnalyticsService.reportError(4, msg);
    }
};

//******************************************************
//*****    Script Resource: SpineExtension
//******************************************************

// This is overwritten because the original functionality doesn't actually check whether or not it is loaded.

tbSpine.prototype.__parentStartLoading = tbSpine.prototype.startLoading;
tbSpine.prototype.startLoading = function(moment, location) {
    "use strict";
    
    // If we did load it already, don't load
    if (this.didLoad) 
        return;

    // Do the original loading code
    if (tbSpine.prototype.__parentStartLoading) tbSpine.prototype.__parentStartLoading.call(this, moment, location);
        
    // If it failed to load
	if (!this.didLoad) {
        var self = this;
        
        if (this.loadTimeout) 
            clearTimeout(this.loadTimeout);

		this.loadTimeout = setTimeout(function() { 
			self.startLoading();
		}, 50);
	}
};

//******************************************************
//*****    Script Resource: AnalyticsHelper
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var AnalyticsHelper = {
	getGameType: function() {
		var playController = this.getPlayController();
		if (!playController) {
			console.warn("Unable to get game type: Missing PlayController!");
			return "unknown_gametype";
		}

		if (playController._gameConnection.getBotBattle()) {
			return "practice";
		}
		else {
			var matchData = UserDataController.getMatchData();
			if (matchData && matchData.isRandomOpponent()) {
				return "instant_play";
			}
		}

		return "challenge";
	},

	getPlayController: function() {
		var playControllers = tbGame.findTokens("playcontroller");
		return playControllers.length != 0 ? playControllers[0] : null;
	},

	reportSocialUpdate: function(eventType) {
		AnalyticsService.reportEvent("engagement", "social_update", {
			eventType: eventType
		});
	},

	reportAdSupport: function(adType, isSupported) {
		AnalyticsService.reportEvent("monetization", "ad_support", {
			eventType: adType,
			valueBoolean: isSupported
		})
	},

	reportButtonClick: function(eventType) {
		AnalyticsService.reportEvent("interaction", "interaction", {
			eventType: eventType
		});
	},

	reportPopup: function(name, openOrClose) {
		AnalyticsService.reportEvent("general_flow", "popup", {
			eventType: openOrClose,
			id: name
		});
	},

	reportAdvancedEntryData: function(type, messageType) {
		var newType = null;
		switch (type) {
			case 'custom_update' : {
				newType = "social_update";
				break;
			}
			case 'custom_share' : {
				newType = "social_share";
				break;
			}
			case 'gamebot' : {
				newType = "social_bot";
				break;
			};
			default : {
				return;
			};
		}

		var content = {};
		content.eventType = newType;
		if (messageType) {
			content.id = messageType;
		}

		AnalyticsService.reportEvent("engagement", "social_accept", content)
	},

	reportMatchEnd: function(didWin, score) {
		var gameMode = this.getGameType();
		var eventName = didWin ? "match_win" : "match_fail";
		var matchId = UserDataController.getCurrentMatchId();

		AnalyticsService.reportEvent("progression", eventName, {
			eventType: gameMode,
			score: score,
			id: matchId
		})
	},

	reportMatchStart: function() {
		var gameMode = this.getGameType();
		var matchId = UserDataController.getCurrentMatchId();

		AnalyticsService.reportEvent("progression", "match_start", {
			eventType: gameMode,
			id: matchId
		})
	},

	reportMatchTurn: function() {
		var gameMode = this.getGameType();
		var matchId = UserDataController.getCurrentMatchId();

		AnalyticsService.reportEvent("progression", "match_turn", {
			eventType: gameMode,
			value: 1,
			id: matchId
		})
	}
}
//******************************************************
//*****    Token Resource: BoardShipModel
//******************************************************

// ***************************************
// Definition of game token BoardShipModel
// ***************************************

// The constructor for the BoardShipModel game token. 
var BoardShipModel = function(ship, x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth; 
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;

	this.alpha = 1;
	this._ship = ship;
	this.animator = null;
	this.isVertical = this._ship._stateVertical;
	this.currentAnimation = null;
	this.queuedAnimation = null;
	this.canPlayAnimation = true;

	this.fireSlotIndices = [];
	this.fireLit = [ false, false, false, false, false ];
	this.fireCount = this._ship.getSize();

	this.spine = this.getSpine(this._ship.id);
	
	if (this.spine && !this.spine.spineData) {
		this.spine.startLoading();
	}

	// Add it to the game engine
	tbGame.addToken(this);
	tbGame.addTokenTags(this, ['token']);
};

BoardShipModel.prototype.lightFire = function(localOffset, fireLit) {

	if (localOffset >= this.fireCount || localOffset < 0) {
		console.error("Pick a localOffset in the range of 0 ~ ship size (exclusive), (" + localOffset + " >= " + this.fireCount + " || " + localOffset + " < 0)");
		return;
	}
	
	if (fireLit === undefined) {
		fireLit = true;
	}
	
	this.resetAnimation();
	this.fireLit[localOffset] = fireLit;
};

BoardShipModel.prototype.resetAnimation = function() {
	
	this.canPlayAnimation = true;
	this.currentAnimation = null;
}

BoardShipModel.prototype.setSkin = function(skinName) {

	if (!this.spine) return;

	// Animator isn't loaded yet, don't set the skin
	var animationLoaded = !!this.spine.spineData;
	if (animationLoaded == false || !this.animator) {
		this.skinToSet = skinName;
		return;
	}

	if (this.animator && this.animator.animation && this.animator.animation.skeleton) {

		this.animator.animation.skeleton.setSkin(null);
		this.animator.animation.skeleton.setSkinByName(skinName);
	}
}

BoardShipModel.prototype.setAlpha = function(alpha) {
	"use strict";
	this.alpha = alpha;
};

BoardShipModel.prototype.getQueuedAnimation = function() {
	return this.queuedAnimation;
};	

BoardShipModel.prototype.getCurrentAnimation = function() {
	return this.currentAnimation;
};	

BoardShipModel.prototype.playIdle = function(isVertical) {
	"use strict";
	// console.log("Playing boat-animation: " + "idle");

	if (this.hasSunk)
		return;

	this.isVertical = isVertical;
	this.setAnimation("battleship_" + (isVertical ? "ver" : "hor") + "_idle", true, null, false);
};

BoardShipModel.prototype.playSink = function(isVertical, skipTransition) {
	"use strict";
	
	this.isVertical = isVertical;
	this.hasSunk = true; 
	
	var self = this;
	var onComplete = function() {
		self.setAnimation("battleship_" + (self.isVertical ? "ver" : "hor") + "_sunken", true, null, false);
	};

	if (skipTransition)
		onComplete();
	else { 
		var onApply = function () { 
			tgfAudio.play(a_ship_explodes);
			
			this.animator.animation.state.onEvent = function(trackIndex, event) { 
				
				if (event.data.name !== "sink")
					return;
				
				tgfAudio.play(a_ship_sink);
			};
		}.bind(this);
		this.setAnimation("battleship_" + (isVertical ? "ver" : "hor") + "_sinking", false, onComplete, skipTransition, onApply);
		
	}
};

BoardShipModel.prototype.playPlacement = function(isVertical, skipTransition, muteSound) {
	"use strict";

	if (this.hasSunk)
		return;


	this.isVertical = isVertical;
	var self = this;
	var onComplete = function() {
		self.setAnimation("battleship_" + (self.isVertical ? "ver" : "hor") + "_idle", true, null, false);
	};

	if (skipTransition)
		onComplete();
	else { 
		if(!muteSound) tgfAudio.play(a_ship_placement);
		this.setAnimation("battleship_" + (isVertical ? "ver" : "hor") + "_placement", false, onComplete, !!skipTransition);
	}
};

BoardShipModel.prototype.playTap = function(isVertical, skipTransition) {
	"use strict";
	
	if (this.hasSunk)
		return;
	
	this.isVertical = isVertical;
	var self = this;
	var onComplete = function() {
		self.setAnimation("battleship_" + (self.isVertical ? "ver" : "hor") + "_idle", true, null, false);
	};

	if (skipTransition)
		onComplete();
	else { 
		this.setAnimation("battleship_" + (isVertical ? "ver" : "hor") + "_tapp", false, onComplete, skipTransition);
		tgfAudio.play(a_ship_tap);
	}
};

BoardShipModel.prototype.setAnimation = function(name, loop, onComplete, skipTransition, onApply) {
	"use strict";

	if (!this.queuedAnimation || this.queuedAnimation.name != name) {

		this.queuedAnimation = { name: name, loop: loop, onComplete: onComplete, skipTransition: skipTransition, onApply: onApply };
	}
};

BoardShipModel.prototype.getSpine = function(id) {
	switch (id) {
	case 1:
		return carrier;
	case 2: 
		return battleship;
	case 3:
		return cruiser;
	case 4:
		return submarine;
	case 5:
		return destroyer;
	}
	return null;
}

// handleRemove is called when the token is removed from the game.
BoardShipModel.prototype.handleRemove = function() {
	"use strict";

	// console.log('BoardShipModel.handleRemove');


	if (this.addToContainerTimeout) {
		clearTimeout(this.addToContainerTimeout);
		
		this.addToContainerTimeout = null;
	}

	if (this.animator) {
		if (this.animator.animation) {
			this.animator.animation.destroy({children: true});
		}
		this.animator = null;
	}
	
	if (this.animator) {
		this.animator = null;
	}

	if (this._ship) {
		this._ship = null;
	}

	if (this.currentAnimation) {
		this.currentAnimation = null;
	}

	if (this.queuedAnimation) {
		this.queuedAnimation = null;
	}

	if (this.fireSlotIndices) {
		this.fireSlotIndices = null;
	}

	if (this.fireLit) {
		this.fireLit = null;
	}
	
	if (this.spine) {
		this.spine = null;
	}
};

// handleBeginStep is called each step before processing other events.
BoardShipModel.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	
	if (!this.spine) return;

	var animationLoaded = !!this.spine.spineData;	

	if (animationLoaded && !this._animationAdded) {
		
		this.animator = this.animator || this.spine.clone();

		if (!this.skinToSet)
			this.skinToSet = "skin_01";

		this.setSkin(this.skinToSet);
		this.skinToSet = null;
		
		var self = this;

		// animation exists?
		if (this.animator && this.animator.animation) {

			// ship + container ready?
			if (this._ship && this._ship.container) {

				this._ship.container.addChild(this.animator.animation);
				this._animationAdded = true;
			}
		}
	}

	if (this._animationAdded) {
		for (var i = 0; i < this.fireCount; i++) {
			var orientationIndexOffset = this.isVertical ? this._ship.getSize() : 0;
			var slotIndex = this.animator.animation.spineData.findSlotIndex("fire" + (i + 1 + orientationIndexOffset).toString());

			if (slotIndex < 0) {
				continue;
			}

			var slot = this.animator.animation.stateData.skeletonData.slots[slotIndex];
			slot.color.a = this.fireLit[i] ? 1 : 0;
		} 

		// We can play an animation and one is queued
		var isNotPlayingThisAnimation = (!this.currentAnimation || (this.queuedAnimation && this.currentAnimation.name != this.queuedAnimation.name));
		if (this.queuedAnimation && this.canPlayAnimation && isNotPlayingThisAnimation) {
			this.animator.animation["skeleton"].setSlotsToSetupPose();
			this.animator.setAnimation(this.queuedAnimation.name, this.queuedAnimation.loop);
			this.canPlayAnimation = this.queuedAnimation.loop; // You can override looping animations.

			var self = this;
			this.animator.setOnComplete(function () {
				self.canPlayAnimation = true;

				if (self.currentAnimation && self.currentAnimation.onComplete) { 
					self.currentAnimation.onComplete();
				}
			});

			if (this.queuedAnimation.onApply)
				this.queuedAnimation.onApply();

			this.currentAnimation = this.queuedAnimation;
			this.queuedAnimation = null;
		}

		// !! Terry did this
		if (!this.animator.animation.transform) return;
		


		// Fix positions for some ships
		var shipId = this._ship.id;
		if (this.isVertical) {
			// default pos
			this.animator.setPosition(74 * 0.5, 1.5 * 74);

			if (shipId == 1) {
				this.animator.setPosition(74 * 0.5, 2.5 * 74);
			}
			else if (shipId == 5) {
				this.animator.setPosition(74 * 0.5, 0.5 * 74);
			}
		}
		else /*if (!this.isVertical)*/ {
			// default pos
			this.animator.setPosition(74 * 1.5, 0.5 * 74);

			if (shipId == 1) {
				this.animator.setPosition(74 * 2.5, 0.5 * 74);
			}
			else if (shipId == 5) {
				this.animator.setPosition(74 * 0.5, 0.5 * 74);
			}
		}

		this.animator.setAlpha(this.alpha)

		//this.animator.setPosition(this._ship.container.container.x, this._ship.container.container.y);
	}

};



//******************************************************
//*****    Token Resource: BoardTargetReticle
//******************************************************

// ***************************************
// Definition of game token BoardTargetReticle
// ***************************************

// The constructor for the BoardTargetReticle game token. 
var BoardTargetReticle = function(tileMap, tileContainer, board, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth; 
	this.layer = 0;
	this.visible = true;
	this.active = true;

	// Settings
	this.travelTime = 300; // in millseconds
	this.waitTime = 100; // wait time after traveling
	this.finalWaitTime = 1000; // How long it grows until it dies

	this.blinkDelay = 50; // How fast the cursor blinks
	this.finalBlinkDelay = 20;

	this.lockSoundDelay = 60; // How fast the cursor blinks
	this.targetSoundDelay = 150;

	this.reticle = s_pla_crosshair.clone();
	this.illegal = s_grid_tile_place_illegal.clone();
	this.legal = s_grid_tile_place_legal.clone();
	this.illegalTrail = s_grid_tile_place_illegal.clone();
	this.legalTrail = s_grid_tile_place_legal.clone();

	this.offset = {
		x: tileContainer.container.x,
		y: tileContainer.container.y
	};

	this.tileContainer = tileContainer;	
	this.addedToTileContainer = false;
	
	this.tileMap = tileMap;
	this.board = board;
	this.futureAimAts = [];
	this.currentAimSequence = [];
	this.currentAimIterator = 0;
	this.totalTime = 0;
	this.shotInfo = null;

	this.blinkTime = 0;
	this.currentAimTime = 0;

	// Stores all the board strikes that are placed
	this.boardStrikes = [];

	// Add it to the game engine
	tbGame.addToken(this);
	tbGame.addTokenTags(this, ['token']);
};

function lerp(a, b, t) {
	t = t < 0 ? 0 : t;
	t = t > 1 ? 1 : t;
	return a + (b - a) * t;
}

BoardTargetReticle.prototype.aimAt = function (shotInfo, onComplete, onLand, shouldSkip) {

	if (UserDataController.isTimedMatch() ) {
		shouldSkip = true;
		this.currentTarget = null;
		this.previousTarget = null;
	}

	if (this.aiming) {
		// console.log("Adding new future aim at because old one isn't done yet.");
		this.futureAimAts.push({ 
			shotInfo: shotInfo, 
			onComplete: onComplete,
			onLand: onLand
		});
		return;
	}

	if (!this.addedToTileContainer) {

		tgfGraphics.addChild(this.illegal.sprite, 'illegal');
		tgfGraphics.addChild(this.legal.sprite, 'legal');
		tgfGraphics.addChild(this.illegalTrail.sprite, 'illegalTrail');
		tgfGraphics.addChild(this.legalTrail.sprite, 'legalTrail');
		tgfGraphics.addChild(this.reticle.sprite, 'reticle');
		
		this.addedToTileContainer = true;
	}

	this.onComplete = onComplete;
	this.onLand = onLand;
	this.currentAimSequence = [];
	this.currentAimIterator = 0;
	this.totalTime = 0;
	this.currentAimTime = 0;
	this.blinkTime = 0;
	this.soundTime = 0;
	this.lastIndex = null;

	this.shouldSkip = !!shouldSkip;
	if (shouldSkip) {
		// console.log("Skipping this aimat");
		this.currentAimIterator = this.currentAimSequence.length;
		this.currentAimTime = 9000;

		this.reticle.setAlpha(0);
		this.legal.setAlpha(0);
		this.illegal.setAlpha(0);
		this.legalTrail.setAlpha(0);
		this.illegalTrail.setAlpha(0);
	}
	
	this.reticle.setAlpha(1);

	var map = this.tileMap.getMap();
	var mapSize = this.tileMap.getRows() * this.tileMap.getColumns();
	var untouchedTiles = [];
	for (var i = 0; i < mapSize; i++) { 
		
		if (map[i] > 9) 
			continue;

		untouchedTiles.push(i);
	}

	// First aim is the tile from the last shot
	if (this.shotInfo) {
		this.currentAimSequence.push(this.shotInfo.center);
	}

	// Get 3 untouched tiles at random
	var length = Math.min(untouchedTiles.length, 3);
	if (length != 1) {
		for (var i = 0; i < length; i++) {
			
			var untouchedIndex = Math.floor(Math.random() * untouchedTiles.length);
			this.currentAimSequence.push(untouchedIndex); // Add to our aim sequence
			untouchedTiles.splice(untouchedIndex, 1); // Make sure this tile won't be used again
		}
	}

	// TODO: If we have less than 3 tiles, fill up the rest with touched tiles and shuffle?

	this.shotInfo = shotInfo;
	this.currentAimSequence.push(shotInfo.center);
	this.aiming = true;

};

BoardTargetReticle.prototype.handleRemove = function() {
	"use strict";

	if (this.reticle) {
		if (this.reticle.sprite) {
			tgfGraphics.removeChild(this.reticle.sprite);
			this.reticle.sprite = null;			
		}
		this.reticle = null;
	}



	if (this.illegal) {
		if (this.illegal.sprite) {
			tgfGraphics.removeChild(this.illegal.sprite);
			this.illegal.sprite = null;
		}
		this.illegal = null;
	}

	if (this.legal) {
		if (this.legal.sprite) {
			tgfGraphics.removeChild(this.legal.sprite);
			this.legal.sprite = null;
		}
		this.legal = null;
	}

	if (this.illegalTrail) {
		if (this.illegalTrail.sprite) {
			tgfGraphics.removeChild(this.illegalTrail.sprite);
			this.illegalTrail.sprite = null;
		}
		this.illegalTrail = null;
	}

	if (this.legalTrail) {
		if (this.legalTrail.sprite) {
			tgfGraphics.removeChild(this.legalTrail.sprite);
			this.legalTrail.sprite = null;
		}
		this.legalTrail = null;
	}
	
	if (this.offset) {
		this.offset = null;
	}

	if (this.tileContainer) {
		this.tileContainer = null;
	}

	if (this.tileMap) {
		this.tileMap = null;
	}

	if (this.board) {
		this.board = null;
	}

	if (this.futureAimAts) {
		this.futureAimAts = null;
	}

	if (this.currentAimSequence) {
		this.currentAimSequence = null;
	}
	
	if (this.tileIndex) {
		this.tileIndex = null;
	}
}

BoardTargetReticle.prototype.handleTouchUp = function(timePassed) { 
	
	if (this.totalTime <= 250)
		return;

	this.currentAimIterator = this.currentAimSequence.length;
	this.currentAimTime = 9000;
	this.shouldSkip = true;

	this.reticle.setAlpha(0);
	this.legal.setAlpha(0);
	this.illegal.setAlpha(0);
	this.legalTrail.setAlpha(0);
	this.illegalTrail.setAlpha(0);
};

BoardTargetReticle.prototype.handleDefault = function(onLand, shootNext) { 

	// Just go over all the tiles and add them regularly
	for (var i = 0; i < this.shotInfo.tiles.length; i++) {

		var tileIndex = this.shotInfo.tiles[i];

		var isLast = i == this.shotInfo.tiles.length - 1;
		var onDone = (isLast && !this.shouldSkip) ? shootNext : null;

		// console.log('TRO::BTR.getStruck', this.tileMap.getStruck(tileIndex), onDone);
		if (this.tileMap.getStruck(tileIndex)) {

		 	if (onDone) onDone();
		}
		else {

			setTimeout(function (tileIndex) { 

				this.addBoardStrike(tileIndex, onDone, onLand.bind(undefined, isLast));
			}.bind(this, tileIndex), 150 * i);
		}
	}
}


BoardTargetReticle.prototype.handleAirStrike = function(onLand, shootNext) { 

	var animation = opponent_special_weapons.clone();

	var horizontal = this.shotInfo.rotateID == 1;
	if (!horizontal) animation.setAnimation("Special_weapon_01_top_to_bottom", false);
	else animation.setAnimation("Special_weapon_01_right_to_left", false);
	animation.shotIndex = 0;
	this.tileContainer.addChild(animation.animation);

	var ty = Math.floor(this.shotInfo.center / TileMapValues.COLS);
	var tx = this.shotInfo.center - (ty * TileMapValues.COLS) + 0.5;

	if (horizontal) animation.setPosition(tx * 74, (ty + 2.5) * 74); // 2,5 needed for a fix
	else animation.setPosition(tx * 74, this.tileMap.getColumns() * 74);

	// Cleanup after we're done
	animation.setOnComplete(function (tileContainer, animation) { 
		setTimeout(function() { 
			if (!tileContainer) return;

			tileContainer.removeChild(animation.animation);
			animation.animation.destroy();
		}, 0);
	}.bind(this, this.tileContainer, animation));

	// Whenever we pass over a tile.
	animation.animation.state.onEvent = function(trackIndex, event) { 

		var name = !horizontal ? event.data.name.replace("Special_weapon_01_vert_drop_", "") : event.data.name.replace("Special_weapon_01_horz_drop_", "") ;
		var num = parseInt(name);
		var planeOffset = horizontal ? num - 1 : TileMapValues.COLS - num;

		for (var i = 0; i < this.shotInfo.tiles.length; i++) {

			var tileIndex = this.shotInfo.tiles[i];
			var ty = Math.floor(tileIndex / this.tileMap.getRows()); // Tile space
			var tx = tileIndex - (ty * this.tileMap.getRows());
			
			if (!horizontal && ty != planeOffset) continue; // this is not the tile we're looking for
			else if (horizontal && tx != planeOffset) continue; // this is not the tile we're looking for

			animation.shotIndex++;
			var doCallbacks = animation.shotIndex == this.shotInfo.tiles.length;
			
			var isLast = animation.shotIndex == this.shotInfo.tiles.length;
			var onDone = (isLast && !this.shouldSkip) ? shootNext : null;
			
			this.addBoardStrike(tileIndex, onDone, onLand.bind(undefined, isLast), "special_weapon_01");
			return;
		}
		console.log(event.data.name, name, num);
	}.bind(this);
}


BoardTargetReticle.prototype.handleBomb = function(onLand, shootNext) { 

	var animation = opponent_special_weapons.clone();
	var horizontal = this.shotInfo.rotateID == 1;
	if (horizontal) animation.setAnimation("Special_weapon_02_vertical", false);
	else animation.setAnimation("Special_weapon_02_diagonal", false);
	animation.shotIndex = 0;
	this.tileContainer.addChild(animation.animation);

	var ty = Math.floor(this.shotInfo.center / TileMapValues.COLS);
	var tx = this.shotInfo.center - (ty * TileMapValues.COLS) + 0.5;

	animation.setPosition(tx * 74, (ty + 0.5) * 74);

	// Cleanup after we're done
	animation.setOnComplete(function (tileContainer, animation) { 
		setTimeout(function() { 
			if (!tileContainer) return;

			tileContainer.removeChild(animation.animation);
			animation.animation.destroy();
		}, 0);
	}.bind(this, this.tileContainer, animation));

	// Whenever we pass over a tile.
	animation.animation.state.onEvent = function(trackIndex, event) { 

		var tileIndex = this.shotInfo.tiles[animation.shotIndex];
		animation.shotIndex++;

		var doCallbacks = animation.shotIndex == this.shotInfo.tiles.length;
		
		var isLast = animation.shotIndex == this.shotInfo.tiles.length;
		var onDone = (isLast && !this.shouldSkip) ? shootNext : null;
		
		this.addBoardStrike(tileIndex, onDone, onLand.bind(undefined, isLast), "special_weapon_02");
	}.bind(this);
}

BoardTargetReticle.prototype.handleTorpedo = function(onLand, shootNext) { 
	var isOld = this.isOldTorpedo();

	this.handleTopTorpedo(isOld);
	var ty = Math.floor(this.shotInfo.center / TileMapValues.COLS);

	setTimeout(function() {
		this.handleBottomTorpedo(onLand, shootNext, isOld);
	}.bind(this), ty * 135);
}

BoardTargetReticle.prototype.isOldTorpedo = function() {
	return (this.shotInfo.tiles[0] < this.shotInfo.tiles[this.shotInfo.tiles.length - 1]);
}

BoardTargetReticle.prototype.handleTopTorpedo = function(isOldTorpedo) {
	var topAnimation = opponent_special_weapons.clone();
	topAnimation.setAnimation("Special_weapon_04_top_to_bottom_1", false);
	this.tileContainer.addChild(topAnimation.animation);
	var ty = Math.floor(this.shotInfo.center / TileMapValues.COLS);
	var tx = this.shotInfo.center - (ty * TileMapValues.COLS) + 0.5;
	var xOffset = isOldTorpedo ? 0.5 : -0.5;
	topAnimation.setPosition((tx + xOffset) * 74, -60);

	topAnimation.setOnComplete(function (tileContainer, topAnimation) { 
		setTimeout(function() { 
			if (!tileContainer) return;

			tileContainer.removeChild(topAnimation.animation);
			topAnimation.animation.destroy();
		}.bind(this), 0);
	}.bind(this, this.tileContainer, topAnimation));
}

BoardTargetReticle.prototype.handleBottomTorpedo = function(onLand, shootNext, isOldTorpedo) {
	var bottomAnimation = opponent_special_weapons.clone();
	bottomAnimation.setAnimation("Special_weapon_04_top_to_bottom_2", false);
	bottomAnimation.shotIndex = 0;
	this.tileContainer.container.addChildAt(bottomAnimation.animation, 1);

	var mask = tbGraphics.drawRectangle(-tgfGraphics.areaWidth, -30, tgfGraphics.areaWidth * 2, tgfGraphics.areaHeight, 0xff0000, null, 0, 0.5);
	this.tileContainer.addChild(mask);
	bottomAnimation.setMask(mask);

	var ty = Math.floor(this.shotInfo.center / TileMapValues.COLS);
	var tx = this.shotInfo.center - (ty * TileMapValues.COLS) + 0.5;
	var xOffset = isOldTorpedo ? 0.5 : -0.5;
	var yOffset = isOldTorpedo ? 1 : 0;

	bottomAnimation.setPosition((tx + xOffset) * 74, (ty + yOffset) * 74);

	// Cleanup after we're done
	bottomAnimation.setOnComplete(function (tileContainer, bottomAnimation, mask) { 
		setTimeout(function() { 
			if (!tileContainer) return;

			tileContainer.removeChild(bottomAnimation.animation);
			tileContainer.removeChild(mask);
			bottomAnimation.animation.destroy();
		}.bind(this), 0);
	}.bind(this, this.tileContainer, bottomAnimation, mask));

	// Whenever we pass over a tile.
	bottomAnimation.animation.state.onEvent = function(trackIndex, event) { 
		
		console.log("BTR.handleTorpedo.onEvent.event.data.name", event.data.name.indexOf('vert_drop'), bottomAnimation.shotIndex, trackIndex); // TODO: start from last 4 events instead of first

		var isValidShot = true;

		if (event.data.name.indexOf('vert_drop') < 0) {

			isValidShot = false;
			console.log("BTR.handleTorpedo.onEvent --> incorrect shotIndex"); // TODO: start from last 4 events instead of first
			return;
		}

		var isLast = bottomAnimation.shotIndex == this.shotInfo.tiles.length - 1;
		var onDone = (isLast && !this.shouldSkip) ? shootNext : null;
		
		if (isValidShot) {
			
			var tileIndex = this.shotInfo.tiles[bottomAnimation.shotIndex];
			console.log('BTR.isValidShot::YES', isLast, tileIndex, onDone);
			
			this.addBoardStrike(tileIndex, onDone, onLand.bind(undefined, isLast), "special_weapon_04");
			bottomAnimation.shotIndex++;
		}
		else {
			console.error('BTR.isValidShot::NO -> should never get here', isLast);
		}

	}.bind(this);

}

BoardTargetReticle.prototype.handleScatterShot = function(onLand, shootNext) { 

	var animation = opponent_special_weapons.clone();
	animation.setAnimation("Special_weapon_05_top_to_bottom", false);
	animation.shotIndex = 0;
	this.tileContainer.addChild(animation.animation);

	var ty = Math.floor(this.shotInfo.center / TileMapValues.COLS);
	var tx = this.shotInfo.center - (ty * TileMapValues.COLS) + 0.5;

	var landPoint = {x: (tx) * 74, y: (ty + 0.5) * 74};

	animation.setPosition(landPoint.x, landPoint.y);

	// Cleanup after we're done
	animation.setOnComplete(function (tileContainer, animation) { 
		setTimeout(function() { 
			if (!tileContainer) return;

			tileContainer.removeChild(animation.animation);
			animation.animation.destroy();
		}.bind(this), 0);
	}.bind(this, this.tileContainer, animation));

	// Whenever we pass over a tile.
	animation.animation.state.onEvent = function(trackIndex, event) { 
		var firedFragments = 0;
		var interval = setInterval(function() {
			if (firedFragments === this.shotInfo.tiles.length) {				
				clearInterval(interval);
				return;
			}

			var isLast = firedFragments === this.shotInfo.tiles.length - 1;
			var onDone = (isLast && !this.shouldSkip) ? shootNext : null;

			var ty = Math.floor(this.shotInfo.tiles[firedFragments] / TileMapValues.COLS);
			var tx = this.shotInfo.tiles[firedFragments] - (ty * TileMapValues.COLS) + 0.5;
			var x = (tx) * 74;
			var y = (ty + 0.5) * 74;

			var onArrive = function(tileIndex, onDone, isLast) {

				this.addBoardStrike(tileIndex, onDone, onLand.bind(undefined, isLast), "special_weapon_05");
				
			}.bind(this, this.shotInfo.tiles[firedFragments], onDone, isLast);

			new ScattershotProjectile(landPoint.x, landPoint.y, x, y, onArrive, this.tileContainer);
			firedFragments++;
		}.bind(this), 50);
	}.bind(this);
}

BoardTargetReticle.prototype.addBoardStrike = function(tileIndex, onDone, onLand, animationName) {

	var prevValue = this.tileMap.getTileByIndex(tileIndex).value;
	this.tileMap.strikeTileByIndex(tileIndex);
	var onStrikeLanded = onLand;

	// If there already is a boardstrike on the tile, remove the old one
	if (prevValue >= 9) {
		for (var i = 0; i < this.boardStrikes.length; i++) {

			if (this.boardStrikes[i].tileIndex == tileIndex) {

				var oldStrike = this.boardStrikes[i];
				this.boardStrikes.splice(i, 1);

				// Override the onLand callback to remove the old boardstrike at the right moment
				onStrikeLanded = function() {

					// Remove the old strike a frame later to prevent errors
					setTimeout(function() {
						tbGame.removeToken(oldStrike);
					}, 0);					

					onLand();

				}.bind(this);
				break;
			}
		}
	}

	var strike = new BoardStrike(this.tileContainer, this.tileMap, tileIndex, true, false, onDone, onStrikeLanded, animationName);
	this.boardStrikes.push(strike);
}

BoardTargetReticle.prototype.hideReticle = function() {
	this.currentAimIterator = this.currentAimSequence.length;
	this.aiming = this.currentAimIterator != this.currentAimSequence.length;

	this.reticle.setAlpha(0);
	this.legal.setAlpha(0);
	this.illegal.setAlpha(0);
	this.legalTrail.setAlpha(0);
	this.illegalTrail.setAlpha(0);

	this.currentTarget = null;
	this.previousTarget = null;
};

BoardTargetReticle.prototype._doneAiming = function() { 
	// Make sure that, if skipping, that we do the right things
	this.hideReticle()

	var self = this;
	var hasShot = false;
	var shootNext = function () {
		if (self.futureAimAts.length != 0) {
			if (!hasShot) {
				// console.log("Aiming at future aimat");
				self.aimAt(self.futureAimAts[0].shotInfo, self.futureAimAts[0].onComplete, self.futureAimAts[0].onLand, self.shouldSkip);
				self.futureAimAts.splice(0, 1);

				hasShot = true;
			}
		}
		else if (self.onComplete) {
			// console.log('done');
			self.onComplete();
			self.onComplete = null;
		}
	};

	var onLand = function (isLast) {

		console.log('BTR.onLand', isLast);

		self.board.updateSank();
		if (self.onLand) {
			self.onLand();
		}

		// Shoot next on land rather than after the whole animation
		if (self.shouldSkip && isLast) 
			shootNext();
	};

	switch (this.shotInfo.strikeID) {
		default:
		case SpecialWeaponData.SpecialWeapon.default:{

			this.handleDefault(onLand, shootNext);
			break;
		};
		case SpecialWeaponData.SpecialWeapon.airStrike: {

			this.handleAirStrike(onLand, shootNext);
			break;
		};
		case SpecialWeaponData.SpecialWeapon.bomb: {

			this.handleBomb(onLand, shootNext);
			break;
		};
		case SpecialWeaponData.SpecialWeapon.torpedo: {
			this.handleTorpedo(onLand, shootNext);
			break;
		};
		case SpecialWeaponData.SpecialWeapon.scatter: {
			this.handleScatterShot(onLand, shootNext);
			break;
		};
	}
}

BoardTargetReticle.prototype.setSingleTarget = function(targetIndex) {
	this.currentAimSequence = [];

	if (this.currentTarget != null) {
		this.previousTarget = this.currentTarget;
	} else {
		this.previousTarget = targetIndex;
	}

	this.currentTarget = targetIndex;
	this.currentAimTime = 0;

	if (!this.addedToTileContainer) {

		tgfGraphics.addChild(this.illegal.sprite, 'illegal');
		tgfGraphics.addChild(this.legal.sprite, 'legal');
		tgfGraphics.addChild(this.illegalTrail.sprite, 'illegalTrail');
		tgfGraphics.addChild(this.legalTrail.sprite, 'legalTrail');
		tgfGraphics.addChild(this.reticle.sprite, 'reticle');
		
		this.addedToTileContainer = true;
	}
}

BoardTargetReticle.prototype.handleEndStep = function(timePassed) { 
	"use strict";

	var wasAiming = this.aiming;
	this.aiming = this.currentAimIterator != this.currentAimSequence.length && !this.currentTarget;
	var isFinal = this.currentAimIterator == this.currentAimSequence.length - 1;
	
	// If we're done.
	if ((this.aiming == false || this.shouldSkip) && !this.currentTarget) {

		// Check if we weren't aiming before
		if (!wasAiming) {
			return; // Don't do anything in this function
		}


		this._doneAiming();		
		
		return;
	}

	this.totalTime += timePassed;
	
	this.blinkTime += timePassed;
	var blinkDelay = (isFinal ? this.finalBlinkDelay : this.blinkDelay);
	if (this.blinkTime > blinkDelay) {
		this.blinkTime = 0;
		
		this.reticle.setAlpha(this.reticle.alpha > 0.5 ? 0.5 : 1.0);
	}

	this.soundTime += timePassed;
	var soundDelay = isFinal ? this.lockSoundDelay : this.targetSoundDelay;
	var sound = isFinal ? a_opponent_target : a_lock_sound;
	if (this.soundTime > soundDelay) {
		this.soundTime = 0;
		tgfAudio.play(sound);
	}

	this.currentAimTime += timePassed;

	var aimStart = this.currentAimSequence[this.currentAimIterator];
	var aimEnd = this.currentAimSequence[Math.min(this.currentAimIterator + 1, this.currentAimSequence.length - 1)]; // This has a Math.min to stay on the final location

	if (this.currentTarget) {
		aimStart = this.previousTarget;
		aimEnd = this.currentTarget;
	}

	var aimStartY = Math.floor(aimStart / this.tileMap.getRows()); // Tile space
	var aimStartX = aimStart - (aimStartY * this.tileMap.getRows());

	var aimEndY = Math.floor(aimEnd / this.tileMap.getRows()); // tile space
	var aimEndX = aimEnd - (aimEndY * this.tileMap.getRows());

	var travelProgression = this.currentAimTime / this.travelTime;
	var waitProgression = (this.currentAimTime - this.travelTime) / this.waitTime; // TODO: Change to finalWaitTime for last one
	
	// Current position based on the lerp between 
	var curX = lerp(aimStartX, aimEndX, travelProgression);
	var curY = lerp(aimStartY, aimEndY, travelProgression);
	var curIndex = Math.round(curY) * this.tileMap.getRows() + Math.round(curX);

	// Get closest tile based on current X/Y
	var closestTileY = Math.floor(curIndex / this.tileMap.getRows()); // Tile space
	var closestTileX = curIndex - (closestTileY * this.tileMap.getRows());

	// Set reticle at actual position
	this.reticle.setPosition(this.offset.x + curX * 74 + this.reticle.xOrigin, this.offset.y + curY * 74 + this.reticle.yOrigin);

	// Set legal or illegal at closest tile
	this.legal.setPosition(this.offset.x + closestTileX * 74, this.offset.y + closestTileY * 74);
	this.illegal.setPosition(this.offset.x + closestTileX * 74, this.offset.y + closestTileY * 74);
	
	// Show legal or illegal tile
	var isShip = this.tileMap.getMap()[curIndex] != 0;
	this.legal.setAlpha(isShip ? 0 : 1);
	this.illegal.setAlpha(isShip ? 1 : 0);
	
	if (curIndex != this.lastIndex) {
		var closestTrailTileY = Math.floor(this.lastIndex / this.tileMap.getRows()); // Tile space
		var closestTrailTileX = this.lastIndex - (closestTrailTileY * this.tileMap.getRows());

		this.legalTrail.setPosition(this.offset.x + closestTrailTileX * 74, this.offset.y + closestTrailTileY * 74);
		this.illegalTrail.setPosition(this.offset.x + closestTrailTileX * 74, this.offset.y + closestTrailTileY * 74);
			
		var isShip = this.tileMap.getMap()[this.lastIndex] != 0;
		this.legalTrail.setAlpha(isShip ? 0 : 0.5);
		this.illegalTrail.setAlpha(isShip ? 0.5 : 0);

		this.lastIndex = curIndex;
	}

	// If we're on our last one
	if (isFinal) {
		var scale = this.reticle.scaleX + 0.001 * timePassed;
		this.reticle.setScale(scale, scale);
	}
	else { 
		this.reticle.setScale(1, 1);
	}

	if (travelProgression > 1) {
		this.legalTrail.setAlpha(0);
		this.illegalTrail.setAlpha(0);
	}

	// If we're done traveling and done waiting
	if (travelProgression > 1 && waitProgression > 1 && !this.currentTarget) {
		this.currentAimIterator++;
		this.currentAimTime -= this.travelTime + this.waitTime;
		if (this.currentAimTime < 0) {
			this.currentAimTime = 0;
		}
	}
};

//******************************************************
//*****    Token Resource: BoardStrike
//******************************************************

// ***************************************
// Definition of game token BoardStrike
// ***************************************

// The constructor for the BoardStrike game token. 
var BoardStrike = function(tileContainer, tileMap, tileIndex, playAnimation, displayImage, onStrikeDone, onLand, animationName, x, y, depth) {
	"use strict";

	console.log('BoardStrike::BoardStrike');

	// Properties used by the engine
	this.depth = depth;
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;

	this.hitSounds = [
		a_board_strike_land_0,
		a_board_strike_land_1,
		a_board_strike_land_2,
		a_board_strike_land_3,
		a_board_strike_land_4
	];

	this._onStrikeDone = onStrikeDone;
	this._onLand = onLand;

	var tileData = tileMap.getTileByIndex(tileIndex);
	this.tileIndex = tileIndex;

	// console.log(tileData);

	var tx = tileData.tx;
	var ty = tileData.ty;

	var pos = { x: tx * TileMapValues.WIDTH + TileMapValues.WIDTH/2, y: ty * TileMapValues.HEIGHT + TileMapValues.HEIGHT/2 };
	
	this.isHit = !(tileData.value == 0 || tileData.value == 9);
	var playIdle = (!!displayImage && !this.isHit);
	var playLand = !!playAnimation;

	this.shouldPlayAnimation = playIdle || playLand; // Play animation anyway if it's a miss and if I requested an image that doesn't exist.

	this.landAnimation = animationName || "land";
	this.animationName = playLand ? this.landAnimation : "idle";
	
	if (playAnimation) {
		tgfAudio.play(a_board_strike);
	}

	if (this.isHit) {
		this.shipId = tileMap.getMap()[tileIndex];
		this.hits = tileMap.getShipHits(this.shipId);
	}
	else {
		this.shipId = null;
		this.hits = null;
	}

	this.container = tileContainer;
	this.tileMap = tileMap;

	this.x = pos.x;
	this.y = pos.y;

	this.animationType = this.isHit ? hit_animation : miss_animation;
	if (this.shouldPlayAnimation) {
		if (this.animationType.spineData === undefined) {
			this.animationType.startLoading();
		}
	}
	else if (this._onStrikeDone) {
		this._onStrikeDone();
	}

	// Add it to the game engine
	tbGame.addToken(this);
	tbGame.addTokenTags(this, ['token']);
};

BoardStrike.comboCount = 0;

BoardStrike.prototype.handleRemove = function() {
	"use strict";
	
	if (this.setIdleAnimationTimeout) { 
		clearTimeout(this.setIdleAnimationTimeout);
		this.setIdleAnimationTimeout = null;
	}

	if (this.hitAnimation) {
		this.hitAnimation.animation.destroy({children: true});
		this.hitAnimation.animation = null;
		this.hitAnimation = null;
	}

	if (this.hitSounds) {
		this.hitSounds = null;
	}

	if (this._onStrikeDone) {
		this._onStrikeDone = null;
	}

	if (this._onLand) {
		this._onLand = null;
	}

	if (this.hitText && this.container && this.container.container) {
		this.hitText.free();
		this.hitText = null;
	}
	else {		
		this.hitText = null;
	}

	if (this.container) {
		this.container = null;
	}
	if (this.tileMap) { 
		this.tileMap = null;
	}

	if (this.animationType) {
		this.animationType = null;
	}
};

// handleEndStep is called each step after processing other events (before draw).
BoardStrike.prototype.handleEndStep = function(timePassed) { 
	"use strict";
	var animationLoaded = this.animationType.spineData !== undefined;
	var animationShown = (this.hitAnimation !== undefined && this.hitAnimation !== null);

	if (this.shouldPlayAnimation && animationLoaded && animationShown == false) {
        this.hitAnimation = this.animationType.clone();

        this.hitAnimation.setPosition(this.x, this.y);
        this.container.addChild(this.hitAnimation.animation);
		this.hitAnimation.setAnimation(this.animationName, false);
		
		var self = this;
		this.hitAnimation.setEventCallback("on_land", function () { 
			if (self._onLand) {
				self._onLand();
			}

			if (self.isHit) {
				var index = Math.min(BoardStrike.comboCount, 4);
				var hitSound = self.hitSounds[index];
				BoardStrike.comboCount += 2;
				
				tgfAudio.play(hitSound);
			}
			else {
				BoardStrike.comboCount = 0;
				tgfAudio.play(a_board_miss);
			}
		});

		// Events for when the hit or miss text should appear
		this.hitAnimation.setEventCallback(self.isHit ? "hit_text" : "miss_text", function () { 
			self.playTextAnimation(self.isHit);
		});

		this.hitAnimation.setOnComplete(function()
		{
			if (self._onStrikeDone && !self._struckOnce) {
				self._struckOnce = true;
				self._onStrikeDone();
			}

			if(self.image) // the hit image doesn't have an animation so self.image contains a placeholder sprite
				self.image.setAlpha(1);
			else { 
				self.setIdleAnimationTimeout = setTimeout(function() {
					console.log("idle", self.hitAnimation);
					self.hitAnimation.setAnimation("idle", true);
					self.hitAnimation.setOnComplete(null);
				}, 0);
			}		
		});
	}

	if (this.textAnimator) {
		this.hitTextFlickerTimer -= timePassed;
		this.textAnimator.updateTime(timePassed);
	}
};

/** Plays the animation of the HIT! or MISS! text when the shot landed */
BoardStrike.prototype.playTextAnimation = function(isHit) {

	this.hitText = isHit ? this.createHitText() : this.createMissText();
	var self = this;
	var startPosY = this.y - 6;

	this.hitText.setPosition(this.x, startPosY);
	this.container.addChild(this.hitText);

	this.hitTextFlickerTimer = 0;
	this.hitTextVisible = false;

	this.textAnimator = new tbAnimator();
	var textAnimatorTrackY = this.textAnimator.addTrack('function', this, function(ypos) { this.hitText.setPosition(this.hitText.x, startPosY + ypos); });
	var textAnimatorTrackAlpha = this.textAnimator.addTrack('function', this, function(value) {

		// Play fade away aniamtion
		if (value <= 1) {
			this.hitText.setAlpha(value);

			// Remove the animator
			if (value == 0) {
				setTimeout(function() {
					if (self.textAnimator) {
						self.textAnimator.removeAllKeys();
						self.textAnimator.removeEvents();
						self.textAnimator = null;
					}
				}, 0);
			}
		}
		// Play flicker animation
		else if (this.hitTextFlickerTimer <= 0) {
			this.hitTextVisible = !this.hitTextVisible;
			this.hitTextFlickerTimer = 50;
			this.hitText.setAlpha(this.hitTextVisible ? 0 : 1);
		}
	});

	this.textAnimator.addKey(textAnimatorTrackAlpha, 0, 2, tbEase.easeLinear, 1);
	this.textAnimator.addKey(textAnimatorTrackAlpha, 500, 1, tbEase.easeLinear, 1);
	this.textAnimator.addKey(textAnimatorTrackAlpha, 1500, 0, tbEase.easeLinear, 1);
	
	this.textAnimator.addKey(textAnimatorTrackY, 0, 0, tbEase.easeLinear, 1);
	this.textAnimator.addKey(textAnimatorTrackY, 1500, -82, tbEase.easeLinear, 1);

	this.textAnimator.setTime(0);
}

BoardStrike.prototype.createMissText = function() {

	var font = f_impact.clone();
	font.setText(tgfDictionary.getText("FloaterMiss"));
	
	font.setFillColor(["#f9fbff", "#7db1ff"]);
	font.setStrokeColor('#082e6f');

	font.setFontSize(30);
	font.setStrokeWidth(4);
	font.setAlign('center');
	font.setBaseline('middle');

	return font;
}

BoardStrike.prototype.createHitText = function() {

	var font = f_impact.clone();
	font.setText(tgfDictionary.getText("FloaterHit"));

	font.setFillColor(['#ffbd00', '#ff1e00']);
	font.setStrokeColor('#650000');

	font.setFontSize(30);
	font.setStrokeWidth(4);
	font.setAlign('center');
	font.setBaseline('middle');

	return font;
}

BoardStrike.prototype.getShipSize = function(id) {

    switch (id) {
        case 11: case 1: return 5;
        case 12: case 2: return 4;
        case 13: case 3: return 3;
        case 14: case 4: return 3;
        case 15: case 5: return 2;
        default: return 0;
    }
}

//******************************************************
//*****    Token Resource: BoardToken
//******************************************************

// ***************************************
// Definition of game token BoardToken
// ***************************************

// The constructor for the BoardToken game token.
var BoardToken = function(x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth;
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;

	var self = this;
	this._isLocked = true;


	var mapOptions = {
		rows: TileMapValues.ROWS,
		cols: TileMapValues.COLS,
		tileWidth: TileMapValues.WIDTH,
		tileHeight: TileMapValues.HEIGHT,
		tileImage: s_pla_tile_board
	};

	this._tileMap = new TileMap(mapOptions);
	this._tileContainer = this._tileMap.getContainer();

	// add ships
	this._ships = [];
	this._placedShips = [];
	var ship;
	var id;

	for (var i = 0; i < 5; i++) {

		id = parseInt(i + 1);

		ship = new BoardShip(id, 0, 0, true);

		ship.onFreeMove = function(x, y) {

			// console.log(this.id);
			self.unplaceShip(this, x, y);
		};

		this._tileContainer.addChild(ship.container);

		this._ships.push(ship);
	}


	this.width = mapOptions.tileWidth * mapOptions.rows;
	this.height = mapOptions.tileHeight * mapOptions.cols;

	// position tile-map
	this._tileContainer.container.x = 384 + ((TileMapValues.MAX_COLS - TileMapValues.COLS) * TileMapValues.WIDTH * 0.5);
	this._tileContainer.container.y = 744 + ((TileMapValues.MAX_ROWS - TileMapValues.ROWS) * TileMapValues.HEIGHT * 0.5) - 100; // Applied offset

	this.targetReticle = new BoardTargetReticle(this._tileMap, this._tileContainer, this);

	this._waveMachine = new WaveMachine(this._tileMap, this);

	// add graphics
	tgfGraphics.addChild(this._tileContainer.container, 'boardtoken._tileContainer');


	// add turn listener
	TurnController.addTurnListener(this.onTurnUpdate, this);

};

BoardToken.prototype.onTurnUpdate = function(state) {

	var bd = UserDataController.getBattleData();

	switch (state) {
		case TurnController._TURN_STATES.FEEDBACK_SHOWING : {
			// console.log('showing opponent shots:', bd.lastAction );

			var len = bd.lastAction.length;
			var last = len - 1;

			if (UserDataController.getMatchData().isTimed) {
				var overlookedShots = this._getOverlookedShots(bd.lastAction);

				if (overlookedShots.length > 0) {
					for (var i = 0; i < overlookedShots.length; i++) {
						this.addShot(overlookedShots[i], (i+1), (i == overlookedShots.length - 1));
					}
				} else {
					this._checkEndgame();
				}
				return
			}

			if (len == 0) {
				this._checkEndgame();
			}
			else {

				for (var i = 0; i < len; i++) {

					this.addShot(bd.lastAction[i], (i+1), (i == last) );
				}
			}
			break;
		}
	}
}

BoardToken.prototype._checkEndgame = function() {

	// console.log('TRO::BT._checkEndgame');

	if (!this._tileMap) {
		console.warn('BoardToken._checkEndGame --> no map found!!, returning....');
		return;
	}

	var result = this._tileMap.getResult();
	// console.log('board-result:', result.shots, result.hits, result.misses);

	if (result.hits >= WinConditions.HITS_REQUIRED) {

		// console.log('TRO::BT._checkEndgame - if');
		tbGame.addSpecial('game-complete-lose', result);
	}
	else {

		// console.log('TRO::BT._checkEndgame - else');
		TurnController.advanceFrom(TurnController._TURN_STATES.FEEDBACK_SHOWING);
		this._shouldPreventDirectShots = false;
	}
}

BoardToken.prototype._getOverlookedShots = function(shots) {
	var overlookedShots = [];
	for (var i = 0; i < shots.length; i++) {
		if (!this._haveTilesBeenHit(shots[i].tiles)) {
			overlookedShots.push(shots[i]);
		}
	}
	return overlookedShots;
}

BoardToken.prototype._haveTilesBeenHit = function(tiles) {

	if (!this._tileMap) {
		console.warn('BoardToken._haveTilesBeenHit --> no map found!!, returning....');
		return true;
	}

	for (var i = 0; i < tiles.length; i++) {
		if (this._tileMap.getTileByIndex(tiles[i]).value < 9) {
			return false;
		}
	}
	return true;
}

BoardToken.prototype.addShot = function(shotInfo, delay, last) {

	// Patch old tile info
	// tileIndex => { tiles: [ tileIndex ], strikeID: regular strike, rotation: none };
	if (Number.isInteger(shotInfo)) shotInfo = BattleData.patchToActionElement(shotInfo);

	if (last) {
		this._shouldPreventDirectShots = true;
	}

	var self = this;
	this.targetReticle.aimAt(shotInfo, function() {
		if (last) {
			setTimeout(function() {
				self._checkEndgame();
			}, 1000);
		}
	});
}

BoardToken.prototype.addShotDirectly = function(shotInfo, delay, last) {

	if (this._shouldPreventDirectShots) {
		return;
	}

	if (Number.isInteger(shotInfo)) shotInfo = BattleData.patchToActionElement(shotInfo);

	var self = this;
	this.targetReticle.aimAt(shotInfo, function() {
		if (last) {
			setTimeout(function() {

				var result = self._tileMap.getResult();

				if (result.hits >= WinConditions.HITS_REQUIRED) {

					tbGame.addSpecial('game-complete-lose', result);
				}


			}, 1000);
		}
	});
}

BoardToken.prototype.parseBoard = function() {

	var tiles = this._tileMap.getMap();

	for (var i = 0; i < tiles.length; i++) {

		var ty = Math.floor(i / TileMapValues.COLS);
		var tx = i - (ty * TileMapValues.COLS);

		var value = this._tileMap.getTileByIndex(i).value;

		if (value >= 9) {

			var boardShot = new BoardStrike(this._tileContainer, this._tileMap, i, false, true, this.updateSank.bind(this, true));
		}
	}
}

BoardToken.prototype.updateSank = function(skipLoad) {

	// console.log("updateSank", this, this._tileMap);

	var tiles = this._tileMap.getMap();


	for (var i = 0; i < this._ships.length; i++) {

		var shipIndex = this._ships[i].id;
		var shipIndexHit = shipIndex + 10;

		var tileStart = -1;

		var shipTileStart = tiles.indexOf(shipIndex);
		var shipTileHitStart = tiles.indexOf(shipIndexHit);

		if (shipTileStart >= 0) {
			if (shipTileHitStart >= 0) {
				tileStart = Math.min(shipTileStart, shipTileHitStart);
			}
			else {
				tileStart = shipTileStart;
			}
		}
		else {
			tileStart = shipTileHitStart;
		}

		var size = this._ships[i].getSize();
		var hasSunk = true;
		var fires = [];
		for (var j = 0; j < size; j++) {
			var horizontalTile = tiles[tileStart + 1 * j];
			var verticalTile = tiles[tileStart + TileMapValues.COLS * j];

			if (verticalTile == shipIndexHit || horizontalTile == shipIndexHit) {
				fires.push(true);
			}
			else {
				hasSunk = false;
				fires.push(false);
			}
		}

		this._ships[i].lightFires(fires, hasSunk, !!skipLoad);
	}
}

BoardToken.prototype.parseFleet = function() {

	var tiles = this._tileMap.getMap();

	for (var i = 0; i < this._ships.length; i++) {

		var shipIndex = this._ships[i].id;
		var shipIndexHit = shipIndex + 10;

		var tileStart = -1;

		var shipTileStart = tiles.indexOf(shipIndex);
		var shipTileHitStart = tiles.indexOf(shipIndexHit);

		if (shipTileStart >= 0) {

			if (shipTileHitStart >= 0) {
				tileStart = Math.min(shipTileStart, shipTileHitStart);
			}
			else {
				tileStart = shipTileStart;
			}
		}
		else {
			tileStart = shipTileHitStart;
		}

		var nextHor = tiles[tileStart + 1];
		var nextVer = tiles[tileStart + TileMapValues.COLS];

		var isVer = (nextVer == shipIndex || nextVer == shipIndexHit );
		var isHor = (nextHor == shipIndex || nextHor == shipIndexHit );

		var size = this._ships[i]._size;

		var ty = Math.floor(tileStart / TileMapValues.COLS);
		var tx = tileStart - (ty * TileMapValues.COLS);

		var tileStartData = this._tileMap.getTileByIndex(tileStart);

		var ship = this._ships[i];

		ship.setTilePosition(tx, ty);
		ship.setVertical(isVer);

		ship.show();
	}
}

BoardToken.prototype.getBoard = function() {
	return this._ships;
}

BoardToken.prototype.getTileMap = function() {
	return this._tileMap;
}

// handleTouchUp is called when a touch is ended or if a mouse button is released.
BoardToken.prototype._deselect = function(tileIndex) {

	if (this.tileDeselected) this.tileDeselected();
}

BoardToken.prototype._select = function(tileIndex) {

	if (this.tileSelected) this.tileSelected(tileIndex);
}


// handleAdd is called when the token is (re-) added to the game.
BoardToken.prototype.handleAdd = function() {
	"use strict";
};

// handleRemove is called when the token is removed from the game.
BoardToken.prototype.handleRemove = function() {
	"use strict";

	// console.log('BoardToken.handleRemove');


	if (this._tileMap) {
		this._tileMap = null;
	}


	if (this._ships) {
		for (var i = 0; i < 5; i++) {

			var ship = this._ships[i];
			this._tileContainer.removeChild(ship.container);
		}

		this._ships = null;
	}

	if (this._placedShips) {
		this._placedShips = [];
	}

	if (this.targetReticle) {
		this.targetReticle = null;
	}

	if (this._waveMachine) {
		tbGame.removeToken(this._waveMachine);
		this._waveMachine = null;
	}

	if (this._shipPlacement) {
		tbGame.removeToken(this._shipPlacement);
		this._shipPlacement = null;
	}

	if (this._tileContainer && this._tileContainer.container) {
		tgfGraphics.removeChild(this._tileContainer.container);
		this._tileContainer.container.destroy({children:true});
		this._tileContainer.container = null;
		this._tileContainer = null;
	}

	if (this._tileContainer) {
		this._tileContainer = null;
	}
};

// handleBeginStep is called each step before processing other events.
BoardToken.prototype.handleBeginStep = function(timePassed) {
	"use strict";
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
BoardToken.prototype.lockBoard = function() {

	this._isLocked = true;
}

BoardToken.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";

	if (this._isLocked) return;

	var tile = this._tileMap.getTile(x, y);

	if (this._tileMap.validateTile(tile)) {
		// console.log(tile);
		this._select(tile.index);
	}
	else {
		this._deselect();
	}
};

BoardToken.prototype.handleTouchUp = function(finger, x, y) {
	"use strict";
};

// handleKeyDown is called if the key with the given keyCode is pressed.
BoardToken.prototype.handleKeyDown = function(keyCode) {
	"use strict";
};

// handleKeyUp is called if the key with the given keyCode is released.
BoardToken.prototype.handleKeyUp = function(keyCode) {
	"use strict";
};

// handleAlarm is called if a global alarm is reached.
BoardToken.prototype.handleAlarm = function(alarm) {
	"use strict";
};

// handleSpecial is called if a special or user-defined event happens.
BoardToken.prototype.handleSpecial = function(id, args) {
	"use strict";
};

// handleEndStep is called each step after processing other events (before draw).
BoardToken.prototype.handleEndStep = function(timePassed) {
	"use strict";
};

// handleDraw is called at the end of a step to draw the token.
BoardToken.prototype.handleDraw = function() {
	"use strict";
};


//******************************************************
//*****    Script Resource: BoardShip
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var BoardShip = function(id, isVertical, hasSunk) {

	isVertical = isVertical || true;

	var self = this;

	this.id = id;
	this._size = this._getSize(id);
	this._hasSunk = !!hasSunk;
	this._stateVertical = true;

	this.tile = -1;

	this.container = new tbContainer();

	this.animation = new BoardShipModel(this, 0, 0);
	this.animation.setAlpha(0);
}

BoardShip.prototype.constructor = BoardShip;

BoardShip.prototype.show = function() {
	this.container.container.visible = true;
	this.animation.setAlpha(1);
}

BoardShip.prototype.hide = function() {

	this.container.container.visible = false;
	this.animation.setAlpha(0);
}

BoardShip.prototype.isVisible = function() {
	return this.container.container.visible;
}

BoardShip.prototype.place = function(placer, skipAnimation, playAudio) {

	if (playAudio == undefined) playAudio = true;

	this.show();
	this.animation.resetAnimation();

    var that = this;
	if (this._timeoutPlayPlacement) {
		clearTimeout(this._timeoutPlayPlacement);
		this._timeoutPlayPlacement = null;
	}
	this._timeoutPlayPlacement = setTimeout(function() {

		that.animation.playPlacement(placer.isVertical(), skipAnimation, playAudio);
	}, 33);
}

BoardShip.prototype.setVertical = function(isVertical) {

	this._stateVertical = isVertical;

	if (this.hasSunk) {	
		// Check if the animation that is going to play is skipping or not 
		if (!this.animation.getQueuedAnimation())
			this.animation.playSink(isVertical, true);
	}
	else { 
		this.animation.playIdle(isVertical);
	}
}

BoardShip.prototype.isVertical = function() {
	return this._stateVertical;
}

BoardShip.prototype.setTilePosition = function(x, y) {

	this.tile = y * TileMapValues.ROWS + x;
	this.tileX = x;
	this.tileY = y;

	if (this.tile < 0) {
		this.x = -9000;
		this.y = -9000;
	
		this.container.setPosition(this.x, this.y);
		return;
	}

	this.x = x * TileMapValues.WIDTH;
	this.y = y * TileMapValues.HEIGHT;

	this.container.setPosition(this.x, this.y);
}

BoardShip.prototype.getAnimator = function() {
	return this.animation;
}

BoardShip.prototype.addToTop = function() {

	if (!this.container.container.parent) throw new Error('BoardShip->container.parent NOT set');

	this.container.container.parent.addChild(this.container.container);
}

BoardShip.prototype.lightFires = function (fires, hasSunk, skipLoad) {
	
	if (this.hasSunk != hasSunk && hasSunk) {
		this.animation.playSink(this._stateVertical, skipLoad);
	}
	this.hasSunk = hasSunk;
	
	for (var i = 0; i < fires.length; i++) {
		this.animation.lightFire(i, fires[i]);
	}

	// Refresh the images
	this.setVertical(this._stateVertical);
}

BoardShip.prototype.getSize = function() {
	return this._getSize(this.id);
}

BoardShip.prototype._getSize = function(id) {
    switch (id) {
        case 1: return 5;
        case 2: return 4;
        case 3: return 3;
        case 4: return 3;
        case 5: return 2;
        default: return 0;
    }
}
//******************************************************
//*****    Token Resource: LightHandler
//******************************************************

// ***************************************
// Definition of game token LightHandler
// ***************************************

// The constructor for the LightHandler game token. 
var LightHandler = function(container, x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth;	
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;

	this.lightCount = 3;
	this.transitionDelay = 500;
	
	var buttonsOffset = { x: 368, y: 250 };

	this.TransitionType = { Blink: 0, Fade: 1 };

	this.buttons = [
		s_fire_led_on.clone(),
		s_fire_led_on.clone(),
		s_fire_led_on.clone()
	];

	this._container = container;

	for(var i = 0; i < 3; i++) {
		this.buttons[i].transitionType = this.TransitionType.Blink;
		this.buttons[i].isTransitioning = false;
		this.buttons[i].transitionTimer = 0;
		this.buttons[i].alphaAfterTransition = 1.0;

		this.buttons[i].setPosition(buttonsOffset.x + 50 * i, buttonsOffset.y);
		this._container.addChild(this.buttons[i]);
	} 

	// Add it to the game engine
	tbGame.addToken(this);
	tbGame.addTokenTags(this, ['token']);

	// Make sure the lights are all on (sanity check)
	this.setLightCount(this.lightCount);
}; 

LightHandler.prototype.handleRemove = function () {
	"use strict";

	if (this.TransitionType) {
		this.TransitionType = null;
	}

	if (this.buttons) {
		
		for(var i = 0; i < 3; i++) {
			if (this._container) {

				this._container.removeChild(this.buttons[i]);
			}
		} 
		
		this.buttons = null;
	}

	this._container = null;
}

LightHandler.prototype.setLightCount = function(lights) {
	this.lightCount = 0;
	for(var i = 2; i >= 0; i--) {
		var isOn = lights > i;

		this.buttons[i].alphaAfterTransition = isOn ? 1.0 : 0.0;
		this.buttons[i].transitionType = Math.random() > 0.5 ? this.TransitionType.Blink : this.TransitionType.Fade;
		this.buttons[i].isTransitioning = this.buttons[i].isTransitioning || this.buttons[i].alphaAfterTransition != this.buttons[i].alpha;
		this.buttons[i].transitionTimer = this.transitionDelay;

		if (isOn) this.lightCount++;
	}
};

LightHandler.prototype.subtractLightCount = function(lights) {
	this.setLightCount(this.lightCount - lights);
};

LightHandler.prototype.addLightCount = function(lights) {
	this.setLightCount(this.lightCount + lights);
};

// handleBeginStep is called each step before processing other events.
LightHandler.prototype.handleBeginStep = function(timePassed) {
	"use strict";

	for(var i = 0; i < 3; i++) {
		if(this.buttons[i].isTransitioning) {
			this.buttons[i].transitionTimer -= timePassed;
			this.buttons[i].isTransitioning = this.buttons[i].transitionTimer > 0;

			if (this.buttons[i].isTransitioning == false) {
				this.buttons[i].transitionTimer = 0;
				this.buttons[i].setAlpha(this.buttons[i].alphaAfterTransition);
				continue;	
			}				

			switch(this.buttons[i].transitionType) {
				case this.TransitionType.Fade:
					var t = 1 - (this.buttons[i].transitionTimer / this.transitionDelay);
					this.buttons[i].alpha = this.buttons[i].alpha + t * (this.buttons[i].alphaAfterTransition - this.buttons[i].alpha);
					this.buttons[i].setAlpha(this.buttons[i].alpha);
					break;
				case this.TransitionType.Blink:
					this.buttons[i].setAlpha(this.buttons[i].alpha + (Math.random() * 0.5) - 0.25);
					break;
			}
		}
	}
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
LightHandler.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
LightHandler.prototype.handleTouchUp = function(finger, x, y) { 
	"use strict";
};
// handleKeyUp is called if the key with the given keyCode is released.
LightHandler.prototype.handleKeyUp = function(keyCode) { 
	"use strict";

};
//******************************************************
//*****    Token Resource: WaveMachine
//******************************************************

// ***************************************
// Definition of game token WaveMachine
// ***************************************

// The constructor for the WaveMachine game token. 
var WaveMachine = function(tileMap, board) {
	"use strict";
	this.depth = 0;	
	this.layer = 0;
	this.visible = true;
	this.active = true;
	
	this.ripples = [];

	this.board = board;
	this.tileMap = tileMap;
	this.time = 0;
	this.waveSpeed = 0.3;
	this.originalPosition = [];

	var tiles = this.tileMap.getTileImages();
	for (var i = 0; i < tiles.length; i++) {
		this.originalPosition.push({ x: tiles[i].x, y: tiles[i].y });
	}

	tbGame.addToken(this);
};

WaveMachine.prototype.addRipple = function(x, y, intensity) {
	
	// Don't react when we're placing or when the fire unit is out.
	var playControllers = tbGame.findTokens("playcontroller");
	if (playControllers.length != 0) {
		var fireUnit = playControllers[0].getFireUnit();
		var isPlacing = playControllers[0].isPlacing();
		var fireUnitVisible = fireUnit && !fireUnit.hasMovedOut();
		if (isPlacing || fireUnitVisible)
			return;
	}

	tgfAudio.play(a_water_tap);

	intensity = (intensity || 1) * 4;

	this.ripples.push({
		x: x, y: y, 
		
		distance: 0,
		originalIntensity: intensity, 
		intensity: intensity, 
		repeated: 0
	});
}

WaveMachine.prototype.handleRemove = function() {
	"use strict";

	if (this.ripples) {
		this.ripples = null;
	}
	
	if (this.board) {
		this.board = null;
	}

	if (this.tileMap) {
		this.tileMap = null;
	}
	
	if (this.originalPosition) {
		this.originalPosition = null;
	}
};

WaveMachine.prototype.handleEndStep = function(timePassed) { 
	"use strict";
	this.time += timePassed;

	// ambience management
	var isPlaying = this.ambience && tgfAudio.isPlaying(this.ambience);
	var shouldPlay = true;

	// update shouldPlay
	var playControllers = tbGame.findTokens("playcontroller");
	if (playControllers.length != 0) {
		var fireUnit = playControllers[0].getFireUnit();
		var fireUnitVisible = fireUnit && !fireUnit.hasMovedOut();

		// Don't play during top-side play
		if (fireUnitVisible)
			shouldPlay = false;
	}

	// check if should be changed
	if ((!isPlaying && shouldPlay) || (isPlaying && !shouldPlay)) {
		if (shouldPlay) { 
			this.ambience = tgfAudio.play(a_water_ambience, 0, 500);
			tgfAudio.setLooping(this.ambience, true);
		}
		else {
			tgfAudio.stop(this.ambience, 500);
			this.ambience = null;
		}
	}

	var realTime = timePassed * 0.001;
	for (var i = 0; i < this.ripples.length; i++) {
		var ripple = this.ripples[i];
		
		ripple.distance += realTime * ripple.intensity;
		ripple.intensity -= realTime;

		if (ripple.intensity <= 0 || ripple.distance > this.tileMap.getRows()) {

			// remove
			//if (ripple.repeated >= 2) {
				this.ripples.splice(i, 1);
				i--;
				continue;
			//}

			ripple.intensity = ripple.originalIntensity * 0.6;
			ripple.originalIntensity = ripple.intensity;
			ripple.distance = 0;
			ripple.repeated++;
		}
	}

	var tiles = this.tileMap.getTileImages();
	for (var i = 0; i < tiles.length; i++) {
		// Create how far the tile will deviate from its origin
		var offset = Math.sin((i * 50 + this.time * this.waveSpeed) * Math.PI / 180);

		var rippleIntensity = 0;

		var explosionDirX = 0;
		var explosionDirY = 0;
		for (var j = 0; j < this.ripples.length; j++) {
			var ripple = this.ripples[j];

			var curY = Math.floor(i / TileMapValues.COLS);
			var curX = i - (curY * TileMapValues.COLS) + 0.5;
			curY += 0.5;

			var distX = ripple.x - curX;
			var distY = ripple.y - curY;	
			
			var dist = Math.sqrt(distX * distX + distY * distY) - ripple.distance;
			
			rippleIntensity += ripple.intensity * (1 - Math.max(0, Math.min(1, Math.abs(dist))));
			explosionDirX += distX;
			explosionDirY += distY;
		}

		if (this.ripples.length > 0) { 
			var dist = 1.0 / Math.sqrt(explosionDirX * explosionDirX + explosionDirY * explosionDirY);
			explosionDirX *= dist;
			explosionDirY *= dist;
		}

		tiles[i].setPosition(this.originalPosition[i].x + explosionDirX * rippleIntensity, this.originalPosition[i].y + offset + explosionDirY * rippleIntensity);
	}
};

WaveMachine.prototype.handleTouchUp = function(finger, x, y) {
	this.waitForUp = false;
};

WaveMachine.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";

	var container = this.tileMap.getContainer().container;

	x -= container.x;
	y -= container.y;

	// Only do this once
	if (this.waitForUp)
		return;
	this.waitForUp = true;

	// Only handle clicks outside this field
	if (x < 0 || x > container.width || y < 0 || y > container.height)
		return;

	var tileDims = this.tileMap.getTileDimension();
	x = x / tileDims.width;
	y = y / tileDims.height;

	this.addRipple(x, y, 2);
	//return true;
};
//******************************************************
//*****    Script Resource: BoardStrikeController
//******************************************************

var BoardStrikeController = function() {

	this._data = null;
	this._sequence = []

	this._skipAiming = false;
}

BoardStrikeController.prototype.constructor = BoardStrikeController;

BoardStrikeController.prototype.start = function(data) {

	this._fireNext();
}

BoardStrikeController.prototype._fireNext = function() {

	if (this._data.length == 0) {

		this._done();
		return;
	}

	var strikeData = this._data.splice(0,1)[0];

	if (this._skipAiming) {
		this._showShot(strikeData);
	}
	else {
		this._aimShot(strikeData)
	}
}

BoardStrikeController.prototype._showAim = function(strikeData) {

	var self = this;

	var btr = new BoardTargetReticle(strikeData);
	btr.onComplete = function() {

		self._shotShow(strikeData);
	}

	btr.start();
}

BoardStrikeController.prototype._shotShow = function(strikeData) {

}

BoardStrikeController.prototype._shotDone = function(strikeData) {

	this._fireNext();
}

BoardStrikeController.prototype._done = function() {

}

//******************************************************
//*****    Token Resource: ScattershotProjectile
//******************************************************

// ***************************************
// Definition of game token ScattershotProjectile
// ***************************************

// The constructor for the ScattershotProjectile game token. 
var ScattershotProjectile = function(x, y, targetX, targetY, onArrive, container) {
	"use strict";
	// Properties used by the engine
	this.depth = 0;	
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;
	this.targetX = targetX;
	this.targetY = targetY;
	this.onArrive = onArrive;

	this.image = cluster_bomb_04.clone();
	this.image.setPosition(this.x, this.y);

	var vect = {x: this.targetX - this.x, y: this.targetY - this.y};
	var magnitude = Math.sqrt(vect.x * vect.x + vect.y * vect.y);
	var normalized = {x: vect.x / magnitude, y: vect.y / magnitude};
	var angle = -(Math.atan2(1, 0) - Math.atan2(normalized.y, normalized.x));

	this.image.setRotation(angle);

	this.container = container;
	this.container.addChild(this.image);

	this.speed = 500;

	// Add it to the game engine
	tbGame.addToken(this);
};

// handleAdd is called when the token is (re-) added to the game. 
ScattershotProjectile.prototype.handleAdd = function() {
	"use strict";
};

// handleRemove is called when the token is removed from the game.
ScattershotProjectile.prototype.handleRemove = function() {
	"use strict";
};

// handleBeginStep is called each step before processing other events.
ScattershotProjectile.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	var remainingVect = {x: this.targetX - this.x, y: this.targetY - this.y}
	var magnitude = Math.sqrt(remainingVect.x * remainingVect.x + remainingVect.y * remainingVect.y);
	var moveDist = this.speed * timePassed * 0.001;
	if (moveDist > magnitude) {
		this.onArrive();
		this.container.removeChild(this.image);
		tbGame.removeToken(this);
		return;
	}
	var toMove = {x: remainingVect.x / magnitude * moveDist, y: remainingVect.y / magnitude * moveDist};
	
	this.x += toMove.x;
	this.y += toMove.y;
	this.image.setPosition(this.x, this.y);
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
ScattershotProjectile.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
ScattershotProjectile.prototype.handleTouchUp = function(finger, x, y) { 
	"use strict";
};

// handleKeyDown is called if the key with the given keyCode is pressed.
ScattershotProjectile.prototype.handleKeyDown = function(keyCode) { 
	"use strict";
};

// handleKeyUp is called if the key with the given keyCode is released.
ScattershotProjectile.prototype.handleKeyUp = function(keyCode) { 
	"use strict";
};

// handleAlarm is called if a global alarm is reached.
ScattershotProjectile.prototype.handleAlarm = function(alarm) { 
	"use strict";
};

// handleSpecial is called if a special or user-defined event happens.
ScattershotProjectile.prototype.handleSpecial = function(id, args) { 
	"use strict";
};

// handleEndStep is called each step after processing other events (before draw).
ScattershotProjectile.prototype.handleEndStep = function(timePassed) { 
	"use strict";
};

// handleDraw is called at the end of a step to draw the token.
ScattershotProjectile.prototype.handleDraw = function() {
	"use strict";
};


//******************************************************
//*****    Token Resource: TargetReticle
//******************************************************

// ***************************************
// Definition of game token TargetReticle
// ***************************************

// The constructor for the TargetReticle game token.
var TargetReticle = function(radar, tileContainer, tileMap, x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth;
	this.layer = 0;
	this.visible = true;
	this.active = true;

	this.savedWeapon = 0;
	this._tileMap = tileMap;
	this._isRotated = false;

	this.highlightDistance = 4;
	this.highlightTimerDelay = 500;
	this.highlightTimer = 0;

	this.radar = radar;
	this.mapWidth = tileMap.getRows();
	this.mapHeight = tileMap.getColumns();
	this.tileContainer = tileContainer;

	this.radarHighlighter = new RadarHighlighter(tileContainer, tileMap);

	this.rotationStates = {
		up: 0,
		down: 1,
		canceled: 2
	}

	this._targetReticle = [];
	for (var i = 0; i < 5; i++) {
		this._targetReticle.push(s_pla_crosshair.clone());
		tileContainer.addChild(this._targetReticle[i]);
	}

	this.rotateButton = s_button_rotate.clone();
	this.rotateButton.sprite.buttonMode = true;
	tileContainer.addChild(this.rotateButton);

	this.setPosition(x, y, false);
	this.hide();

	this.rotateButton.sprite.on('pointerdown', function (e) {
		this.rotateState = this.rotationStates.down;
		this.rotateButton.gotoAndStop(1);

	}.bind(this));

	this.rotateButton.sprite.on('pointerup', function (e) {
		if (this.rotateState == this.rotationStates.down) {

			// Rotate the reticles
			this.rotate();
			this.setPosition(this.tileX, this.tileY, false);
		}
		this.rotateState = this.rotationStates.up;
		this.rotateButton.gotoAndStop(0);

	}.bind(this));

	this.rotateButton.sprite.on('pointerupoutside', function (e) {
		this.rotateState = this.rotationStates.up;
		this.rotateButton.gotoAndStop(0);

	}.bind(this));

	// Add it to the game engine
	tbGame.addToken(this);
	tbGame.addTokenTags(this, ['token']);
};

TargetReticle.prototype.setSpecialWeaponButtonManager = function(specialWeaponButtonManager) {
	this.specialWeaponButtonManager = specialWeaponButtonManager;
};

TargetReticle.prototype.pushToTop = function() {
	for (var i = 0; i < 5; i++) {
		this.tileContainer.addChild(this._targetReticle[i]);
	}
	this.tileContainer.addChild(this.rotateButton);
}

TargetReticle.prototype.show = function() {
	"use strict";
	var alpha = 0.5;
	this.isOnScreen = true;

	this._targetReticle[0].setAlpha(alpha);
	this._updateRotateButtonVisibility();

	this.pushToTop();
};

TargetReticle.prototype.hide = function() {
	"use strict";
	this.isOnScreen = false;

	for (var i = 0; i < 5; i++) {
		this._targetReticle[i].setAlpha(0);
	}
	this._setRotateButtonVisible(false);

	this.radarHighlighter.setActiveOnAll(false);
};

/** Makes the rotate button visible or invisible based on the special weapon that is currently in use */
TargetReticle.prototype._updateRotateButtonVisibility = function(buttonPosX, buttonPosY) {
	var dataSpecialWeapon = UserDataController.getSpecialWeaponData();
	var specialWeapon = dataSpecialWeapon ? dataSpecialWeapon.getSelectedSpecialWeapon() : null;

	var showButton = this.rotateState != this.rotationStates.canceled && specialWeapon !== null && specialWeapon.canRotate;

	// Put the rotation button on a new location, otherwise it uses its old location
	if (showButton && buttonPosX != undefined && buttonPosY != undefined) {
		this.rotateButton.setPosition(buttonPosX, buttonPosY);
	}

	this._setRotateButtonVisible(showButton);
}

TargetReticle.prototype._setRotateButtonVisible = function(visible) {
	var alpha = visible ? 1 : 0;

	// If alpha has not changed, stop
	if (this.rotateButton.alpha == alpha) {
		return;
	}

	this.rotateButton.sprite.interactive = visible;
	this.rotateButton.setAlpha(alpha);

	// Make sure the rotate button is layered above the reticles
	if (visible) {
		this.pushToTop();
	}
}

TargetReticle.prototype.rotate = function() {
	var dataSpecialWeapon = UserDataController.getSpecialWeaponData();
	var specialWeapon = dataSpecialWeapon ? dataSpecialWeapon.getSelectedSpecialWeapon() : null;

	if (specialWeapon !== null) {
		specialWeapon.rotate();
	}
}

TargetReticle.prototype.isRotated = function() {
	var dataSpecialWeapon = UserDataController.getSpecialWeaponData();
	var specialWeapon = dataSpecialWeapon ? dataSpecialWeapon.getSelectedSpecialWeapon() : null;

	if (specialWeapon !== null) {
		return specialWeapon.isRotated;
	}
	return false;
}

TargetReticle.prototype.setPosition = function(x, y, playSound) {
	"use strict";

	// console.log("Console log passed: ", x, y, this.tileX, this.tileY);

	var dataSpecialWeapon = UserDataController.getSpecialWeaponData();
	var specialWeapon = dataSpecialWeapon ? dataSpecialWeapon.getSelectedSpecialWeapon() : null;

	// Adjust the position so that the reticles of the special weapon won't go outside the board
	if (specialWeapon !== null) {
		x = specialWeapon.adjustX(x);
		y = specialWeapon.adjustY(y);
	}

	playSound = playSound || (this.tileX != x || this.tileY != y);

	// If I was rotating, stop.
	if (this.tileX != x || this.tileY != y) {
		this.rotateState = this.rotationStates.canceled;
	}

	var tileDim = this._tileMap.getTileDimension();

	this.tileX = x;
	this.tileY = y;

	this.x = (x + 0.5) * tileDim.width,
	this.y = (y + 0.5) * tileDim.height;

	this._updateRotateButtonVisibility(x * tileDim.width + 4, y * tileDim.height);

	// Make the reticles invisible
	for(var i = 1; i < this._targetReticle.length; i++) {
		this._targetReticle[i].setAlpha(0);
	}

	// If a special is being used, put target reticles on the tiles we would be shooting at
	if (specialWeapon !== null) {
		var tiles = specialWeapon.generateShotTiles(x, y);

		for(var i = 0; i < tiles.length; i++) {

			// Don't show the target reticle under a visible rotate button.
			if (specialWeapon.canRotate && this.rotateState != this.rotationStates.canceled && x == tiles[i].x && y == tiles[i].y) {

				this._targetReticle[i].setAlpha(0);
				continue;
			}

			this._targetReticle[i].setAlpha(0.75);
			this._targetReticle[i].setPosition((tiles[i].x + 0.5) * tileDim.width + 4, (tiles[i].y + 0.5) * tileDim.height);
		}
	}
	else {
		this._targetReticle[0].setPosition((x + 0.5) * tileDim.width + 4, (y + 0.5) * tileDim.height);
		this._targetReticle[0].setAlpha(0.75);
	}

	if (x !== undefined && y !== undefined) {
		var tiles = specialWeapon.generateHighlightTiles(x, y, this.mapWidth, this.mapHeight);
		var targets = specialWeapon.generateHighlightCenters(x, y);
		this.radarHighlighter.activateAllFromTileList(tiles);
		this.radarHighlighter.setTargets(targets);
	}

	this.radarHighlighter.adjustHighlight(this.highlightDistance);

	if(playSound)
		tgfAudio.play(a_radar_tap);

	return {
		x: x,
		y: y,
		index: y * TileMapValues.ROWS + x
	};
};

TargetReticle.prototype.handleTouchUp = function(finger, x, y) {
	"use strict";

	if (this.isOnScreen) {
		this.rotateState = this.rotationStates.up;
		this.rotateButton.gotoAndStop(0);
	}
};

TargetReticle.prototype.handleRemove = function () {
	"use strict";

	if (this._tileMap) {
		this._tileMap = null;
	}

	if (this.tileContainer) {
		this.tileContainer = null;
	}

	if (this._targetReticle) {
		this._targetReticle = null;
	}
}

// handleBeginStep is called each step before processing other events.
TargetReticle.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	this.highlightTimer -= timePassed;
	if(this.highlightTimer <= 0 && this.isOnScreen) {

		this.highlightDistance--;
		this.highlightTimer = this.highlightTimerDelay;

		if (this.highlightDistance < -3) {
			var distanceX = 4; // this.tileX > 5 ? this.tileX : (this.mapWidth - 1) - this.tileX;
			var distanceY = 4; // this.tileY > 5 ? this.tileY : (this.mapHeight - 1) - this.tileY;

			this.highlightDistance = distanceX > distanceY ? distanceX : distanceY;
		}

		this.radarHighlighter.adjustHighlight(this.highlightDistance);
	}

	// Get current weapon selection
	var dataSpecialWeapon = UserDataController.getSpecialWeaponData();
	var specialWeaponType = SpecialWeaponData.SpecialWeapon.default; // regular shot
	if (dataSpecialWeapon && this.specialWeaponButtonManager) specialWeaponType = this.specialWeaponButtonManager.getSelectedSpecialWeaponType();

	// Make sure we're inside the bounds for current special weapon
	if (this.savedWeapon != specialWeaponType) {
		this.savedWeapon = specialWeaponType;

		this.radar._select();
	}
};

//******************************************************
//*****    Token Resource: RadarStrike
//******************************************************

// ***************************************
// Definition of game token RadarStrike
// ***************************************

// The constructor for the RadarStrike game token. 
var RadarStrike = function(tileIndex, tileMap, isCenterTile, onVisibleCallback, depth) {
	"use strict";

	console.log('RadarStrike::RadarStrike');

	// Properties used by the engine
	this.depth = depth;
	this.layer = 0;
	this.visible = true;
	this.active = true;

	// Your own properties
	this.shipElement = null;
	this.isVisible = false;
	this.onVisibleCallback = onVisibleCallback;
	this.container = tileMap.getContainer();
	this.isCenterTile = isCenterTile;

	// The alpha the image should use when the strike is highlighted
	this.highlightAlpha = 0.75;
	// The standard alpha the strike image should use
	this.normalAlpha = 0.5;
	// The speed used to transition from highlight alpha to normal alpha
	this.alphaTransitionSpeed = 0.0009;

	// Get the data of the current tile
	this.tileIndex = tileIndex;
	var tileData = tileMap.getTileByIndex(tileIndex);

	// Strike the tile and check if it was a hit or a miss
	tileMap.strikeTileByIndex(tileIndex);
	this.isHit = tileMap.getStruck(tileIndex);

	// Calculate the world position of the strike
    this.worldX = tileData.tx * TileMapValues.WIDTH;
	this.worldY = tileData.ty * TileMapValues.HEIGHT;

	this._initImage();
	this._initFont();

	// Add it to the game engine
	tbGame.addToken(this);
	tbGame.addTokenTags(this, ['play', 'token', 'strike']);
};

// Static variable to count the amount of strikes hit in a sequence
RadarStrike.comboCount = 0;

RadarStrike.hitSounds = [
	a_radar_hit_0,
	a_radar_hit_1,
	a_radar_hit_2,
	a_radar_hit_3,
	a_radar_hit_4
];

RadarStrike.prototype._initImage = function() {
	// Create the image
	this.image = this.isHit ? s_opp_hit.clone() : s_opp_miss.clone();

	this.image.setPosition(this.worldX, this.worldY);
	this.image.add(this.container);

	this.image.setAlpha(0);
}

RadarStrike.prototype._initFont = function() {
	"use strict";
	this.font = bitdust.clone();
	this.font.setText(this.isHit ? tgfDictionary.getText("FloaterHit") : tgfDictionary.getText("FloaterMiss"));
	this.font.setPosition(this.worldX + 4 + 74 * 0.5, this.worldY - 74 * 0.25);
	this.font.setAlpha(0);
	this.font.baseAlpha = 1;
	this.font.setAlign("center");
	this.font.setBaseline("middle");

	this.font.setFontSize(30);
	this.font.setFillColor(this.isHit ? "#ff1800" : "#00ce00");
	this.font.setShadow({ 
		active: true, 
		color: this.isHit ? "#301111" : "#072000", 
		offsetX: 0, 
		offsetY: -2, 
		blur: 0, 
	});

	this.container.addChild(this.font);
}

RadarStrike.prototype.show = function(skip) {
	"use strict";
	if (this.shipElement == null) {
		this.image.setAlpha(this.highlightAlpha);
	}
	this.isVisible = true;


	// use radarstrike normally
	if (!skip) {

		var hitSound;
		if (this.isHit) {
			// Choose the correct hit sound
			hitSound = RadarStrike.hitSounds[Math.min(RadarStrike.comboCount, 4)]
			RadarStrike.comboCount += 2;
		}
		else {
			// Stop the combo if there is a miss
			hitSound = a_radar_miss;
			RadarStrike.comboCount = 0;
		}
		// Play the hit or miss sound
		tgfAudio.play(hitSound);
		
		if (this.font) this.font.setAlpha(1);
	}

	// Show the hit or miss font

	if (this.onVisibleCallback) this.onVisibleCallback(this);
}

RadarStrike.prototype.setShipElement = function(element) {
	// Set the ship element
	this.shipElement = element;

	// Hide the strike image
	this.image.setAlpha(0);
}

/** Highlights the strike image everytime the sweeper moves over it */
RadarStrike.prototype.onSweeperPassed = function() {
	"use strict";
	if (!this.isVisible) return;

	if (this.shipElement == null) {
		this.image.setAlpha(this.highlightAlpha);
	}
}

// handleAdd is called when the token is (re-) added to the game. 
RadarStrike.prototype.handleAdd = function() {
	"use strict";
};

// handleRemove is called when the token is removed from the game.
RadarStrike.prototype.handleRemove = function() {
	"use strict";

	if (this.image) {
		this.image = null;
	}

	if (this.container) {
		this.container = null;
	}

	if (this.font) {
		this.font = null;
	}

	if (this.shipElement) {
		this.shipElement = null;
	}

	if (this.onVisibleCallback) {
		this.onVisibleCallback = null;
	}
};

// handleBeginStep is called each step before processing other events.
RadarStrike.prototype.handleBeginStep = function(timePassed) {
	"use strict";

	if (!this.isVisible) return;

	// Fades the alpha from highlighted to normal
	if (this.image.alpha > this.normalAlpha) {
		var newAlpha = Math.max(this.normalAlpha, this.image.alpha - timePassed * this.alphaTransitionSpeed);

		this.image.setAlpha(newAlpha);
	}

	// Fades the alpha of the font to invisible
	if (this.font && this.font.font["alpha"] > 0) {
		this.font.baseAlpha = this.font.baseAlpha - timePassed * 0.001;
		
		if (this.font.baseAlpha > 0.5) {
			this.font.setAlpha(this.font.baseAlpha + (Math.random() * 0.5) - 0.25);
		}
		else { 
			this.font.setAlpha(this.font.baseAlpha);
		}
		
		this.font.setPosition(this.font.x, this.font.y - timePassed * 0.01);
	}
};
//******************************************************
//*****    Token Resource: RadarToken
//******************************************************

// ***************************************
// Definition of game token RadarToken
// ***************************************

// The constructor for the RadarToken game token.
var RadarToken = function(x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth;
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;

	this.specialWeapon = null;

	this.showingAllShips = false;
	this.onAllShipsVisible = null;
	this.fireUnit = null;
	this._isLocked = true;

	var mapOptions = {
		rows: TileMapValues.ROWS,
		cols: TileMapValues.COLS,
		tileWidth: TileMapValues.WIDTH,
		tileHeight: TileMapValues.HEIGHT,
		dataMode: true
	};

	this._tileMap = new TileMap(mapOptions);
	this._tileContainer = this._tileMap.getContainer();

	this._tileContainer.container.x = 384 + ((TileMapValues.MAX_COLS - TileMapValues.COLS) * TileMapValues.WIDTH * 0.5);
	this._tileContainer.container.y = 82 + ((TileMapValues.MAX_ROWS - TileMapValues.ROWS) * TileMapValues.HEIGHT * 0.5) -65; // Applied offset

	this._targetReticle = new TargetReticle(this, this._tileContainer, this._tileMap);

	var radarSweeperRadius = mapOptions.tileHeight * TileMapValues.MAX_COLS * 0.5;
	this.sweeper = new RadarSweeper(this,
		mapOptions.tileWidth * mapOptions.rows * 0.5,
		mapOptions.tileHeight * mapOptions.cols * 0.5,
		radarSweeperRadius);

	this.width = mapOptions.tileWidth * mapOptions.rows;
	this.height = mapOptions.tileHeight * mapOptions.cols;

	this.strikeManager = new StrikeManager(this._tileMap);

	// this._buildMap();
	this.ships = [
		{id: 1, size: 5, element: null},
		{id: 2, size: 4, element: null},
		{id: 3, size: 3, element: null},
		{id: 4, size: 3, element: null},
		{id: 5, size: 2, element: null},
	];

	this._clickToFirePositionYTo = 690;
	this._clickToFirePositionYOffset = 60;
	this._containerClickToFire = new tbContainer();
	this._containerClickToFire.setPosition(tgfGraphics.areaWidth/2, this._clickToFirePositionYTo + this._clickToFirePositionYOffset);

	this._clickToFireImage = s_pla_dialogue_fire.clone();
	this._clickToFireImage.setPosition(-s_pla_dialogue_fire.width/2, 0);
	this._clickToFireImage.add(this._containerClickToFire);

	// tgfGraphics.addChild(this._containerClickToFire.container);


	// animator
	this._animatorClickToFire = new tbAnimator(this._containerClickToFire.container);
	this._animatorClickToFireTrackY = this._animatorClickToFire.addTrack('y');
	this._animatorClickToFireTrackAlpha = this._animatorClickToFire.addTrack('alpha');


	var containerLabel = f_babas_regular.clone();
	this._containerClickToFire.addChild(containerLabel);

	containerLabel.setFontSize(42);
	containerLabel.setFillColor("#FFF");
	containerLabel.setPosition(0, s_pla_dialogue_fire.height / 2 + 6);
	containerLabel.width = s_pla_dialogue_fire.width * 0.8;
	containerLabel.style.align = "center";
	containerLabel.setAlign("center");
	containerLabel.setBaseline("middle");
	containerLabel.defaultText = tgfDictionary.getText("FireUnitSelectACellTop") + "\n" + tgfDictionary.getText("FireUnitSelectACellBottom");
	containerLabel.setText(containerLabel.defaultText);
	this.clickToFireLabel = containerLabel;

	this._containerClickToFire.setAlpha(0);
	tgfGraphics.addChild(this._containerClickToFire.container, 'radarToken.clicktofire');


	tgfGraphics.addChild(this._tileContainer.container, 'radartoken._tileContainer');

	TurnController.addTurnListener(this.onTurnUpdate, this);
};

RadarToken.prototype.onTurnUpdate = function(state) {

	this.lastState = state;

	switch (state) {
		case TurnController._TURN_STATES.FIRE1: {
			this._selectedTile = null;
			this.showClickToFire();
			this.unlockBoard();
			break;
		}
		case TurnController._TURN_STATES.FIRE2: {
			this.showClickToFire((tgfDictionary.getText("FireUnitShotsRemainingTop") + "\n" + tgfDictionary.getText("FireUnitShotsRemainingBottom")).replace("{shots}", 2));
			this.unlockBoard();
			break;
		}
		case TurnController._TURN_STATES.FIRE3: {
			this.showClickToFire(tgfDictionary.getText("FireUnitShotsRemainingSingularTop") + "\n" + tgfDictionary.getText("FireUnitShotsRemainingSingularBottom"));
			this.unlockBoard();
			break;
		}
		case TurnController._TURN_STATES.FIRE_X_POPUP: {
			this.lockBoard();
			break;
		}
		case TurnController._TURN_STATES.FIRE_X_SHOT: {
			this.showClickToFire(tgfDictionary.getText("FireUnitShotsRemainingExtraShotTop") + "\n" + tgfDictionary.getText("FireUnitShotsRemainingExtraShotBottom"));
			this.unlockBoard();
			break;
		}
		case TurnController._TURN_STATES.GAME_ENDED: {

			this.lockBoard();
			this._targetReticle.hide();
			this.hideClickToFire();
			break;
		}
		default: {

			this.lockBoard();
			this.hideClickToFire();
		}

	}
}


RadarToken.prototype.showClickToFire = function(text) {

	var self = this;

	if (text) this.clickToFireLabel.setText(text);
	else this.clickToFireLabel.setText(this.clickToFireLabel.defaultText);

	if (this._containerClickToFire) return;
	// Reset the alpha and position
	this._containerClickToFire.container.alpha = 0;
	this._containerClickToFire.container.y = this._clickToFirePositionYTo - this._clickToFirePositionYOffset / 2;

	this._animatorClickToFire.pause();
	this._animatorClickToFire.removeAllKeys();

	// y
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackY, 0, this._clickToFirePositionYTo + this._clickToFirePositionYOffset, tbEase.easeInOutExponential, 2);
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackY, 1500, this._clickToFirePositionYTo + this._clickToFirePositionYOffset, tbEase.easeInOutExponential, 2);
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackY, 1800, this._clickToFirePositionYTo, tbEase.easeInOutExponential, 2);

	// alpha
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackAlpha, 0, this._containerClickToFire.container.alpha, tbEase.easeInOutExponential, 2);
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackAlpha, 1500, this._containerClickToFire.container.alpha, tbEase.easeInOutExponential, 2);
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackAlpha, 1800, 1, tbEase.easeInOutExponential, 2);
	this._animatorClickToFire.addEvent(this._animatorClickToFireTrackAlpha, 1500, function() {
		if (!self._selectedTile) { // Don't play it when something was selected.
			tgfAudio.play(a_popup_show);
		}
	});

	this._animatorClickToFire.setTime(0);

	this._animatorClickToFire.resumeForced();
}

/** Makes the clickToFire tooltip reappear in the same state as when it was hidden */
RadarToken.prototype.reappearClickToFire = function() {

	console.log("RadarToken::reappearClickToFire");

	switch(this.lastState) {
		case TurnController._TURN_STATES.FIRE1:
		case TurnController._TURN_STATES.FIRE2:
		case TurnController._TURN_STATES.FIRE3:
		case TurnController._TURN_STATES.FIRE_X_SHOT: {

			// No need to reappear if the tooltip is already visible
			if (this._containerClickToFire) {

					if (this._containerClickToFire.container && this._containerClickToFire.container.alpha > 0) return;

					this.showClickToFire(this.clickToFireLabel.text);
			}
			break;
		}
	}
}

RadarToken.prototype.hideClickToFire = function() {

	this._animatorClickToFire.pause();
	this._animatorClickToFire.removeAllKeys();

	// y
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackY, 0, this._clickToFirePositionYTo, tbEase.easeInOutExponential, 2);
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackY, 150, this._clickToFirePositionYTo - this._clickToFirePositionYOffset / 2, tbEase.easeInOutExponential, 2);

	// alpha
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackAlpha, 0, this._containerClickToFire.container.alpha, tbEase.easeInOutExponential, 2);
	this._animatorClickToFire.addKey(this._animatorClickToFireTrackAlpha, 150, 0, tbEase.easeInOutExponential, 2);

	this._animatorClickToFire.setTime(0);

	this._animatorClickToFire.resumeForced();
}

RadarToken.prototype.getTileMap = function() {
	return this._tileMap;
}

RadarToken.prototype.setOpponentMap = function(mapData) {

	if (mapData) {

		this._tileMap.setMap(mapData);
	}

	//
	// this._tileMap.toStringMap('setOpponentMap');

	this._buildMap();
	this._buildFleet();
}

RadarToken.prototype._buildMap = function(mapData) {

	var tiles = this._tileMap.getMap();

	console.log('MAP::', mapData);

	for (var i = 0; i < tiles.length; i++) {

		var ty = Math.floor(i / TileMapValues.COLS);
		var tx = i - (ty * TileMapValues.COLS);

		var value = this._tileMap.getTileByIndex(i).value;

		console.log('MAP::', i, value);
		if (value >= 9) {

			console.log('MAP:: 	-> strike-here', i, value, tx, ty);
			// console.log('SW::3')



			//			   strikeCenter, 	tileIndices, 					strikeType, isRotated,	rebuildFleet,	showAnimation,	onStrikeAppear
			// this.addStrike(i, 				[ { x: tx, y: ty, index: i } ], 0,			false, 		false, 			false);


			// centerIndex, strikeElements, onDone, specialWeapon
			this.addStrike(i, [ { x: tx, y: ty, index: i } ], function() {
				console.log('MAP::', i, 'shots fired!');
			}, null, true);

		}
	}
}

RadarToken.prototype.showAllShips = function (onAllShipsVisible) {

	console.log('showAllShips');

	this.showingAllShips = true;
	this.onAllShipsVisible = onAllShipsVisible;

	var tiles = this._tileMap.getMap();
	for (var i = 0; i < this.ships.length; i++) {

		if (this.ships[i].element)
			continue;

		var shipIndex = this.ships[i].id;
		var shipIndexHit = shipIndex + 10;

		var tileStart = 0;
		var shipTileStart = tiles.indexOf(shipIndex);
		var shipTileHitStart = tiles.indexOf(shipIndexHit);

		if (shipTileStart >= 0) {
			if (shipTileHitStart >= 0) {
				tileStart = Math.min(shipTileStart, shipTileHitStart);
			}
			else {
				tileStart = shipTileStart;
			}
		}
		else {
			tileStart = shipTileHitStart;
		}

		var ty = Math.floor(tileStart / TileMapValues.COLS);
		var tx = tileStart - (ty * TileMapValues.COLS);

		var nextTile = tiles[tileStart + 1];
		var isVertical = nextTile != shipIndex && nextTile != shipIndexHit;
		this.ships[i].element = new RadarShip(this._tileContainer, this.ships[i].id, tx * 74, ty * 74, isVertical, true);
	};
};

RadarToken.prototype._buildFleet = function() {

	var tiles = this._tileMap.getMap();

	// return;

	// Loop through all the ships to check if they should be build
	for (var i = 0; i < this.ships.length; i++) {

		// Don't update already existing elements
		if (this.ships[i].element !== null)
			continue;

		// The number that indicates that this ship is hit
		var shipIDHit = this.ships[i].id + 10;

		// Get the index of the first tile that contains the shipID
		var tileStart = tiles.indexOf(shipIDHit);
		if (tileStart < 0)
			continue;

		// Keeps track of all the strikes that forms this ship
		shipStrikes = [];

		// Every tile afterwards, either horizontally or vertically,
		// needs to be the same for the whole size of the ship.
		found = true;
		for (var j = 0; j < this.ships[i].size; j++) {
			var index = tileStart + j;

			if (tiles[index] != shipIDHit) {
				found = false;
				break;
			}

			var strike = this.strikeManager.getStrikeByIndex(index);
			if (strike == null) {
				console.warn("Couldn't find a strike that should be there");
				found = false;
				break;
			}

			shipStrikes.push(strike);
		}

		// Check vertically if the ship wasn't found horizontally
		var isVertical = !found;
		if (isVertical) {
			// Set found back to true for a new attempt to find the ship
			found = true;

			for (var j = 0; j < this.ships[i].size; j++) {
				var index = tileStart + j * TileMapValues.ROWS;

				if (tiles[index] != shipIDHit) {
					found = false;
					break;
				}

				var strike = this.strikeManager.getStrikeByIndex(index);
				if (strike == null) {
					console.warn("Couldn't find a strike that should be there");
					found = false;
					break;
				}

				shipStrikes.push(strike);
			}
		}

		// Continue checking the next ship if this ship wasn't found
		if (!found) continue;

		var ty = Math.floor(tileStart / TileMapValues.ROWS);
		var tx = tileStart - (ty * TileMapValues.ROWS);

		// Create a new ship
		this.ships[i].element = new RadarShip(this._tileContainer, this.ships[i].id, tx * TileMapValues.WIDTH, ty * TileMapValues.HEIGHT, isVertical);

		// Store the ship element in every strike that forms this ship
		for (var j = 0; j < shipStrikes.length; j++) {
			shipStrikes[j].setShipElement(this.ships[i].element);
		}
	}
}

RadarToken.prototype.addStrike = function(centerIndex, strikeElements, onDone, specialWeapon, skipAnimation) {

	// console.log('MAP::.addStrike-before', centerIndex, strikeElements, specialWeapon);

	skipAnimation = skipAnimation || false;

	var centerTile = this._tileMap.getTileByIndex(centerIndex);

	if (!specialWeapon) {

		if (this.specialWeapon) {
			specialWeapon = this.specialWeapon;
		}
		else {
			specialWeapon = new WeaponBase();
		}
	}

	// console.log('MAP::.addStrike-after', centerIndex, centerTile, strikeElements, specialWeapon);

	this.strikeManager.createStrikes(centerTile, strikeElements, specialWeapon, function() {

		// Build any new ships
		this._buildFleet();

		if (onDone) onDone();

	}.bind(this), skipAnimation);
}

RadarToken.prototype.getStrikeManager = function() {
	return this.strikeManager;
}

// handleAdd is called when the token is (re-) added to the game.
RadarToken.prototype.handleAdd = function() {
	"use strict";
};

// handleRemove is called when the token is removed from the game.
RadarToken.prototype.handleRemove = function() {
	"use strict";

	// console.log('RadarToken.handleRemove');

	if (this._tileContainer && this._tileContainer.container) {

		tgfGraphics.removeChild(this._tileContainer.container);
		this._tileContainer.container.destroy({children:true});
		this._tileContainer.container = null;
		this._tileContainer = null;
	}

	if (this._containerClickToFire && this._containerClickToFire.container) {

		tgfGraphics.removeChild(this._containerClickToFire.container);
		// this._containerClickToFire.container.destroy();
		// this._containerClickToFire.container = null;
		// this._containerClickToFire = null;
	}

	// console.log('RadarToken remove');
};

// handleBeginStep is called each step before processing other events.
RadarToken.prototype.handleBeginStep = function(timePassed) {
	"use strict";

	for (var i = 0; i < this.ships.length; i++) {
		if (this.ships[i].element) {
			this.ships[i].element.handleBeginStep(timePassed);
		}
	}

	// If mouse is inside our radar
	var mouseX = tbGame.touchX(0) - this._tileContainer.container.x;
	var mouseY = tbGame.touchY(0) - this._tileContainer.container.y;

	if (this._isLocked == false &&
		(mouseX > 0 && mouseX < this._tileMap.width) &&
		(mouseY > 0 && mouseY < this._tileMap.height)) {

		this._insideRadar = true;
	}
	else {

		this._insideRadar = false;
	}


	if (this._isLocked) {
		this._targetReticle.hide();
		this._insideRadar = false;
		this._isDraggingFinger = false;
	}
	else if (this._insideRadar && this._isDraggingFinger) {

		var rx = Math.round((mouseX - TileMapValues.WIDTH / 2) / TileMapValues.WIDTH);
		var ry = Math.round((mouseY - TileMapValues.HEIGHT / 2) / TileMapValues.HEIGHT);

		this._targetReticle.show();
		this._targetReticle.setPosition(rx, ry);
		this.moveTargetReticle(tbGame.touchX(0), tbGame.touchY(0));
	}

	if (this.showingAllShips && this.onAllShipsVisible) {
		var allShipsSeen = true;
		for (var i = 0; i < this.ships.length; i++) {
			if (this.ships[i].element.hasBeenSpotted == false) {
				allShipsSeen = false;
				break;
			}
		}

		if (allShipsSeen) {
			var callback = this.onAllShipsVisible;
			setTimeout(callback, 3000);
			this.onAllShipsVisible = null;
		}
	}

	if (this._animatorClickToFire) {
		this._animatorClickToFire.updateTime(timePassed);
	}

	this.strikeManager.update(timePassed);

	if (this._selectedTile) {
		this._select();
	}
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
RadarToken.prototype.lockBoard = function() {
	// console.log("locked radar");
	this._isLocked = true;
}

RadarToken.prototype.unlockBoard = function() {
	// console.log("unlocked radar");
	this._isLocked = false;
}

RadarToken.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";

	if (this._insideRadar) this._isDraggingFinger = true;

	this.moveTargetReticle(x, y);
};

RadarToken.prototype.handleTouchUp = function(finger, x, y) {
	"use strict";

	this._isDraggingFinger = false;
};

RadarToken.prototype.moveTargetReticle = function(x, y) {

	if (this._isLocked) return;

	var tile = this._tileMap.getTile(x, y);

	// if(tile.value >= 9)
	// 	return;

	if (this._tileMap.validateTile(tile)) {
		// console.log(tile);
		this._select(tile.index);
	}
	else {
		// this._deselect();
	}
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
RadarToken.prototype._deselect = function() {

	// throw new Error('RadarToken._deselect');

	this._selectedTile = null;

	if (this.tileDeselected) this.tileDeselected();
}

RadarToken.prototype._select = function(tileIndex) {
	// If the tileIndex is undefined, use the currently selected tile instead. Stop the funtion if that one is undefined as well.
	if (tileIndex === void 0) {
		if (!this._selectedTile) return;
		tileIndex = this._selectedTile.index;
	}

	// Calculate the tile positions
	var tileY = Math.floor(tileIndex / TileMapValues.ROWS);
	var tileX = tileIndex - (tileY * TileMapValues.ROWS);

	// Get the data class for the special weapon
	var specialWeaponData = UserDataController.getSpecialWeaponData();

	if (specialWeaponData) {
		// Get the type of the currently selected special weapon
		var specialWeaponType = this.fireUnit._specialWeaponButtonManager.getSelectedSpecialWeaponType();

		// Check if the special weapon is different then before
		if (this.specialWeapon === null || this.specialWeapon.weaponID != specialWeaponType) {
			// Generate a new special weapon class
			this.specialWeapon = specialWeaponData.generateSpecialWeapon(specialWeaponType);
		}
	}

	// A list of all the tiles. By default add the currently selected one.
	var tiles = [ { x: tileY, y: tileX, index: tileIndex } ];

	// If there is a special weapon being used
	if (this.specialWeapon != null) {
		// Generate the tiles the special weapon can shoot on
		tileX = this.specialWeapon.adjustX(tileX);
		tileY = this.specialWeapon.adjustY(tileY);
		var newTiles = this.specialWeapon.generateShotTiles(tileX, tileY);
		if (newTiles !== null) tiles = newTiles;
	}

	// If none of the tiles can be hit, deselect all of them and stop the function
	if (!this.canHitAny(tiles)) {
		this._targetReticle.hide();
		this._deselect();
		return;
	}

	// Show the target reticle if we can hit something
	this._targetReticle.show();

	// Get the tile data based on the selected index
	var tile = this._tileMap.getTileByIndex(tileIndex);

	// Target Reticle might move the position due to special weapon restrictions
	var selectedTile = this._targetReticle.setPosition(tile.tx, tile.ty);
	if (selectedTile) tile = this._tileMap.getTileByIndex(selectedTile.index);

	// Set the current selected tile
	this._selectedTile = tile;

	// Callback to FireUnit class
	if (this.tileSelected) this.tileSelected(this._selectedTile.index);
}

// Checks if any of the specified tiles can be hit
RadarToken.prototype.canHitAny = function(tiles) {
	// Loop through all the tiles to see if there is at least one that can be hit
	for(var i = 0; i < tiles.length; i++) {
		var tile = this._tileMap.getTileByIndex(tiles[i].index);

		// If any of the tiles are not yet hit return true
		if (tile.value <= 5) {
			return true;
		}
	}
	// If all the tiles can't be hit return false
	return false;
}


// handleKeyDown is called if the key with the given keyCode is pressed.
RadarToken.prototype.handleKeyDown = function(keyCode) {
	"use strict";
};

// handleKeyUp is called if the key with the given keyCode is released.
RadarToken.prototype.handleKeyUp = function(keyCode) {
	"use strict";
};

// handleAlarm is called if a global alarm is reached.
RadarToken.prototype.handleAlarm = function(alarm) {
	"use strict";
};

// handleSpecial is called if a special or user-defined event happens.
RadarToken.prototype.handleSpecial = function(id, args) {
	"use strict";
};

// handleEndStep is called each step after processing other events (before draw).
RadarToken.prototype.handleEndStep = function(timePassed) {
	"use strict";
};

// handleDraw is called at the end of a step to draw the token.
RadarToken.prototype.handleDraw = function() {
	"use strict";
};

//******************************************************
//*****    Token Resource: RadarSweeper
//******************************************************

// ***************************************
// Definition of game token RadarSweeper
// ***************************************

// The constructor for the RadarSweeper game token. 
var RadarSweeper = function(radar, x, y, radius, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth; 
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;
	this.radar = radar;
	this.container = radar._tileContainer;

	this.effect = s_opp_radar_swoosh.clone();
    this.effect.setPosition(x, y);
	
	var graphics = new PIXI["Graphics"]();
	graphics.lineStyle(0);
	graphics.beginFill(0xFFFFFF);
	graphics.drawRect(x + radar._tileContainer.container.x - radius, y + radar._tileContainer.container.y - radius, radius * 2, radius * 2);
	graphics.endFill();

    this.effect.setMask(graphics);
	this.container.addChild(this.effect);

	this.rotation = 0;
	this.canPlaySound = true;
	this.speed = 1;

	// Add it to the game engine
	tbGame.addToken(this);
	tbGame.addTokenTags(this, ['token']);
};

// handleAdd is called when the token is (re-) added to the game. 
RadarSweeper.prototype.handleAdd = function() {
	"use strict";

};

// handleRemove is called when the token is removed from the game.
RadarSweeper.prototype.handleRemove = function() {
	"use strict";

	// console.log('RadarSweeper.handleRemove');
	
	if (this.radar) {
		this.radar = null;
	}

	if (this.container) {
		this.container = null;
	}

	if (this.effect) {
		this.effect = null;
	}
};

// handleBeginStep is called each step before processing other events.
RadarSweeper.prototype.handleBeginStep = function(timePassed) {
	"use strict";

	// return;

	var speed = this.speed * (this.radar.showingAllShips ? 2 : 1);

	this.rotation += timePassed * 0.001 * speed;
	if(this.rotation > Math.PI * 2) {
		this.rotation -= Math.PI * 2;
		this.canPlaySound = true;
	}

	if (Math.abs(this.rotation - Math.PI) < 0.01 * speed && this.canPlaySound) {

		var canPlay = true;
		var playControllers = tbGame.findTokens("playcontroller");
		if (playControllers.length != 0) {
			var fireUnit = playControllers[0].getFireUnit();
			var isPlacing = playControllers[0].isPlacing();
			var fireUnitVisible = fireUnit && !fireUnit.hasMovedOut();

			// Dont play during placement or when you're watching the bottom side
			if (isPlacing || !fireUnitVisible)
				canPlay = false;
		}

		if (canPlay) tgfAudio.play(a_radar_ambience);
		this.canPlaySound = false;
	}

	this.effect.setAlpha(0.7 + Math.sin(this.rotation) * 0.3);

	this.effect.setRotation(this.rotation);

	var sweepDir = { 
		x: -Math.sin(this.effect.rotation),
		y: Math.cos(this.effect.rotation)
	};	
		
	var radarStrikeCount = this.radar.strikeManager.radarStrikes.length;
	for(var i = 0; i < radarStrikeCount; i++) {
		var strike = this.radar.strikeManager.radarStrikes[i];

		// Get the direction from the center of the radar to the strike location
		if (strike.dirVec === undefined) {
			strike.dirVec = {
				x: strike.worldX - this.x + TileMapValues.WIDTH * 0.5, 
				y: strike.worldY - this.y + TileMapValues.HEIGHT * 0.5
			};

			// normalise
			var length = 1.0 / Math.sqrt(strike.dirVec.x * strike.dirVec.x + strike.dirVec.y * strike.dirVec.y);
			strike.dirVec.x *= length;
			strike.dirVec.y *= length;
		}
		
		if ((sweepDir.x > 0 && strike.dirVec.x < 0) ||
			(sweepDir.x < 0 && strike.dirVec.x > 0) ||
			(sweepDir.y < 0 && strike.dirVec.y > 0) ||
			(sweepDir.y > 0 && strike.dirVec.y < 0))
			continue;

		var crossZ = strike.dirVec.x * sweepDir.y - strike.dirVec.y * sweepDir.x;
		// console.log(crossZ);

		// Sweeper has passed
		if (Math.abs(crossZ) < 0.04 * speed) {
			strike.onSweeperPassed(1.0);
		}
	}

	if(this.radar.showingAllShips) {
		var shipCount = this.radar.ships.length;
		for(var i = 0; i < shipCount; i++) {
			var shipElement = this.radar.ships[i].element;
			var ship = this.radar.ships[i].element.shipImage;
	
			// Get the direction from the center of the radar to the strike location
			if (ship.dirVec === undefined) {
				ship.dirVec = {
					x: ship.x - this.x + TileMapValues.WIDTH * 0.5, 
					y: ship.y - this.y + TileMapValues.HEIGHT * 0.5
				};
	
				// normalise
				var length = 1.0 / Math.sqrt(ship.dirVec.x * ship.dirVec.x + ship.dirVec.y * ship.dirVec.y);
				ship.dirVec.x *= length;
				ship.dirVec.y *= length;
			}
			
			if ((sweepDir.x > 0 && ship.dirVec.x < 0) ||
				(sweepDir.x < 0 && ship.dirVec.x > 0) ||
				(sweepDir.y < 0 && ship.dirVec.y > 0) ||
				(sweepDir.y > 0 && ship.dirVec.y < 0))
				continue;
	
			var crossZ = ship.dirVec.x * sweepDir.y - ship.dirVec.y * sweepDir.x;
			// console.log(crossZ);
	
			// Sweeper has passed
			if (Math.abs(crossZ) < 0.04) {
				shipElement.onSweeperPassed(1.0);
			}
		}
	}
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
RadarSweeper.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";

	if (this.radar.showingAllShips)
		this.speed = 2;
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
RadarSweeper.prototype.handleTouchUp = function(finger, x, y) { 
	"use strict";
};

// handleKeyDown is called if the key with the given keyCode is pressed.
RadarSweeper.prototype.handleKeyDown = function(keyCode) { 
	"use strict";
};

// handleKeyUp is called if the key with the given keyCode is released.
RadarSweeper.prototype.handleKeyUp = function(keyCode) { 
	"use strict";
};

// handleAlarm is called if a global alarm is reached.
RadarSweeper.prototype.handleAlarm = function(alarm) { 
	"use strict";
};

// handleSpecial is called if a special or user-defined event happens.
RadarSweeper.prototype.handleSpecial = function(id, args) { 
	"use strict";
};

// handleEndStep is called each step after processing other events (before draw).
RadarSweeper.prototype.handleEndStep = function(timePassed) { 
	"use strict";
};

// handleDraw is called at the end of a step to draw the token.
RadarSweeper.prototype.handleDraw = function() {
	"use strict";
};



//******************************************************
//*****    Script Resource: RadarShip
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var RadarShip = function(container, id, x, y, isVertical, revealShip) {

	var self = this;

	this.id = id;

	this._size = this._getSize(id);
	var halfSizeRoundDown = Math.floor((this._size - 1) / 2);

	this._stateVertical = isVertical;

	this.container = container;

	this._shipRevealing = !!revealShip;
	this.shipImage = this._getImage(id).clone();

	this.shipImage.xOrigin = this.shipImage.width * 0.5;
	this.shipImage.yOrigin = this.shipImage.height * 0.5;

    this.shipImage.sprite["pivot"]["x"] = this.shipImage.xOrigin;
    this.shipImage.sprite["pivot"]["y"] = this.shipImage.yOrigin;
    // console.log('ship positions', x,y);
	// this.shipImage.setPosition(x, y);
	this.shipImage.setPosition(x + (this.shipImage.width * 0.5) - 74, y + (this.shipImage.height * 0.5) -74 );
	


	this.imageAdded = false;
	this.hasBeenSpotted = false;

	if (this._shipRevealing) {
		this.shipImage.setAlpha(0);
		this.animator = new tbAnimator(this.shipImage);
		this.scaleTrack = this.animator.addTrack('scale');
		this.animator.pause();
	}
	else tgfAudio.play(a_ship_sink);
}

RadarShip.prototype.constructor = RadarShip;

RadarShip.prototype.setAlpha = function(a) {
	this.show();
	this.shipImage.setAlpha(a);
}

RadarShip.prototype.onSweeperPassed = function(alpha) {
	
	if (!this.hasBeenSpotted && this.shipImage && this._shipRevealing) { 
		this.shipImage.setAlpha(0.75);	
		
		this.animator.removeAllKeys();
		this.animator.removeEvents();
		this.animator.addKey(this.scaleTrack, 0, 0.001, tbEase.easeOutOvershoot, 0.65);
		this.animator.addKey(this.scaleTrack, 1000, 1, tbEase.easeOutOvershoot, 0.65);
		this.animator.setTime(0);
		this.animator.resumeForced();
		tgfAudio.play(a_radar_reveal);
	}
	this.hasBeenSpotted = true;
	
}

RadarShip.prototype.handleRemove = function() {
	"use strict";
	
	if (this.container) {
		this.container = null;
	}

	if (this.animator) {
		this.animator = null;
	}
	
	if (this.shipImage) {
		this.shipImage = null;
	}

	if (this.scaleTrack) {
		this.scaleTrack = null;
	}
}

RadarShip.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	this.show();

	if (this._animatorScreenTransition) {
		this._animatorScreenTransition.updateTime(timePassed);
	}
	
	if (this.animator) {
		this.animator.updateTime(timePassed);
		this.shipImage.setScale(this.shipImage.scale, this.shipImage.scale);
	}

	var revealShip = this.hasBeenSpotted && this._shipRevealing;
	if (!this.hasBeenSpotted && this._shipRevealing) {
		this.shipImage.setAlpha(0);
		return;
	}
	else this.shipImage.setAlpha(1);

	if(!revealShip && this.shipImage.alpha > 0.5) {
		this.shipImage.setAlpha(this.shipImage.alpha - timePassed * 0.0002);
	}
}

RadarShip.prototype.show = function() {

	if (this.imageAdded == false) {
		this.container.addChild(this.shipImage);
		this.imageAdded = true;
	}
	
	this.container.container.visible = true;
}

RadarShip.prototype.hide = function() {

	this.container.container.visible = false;
}

RadarShip.prototype.setTiles = function() {
	
}

RadarShip.prototype.getTiles = function() {
	return (this._stateVertical) ? this._tiles.vertical : this._tiles.horizontal;
}

RadarShip.prototype.addToTop = function() {

	if (!this.container.container.parent) throw new Error('RadarShip->container.parent NOT set');

	this.container.container.parent.addChild(this.container.container);
}


RadarShip.prototype._getImage = function(id) {
	var shipImages = this._shipRevealing ? [
		{},
		{ ver: s_opp_ship_carrier_green_ver,	hor: s_opp_ship_carrier_green_hor },
		{ ver: s_opp_ship_battleship_green_ver,	hor: s_opp_ship_battleship_green_hor },
		{ ver: s_opp_ship_cruiser_green_ver,	hor: s_opp_ship_cruiser_green_hor },
		{ ver: s_opp_submarine_green_ver,	hor: s_opp_submarine_green_hor },
		{ ver: s_opp_ship_destroyer_green_ver,	hor: s_opp_ship_destroyer_green_hor },
	] : [
		{},
		{ ver: s_opp_ship_carrier_ver,		hor: s_opp_ship_carrier_hor },
		{ ver: s_opp_ship_battleship_ver,	hor: s_opp_ship_battleship_hor },
		{ ver: s_opp_ship_cruiser_ver,		hor: s_opp_ship_cruiser_hor },
		{ ver: s_opp_submarine_ver,			hor: s_opp_submarine_hor },
		{ ver: s_opp_ship_destroyer_ver,	hor: s_opp_ship_destroyer_hor },
	];

	return this._stateVertical ? shipImages[id].ver : shipImages[id].hor;
}


RadarShip.prototype._getSize = function(id) {

	var size = null;

	switch (id) {
		case 1 :
		{
			size = 5;
			break;
		}
		case 2 :
		{
			size = 4;
			break;
		}
		case 3 :
		{
			size = 3;
			break;
		}
		case 4 :
		{
			size = 3;
			break;
		}
		case 5 :
		default :
		{
			size = 2;
			break;
		}
	}

	return size;
}
//******************************************************
//*****    Script Resource: RadarExplosion
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

/** Creates a new RadarExplosion. It can play a single explosion animation. */
var RadarExplosion = function(x, y, specialWeapon, container) {
    "use strict";

    this.explosionAnimation = null;
    this.animationName = specialWeapon.getExplosionAnimationName();
    this.container = container;

    this.position = { x: x, y: y };
}

/** Starts playing the explosion animation */
RadarExplosion.prototype.playAnimation = function(onPlayCallback) {
    "use strict";
    
    this.explosionAnimation = player_explosion.clone();

    this.explosionAnimation.setAnimation(this.animationName, false);

    // Call onPrepareDone a frame later when the animation is initialized
    setTimeout(function () {
        this._onPrepareDone();
        if (onPlayCallback) onPlayCallback();
    }.bind(this), 0);
}

/** Called when the animation is initialized */
RadarExplosion.prototype._onPrepareDone = function() {
    "use strict";

    // Add the animation to the game
    this.explosionAnimation.setPosition(this.position.x, this.position.y);
    this.container.addChild(this.explosionAnimation.animation);
}

/** Called when the animation is done */
RadarExplosion.prototype.destroy = function(onDestroyedCallback) {
    "use strict";

    // Remove the animation a frame later
    setTimeout(function () {
        // Remove the animation from the game
        this.container.removeChild(this.explosionAnimation.animation);
        this.explosionAnimation.animation.destroy();

        if (onDestroyedCallback) onDestroyedCallback();
    }.bind(this), 0);
}
//******************************************************
//*****    Script Resource: StrikeManager
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var StrikeManager = function(tileMap) {
    "use strict";

    this._tileMap = tileMap;

    this.radarStrikes = [];
    this.missiles = [];
}

StrikeManager.prototype.createStrikes = function(centerTile, tilesToStrike, specialWeapon, onDoneCallback, skipAnimation) {
    "use strict";


    console.log('MAP::SM.createStrikes', centerTile, tilesToStrike, specialWeapon);

    var self = this;

    var strikes = [];
    var visibleStrikesAmount = 0;

    // Create the strikes
    for (var i = 0; i < tilesToStrike.length; i++) {
        // Skip this tile if it already contains a strike
        // if (this._tileMap.getShotAt(tilesToStrike[i].index)) {
        if (this.getStrikeByIndex(tilesToStrike[i].index) ) {

            console.log('MAP::tile shot at already - returning', tilesToStrike[i]);
            continue;
        }

        // Check if the strike is in the center
        var isCenter = centerTile.index == tilesToStrike[i].index;

        // Add a single strike to the list
        strikes.push(new RadarStrike(tilesToStrike[i].index, self._tileMap, isCenter, function(visibleStrike) {

            // Add every visible strike to the array
            self.radarStrikes.push(visibleStrike);
            
            // When the last strike becomes visible, the strike animation is done
            visibleStrikesAmount++;
            if (visibleStrikesAmount >= strikes.length) {
                onDoneCallback();
            }
        }));
    }

    // If there weren't any new strikes added, stop this function
    if (strikes.length == 0) {
        console.warn("StrikeManager::No new strikes were added");
        onDoneCallback();
        return;
    }

    // Create the missile
    this._createMissile(centerTile, strikes, specialWeapon, skipAnimation);
}

StrikeManager.prototype.update = function(timePassed) {
    "use strict";

    for (var i = 0; i < this.missiles.length; i++) {
        this.missiles[i].update(timePassed);
    }
}

StrikeManager.prototype._createMissile = function(centerTile, strikes, specialWeapon, skipAnimation) {
    "use strict";

    // Calculate the world position where the missile should be placed
    var worldX = (centerTile.tx + specialWeapon.pivot.x) * TileMapValues.WIDTH;
    var worldY = (centerTile.ty + specialWeapon.pivot.y) * TileMapValues.HEIGHT;

    if (skipAnimation) {

        for (var i = 0; i < strikes.length; i++) {
            strikes[i].show(true);
        }
        return;
    }
    else {
        tgfAudio.play(specialWeapon.shootSound);
    }

    // Get the direction of the missile
    var frontToBack = specialWeapon.getMissileDirection(centerTile);

    // Create a new missile object to play the missile animation
    var missile = new RadarMissile(worldX, worldY, specialWeapon, this._tileMap.getContainer(), frontToBack);

    this.missiles.push(missile);
    
    // Play the missile animation
    missile.playAnimation();

    // Call the onMissileFire event to execute the strike appearing logic
    specialWeapon.onMissileFire(missile, strikes, function() {
        // Call onComplete a frame later when the animation completed
        missile.destroy(function () {
            // Delete the missile
            var index = this.missiles.indexOf(missile);
            if (index > -1)
                this.missiles.splice(index, 1);
            missile = null;

        }.bind(this));
    }.bind(this), this._tileMap.getContainer());
}

/** Returns a radar strike that corresponds to a tile index */
StrikeManager.prototype.getStrikeByIndex = function(index)
{
	for (var i = 0; i < this.radarStrikes.length; i++) {
		if (this.radarStrikes[i].tileIndex == index) {
			return this.radarStrikes[i];
		}
	}
	return null;
}
//******************************************************
//*****    Script Resource: RadarMissile
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

/** Creates a new RadarExplosion. It can play a single explosion animation. */
var RadarMissile = function(x, y, specialWeapon, container, frontToBack) {
    "use strict";

    this.fireAnimation = null;
    this.animationName = specialWeapon.getMissileAnimationName(frontToBack);
    this.container = container;

    this.position = { x: x, y: y };

    this.frontToBack = frontToBack;

    this.soundTimer = 0;
    this.soundTimerInterval = 150;

    this.animationStarted = false;
}

RadarMissile.prototype.playAnimation = function() {
    "use strict";

    this.fireAnimation = player_missile.clone();

    this.fireAnimation.setAnimation(this.animationName, false);

    // Call onPrepareDone a frame later when the animation is initialized
    setTimeout(this._onPrepareDone.bind(this), 0);
}

/** Called when the animation is initialized */
RadarMissile.prototype._onPrepareDone = function() {
    "use strict";

    // Add the animation to the game
    this.fireAnimation.setPosition(this.position.x, this.position.y);
    this.container.addChild(this.fireAnimation.animation);

    this.animationStarted = true;
}

RadarMissile.prototype.update = function(timePassed) {
    "use strict";
    if (!this.animationStarted) return;

    this.soundTimer += timePassed;

    if (this.soundTimer >= this.soundTimerInterval) {
        this.soundTimer -= this.soundTimerInterval;

        tgfAudio.play(a_radar_strike_flight);
    }
}

/** Destroys the animation */
RadarMissile.prototype.destroy = function(onDestroyedCallback) {
    "use strict";

    // Remove the animation a frame later
    setTimeout(function () {
        // Remove the animation from the game
        this.container.removeChild(this.fireAnimation.animation);
        this.fireAnimation.animation.destroy();

        if (onDestroyedCallback) onDestroyedCallback();
    }.bind(this), 0);
}
//******************************************************
//*****    Script Resource: RadarHighlighter
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var RadarHighlighter = function(tileContainer, tilemap) {
	this.highlights = [];

	this.mapWidth = tilemap.getRows();
	this.mapHeight = tilemap.getColumns();

	this.targets = [];

	var lineOffset = 4;
	for (var x = 0; x < this.mapWidth; x++) {
		this.highlights[x] = [];
		for (var y = 0; y < this.mapHeight; y++) {
			var lineElement = s_grid_tile_place_legal.clone();
			tileContainer.addChild(lineElement);
			lineElement.setAlpha(0);
			var xPos = x * tilemap.getTileDimension().width + lineOffset;
			var yPos = y * tilemap.getTileDimension().height + lineOffset;
			lineElement.setPosition(xPos, yPos);
	
			var highlight = {image: lineElement, active: false}
	
			this.highlights[x].push(highlight);
		}
	}
};

RadarHighlighter.prototype.activateAllFromTileList = function(list) {
	this.setActiveOnAll(false);

	for (var i = 0; i < list.length; i++) {
		this.setActive(list[i].x, list[i].y, true);
	}
};

RadarHighlighter.prototype.setActiveOnAll = function(active) {
	for (var x = 0; x < this.mapWidth; x++) {
		for (var y = 0; y < this.mapHeight; y++) {
			this.setActive(x, y, active);
		}
	}
};

RadarHighlighter.prototype.setTargets = function(tiles) {
	this.targets = tiles;
};

RadarHighlighter.prototype.setActive = function(x, y, active) {
	this.highlights[x][y].active = active;
	var alpha = active ? 0.5 : 0;
	this.highlights[x][y].image.setAlpha(alpha);
};

RadarHighlighter.prototype.adjustHighlight = function(highLightDistance) {
	for (var x = 0; x < this.highlights.length; x++) {
		for (var y = 0; y < this.highlights[x].length; y++) {
			if (!this.highlights[x][y].active) {
				continue;
			}

			var distance = Math.abs(this.distanceFromNearestTarget(x, y) - highLightDistance);
			var alpha = Math.max(0.6 - distance * 0.1, 0.3);
			this.highlights[x][y].image.setAlpha(alpha)
		}
	}
};

RadarHighlighter.prototype.distanceFromNearestTarget = function(x, y) {
	if (this.targets.length === 0) {
		return 0;
	}

	var minDistance = Infinity;
	for (var i = 0; i < this.targets.length; i++) {
		var target = this.targets[i];
		var dist = Math.max(Math.abs(target.x - x), Math.abs(target.y - y));
		if (dist < minDistance) {
			minDistance = dist;
		}
	}

	return minDistance;
};
//******************************************************
//*****    Script Resource: ShipPlacer
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var ShipPlacer = function(options, ship, playController, tileContainer) {

	this.tileContainer = tileContainer.container;
    this._isVertical = (options.isVertical === true || options.isVertical === false) ? this._isVertical : true;
	this._id = options.id || 1;
	this.shipYardPos = {
		x: options.shipYardPos.x,
		y: options.shipYardPos.y
	};
	
	// ship size
	this._size = this._getSize(this._id);
	this.isDragging = false;
	this._ship = ship;
	this.playController = playController;

	// Reset invalid tile count
	this.tilesOffMap = this.invalidTiles = this._size;
	
	// ship image refs
	var images = this._getImage(this._id);
	this._imageVer = images.shipPlaceVer.clone();
	this._imageHor = images.shipPlaceHor.clone();

	var tileScale = TileMapValues.WIDTH / ShipPlacementController.TILE_SIZE;

	this._imageVer.setScale(tileScale, tileScale);
	this._imageHor.setScale(tileScale, tileScale);

	// container
	this.container = new tbContainer();
	this.container.x = this.container.container.x = this.shipYardPos.x;
	this.container.y = this.container.container.y = this.shipYardPos.y;
	
	this._imageVer.sprite.x = ShipPlacementController.TILE_SIZE/2 - this._imageVer.sprite.width / 2;
	this._imageVer.sprite.y = (ShipPlacementController.TILE_SIZE * this._size / 2) - this._imageVer.sprite.height / 2;
	this._imageHor.sprite.x = this._imageHor.sprite.width / 2;
	this._imageHor.sprite.y = this._imageHor.sprite.height / 2 - ShipPlacementController.TILE_SIZE / 2;
	
	// draw hit (interaction) area
	this._hitArea = tbGraphics.drawRectangle(0, 0, ShipPlacementController.TILE_SIZE, ShipPlacementController.TILE_SIZE * this._size, 0xff00ff, null, 0, 0.001);
	this._hitArea.buttonMode = true;
	this._hitArea.interactive = true;
	this.width = this._hitArea.width;
	this.height = this._hitArea.height;

	this.buttonRotate = s_button_rotate.clone();

	this.container.addChild(this._hitArea);
	this.container.addChild(this._imageVer);
	this.container.addChild(this._imageHor);

	this.validationImages = { legal: [], illegal: [] };
	for (var i = 0; i < this._size; i++) {

		var legal = s_grid_tile_place_legal.clone();
		this.validationImages.legal.push(legal);
		legal.setAlpha(0);
		legal.setPosition(-100, 0);
		tgfGraphics.addChild(legal.sprite, ('ShipPlacer.legal' + i));

		var illegal = s_grid_tile_place_illegal.clone();
		this.validationImages.illegal.push(illegal);
		illegal.setAlpha(0);
		illegal.setPosition(-100, 0);
		tgfGraphics.addChild(illegal.sprite, ('ShipPlacer.illegal' + i));
	}

	this.addShipClickListeners();

	this.setVertical(this._isVertical);
	tgfGraphics.addChild(this.container.container, 'shipplacer.container');
	tgfGraphics.addChild(this.buttonRotate.sprite, 'shipplacer.buttonrotate');
	this.buttonRotate.setAlpha(0);

	this.hasMoved = false;
	this.soundPlayed = false;
}

ShipPlacer.prototype.constructor = ShipPlacer;

ShipPlacer.prototype.addShipClickListeners = function () {
	// add hit area interaction listeners

	var self = this;

	this._hitArea.on('pointerdown', function (e) { 

		if (ShipPlacementController.isAnimating) ShipPlacementController.finishShipyardAnimation();
		
		if (self.playController.isPlacing() == false) return;

		if (ShipPlacementController.draggingShip != 0) return;

		tgfAudio.play(a_ship_tap);
		self.isDragging = true; 
		self.originalTile = self._ship.tile;
		ShipPlacementController.draggingShip = self._id; 
		self.buttonRotate.gotoAndStop(1);

		self.startMouseX = self.mouseWorldX = e.data.global.x;
		self.startMouseY = self.mouseWorldY = e.data.global.y;

		self.mouseWorldX = e.data.global.x;
		self.mouseWorldY = e.data.global.y;
		
		self.onDrag();

	});

	var onDragStop = function (e) { 

		if (ShipPlacementController.draggingShip != self._id || self.isDragging == false) 
			return;

		self.isDragging = false; 
		ShipPlacementController.draggingShip = 0; 

		self.mouseWorldX = e.data.global.x;
		self.mouseWorldY = e.data.global.y;

		var mouseOffsetX = Math.abs(self.startMouseX - self.mouseWorldX);
		var mouseOffsetY = Math.abs(self.startMouseY - self.mouseWorldY);

		// If we stayed on the same tile, rotate instead.
		if (self.originalTile >= 0 && mouseOffsetX < TileMapValues.WIDTH * 0.5 && mouseOffsetY < TileMapValues.HEIGHT * 0.5)
			self.onRotate();
		else self.onDrag(); 
	};

	
	this._hitArea.on('pointermove', function (e) { 
		
		if (ShipPlacementController.isAnimating) return;
		if (self.playController.isPlacing() == false) return;

		if (ShipPlacementController.draggingShip != self._id || self.isDragging == false) 
			return;

		self.mouseWorldX = e.data.global.x;
		self.mouseWorldY = e.data.global.y;
		
		self.onDrag(); 
	});
	
	this._hitArea.on('pointerup', onDragStop);
	this._hitArea.on('pointerupoutside', onDragStop);
};	

ShipPlacer.prototype.shuffleTo = function (placementData) {

	var ty = Math.floor(placementData.tileAnchor / TileMapValues.COLS);
	var tx = placementData.tileAnchor - (ty * TileMapValues.COLS);
	
	this.setVertical(placementData.vertical);

	this._imageVer.setAlpha(this._isVertical ? 1 : 0);
	this._imageHor.setAlpha(!this._isVertical ? 1 : 0);	
	
	this.container.container.visible = true;
	this._ship.hide();
	
	// Move placer boat to correct position
	var middleX = this.tileContainer.x + tx * 74;
	var middleY = this.tileContainer.y + ty * 74;
	
	this.container.setPosition(middleX, middleY);

	this.hasMoved = true;

	this.tileX = tx;
	this.tileY = ty;
	this.prevTileX = tx;
	this.prevTileY = ty;

	this._ship.setTilePosition(tx, ty);

	var playAudio = false;	
	// if (this._id == 1) playAudio = true;

	this.validateShipPosition(playAudio);
	this.bringRotateButtonToTop();
}


ShipPlacer.prototype.bringRotateButtonToTop = function () {
	
	this.placeRotateButton();	
	tgfGraphics.addChild(this.buttonRotate.sprite, 'shipplacer.buttonrotate');
}

ShipPlacer.prototype.onDrag = function(force) {
	
	this.buttonRotate.gotoAndStop(0);

	tgfGraphics.addChild(this.container.container);	
	this.bringRotateButtonToTop();

	// Fix validation only when tiles have properly been diagnosed
	this.validateShipPosition();

	this.placeRotateButton();

	// Don't update positions when button is released
	if (!force) {

		if (this.isDragging == false) return;
	}

	console.log('onDrag');

	this._ship.setTilePosition(-1, -1);
	this._imageVer.setAlpha(this._isVertical ? 1 : 0);
	this._imageHor.setAlpha(!this._isVertical ? 1 : 0);	
	
	this.container.container.visible = true;
	this._ship.hide();
	
	// Move placer boat to correct position
	var middleX = this.mouseWorldX - (ShipPlacementController.TILE_SIZE * 0.5 * (this._isVertical ? 1 : this._size));
	var middleY = this.mouseWorldY - (ShipPlacementController.TILE_SIZE * 0.5 * (!this._isVertical ? 1 : this._size));
	this.container.setPosition(middleX, middleY);

	// initialise prevTiles
	if (typeof this.prevTileX !== 'number') {
		this.prevTileX = Math.round((middleX - this.tileContainer.x) / (TileMapValues.WIDTH));
		this.prevTileY = Math.round((middleY - this.tileContainer.y) / (TileMapValues.HEIGHT));
	}

	var tileX = (middleX - this.tileContainer.x) / (TileMapValues.WIDTH);
	var tileY = (middleY - this.tileContainer.y) / (TileMapValues.HEIGHT);

	this.tileX = (this.prevTileX > tileX) ? Math.ceil(tileX) : Math.floor(tileX);	
	this.tileY = (this.prevTileY > tileY) ? Math.ceil(tileY) : Math.floor(tileY);	

	// Get previous tiles if needed
	this.hasMoved = false;
	if (this.prevTileX != this.tileX)  {
		this.hasMoved = true;
		this.prevTileX = this.tileX;
	}
	if (this.prevTileY != this.tileY) {
		this.hasMoved = true;
		this.prevTileY = this.tileY;
	}

	var verticalSize = this._isVertical ? this._size : 1;
	var horizontalSize = !this._isVertical ? this._size : 1;

	if (this.tileX < 0) this.tileX = 0;
	if (this.tileX > TileMapValues.ROWS - horizontalSize) this.tileX = TileMapValues.ROWS - horizontalSize;
	if (this.tileY < 0) this.tileY = 0;
	if (this.tileY > TileMapValues.COLS - verticalSize) this.tileY = TileMapValues.COLS - verticalSize;

	this._ship.setTilePosition(this.tileX, this.tileY);
};

ShipPlacer.prototype.onRotate = function() {

	// Can only be placed when they are on the map
	if (this.tilesOffMap == this._size) return;

	tgfAudio.play(a_ship_rotation);
	this.setVertical(!this._isVertical);

	var halfSize = Math.floor((this._size - 1) / 2);

	// This makes it rotate around the middle, rather than tileX/Y
	if (!this._isVertical) {
		this.tileX -= halfSize;
		this.tileY += halfSize;
	}
	else /*if (!this._isVertical)*/ {
		this.tileX += halfSize;
		this.tileY -= halfSize;
	}

	var verticalSize = this._isVertical ? this._size : 1;
	var horizontalSize = !this._isVertical ? this._size : 1;

	if (this.tileX < 0) this.tileX = 0;
	if (this.tileX > TileMapValues.ROWS - horizontalSize) this.tileX = TileMapValues.ROWS - horizontalSize;
	if (this.tileY < 0) this.tileY = 0;
	if (this.tileY > TileMapValues.COLS - verticalSize) this.tileY = TileMapValues.COLS - verticalSize;

	console.log("new: ", this.tileX, this.tileY);

	this.validateShipPosition();
	this.onDrag();
	this._ship.setTilePosition(this.tileX, this.tileY);
	if (this._ship.isVisible()) {
		this._ship.place(this, true);
	}

	return true;
};

ShipPlacer.prototype.placeRotateButton = function (middleX, middleY) {
	
	if (!this.isDragging && this._ship.tile >= 0) {
		var halfSize = Math.floor((this._size - 1) / 2);
		
		var tileX = this.tileX;
		var tileY = this.tileY;
		if (!this._isVertical)
			tileX += halfSize;
		else tileY += halfSize;

		var worldTileX = (this.tileContainer.x + tileX * TileMapValues.WIDTH);
		var worldTileY = (this.tileContainer.y + tileY * TileMapValues.HEIGHT);

		// The hitbox is slightly larger, center it right over the image below by subtracting the difference
		if (this._isVertical) worldTileX += (ShipPlacementController.TILE_SIZE - TileMapValues.WIDTH) * 0.5;
		else worldTileY += (ShipPlacementController.TILE_SIZE - TileMapValues.HEIGHT) * 0.5;

		if (this.invalidTiles > 0 && !this._isVertical) worldTileY -= ShipPlacementController.TILE_SIZE * 0.5;
		this.buttonRotate.setPosition(worldTileX, worldTileY);
		this.buttonRotate.setAlpha(1);
	}
	else {
		this.buttonRotate.setAlpha(0);
		
	}
}

ShipPlacer.prototype.resetHitboxSize = function (placerImageUsed) {

	var tileSize = (placerImageUsed) ? ShipPlacementController.TILE_SIZE : TileMapValues.WIDTH;
	
	// Resize hitbox
	this._hitArea.width = this._isVertical ? tileSize : this._size * tileSize;
	this._hitArea.height = !this._isVertical ? tileSize : this._size * tileSize;
}

ShipPlacer.prototype.hideValidationImages = function(onlyLegal) {
	
	for (var i = 0; i < this._size; i++) {
		this.validationImages.legal[i].setAlpha(0);
		if (!onlyLegal) this.validationImages.illegal[i].setAlpha(0);
	}
}

ShipPlacer.prototype.validateShipPosition = function(playAudio) {
	
	var self = this;

	if (playAudio == undefined) playAudio = true;

	this.hideValidationImages();
	if (typeof this.prevTileX !== 'number') return;

	var invalidLocations = 0;
	var locationsOffmap = 0;

	// For every ship tile
	for (var i = 0; i < this._size; i++) {
		
		// Get the tile space X and Y
		var tileOffsetX = (this.tileX + (this._isVertical ? 0 : i));
		var tileOffsetY = (this.tileY + (!this._isVertical ? 0 : i));

		// Check if off-map
		if (tileOffsetX < -1 || tileOffsetX > TileMapValues.ROWS || tileOffsetY < -1 || tileOffsetY > TileMapValues.COLS) {
			invalidLocations++;
			locationsOffmap++;
			continue;
		}

		// Check if valid
		var isLocationValid = ShipPlacementController.isValidLocation(this._id, tileOffsetX, tileOffsetY, this._isVertical);
		if (isLocationValid == false) invalidLocations++; // Count them

		
		// Get the correct colour based on validity
		var tile = isLocationValid ? this.validationImages.legal[i] : this.validationImages.illegal[i];
		
		var worldX = this.tileContainer.x + tileOffsetX * 74;
		var worldY = this.tileContainer.y + tileOffsetY * 74;

		// If we're not dragging, dont show valid locations
		if (!isLocationValid || this.isDragging) tile.setAlpha(1);
		
		// For the dragging ship, if we just moved and we have an illegal placement, play a sound once.
		if (this.isDragging && !isLocationValid && this.hasMoved && !this.soundPlayed) {
			this.soundPlayed = true;
			setTimeout(function() { self.soundPlayed = false; }, 100);
			tgfAudio.play(a_illegal_placement);
		}
		tile.setPosition(worldX, worldY);
	}

	this.invalidTiles = invalidLocations;
	this.tilesOffMap = locationsOffmap;

	if (this.isDragging == false) {
		
		this._imageVer.setAlpha(0);
		this._imageHor.setAlpha(0);

		var shipPlacerImage = this._isVertical ?  this._imageVer : this._imageHor;
		
		// invalid tiles are the amount of tiles the ship touches that are not placable
		if (this.invalidTiles > 0) {
			if (this._ship.isVisible()) {
				this._ship.hide();
			}

			shipPlacerImage.setAlpha(1);
			this.resetHitboxSize(true);
		}
		else { // Everything is a-ok, show animated ship
			if (!this._ship.isVisible()) {
				this._ship.place(this);
			}

			shipPlacerImage.setAlpha(0);
			this.resetHitboxSize(false);
		}

		var worldTileX = (this.tileContainer.x + this.tileX * TileMapValues.WIDTH);
		var worldTileY = (this.tileContainer.y + this.tileY * TileMapValues.HEIGHT);
		
		// The hitbox is slightly larger, center it right over the image below by subtracting the difference
		var centerWidth = ShipPlacementController.TILE_SIZE - TileMapValues.WIDTH;
		var centerHeight = ShipPlacementController.TILE_SIZE - TileMapValues.WIDTH;

		this.container.setPosition(worldTileX, worldTileY - centerHeight * 0.5);
	}
}

ShipPlacer.prototype.setVertical = function(boolVertical) {
	this._isVertical = boolVertical;

	this._ship.setVertical(boolVertical);

	if (this._imageHor)
		this._imageVer.setAlpha((this._isVertical) ? 1 : 0);
	
	if (this._imageVer)
		this._imageHor.setAlpha((this._isVertical) ? 0 : 1);
}

ShipPlacer.prototype.isVertical = function() {
	return this._isVertical;
}

ShipPlacer.prototype.sendBackToShipyard = function() {

	this.resetHitboxSize(true);

	this.container.x = this.container.container.x = this.shipYardPos.x;
	this.container.y = this.container.container.y = this.shipYardPos.y;
	this._ship.tile = -1;
	this.buttonRotate.setAlpha(0);
	this.buttonRotate.setPosition(-9000, -9000);
	this.invalidTiles = this._size;

	this.setVertical(true);
}

ShipPlacer.prototype.remove = function() {
	
	this._hitArea = null;
	tgfGraphics.removeChild(this.container.container);
	tgfGraphics.removeChild(this.buttonRotate.sprite);

	this.container.removeChild(this._hitArea);
	this.container.removeChild(this._imageVer);
	this.container.removeChild(this._imageHor);

	for (var i = 0; i < this._size; i++) {
		tgfGraphics.removeChild(this.validationImages.legal[i].sprite);
		tgfGraphics.removeChild(this.validationImages.illegal[i].sprite);
	}
	this.validationImages = { legal: [], illegal: [] };
}

ShipPlacer.prototype.getId = function() {
	return this._id;
}

ShipPlacer.prototype.getSize = function() {
	return this._size;
}

ShipPlacer.prototype.getVerticalImage = function() {
	return this._imageVer;
}

ShipPlacer.prototype.getShipName = function() {
	switch (this._id) {
		case 1: return "carrier";
		case 2: return "battleship";
		case 3: return "cruiser";
		case 4: return "submarine";
		case 5: return "destroyer"
		default: return String(this._id);
	}
}

ShipPlacer.prototype._getImage = function(id)  {
	
	var imageShipPlaceVer = null;
	var imageShipPlaceHor = null;
	var imageShipVer = null;
	var imageShipHor = null;

	switch (id) {
		case 1 :
		{
			imageShipPlaceVer = s_ship_place_carrier;
			imageShipPlaceHor = s_ship_place_carrier_h;
			imageShipVer = s_pla_ship_carrier_ver;
			imageShipHor = s_pla_ship_carrier_hor;
			break;
		}
		case 2 :
		{
			imageShipPlaceVer = s_ship_place_battleship;
			imageShipPlaceHor = s_ship_place_battleship_h;
			imageShipVer = s_pla_ship_battleship_ver;
			imageShipHor = s_pla_ship_battleship_hor;
			break;
		}
		case 3 :
		{
			imageShipPlaceVer = s_ship_place_cruiser;
			imageShipPlaceHor = s_ship_place_cruiser_h;
			imageShipVer = s_pla_ship_cruiser_ver;
			imageShipHor = s_pla_ship_cruiser_hor;
			break;
		}
		case 4 :
		{
			imageShipPlaceVer = s_ship_place_submarine;
			imageShipPlaceHor = s_ship_place_submarine_h;
			imageShipVer = s_pla_ship_submarine_ver;
			imageShipHor = s_pla_ship_submarine_hor;
			break;
		}
		case 5 :
		default :
		{
			imageShipPlaceVer = s_ship_place_destroyer;
			imageShipPlaceHor = s_ship_place_destroyer_h;
			imageShipVer = s_pla_ship_destroyer_ver;
			imageShipHor = s_pla_ship_destroyer_hor;
			break;
		}
	}

	var imageRefs = {};
	imageRefs.shipPlaceVer = imageShipPlaceVer;
	imageRefs.shipPlaceHor = imageShipPlaceHor;
	imageRefs.shipVer = imageShipVer;
	imageRefs.shipHor = imageShipHor;

	return imageRefs;
}
	

ShipPlacer.prototype._getSize = function(id) {
    switch (id) {
        case 1: return 5;
        case 2: return 4;
        case 3: return 3;
        case 4: return 3;
        case 5: return 2;
        default: return 0;
    }
}

//******************************************************
//*****    Script Resource: ShipPlacementController
//******************************************************

var ShipPlacementController = {

		TILE_SIZE: 88,

		draggingShip: 0,

		_board: null,
		_onComplete: [],
		_onFailure: null,

		_initialised: false,
		_shipYardImage: null,
		_placementContainer: null,
		_title: null,
		_placers: [],
		_uiPopupIncorrectPlacement: null,

		storedPlacementValid: false,
		storedDonePlacing: false,

		show: function (board, playController, tileContainer, onComplete, onFailure) {

			// this._showingPlacement = true;

			if (!this._initialised) {

				BattleshipsAnalytics.reportScreenShipSetup();

				this._playController = playController;
				this._tileContainer = tileContainer;

				// main container
				this._placementContainer = new tbContainer();

				this._placementContainer.setPosition(0, -65); // Applied offset

				this._placementContainer.width = s_overlay_shipyard.width;
				this._placementContainer.height = s_overlay_shipyard.height;



				// This is a permanent temporary solution
				this._backgroundOverlayShade = s_overlay_next_battle.clone();
				this._backgroundOverlayShade.setAlpha(0);
				this._backgroundOverlayShade.sprite.width = 1366;


				this._uiContainer = new tgfDialogs.Container({
					// baseContainer: this._placementContainer,
					width: tgfGraphics.areaWidth,
					height: tgfGraphics.areaHeight
				});

				var buttonImage = s_button_green;

				this._buttonRandomize = new tgfComponents.ComponentBattleshipButton({
					text: tgfDictionary.getText("buttonShuffle"),
					image: buttonImage,
					width: 320,
					height: 86,
					x: tgfGraphics.areaWidth / 2,
					y: tgfGraphics.areaHeight / 2 - 90, // Applied offset
					icon: s_shuffle_icon,
					iconPosition: 'right',
					onClick: this._shuffleSetup.bind(this),
					fontSize: 40
				});



				// background
				if(!shipyard.spineData) {
					shipyard.startLoading();
				}

				this._title = f_babas_bold.clone();
				this._title.setAlign("center");
				this._title.setText(tgfDictionary.getText("ShipPlacementInstructions"));
				this._title.setFillColor("#ffffcc");
				this._title.setStrokeColor("#002d57");
				this._title.setStrokeWidth(2);
				// this._title.setFontStyle("italic");
				this._title.setFontSize(62);
				this._title.add(this._placementContainer);

				this._backgroundOverlayShade.add(this._placementContainer);
				tgfGraphics.addChild(this._placementContainer.container, '_placementContainer');


				this._uiContainer.addComponent(this._buttonRandomize);
				this._uiContainer.show();

				// setTimeout(function() {

				// 	this._buttonRandomize.image.sprite.on('pointerup', function() {
				// 		console.log('!!SHUFFLE!!');
				// 	});
				// }.bind(this), 0);


				this._initialised = true;
				tbGame.addToken(this);
			}

			this._board = board;
			this._placers = [];

			this._onComplete = onComplete;
			this._onFailure = onFailure;

			this.storedPlacementValid = false;
			this.storedDonePlacing = false;


		},

		hide: function() {

			tbGame.removeToken(this);

			if (this._uiContainer) {
				this._uiContainer.hide(true);
				this._uiContainer = null;

				this._buttonRandomize = null;
			}
			// this._showingPlacement = false;

			if (this._board) this._board = null;
			if (this._onComplete) this._onComplete = [];
			if (this._onFailure) this._onFailure = null;

			if (this._initialised) this._initialised = false;

			if (this._shipYardImage) {
				this._shipYardImage.animation.destroy({children: true});
				this._shipYardImage.animation = null;
				this._shipYardImage.remove(this._placementContainer);
				this._shipYardImage = null;
			}

			if (this._placementContainer) {
				if (this._placementContainer.container) {
					tgfGraphics.removeChild(this._placementContainer.container);
					this._placementContainer.container.destroy({children:true});
					this._placementContainer.container = null;
				}
				this._placementContainer = null;
			}

			if (this._title) this._title = null;

			if (this._placers && this._placers.length > 0) {
				for (var i = 0; i < 5; i++) {
					this._placers[i].remove();
				}
				this._placers = [];
			}

			if (this._uiPopupIncorrectPlacement) {
				// this._uiPopupIncorrectPlacement.hide();
				this._uiPopupIncorrectPlacement.free();
				this._uiPopupIncorrectPlacement = null;
			}
		},

		finishShipyardAnimation: function () {
			this._shipYardImage.setSpeed(9000);
		},

		copyPlacementToNewTileMap: function (board) {
			var map = board.getTileMap().getMap();
			var ships = board.getBoard();

			for (var i = 0; i < map.length; i++) map[i] = 0;

			for (var i = 0; i < ships.length; i++) {
				var ship = ships[i];

				for (var shipTile = 0 ; shipTile < ship.getSize(); shipTile++) {
					var iterator = ship.tile + shipTile * (ship.isVertical() ? TileMapValues.ROWS : 1);
					map[iterator] = ship.id;
				}
			};
		},

		isValidLocation: function(shipId, x, y) {

			// Has to be a legit value on the map
			if (x < 0 || y < 0 || x >= TileMapValues.ROWS || y >= TileMapValues.COLS)
				return false;

			// x and y are in tile space

			var tileIndex = y * TileMapValues.ROWS + x;
			var ships = this._board.getBoard();

			// For each ship
			for (var i = 0; i < ships.length; i++) {

				var ship = ships[i];

				// If ship is the same as the one we're checking, or not on the map
				if (shipId == ship.id || ship.tile < 0) continue;

				var shipTileIndex = ship.tile;

				// For every tile in ship
				for (var shipOffset = 0; shipOffset < ships[i]._size; shipOffset++) {
					var offset = ships[i]._stateVertical ? shipOffset * TileMapValues.ROWS : shipOffset;

					// If something occupies this tile, stop and invalidate tile
					if (tileIndex == shipTileIndex + offset) {
						return false;
					}
				}
			}

			return true;
		},

		handleTouchDown: function () {

			if (ShipPlacementController.isAnimating)
				ShipPlacementController.finishShipyardAnimation();
		},

		handleBeginStep: function (timePassed) {

			// if (!this._showingPlacement) return;

			if (!this._initialised) return;

			var animationLoaded = !!shipyard.spineData;
			var animationShown = !!this._shipYardImage;

			if (animationLoaded && animationShown == false) {

				this._shipYardImage = shipyard.clone();
				this._shipYardImage.setAnimation("shipyard_in", false);
				tgfAudio.play(a_shipyard_animation);
				this._shipYardImage.add(this._placementContainer);
				this._title.add(this._placementContainer);
				this._shipYardImage.setPosition(tgfGraphics.areaWidth * 0.5, tgfGraphics.areaHeight * 0.5);
				this.isAnimating = true;
				this._shipYardImage.setOnComplete(function() {
					this.updateShipyardAnimation(200);
					this.isAnimating = false;
					if (ABTestInstance.isFeatureSupported(tgfSettings.abTests.features.INSTANT_SHIP_PLACEMENT)) {
						this._shuffleSetup();
					}
				}.bind(this));

				// setTimeout(function () {

					for (var i = 0; i < 5; i++) {

						var placerOptions = {
							id: i + 1,

							shipYardPos: {
								x: -9000,
								y: -9000
							}
						};

						var ships = this._board.getBoard();

						placer = new ShipPlacer(placerOptions, ships[i], this._playController, this._tileContainer);
						this._placers.push(placer);
					};

					this._shipsReady = true;

				// }.bind(this), 0);
			}
			else if (animationLoaded && this._shipsReady) {

				this.updateShipyardAnimation(timePassed);
				this.updateValidation(timePassed);
			}
		},

		_shuffleSetup: function () {

			BattleshipsAnalytics.reportUxShuffleButtonClick();

			AnalyticsService.reportEvent("interaction", "interaction", {
				eventType: "button_ship_shuffle"
			});

			var placementData = RandomMap.generateMap();

			tgfAudio.play(a_ship_placement);

			for (var i = 0; i < placementData.length; i++) {

				// console.log(this._placers[i], placementData[i]);
				if (this._placers && this._placers[i]) {
					this._placers[i].shuffleTo(placementData[i]);
				}
			}
		},

		updateShipyardAnimation: function (timePassed) {

			if (!this.isAnimating) return;

			var textBone = "text";
			var textBoneIndex = this._shipYardImage.animation.spineData.findBoneIndex(textBone);
			if (textBoneIndex < 0) {
				console.warn("Expected bone with boneName '" + textBone + "' in updateShipyardAnimation");
			}
			else if (!this._shipYardImage) {
				this._title.setPosition(tgfGraphics.areaWidth / 2, 0);
			}
			else {
				var bone = this._shipYardImage.animation.skeleton.bones[textBoneIndex];

				var worldX = 0, worldY = 0;
				while(bone != null) {
					worldX += bone.x;
					worldY += bone.y;

					bone = bone.parent;
				}

				// position is now still not world, needs to add the position of the animation on top
				worldX += this._shipYardImage.x;
				worldY += this._shipYardImage.y + tgfGraphics.areaHeight * 0.5 - 17;


				this._title.x = worldX;
				this._title.y = tgfGraphics.areaHeight - worldY;

				this._title.setPosition(this._title.x, this._title.y + 80); // Applied offset
			}

			if (!this._shipYardImage) return;

			for (var i = 0; i < this._placers.length; i++) {
				var placer = this._placers[i];
				var boneName = placer.getShipName();

				var boneIndex = this._shipYardImage.animation.spineData.findBoneIndex(boneName);
				if (boneIndex < 0) {
					console.warn("Expected bone with boneName '" + boneName + "' in ShipPlacer " + i);
					continue;

				}
				var bone = this._shipYardImage.animation.skeleton.bones[boneIndex];

				// Bone positions are relative to their parent, add parent position until we have no parent.
				var worldX = 0, worldY = 0;
				while(bone != null) {
					worldX += bone.x;
					worldY += bone.y;

					bone = bone.parent;
				}

				// position is now still not world, needs to add the position of the animation on top
				worldX += this._shipYardImage.x;
				worldY += this._shipYardImage.y;

				// and the ship offset correction
				worldX -= this.TILE_SIZE * 0.5;
				worldY += this.TILE_SIZE * (placer.getSize() + 1) * 0.5;

				placer.container.x = placer.container.container.x = placer.shipYardPos.x = worldX;
				placer.container.y = placer.container.container.y = placer.shipYardPos.y = tgfGraphics.areaHeight - worldY - 65; // Applied offset
			}
		},

		updateValidation: function(timePassed) {

			// console.log('update-validate::', this._placers, this._placers.length);

			// if (this._placers) {

			// 	if (this._placers.length == 0) return;
			// }
			// else {
			// 	return;
			// }

			// Validate all ships
			for (var i = 0; i < this._placers.length; i++) {
				this._placers[i].validateShipPosition();
			}

			// Below this point calculates whether or not it should show the popup
			var placementValid = true;
			var donePlacing = this.draggingShip == 0; // If you aren't dragging a ship, you are done.
			for (var i = 0; i < this._placers.length; i++) {

				// If we misplaced, but are not completely off map
				if (this._placers[i].invalidTiles > 0) {
					placementValid = false;
				}

				if (this._placers[i].tilesOffMap == this._placers[i]._size) {
					donePlacing = false;
				}
			}

			if (!this._uiPopupIncorrectPlacement)
				this._uiPopupIncorrectPlacement = new tgfDialogs.BattleshipIncorrectPlacementPopupDialog({
					x: 0,
					y: 0,
					positionX: tgfGraphics.areaWidth/2,
					positionY: tgfGraphics.areaHeight/4,
					width: 640,
					height: 300
				});

			if (placementValid == this.storedPlacementValid && donePlacing == this.storedDonePlacing)
				return;

			this.storedPlacementValid = placementValid;
			this.storedDonePlacing = donePlacing;

            if (donePlacing) {
                if (this._onComplete) {
					this._onComplete();
				}
            }
            else {
				this._uiPopupIncorrectPlacement.hide(false);
            }

			if (placementValid) {
				this._uiPopupIncorrectPlacement.hide(false);
			}
			else {
				if (this._onFailure) {
					this._onFailure();
                }
				this._uiPopupIncorrectPlacement.show();
			}
		}
	};

//******************************************************
//*****    Script Resource: RandomMap
//******************************************************

var RandomMap = window.rm = function() {


}

RandomMap.generateMap = function() {
    
    var amountOfTiles = TileMapValues.COLS * TileMapValues.ROWS;
    var arrTiles = new Array(amountOfTiles).fill(0);

    var placementCollection = [];
    
    // Go over each ship, in random order
    // var shipPlaceOrder = RandomMap._shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    var shipPlaceOrder = [1, 2, 3, 4, 5];
    for (var shipIndex = 0; shipIndex < shipPlaceOrder.length; shipIndex++) {
        var shipID = shipPlaceOrder[shipIndex];
        var shipLength = RandomMap._getShipSize(shipID);

        // If shipIndex = 0, all locations fit (no ships are placed). Otherwise, find the fitting spots.
        var horFittingLocations = [];
        var verFittingLocations = [];


        var placementData = {};
        placementData.id = shipID;
        placementCollection.push(placementData);

        // Go over each tile
        for (var tileIndex = 0; tileIndex < arrTiles.length; tileIndex++) {
            var tileY = Math.floor(tileIndex / TileMapValues.COLS);
            var tileX = tileIndex - (tileY * TileMapValues.COLS);

            // See if it fits horizontally.
            var horizontalSpaceLeft = TileMapValues.COLS - tileX;
            if (horizontalSpaceLeft >= shipLength) {
                var fits = true;
                for (var horOffset = 0; horOffset < shipLength; horOffset++) {
                    if (arrTiles[tileIndex + horOffset] != 0) {
                        fits = false;
                        break;
                    }
                }

                // If it fits, j is a fitting location.
                if (fits) horFittingLocations.push(tileIndex);
            }

            // See if it fits vertically.
            var verticalSpaceLeft = TileMapValues.ROWS - tileY;
            if (verticalSpaceLeft >= shipLength) {
                var fits = true;
                for (var verOffset = 0; verOffset < shipLength; verOffset++) {
                    if (arrTiles[tileIndex + verOffset * TileMapValues.ROWS] != 0) {
                        fits = false;
                        break;
                    }
                }

                // If it fits, j is a fitting location.
                if (fits) verFittingLocations.push(tileIndex);
            }
        }

        var vertical = Math.random() > 0.5;


        // Choose a random axis
        if (vertical && verFittingLocations.length != 0) {
            var baseIndex = verFittingLocations[Math.floor(Math.random() * verFittingLocations.length)];

        	placementData.tileAnchor = baseIndex;// + (Math.floor((shipLength-1)/2) * TileMapValues.COLS);
        	placementData.case = 'A';
        	placementData.shipLength = shipLength;
        	placementData.vertical = true;

            for (var shipTile = 0; shipTile < shipLength; shipTile++) {
                arrTiles[baseIndex + shipTile * TileMapValues.COLS] = shipID; 
            }
        }
        else if (!vertical && horFittingLocations.length != 0) {
            var baseIndex = horFittingLocations[Math.floor(Math.random() * horFittingLocations.length)];

            placementData.tileAnchor = baseIndex;// + Math.floor((shipLength-1)/2);
        	placementData.case = 'B';
        	placementData.shipLength = shipLength;
            placementData.vertical = false;

            for (var shipTile = 0; shipTile < shipLength; shipTile++) {
                arrTiles[baseIndex + shipTile ] = shipID; 
            }
        }
        else  {

            // The randomly chosen axis doesn't work out, choose the other one
            if (verFittingLocations.length != 0) {
                var baseIndex = verFittingLocations[Math.floor(Math.random() * verFittingLocations.length)];
    
            	placementData.tileAnchor = baseIndex;// + (Math.floor((shipLength-1)/2) * 8);
        		placementData.case = 'C';
        		placementData.shipLength = shipLength;
                placementData.vertical = true;

                for (var shipTile = 0; shipTile < shipLength; shipTile++) {
                    arrTiles[baseIndex + shipTile * TileMapValues.COLS] = shipID; 
                }
            }
            else if (horFittingLocations.length != 0) {
                var baseIndex = horFittingLocations[Math.floor(Math.random() * horFittingLocations.length)];
    
            	placementData.tileAnchor = baseIndex;// + Math.floor((shipLength-1)/2);
        		placementData.case = 'D';
        		placementData.shipLength = shipLength;
                placementData.vertical = false;

                for (var shipTile = 0; shipTile < shipLength; shipTile++) {
                    arrTiles[baseIndex + shipTile ] = shipID; 
                }
            }
            else {
            	console.log('cant place ship with id :: ', shipID);
            }
        }
    }



    var message = "";
    for (var i = 0; i < arrTiles.length; i++) {
        message += arrTiles[i] + " ";
        // message += RandomMap._getShipSize(arrTiles[i]) + " ";
        if (i % TileMapValues.COLS == TileMapValues.COLS - 1)
            message += "\n";
    }



    // console.log(placementCollection);
    console.log(message);
    
    return placementCollection;
};

RandomMap._shuffle = function(array) {
    var currentIndex = array.length, temporaryValue, randomIndex;
    while (0 !== currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    return array;
}

RandomMap._getShipSize = function(id) {
    switch (id) {
        case 1: return 5;
        case 2: return 4;
        case 3: return 3;
        case 4: return 3;
        case 5: return 2;
        default: return 0;
    }
}
//******************************************************
//*****    Script Resource: MiniTurnIndicator
//******************************************************

MiniTurnIndicator = function(userIsOnline) {

	this.container = new tbContainer();

    this.panel = s_overlay_waiting_for_opp_panel.clone();
    this.sweeper = s_overlay_waiting_for_opp_gradient.clone();
    this.avatar = s_overlay_waiting_for_opp_avatar.clone();
    this.onlineLight = s_overlay_waiting_for_opp_greenlight.clone();

    this.container.addChild(this.panel);
    this.panel.addChild(this.sweeper);
    this.panel.addChild(this.avatar);
    this.panel.addChild(this.onlineLight);

    this._valueIn = -this.panel.width + 75;
    this._valueOut = 0;
    this.panel.setPosition(-this.panel.width, 105);
    this.avatar.setPosition(42, 43);
    this.sweeper.setPosition(42, 42);
    this.onlineLight.setPosition(0, 72);
    this.onlineLight.setAlpha(userIsOnline ? 1 : 0);

    this.onlineLight.isTransitioning = false;
    this.onlineLight.transitionTimer = 0;
    this.onlineLight.alphaAfterTransition = 1.0;
    this.sweeper.targetAlpha = 0;

    tgfGraphics.addChild(this.container.container, 'miniturnind.container');

	this._animator = new tbAnimator(this.panel.sprite);
	this._animatorXTrack = this._animator.addTrack('x');


	this.container.setAlpha(0);

 	// track, time, value, easing, easingModifierValue
	this._animator.addKey(this._animatorXTrack, 0, this._valueOut);
	this._animator.updateTime(0);
	this._animator.pause();
}

MiniTurnIndicator.prototype.constructor = MiniTurnIndicator;

MiniTurnIndicator.prototype._toggle = function() {

	if (this._showing) {
		this.hide();
	}
	else {
		this.show();
	}
}

MiniTurnIndicator.prototype.addAvatar = function(isBotBattle) {

	// console.log('mini-avatar');

	this._isBotBattle = isBotBattle;

	if (this._isBotBattle && this.onlineLight) {
		this.onlineLight.isTransitioning = true;
		this.onlineLight.transitionTimer = 1000;
		this.onlineLight.alphaAfterTransition = 1.0;
	}


	var self = this;
	// add avatar
	this._onAvatarReady = function(res) {

		if (res) {

			// console.log('mini-av-res', res);

			res.setPosition(2, 2);
			if (self.avatar) {

				// console.log('mini-av-avatar', self.avatar);
				self.avatar.addChild( res );
			}
		}
	};

	// avatar fetcher

	var photoURL;
	var avatarWidth = 62;
	var avatarHeight = 62;

	var opponentData = UserDataController.getMatchData().getOpponentData(UserDataController.getData().id);
	photoURL = opponentData.photo;
	// console.log('mini-av', photoURL);

	if (photoURL.indexOf('http') >= 0) {

		// console.log('mini-av-adding avatar');

		this._opponentId = opponentData.id;

		var cachedStatus = OpponentOnlineManager.getOpponentCache( this._opponentId );
		this.onStatusChange(cachedStatus);

		OpponentOnlineManager.addListener(this, this.onStatusChange.bind(this));


		this._usingPendingAvatar = false;
		var res = AvatarFetcher.getOpponentImage(avatarWidth, avatarHeight);
		this._onAvatarReady(res)
		// AvatarFetcher.loadAvatar(photoURL, this._onAvatarReady, avatarWidth, avatarHeight, 0, 0);
	}
	else if (this._isBotBattle) {

		// console.log('mini-av-adding bot image');

		var pendingImage = AvatarFetcher.getOpponentImage(avatarWidth, avatarHeight);
		pendingImage.setPosition(4, 4);
		this.avatar.addChild( pendingImage );
	}
	else {

		// console.log('mini-av-adding pending image');
		this._usingPendingAvatar = true;
	}
}

MiniTurnIndicator.prototype.show = function() {

	if (this._showing) return;

	if (this._usingPendingAvatar) {
		this.addAvatar(this._isBotBattle);
	}

	console.log('show');

	this.container.setAlpha(1);

	this._showing = true;

	this._animator.pause();
	this._animator.removeAllKeys();

	this._animator.addKey(this._animatorXTrack, 0,      this.panel.sprite.x);
	this._animator.addKey(this._animatorXTrack, 500,    this.panel.sprite.x, tbEase.easeOutOvershoot, .25);
	this._animator.addKey(this._animatorXTrack, 850,    this._valueIn);

	this._animator.setTime(0);

	this._animator.resumeForced();

	tgfAudio.play(a_popup_show);
}

MiniTurnIndicator.prototype.hide = function() {

	// if (!this._showing) return;
	// console.log('hide');

	// // return;

	// this._showing = false;

	// this._animator.pause();
	// this._animator.removeAllKeys();

	// this._animator.addKey(this._animatorXTrack, 0,      this.panel.sprite.x, tbEase.easeInOvershoot, .25);
	// this._animator.addKey(this._animatorXTrack, 250,    this._valueOut);

	// this._animator.setTime(0);

	// this._animator.resumeForced();

	// tgfAudio.play(a_popup_show);
}

MiniTurnIndicator.prototype.update = function(timePassed) {

	var xTo = 1366/2 + tgfGraphics.visibleWidth/2;//((1366/2) * tgfGraphics.ratio);
   	this.container.setPosition(xTo, 0);

    this._animator.updateTime(timePassed);
    this.sweeper.setRotation(this.sweeper.rotation + timePassed / 1000);

    if(this.onlineLight.isTransitioning) {
        this.onlineLight.transitionTimer -= timePassed;
        this.onlineLight.isTransitioning = this.onlineLight.transitionTimer > 0;

        if (this.onlineLight.isTransitioning == false) {
            this.onlineLight.transitionTimer = 0;
            this.onlineLight.setAlpha(this.onlineLight.alphaAfterTransition);
            return;
        }

        this.onlineLight.setAlpha(this.onlineLight.alpha + (Math.random() * 0.5) - 0.25);
    }

    // Fade the sweeper to the target alpha
    this.sweeper.setAlpha(this.sweeper.alpha + ((this.sweeper.targetAlpha - this.sweeper.alpha) * 2 * timePassed * 0.001));
}

MiniTurnIndicator.prototype.setWaitingMode = function(boolValue) {

	this.sweeper.targetAlpha = boolValue == true ? 1 : 0;

	if (this._usingPendingAvatar) {
		this.addAvatar(this._isBotBattle);
	}
}

MiniTurnIndicator.prototype.remove = function() {

	// console.log('MiniTurnIndicator:remove');

	if (this._onAvatarReady) {

		this._onAvatarReady = null;
	}

	if (this.container && this.container.container) {

		tgfGraphics.removeChild(this.container.container);

		this.container.container.destroy({children: true});
		this.container.container = null;
	}

}

MiniTurnIndicator.prototype.onStatusChange = function (status) {

	// console.log('OOMSC::', status);

	if (this._opponentId && status && (status.userId == this._opponentId) ) {
		var match = UserDataController.getCurrentMatchId()
		this.onlineLight.isTransitioning = true;
		this.onlineLight.transitionTimer = 1000;
		this.onlineLight.alphaAfterTransition = status.online && match === status.currentMatchId ? 1.0 : 0.0;
	}
}

//******************************************************
//*****    Script Resource: TurnController
//******************************************************

var TurnController = (function() {

	var _TurnController = function() {

		this._TURN_STATES = {
			PLACEMENT : 1,
			INITIALIZING: 5,
			RECONNECTING_TRO: 7,
			WAITING: 10,
			FEEDBACK_READY: 20,
			FEEDBACK_SHOWING: 30,
			TURN_START: 60,
			FIRE1: 70,
			FIRE2: 80,
			FIRE3: 90,
			FIRE_X_POPUP: 91,
			FIRE_X_SHOT: 92,
			TURN_OVER_BEFORE: 99,
			TURN_OVER: 100,
			GAME_ENDED: 200,
			BROKEN: 999
		};

		this._turnFlow = [
			this._TURN_STATES.INITIALIZING,
			this._TURN_STATES.WAITING,
			this._TURN_STATES.FEEDBACK_READY,
			this._TURN_STATES.FEEDBACK_SHOWING,
			this._TURN_STATES.TURN_START,
			this._TURN_STATES.FIRE1,
			this._TURN_STATES.FIRE2,
			this._TURN_STATES.FIRE3,
			this._TURN_STATES.FIRE_X_POPUP,
			this._TURN_STATES.FIRE_X_SHOT,
			this._TURN_STATES.TURN_OVER
		]

		this._debug = false;

		this._listeners = [];

		this.TURN_STATES = this._TURN_STATES;

		this.reset();
	}


	_TurnController.prototype.constructor = _TurnController;


	_TurnController.prototype.reset = function() {

		// only reset when ending game (playController)
		this._state = 0;
	}

	_TurnController.prototype.initialize = function(matchData) {

		this.reset();
		
		if (this._isMyTurn() ) {

			var initState = matchData.playerState;

			switch (initState) {

				case this._TURN_STATES.FEEDBACK_READY: 
				case this._TURN_STATES.FIRE1: 
				case this._TURN_STATES.FIRE2: 
				case this._TURN_STATES.FIRE3:
				case this._TURN_STATES.FIRE_X_SHOT:
				{
					initState = matchData.playerState;
					break;
				};
				case this._TURN_STATES.FIRE_X_POPUP: {

					// SCARY IFFY --> awardsAds supported? proceed! no? end turn
					if (AdManager.supportsRewarded()) {
						
						initState = matchData.playerState;
					} 
					// also do nothing for now
					else {

						initState = matchData.playerState;
						// initState = this._TURN_STATES.TURN_OVER;
					}
					break;
				};
				case this._TURN_STATES.TURN_OVER:
				{
					initState = this._TURN_STATES.FEEDBACK_READY;
					if (matchData.playerTurn == 1) initState = this._TURN_STATES.TURN_START;
					break;
				};
				default : {
					initState = this._TURN_STATES.FEEDBACK_READY;
					if (matchData.playerTurn == 1) initState = this._TURN_STATES.TURN_START;
					break;
				};
			} 

			this._updateState(initState);
		}
		else {
			
			this._updateState(this._TURN_STATES.WAITING);
		}
	}


	_TurnController.prototype.advanceFrom = function(state) {

		var stateIndex = this._turnFlow.indexOf(state);

		var next = this._turnFlow[(stateIndex+1)];

		this._updateState(next);
	}

	_TurnController.prototype.advanceTo = function(state) {

		this._updateState(state);
	}

	_TurnController.prototype.advance = function() {

		if (this._debug) console.log('TC::TurnController.advance?state=', this._state);
		
		// still initializing
		if (this._state == this._TURN_STATES.INITIALIZING) {
			return;
		}

		// game ended
		if (this._state == this._TURN_STATES.GAME_ENDED) {
			return;
		}

		// I am waiting
		if (this._state == this._TURN_STATES.WAITING) {

			// not my turn? return
			if (this._isMyTurn() == false) {
				return;
			}
		}


		// turn over - set to waiting
		if (this._state == this._TURN_STATES.TURN_OVER) {
			
			this._updateState(this._TURN_STATES.WAITING);
			return;
		}
		// advance normally
		else {

			var stateIndex = this._turnFlow.indexOf(this._state);

			var next = this._turnFlow[(stateIndex+1)];
		}

		this._updateState(next);
	}

	
	_TurnController.prototype.advanceEndGame = function() {

		this._updateState(this._TURN_STATES.GAME_ENDED);
	}


	_TurnController.prototype.getState = function() {
		return this._state;
	}

	_TurnController.prototype.addTurnListener = function(listener, scope) {

		// console.log('TC::TC - addTurnListener', listener);

		for (var i = 0; i < this._listeners.length; i++) {

			if (this._listeners[i].scope == scope && this._listeners[i].listener == listener ) {
				// console.log('TC::TRO::listener already present');
				return;
			}
		}

		this._listeners.push({listener: listener, scope: scope});

		// console.log('TC::TRO::TC.addTurnListener', listener, scope);
		if (this._debug) {

			// console.log('TC::TRO::TC.listeners.length', this._listeners.length);
		}

		var md = UserDataController.getMatchData();

		// trigger added listener once - friend matches only
		if (md) {

			if (md.isTimed == true) {

				// dont' do anything!!
			}
			else {

				listener.call(scope, this._state);
			}
		}
	}

	_TurnController.prototype.removeTurnListener = function(listener, scope) {

		if (!this._listeners) return;

		var index = -1;
		for (var i = 0; i < this._listeners.length; i++) {
			if (this._listeners[i].scope == scope && this._listeners[i].listener == listener )
			{
				index = i;
				break;
			}
		}

		if (index >= 0) {

			// console.log('TC::TC.removeTurnListener at index', index);
			this._listeners.splice(index, 1);
		}
	},
	
	_TurnController.prototype.clearListeners = function() {

		this._listeners = [];

	},

	_TurnController.prototype._isMyTurn = function() {

		var id = UserDataController.getField('id');
		var md = UserDataController.getMatchData();

		// console.log(mTC::d);
	
		if (md && md.getCurrentPlayer() == id) {

			// console.log('TC::TC - TC -> its my turn!');
			return true;
		}
		else {

			// console.log('TC::TC - TC -> its not my turn!');
			return false;
		}
	}


	_TurnController.prototype._updateState = function(state) {

		if (this._state == state) {
			console.warn('TC::TurnController._updateState::setting state to same state ? new:: ' + state + 'current:: ' + this._state);
			return;
		}

		if (this._state == this._TURN_STATES.GAME_ENDED) {
			console.warn('TC::TurnController.cant update to' + state + '::game ended');
			return;
		}

		console.log('TC::TurnController._updateState from => ', this._state, 'to =>', state);

		if (state < this._state) {
			
			console.log('TC::TurnController._updateState => going back in time? Did my turn end?');

			if (state != this._TURN_STATES.WAITING) {
				
				console.log('TC::TurnController._updateState != WAIT, so skipping');
				return;
			}
		}

		this._state = state;

		var md = UserDataController.getMatchData();
		var bd = UserDataController.getBattleData();

		if (!md) {

			console.warn('TC::TurnController._updateState::no match found -> returning');
			return;
		}

		md.playerState = this._state;
		
		switch (this._state) {
			
			case this._TURN_STATES.PLACEMENT : {
				if (this._debug)
				console.log('TC::TC - i am placing my ships');
				break;
			};
			case this._TURN_STATES.INITIALIZING : {

				if (this._debug)
				console.log('TC::TC - i am still initializing');
				break;
			};
			case this._TURN_STATES.WAITING : {

				if (this._debug)
				console.log('TC::TC - i am waiting for my opponent');
				break;
			};
			case this._TURN_STATES.FEEDBACK_READY : {

				BattleshipsAnalytics.reportStartedTurn();
				if (this._debug)
				console.log('TC::TC - i am ready to watch my opponent feedback');
				break;
			};
			case this._TURN_STATES.FEEDBACK_SHOWING : {

				BattleshipsAnalytics.reportStartedTurn();

				if (this._debug)
				console.log('TC::TC - i am watching my board being shot at');
				break;
			};
			case this._TURN_STATES.TURN_START : {

				BattleshipsAnalytics.reportStartedTurn();
				// save battle data -> add lastAction to board, clear lastAction + save board

				if (this._debug)
				console.log('TC::TC - i am starting my turn');
				break;
			};
			case this._TURN_STATES.FIRE1 : {

				BattleshipsAnalytics.reportStartedTurn();
				// save battle data -> add lastAction to board, clear lastAction + save board

				if (this._debug)
				console.log('TC::TC - i am shooting my first shot');
				break;
			};
			case this._TURN_STATES.FIRE2 : {

				BattleshipsAnalytics.reportStartedTurn();
				// save match + battle data (playerState + lastAction)

				if (this._debug)
				console.log('TC::TC - i am shooting my second shot');
				break;
			};
			case this._TURN_STATES.FIRE3 : {

				BattleshipsAnalytics.reportStartedTurn();
				// save match + battle data (playerState + lastAction)
				
				if (this._debug)
				console.log('TC::TC - i am shooting my third and last shot');
				break;
			};
			case this._TURN_STATES.FIRE_X_POPUP : {

				BattleshipsAnalytics.reportStartedTurn();

				if (UserDataController.getMatchData().isTimed) {

					this._updateState(this._TURN_STATES.TURN_OVER);
					return;
				}


				if (AdManager.supportsRewarded()) {
					// do nothing
				}
				else {
					// also do nothing for now
					// this._updateState(this._TURN_STATES.TURN_OVER);
					// return;
				}
 				
				if (this._debug)
				console.log('TC::TC - i am looking at an extra-shot popup');
				break;
			};
			case this._TURN_STATES.FIRE_X_SHOT : {

				BattleshipsAnalytics.reportStartedTurn();
				// save match + battle data (playerState + lastAction)
				
				if (this._debug)
				console.log('TC::TC - i am shooting my extra-shot now');
				break;
			};
			case this._TURN_STATES.TURN_OVER : {

				BattleshipsAnalytics.reportStartedTurn();
				// save match + battle data (playerState + lastAction) -> set to waiting

				// this._state = this._TURN_STATES.WAITING;
				BattleshipsAnalytics.reportEndedTurn();
				AnalyticsHelper.reportMatchTurn();
				
				if (this._debug)
					console.log('TC::TC - i am ending my turn');

				break;
			};
			case this._TURN_STATES.GAME_ENDED : {

				// save match + battle data (playerState + lastAction) -> set to waiting

				// this._state = this._TURN_STATES.WAITING;

				if (this._debug)
					console.log('TC::TC - game has ended');

				break;
			};
			default: {

				this._state = this._TURN_STATES.BROKEN;

				console.warn('TurnController.BROKEN --> please check');

				// if ( this._isMyTurn() ) this._updateState(this._TURN_STATES.FEEDBACK_READY);
				// else this._updateState(this._TURN_STATES.WAITING);
				
				return;
			};
		}

		this._dispatchTurnState();
	}


	_TurnController.prototype._dispatchTurnState = function() {

		if (this._debug) {
			console.log('TC::TRO::TC - dispatching to listners');
		}

		// if (!this._calledOnce) {
		// 	this._calledOnce = true;

		// 	console.log('TC.dispatching::', this._listeners.length, this._listeners);
		// }
		// else {
			
		// 	console.log('TC.dispatching::', this._listeners.length, this._listeners);
		// }

		for (var i = 0; i < this._listeners.length; i++) {

			if (this._debug) {

				console.log('	TC::TRO::TC - dispatching to listner', i);
			}

			
			this._listeners[i].listener.call(this._listeners[i].scope, this._state);
		}
	}


	return new _TurnController();
}());


//******************************************************
//*****    Script Resource: TurnIndicator
//******************************************************

var TurnIndicator = function(options) {

	this._direction = options.direction;

	this.container = new tbContainer();
	this.container.setPosition(tgfGraphics.areaWidth/2, 384);

	this._image = options.image.clone();
	this.container.addChild(this._image);




	this.container.add(options.parent);

	this._showing = false;

	var text = (this._direction == 1) ?
		tgfDictionary.getText("TurnIndicatorYourTurnTop") + ' ' + tgfDictionary.getText("TurnIndicatorYourTurnBottom") :
		tgfDictionary.getText(CaptainManager.getTurnText());
	if (options.turnText) {

		this._turnText = options.turnText;
		text = options.turnText;
	}

	var containerLabel = f_babas_regular.clone();

	containerLabel.setFontSize(options.fontSize ? options.fontSize : 56);
	containerLabel.setFillColor("#FFF");
	containerLabel.setPosition(140 * -this._direction, options.baseline ? -84 : -8);
	containerLabel.style.align = "center";

	if (this._direction == 1) {
		containerLabel.setAlign("right");
	}
	else {
		containerLabel.setAlign("left");
	}
	containerLabel.setFontStyle("normal");
	containerLabel.setBaseline(options.baseline ? options.baseline : "middle");
	containerLabel.setText(text);

	// Stay on screen by wordwrapping
	containerLabel.setWordWrap(true, 360);
	// containerLabel.setWordWrap(false);

	this._containerLabel = containerLabel;

	this.container.addChild(containerLabel);

	this.instructionLabelTimer = 0;
	this.instructionLabel = null;

	if(options.showInstruction) {
		var instructionLabel = f_babas_regular.clone();

		instructionLabel.setFontSize(32);
		instructionLabel.setFillColor("#FFF");
		instructionLabel.setPosition(135 * -this._direction, 24);
		instructionLabel.style.align = "center";

		if (this._direction == 1) {
			instructionLabel.setAlign("right");
		}
		else {
			instructionLabel.setAlign("left");
		}
		instructionLabel.setWordWrap(false);
		instructionLabel.setFontStyle("normal");
		instructionLabel.setBaseline("top");
		instructionLabel.setText(tgfDictionary.getText("TurnIndicatorTapToView"));

		this.instructionLabel = instructionLabel;
		this.container.addChild(instructionLabel);
	}

	// If we have an instruction label
	if (this.instructionLabel) {
		if (!this.instructionLabel.font.originalFontSize) {
			this.instructionLabel.originalFontSize = this.instructionLabel.font.style.fontSize;
		}

		// Reset font size
		this.instructionLabel.font.style.fontSize = this.instructionLabel.originalFontSize;
		this.instructionLabel.font.calculateBounds();

		// Make it the max size.
		while (this.instructionLabel.font.width > 300) {
			this.instructionLabel.font.style.fontSize--;
			this.instructionLabel.font.calculateBounds();
		}
	}

	if (!this._containerLabel.font.originalFontSize) {
		this._containerLabel.originalFontSize = this._containerLabel.style.fontSize;
	}

	// Reset font size
	this._containerLabel.font.style.fontSize = this._containerLabel.originalFontSize;
	this._containerLabel.font.calculateBounds();

	// Fit label text
	this._fitLabelText();


	this._animator = new tbAnimator(this.container.container);
	this._animatorXTrack = this._animator.addTrack('x');

	this._valueOut = -(tgfGraphics.areaWidth/4 * 3) * this._direction;
	// this._valueIn = 90 * this._direction;
	this._valueIn = 150 * this._direction;

	// track, time, value, easing, easingModifierValue
	this._animator.addKey(this._animatorXTrack, 0, this._valueOut);
	this._animator.updateTime(0);
	this._animator.pause();
}


TurnIndicator.prototype.constructor = TurnIndicator;



TurnIndicator.prototype.addAvatar = function(isBotBattle) {
	// console.log('normal-avatar', this._direction);

	this._isBotBattle = true;

	// add avatar
	var self = this;
	this._onAvatarReady = function(res) {

		if (res) {

			res.setPosition(-parseInt(avatarWidth/2), -parseInt(avatarHeight/2) -11 );

			if (self.container && self.container.container) {

				self.container.addChild( res );
			}
		}
	};

	// avatar fetcher
	var photoURL;
	var avatarWidth = 200;
	var avatarHeight = 200;

	// console.log('adding bot image');
	var pendingImage;

	if (this._direction == 1) {
		pendingImage = AvatarFetcher.getPlayerImage(avatarWidth, avatarHeight);
	} else {
		pendingImage = AvatarFetcher.getOpponentImage(avatarWidth, avatarHeight);
	}

	pendingImage.setPosition(-parseInt(avatarWidth/2), -parseInt(avatarHeight/2) - 11);
	this.container.addChild( pendingImage );

}

TurnIndicator.prototype._fitLabelText = function() {

	var maxW = 360;
	var maxH = 94;

	this._containerLabel.font.style.fontSize = this._containerLabel.originalFontSize;
	this._containerLabel.font.calculateBounds();

	// setTimeout(function() {

		this._containerLabel.setWordWrap(false);

		this._initialWidth = this._containerLabel.font.width;
		this._initialLines = Math.ceil(this._initialWidth / maxW);

		this._containerLabel.setWordWrap(true, Math.ceil(this._initialWidth / this._initialLines));

		function shrink() {

			// if (this._containerLabel.font.width > maxW) {
			while (this._containerLabel.font.height > maxH) {

				this._containerLabel.font.style.fontSize--;
				this._containerLabel.fontSize = this._containerLabel.font.style.fontSize;
				this._containerLabel.font.calculateBounds();


				// setTimeout(shrink.bind(this), 500);
			}
			// else {

				var lines = this._containerLabel.lineInfo().lines.length;

				this._containerLabel.setWordWrap(false);

				var wrap = (this._containerLabel.font.width / lines);

				this._containerLabel.setWordWrap(true, wrap);

				while (this._containerLabel.lineInfo().lines.length > lines) {

					wrap += 1;
					this._containerLabel.setWordWrap(true, wrap);
				}
			// }
		}

		// shrink.bind(this);
		setTimeout(shrink.bind(this), 0);

	// }.bind(this), 0);

}


TurnIndicator.prototype.show = function(waitForInteraction) {

	console.log("TurnIndicator::Show", waitForInteraction, this._showing);

	var self = this;

	if (this._showing) return;
	this._showing = true;

	if (this._usingPendingAvatar) {
		this.addAvatar(this._isBotBattle);
	}

	if (this._turnText && UserDataController.getMatchData().players.length >= 2) {
		var md = UserDataController.getMatchData();
		var opponentName = md.getOpponentData(UserDataController.getData().id).name;

		var text = tgfDictionary.getText("TurnIndicatorUserHasFiredTop") + ' ' + tgfDictionary.getText("TurnIndicatorUserHasFiredBottom");

		if (text != this._containerLabel.text) {

			this._containerLabel.setText(text.replace("{username}", opponentName));

			this._fitLabelText();
		}

		tgfAudio.play(a_on_opp_turn);
	}
	else {
		tgfAudio.play(a_popup_show);
	}


	this._animator.pause();
	this._animator.removeAllKeys();

	this._animator.addKey(this._animatorXTrack, 0, this.container.container.x);
	this._animator.addKey(this._animatorXTrack, 250, this.container.container.x, tbEase.easeOutOvershoot, 1);
	this._animator.addKey(this._animatorXTrack, 550, this._valueIn);

	if (!waitForInteraction) {

		this._animator.addKey(this._animatorXTrack, 1450, this._valueIn, tbEase.easeInOvershoot, 1);
		this._animator.addKey(this._animatorXTrack, 1700, this._valueOut);
	}


	if (this._direction == -1 && !this._isBotBattle) {
		var uid = UserDataController.getData().id;
		var md = UserDataController.getMatchData();
		var oid = md.getOpponentData(uid).id;

		console.log("OOM::oid ->", oid);
		if (oid) {
		}
		else {

			this._animator.setTime(0);
			this._animator.resumeForced();
		}
	}
	else {

		this._animator.setTime(0);
		this._animator.resumeForced();
	}
}

TurnIndicator.prototype._handleOpponentID = function(oid) {
	var self = this;

	if (UserDataController.isTimedMatch()) {
		return;
	}

	var _handlePopupClose = function(oid) {
		OpponentOnlineManager.getOpponentOnline(oid, function(status) {
			console.log("OOM::opponentOnline -> ", status);

			if (status && status.online && status.currentMatchId === UserDataController.getCurrentMatchId()) {

				console.log('TI::EOT::getOO-online -> proceed normally');

				self._animator.setTime(0);
				self._animator.resumeForced();
			}
			else {

				console.log('TI::EOT::getOO-online -> show-EOT');

				if (self.instructionLabel) {

					self._animator.setTime(0);
					self._animator.resumeForced();
				}
			}

			tbGame.addSpecial('opponent-status', status);
		});
	}

	if (TurnController.getState() === TurnController._TURN_STATES.WAITING) {
		this.endOfTurnPopup = new tgfDialogs.BattleshipEndOfTurnPopup({
			x: 0,
			y: 0,
			width: 640,
			height: 520
		});
		this.endOfTurnPopup.show();

		this.endOfTurnPopup.setOnHiddenCallback(_handlePopupClose.bind(this, oid));

		return;
	}

	_handlePopupClose(oid);
};

TurnIndicator.prototype.hide = function() {

	if (this._showing) {
		tgfAudio.play(a_popup_show);
	}
	this._showing = false;

	this._animator.pause();
	this._animator.removeAllKeys();

	this._animator.addKey(this._animatorXTrack, 0, this.container.container.x, tbEase.easeInOvershoot, 1);
	this._animator.addKey(this._animatorXTrack, 300, this._valueOut);

	this._animator.setTime(0);

	this._animator.resumeForced();
}

TurnIndicator.prototype.update = function(timePassed) {

	this._animator.updateTime(timePassed);

	if (this.instructionLabel) {
		this.instructionLabelTimer += timePassed * 0.005;

		alpha = Math.sin(this.instructionLabelTimer) + 1;
		this.instructionLabel.setAlpha(0.5 + alpha * 0.25);
	}
	// console.log();
}

TurnIndicator.prototype.remove = function() {
	// console.log('TurnIndicator:remove');

	if (this._onAvatarReady) {

		this._onAvatarReady = null;
	}

	// if (this._animator) {

	// 	this._animator = null;
	// }
}

//******************************************************
//*****    Script Resource: TurnIndicatorController
//******************************************************

var TurnIndicatorController = function() {

	this.container = new tbContainer();
	this.container.setPosition(tgfGraphics.areaWidth/2, 0);

	this._indicators = [];

	// player turn indicator
	var indicatorOptions = {
		parent: this.container,
		image: s_overlay_turnindicator_player,
		direction: 1
	};

	this._indicators.push(new TurnIndicator(indicatorOptions) );


	// opponent turn indicator
	indicatorOptions.direction = -1;
	indicatorOptions.image = s_overlay_turnindicator_opponent;

	this._indicators.push(new TurnIndicator(indicatorOptions) );

	this._miniIndicator = new MiniTurnIndicator();
	// turn ready indicator
	indicatorOptions.direction = -1;
	indicatorOptions.image = s_overlay_turnindicator_opponent;
	indicatorOptions.turnText = 'OPPONENT FIRED AT YOUR SHIPS!';
	indicatorOptions.fontSize = 42;
	indicatorOptions.baseline = 'top';
	indicatorOptions.showInstruction = true;

	this._indicators.push( new TurnIndicator(indicatorOptions) );


	var opponentDoneIndicator = tbGraphics.drawRectangle(-tgfGraphics.areaWidth/2,0,tgfGraphics.areaWidth, tgfGraphics.areaHeight, 0x00ff00, null, null, 0.00000000001);//this._indicators[2];
	opponentDoneIndicator.on('pointertap', function() {

		// console.log('player indicator tapped');

		this.interactive = false;
		this.buttonMode = false;

		console.log('OPPONENT DONE, STATE', TurnController.getState());

		TurnController.advanceFrom(TurnController._TURN_STATES.FEEDBACK_READY);
	})
	this._opponentDoneIndicator = opponentDoneIndicator;
	this.container.addChild(this._opponentDoneIndicator);


	TurnController.addTurnListener(this.onTurnUpdate, this);
}

TurnIndicatorController.prototype.constructor = TurnIndicatorController;


TurnIndicatorController.prototype.initAvatars = function(isBotBattle) {

	this._isBotBattle = isBotBattle;

	for (var i = 0; i < this._indicators.length; i++) {
		this._indicators[i].addAvatar(this._isBotBattle);
	}

	this._miniIndicator.addAvatar(this._isBotBattle);
}


TurnIndicatorController.prototype.onTurnUpdate = function(state) {

	var md = UserDataController.getMatchData();


	var that = this;

	if (this._timeoutWaitingMini) {
		clearTimeout(this._timeoutWaitingMini);
		this._timeoutWaitingMini = null;
	}

	switch (state) {
		case TurnController._TURN_STATES.WAITING : {

			console.log('ADS:interstitial->waiting');

			var showWaitingState = function() {

				console.log('EOT::showWaitingState');


				// that._handleEndOfTurn();


				// THEIR TURN
				that.updatePlayer(1);
				that._miniIndicator.hide();

				// SET TO WAITING MODE
				that._timeoutWaitingMini = setTimeout(function() {
					console.log('show now');
					that._miniIndicator.show();
					that._miniIndicator.setWaitingMode(true);
				}, 2000);
			}

			// TODO: After the interstitial, the EndOfTurnPopup should show. That is now done in the PlayController
			// Also, only after the EndOfTurnPopup the opponent indicator should show if the opponent is online, otherwise it should go to the NextBattlePopup

			console.log('EOT::afterInterstitial');

			state = TurnController.getState();

			// IT IS MY TURN ALREADY -> SKIP END OF TURN POPUP
			if (state == TurnController._TURN_STATES.FEEDBACK_READY) {

				console.log('EOT::afterInterstitial - if');

				var playerIndicator = that._opponentDoneIndicator;
				playerIndicator.interactive = true;
				playerIndicator.buttonMode = true;

				that.updatePlayer(2, true);
				that._miniIndicator.hide();
			}
			// START END OF TURN FLOW
			else {

				console.log('EOT::afterInterstitial - else');
				showWaitingState();
			}

			break;
		};
		case TurnController._TURN_STATES.FEEDBACK_READY : {
			console.warn("Turn indicator should never be here.")
			break;
			console.log("EOT::updatePlayer testing")
			// make button clickable once
			var playerIndicator = this._opponentDoneIndicator;
			playerIndicator.interactive = true;
			playerIndicator.buttonMode = true;

			this.updatePlayer(2, true);
			this._miniIndicator.hide();

			break;
		};
		case TurnController._TURN_STATES.TURN_START : {

			this.updatePlayer(0);
			this._miniIndicator.hide();

			break;
		};
		case TurnController._TURN_STATES.FIRE1 : {

			this._miniIndicator.setWaitingMode(false);
			this._miniIndicator.show();
			break;
		};
		case TurnController._TURN_STATES.GAME_ENDED : {

			if (this._miniIndicator) {

				this._gameEnded = true;
				this._miniIndicator.hide();
			}

			break;
		};
		default : {

			this.updatePlayer(-1);
			this._miniIndicator.setWaitingMode(false);
			this._miniIndicator.show();
			break;
		}
	}
}

TurnIndicatorController.prototype._handleEndOfTurn = function() {

}

TurnIndicatorController.prototype.update = function(timePassed) {

	for (var i = 0; i < this._indicators.length; i++) {
		this._indicators[i].update(timePassed);
	}

	this._miniIndicator.update(timePassed);
}


TurnIndicatorController.prototype.updatePlayer = function(passedPlayerIndex, needsClick) {


	var currentPlayerIndex = passedPlayerIndex;
	if (!needsClick) needsClick = false;

	console.log('EOT::updatePlayer - ', currentPlayerIndex, needsClick);

	for (var i = 0; i < this._indicators.length; i++) {

		if (i == currentPlayerIndex) {

			if (currentPlayerIndex == 2 && UserDataController.getMatchData().isTimed == true) {

				var playerIndicator = this._opponentDoneIndicator;
				playerIndicator.interactive = false;
				playerIndicator.buttonMode = false;
				console.log("test")
				TurnController.advanceFrom(TurnController._TURN_STATES.FEEDBACK_READY);
			}
			else {

				this._indicators[i].show(needsClick);
			}
		}
		else {
			this._indicators[i].hide(needsClick);
		}
	}
}


TurnIndicatorController.prototype.hasOpponentAvatar = function() {

	var hasAvatar = false;

	var md = UserDataController.getMatchData();
	var opponentData = md.getOpponentData(UserDataController.getData().id);
	if (md && opponentData ) {

		if (this._isBotBattle || opponentData.photo != '[DEFAULT]') {
			// this._miniIndicator.show();
			hasAvatar = true;
		}
	}

	return hasAvatar;
}

TurnIndicatorController.prototype.remove = function() {

	// console.log('TurnIndicatorController:remove');

	if (this._timeoutWaitingMini) {
		clearTimeout(this._timeoutWaitingMini);
		this._timeoutWaitingMini = null;
	}

	for (var i = 0; i < this._indicators.length; i++) {

		this._indicators[i].remove();
	}
	this._indicators = null;

	this._miniIndicator.remove();
	this._miniIndicator = null;
}

//******************************************************
//*****    Script Resource: TileMap
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var TileMap = function(options) {

	this.tileImage = options.tileImage;

	this._rows = options.rows || TileMapValues.ROWS;
	this._cols = options.cols || TileMapValues.COLS;
	this._tiles = [];
	this._map = [];


	this._dataMode = options.dataMode || false;

	this._TILE_WIDTH = options.tileWidth || TileMapValues.WIDTH;
	this._TILE_HEIGHT = options.tileHeight || TileMapValues.HEIGHT;
	

	this.width = this._rows * this._TILE_WIDTH;
	this.height = this._cols * this._TILE_HEIGHT;


	this._tileContainer = new tbContainer();

	for (var i = 0; i < this._cols; i++) {
		
		for (var j = 0; j < this._rows; j++) {

			if (!this._dataMode) {
				// dont draw crap
				var tile = this.tileImage.clone();
				// var tile = s_pla_tile_board.clone();
				tile.x = tile.sprite.x = j * this._TILE_WIDTH;// + 2;
				tile.y = tile.sprite.y = i * this._TILE_HEIGHT;// + 2;
				tile.struck = false;

				this._tileContainer.addChild(tile);

				this._tiles.push(tile);
			}

			this._map.push(0);
		}
	}
}


TileMap.prototype.getContainer = function() {
	return this._tileContainer;
}

TileMap.prototype.setMap = function(map) {
	this._map = map;
}

TileMap.prototype.getMap = function() {
	return this._map;
}

TileMap.prototype.getTileImages = function() {
	return this._tiles;
}

TileMap.prototype.getRows = function(){
	return this._rows;
}

TileMap.prototype.getColumns = function(){
	return this._cols;
}

TileMap.prototype.getTileDimension = function(){
	return { 
		width: this._TILE_WIDTH, 
		height: this._TILE_HEIGHT 
	};
}

TileMap.prototype.toStringMap = function(anchor) {
	
	anchor = anchor || '';

	console.log('MAP ->', anchor);

	for (var i = 0; i < this._cols; i++) {
		
		var s = i + ' - ';

		for (var j = 0; j < this._rows; j++) {

			if (j > 0) s += ','
			s += this._map[(i * this._cols) + j];
		}

		console.log(s);
	}
}

TileMap.prototype.getTile = function(x, y) {

	var tileData = {};

	tileData.tx = Math.floor((x - this._tileContainer.container.x) / this._TILE_WIDTH);
	tileData.ty = Math.floor((y - this._tileContainer.container.y) / this._TILE_HEIGHT);

	tileData.index = tileData.ty * this._rows + tileData.tx;
	tileData.value = -1;


	if (this.validateTile(tileData)) {
		tileData.value = this._map[tileData.index];
	}
	else {
		tileData.invalid = true;
		tileData.index = -1;
	}

	return tileData;
}

TileMap.prototype.getTileShifted = function(tileData, shiftX, shiftY) {

	console.log(tileData.tx);

	tileData.tx += shiftX;
	tileData.ty += shiftY;

	tileData.index = tileData.ty * this._rows + tileData.tx;
	tileData.value = this._map[tileData.index];

	console.log(tileData.index);

	return tileData;	
}

TileMap.prototype.getTileByIndex = function(index) {

	var tileData = {};

	tileData.ty = Math.floor(index / this._rows);
	tileData.tx = Math.round(index - (tileData.ty * this._rows));

	tileData.index = index;
	tileData.value = this._map[index];

	return tileData;
}

TileMap.prototype.validateTile = function(tileData) {

	var tx = tileData.tx;
	var ty = tileData.ty;
	var tileIndex = tileData.index;

	// valid tile?
	if (tx < 0 || tx >= this._rows || tileIndex < 0 || tileIndex >= this._map.length) {
		
		return false;
	}
	else {
		
		return true;
	}
}



TileMap.prototype.allocateTiles = function(tileDataArray, value) {

	for (var i = 0; i < tileDataArray.length; i++) {
		this.allocateTile(tileDataArray[i], value)
	}
}

TileMap.prototype.allocateTile = function(tileData, value) {

	if (this._map[tileData.index] == 0) {

		this._map[tileData.index] = value;
	}
}

TileMap.prototype.strikeTileByIndex = function(index) {

	var currentValue = this._map[index];

	if (currentValue >= 9) return;

	switch (currentValue) {
		case 0: {

			this._map[index] = 9;
			break;
		};
		default: {
			// add 10 to current value
			currentValue += 10;

			if (currentValue >= 19) {
				console.warn('TileMap.strikeTileByIndex -> Setting a tile higher then possible?', index, currentValue);
			}
			else {

				this._map[index] = currentValue;
			}
			break;
		};
	}
}

TileMap.prototype.getStruck = function(index) {
	return (this._map[index] >= 10);
}

TileMap.prototype.getShotAt = function(index) {
	return (this._map[index] >= 9);
}


TileMap.prototype.freeTiles = function(tileDataArray, value) {

	for (var i = 0; i < tileDataArray.length; i++) {
		this.freeTile(tileDataArray[i], value)
	}
}

TileMap.prototype.freeTile = function(tileData, value) {

	if (this._map[tileData.index]) {

		if (this._map[tileData.index] == value) {

			this._map[tileData.index] = 0;
		}
	}
}


TileMap.prototype.getResult = function() {

	var len = this._map.length;
	var map = this._map;

	var result = {};
	result.shots = 0;
	result.hits = 0;
	result.misses = 0;
	result.ships = {};
	result.ships['11'] = 0;
	result.ships['12'] = 0;
	result.ships['13'] = 0;
	result.ships['14'] = 0;
	result.ships['15'] = 0;

	result.ships.destroyed = [];



	var value = null;

	// count stats
	for (var i = 0; i < len; i++) {

		value = map[i];

		// miss
		if (value == 9) {
			result.shots++;
			result.misses++;
		} 
		// hit
		else if (value >= 10) {
		
			if (result.ships[String(value)] != null) {

				console.log('RESULT.hit ship with value', value);

				result.ships[String(value)]++;
			}

			result.shots++;
			result.hits++;
		}
		else {
			// empty for now
		}
	}

	if (this.getShipDestroyed(11, result.ships['11']) ) result.ships.destroyed.push(11);
	if (this.getShipDestroyed(12, result.ships['12']) ) result.ships.destroyed.push(12);
	if (this.getShipDestroyed(13, result.ships['13']) ) result.ships.destroyed.push(13);
	if (this.getShipDestroyed(14, result.ships['14']) ) result.ships.destroyed.push(14);
	if (this.getShipDestroyed(15, result.ships['15']) ) result.ships.destroyed.push(15);

	console.log('RESULT', result);

	return result;
}

TileMap.prototype.getShipDestroyed = function(value, shipHits) {

	var shipType = ShipUtils.getTypeByTileValue(value);
	var shipSize = ShipUtils.getSize(shipType);

	return (shipHits >= shipSize);
}

TileMap.prototype.getShipHits = function(id) {

	if (id > 10) id -= 10;

	var len = this._map.length;
	var map = this._map;

	var hits = 0;
	var value = null;

	// count stats
	for (var i = 0; i < len; i++) {
		if (map[i] == 10 + id) {
			hits++;
		}
	}

	return hits;
}
//******************************************************
//*****    Script Resource: TileMapValues
//******************************************************

var TileMapValues = {
	ROWS: 0,
	MAX_ROWS: 0,
	COLS: 0,
	MAX_COLS: 0,
	WIDTH: 0,
	HEIGHT: 0,

	reset: function() {
		this.ROWS = tgfSettings.tileMapValues.ROWS
		this.MAX_ROWS = tgfSettings.tileMapValues.MAX_ROWS
		this.COLS = tgfSettings.tileMapValues.COLS
		this.MAX_COLS = tgfSettings.tileMapValues.MAX_COLS
		this.WIDTH = tgfSettings.tileMapValues.WIDTH
		this.HEIGHT = tgfSettings.tileMapValues.HEIGHT
	}
}

//******************************************************
//*****    Token Resource: FireUnit
//******************************************************

// ***************************************
// Definition of game token FireUnit
// ***************************************

// The constructor for the FireUnit game token.
var FireUnit = function(board, x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth;
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;
	this._board = board;
	this.hasWon = false;

	var self = this;
	this._board.tileDeselected = function(index) {

		// tile deselected - should be disabled
		// console.log('FireUnit.tileDeselected', index);
		self._tileIndex = null;

		self.buttonFire.disable();
	};

	this.enableButtonTimeout = null;
	this._board.tileSelected = function(index) {
		// tile selected

		// console.log('FireUnit.tileSelected', index);

		self._board.hideClickToFire();

		self._tileIndex = index;
		self.buttonFire.enable();
	};

	this.uiFireControl = new tgfDialogs.UiEmpty({
		x: 0,
		y: 0,
		width: tgfScale(tgfGraphics.areaWidth),
		backgroundImage: s_pla_fire_overlay
	});


	this.uiFireControl.height = s_pla_fire_overlay.height;


	this._specialWeaponButtonManager = null;

	this._animatorUIFire = new tbAnimator(this.uiFireControl.baseContainer.container);
	this._animatorUIFireTrackY = this._animatorUIFire.addTrack('y');
	this._animatorUIFire.addKey(this._animatorUIFireTrackY, 0, tgfScale(tgfGraphics.areaHeight) );
	this._animatorUIFire.updateTime(1);
	this._animatorUIFire.pause();

	//Shows the ui
	this.uiFireControl.show();


	this.lightHandler = new LightHandler(this.uiFireControl.baseContainer);

	this.onSpecialWeaponChange = function(specialWeapon) {
		this.buttonFire.setSpecialWeaponImage(specialWeapon);
	}.bind(this);
	this.buttonFire = new FireButton(s_pla_fire_overlay.width/2, s_pla_fire_overlay.height/2 - 55); // Applied offset
	this.uiFireControl.baseContainer.addChild(this.buttonFire.container.container);

	this.buttonFire.onFire = function(forcedSpecialWeapon) {

		// Check if it's allowed to fire based on the state of the turn
		if (!self.canFire(TurnController.getState())) {
			return false;
		}

		if (self._tileIndex === undefined) {
			self._tileIndex = 0;
		}

		// Get the selected special weapon
		var specialWeaponData = UserDataController.getSpecialWeaponData();
		var specialWeapon = specialWeaponData ? specialWeaponData.getSelectedSpecialWeapon() : null;
		if (forcedSpecialWeapon !== undefined) {
			specialWeapon = forcedSpecialWeapon;
		}
		var specialWeaponType = WeaponBase.SpecialWeapons.default;

		// Get the selected tile
		var tile = self._board.getTileMap().getTileByIndex(self._tileIndex);

		// Stores the tiles that are going to be shot
		var shotTiles = [{ x: tile.tx, y: tile.ty, index: tile.index }];

		if (specialWeapon !== null) {
			// Get all the tiles that are going to be shot by the special weapon
			shotTiles = specialWeapon.generateShotTiles(tile.tx, tile.ty);

			// Store the Special Weapon Type
			specialWeaponType = specialWeapon.weaponID;
		}

		// Stop the function if we already won the game
		var preHitResult = self._board.getTileMap().getResult();
		if (preHitResult.hits >= WinConditions.HITS_REQUIRED) {
			console.log('FireUnit -> cannot fire, GAME IS OVER!!');
			return false;
		}

		var canShoot = false;
		// Search for at least one tile that can be shot
		for (var i = 0; i < shotTiles.length; i++) {
			// If the value of the tile <= 9 it means it's a tile it can shoot at
			if (self._board.getTileMap().getTileByIndex(shotTiles[i].index).value <= 9) {
				// There is a tile that can be shot, stop searching

				canShoot = true;
				break;
			}
		}
		// Stop the function if can't shoot
		if (!canShoot) {
			console.log("FireUnit -> Cannot fire because it tries to shoot at tiles that are already shot");
			return false;
		}

		// Create an array for all the indices of the tiles
		var tileIndices = [];
		shotTiles.forEach(function(t) {
			tileIndices.push(t.index);
		});

		// Generate information of the shots for the BattleshipsAnalytics
		var shotInfo = BattleData.generateActionElement(self._tileIndex, tileIndices, specialWeaponType, self._board._targetReticle.isRotated());
		BattleshipsAnalytics.reportShotTaken();

		//
		UserDataController.getBattleData().lastAction.push( shotInfo );
		// UserDataController.getBattleData().lastAction.push(self._tileIndex);


		// Update the state of the used special weapon
		if (specialWeaponData) {
			specialWeaponData.onFire(specialWeaponType);
			self._specialWeaponButtonManager.updateStateFromData(true);
		}

		// Disable the button and hide the reticle
		self.buttonFire.disable();
		self._board._targetReticle.hide();

		//
		if (this.enableButtonTimeout) {
			clearTimeout(this.enableButtonTimeout);
			this.enableButtonTimeout = null;
		}

		// Add a new strike on the radar
		self._board.addStrike(self._tileIndex, shotTiles, function() {

			console.log('FireUnit.onFire::addStrike -> on done callback');

			// Check if the player has won the game when the strike is added
			var result = self._board.getTileMap().getResult();
			if (result.hits >= WinConditions.HITS_REQUIRED && !self.hasWon) {
				self.hasWon = true;
				tbGame.addSpecial('game-complete-win', result);
			}
		});

		// TODO, change to switch(turnState) and use advanceTo for better control?
		TurnController.advance();

		if (self._screenShake) {
			self._screenShake.destroy();
			self._screenShake = null;
		}
		self._screenShake = new ScreenShakeEffect({ x: 10, y: 0}, 400);
		return true;
	};

	this._shotsText = f_babas_regular.clone();
	this._shotsText.setPosition(435, 310);
	this._shotsText.setFontSize(40);
	this._shotsText.setFillColor("#3a4459");
	this._shotsText.setAlign("center");
	this._shotsText.setShadow(null);
	// this._shotsText.setFontStyle("italic");
	this._shotsText.setText(tgfDictionary.getText("FireUnitShotLightContext"));
	this.uiFireControl.baseContainer.addChild(this._shotsText);

	this._standardShotText = f_babas_regular.clone();
	this._standardShotText.setPosition(390, 451);
	this._standardShotText.setFontSize(32);
	this._standardShotText.setFillColor("#545f77");
	this._standardShotText.setStrokeWidth(0);
	this._standardShotText.setAlign("center");
	this._standardShotText.setShadow(null);
	// this._standardShotText.setFontStyle("italic");
	this._standardShotText.setText(tgfDictionary.getText("SpecialWeaponCategoryStandard"));
	this.uiFireControl.baseContainer.addChild(this._standardShotText);

	this._specialWeaponsText = f_babas_regular.clone();
	this._specialWeaponsText.setPosition(750, 451);
	this._specialWeaponsText.setFontSize(32);
	this._specialWeaponsText.setFillColor("#545f77");
	this._specialWeaponsText.setStrokeWidth(0);
	this._specialWeaponsText.setAlign("center");
	this._specialWeaponsText.setShadow(null);
	// this._specialWeaponsText.setFontStyle("italic");
	this._specialWeaponsText.setText(tgfDictionary.getText("SpecialWeaponCategorySpecial"));
	this.uiFireControl.baseContainer.addChild(this._specialWeaponsText);

	// Add it to the game engine
	// tbGame.addToken(this); <- already added in playcontroller

	TurnController.addTurnListener(this.onTurnUpdate, this);
};

FireUnit.prototype.addClock = function(state) {

	var imageTurnClock = s_pla_fire_overlay_clock.clone();
	imageTurnClock.setPosition(920, 296 - 21);

	this._turnText = f_babas_regular.clone();
	this._turnText.setPosition(920, 310);
	this._turnText.setFontSize(40);
	this._turnText.setFillColor("#3a4459");
	this._turnText.setAlign("center");
	this._turnText.setShadow(null);
	this._turnText.setText(String("Your turn").toUpperCase());
	this.uiFireControl.baseContainer.addChild(this._turnText);

	this._textClock = f_babas_regular.clone();
	this._textClock.setPosition(115, 13);
	this._textClock.setFontSize(35);
	this._textClock.setFillColor("#3f7cba");
	this._textClock.setAlign("center");
	this._textClock.setShadow(null);
	this._textClock.setText("30");
	imageTurnClock.addChild(this._textClock);

	this.uiFireControl.addChild(imageTurnClock);

	return this._textClock;
}


FireUnit.prototype.changeTime = function(time) {

	// #3f7cba
}


FireUnit.prototype.onTurnUpdate = function(state) {

	var shotsLeft = 0;
	var self = this;

	var animateOutDelay = 1500;

	var keepUnitUp = false;

	if (state == TurnController._TURN_STATES.FIRE1)
		shotsLeft = 3;
	if (state == TurnController._TURN_STATES.FIRE2)
		shotsLeft = 2;
	if (state == TurnController._TURN_STATES.FIRE3)
		shotsLeft = 1;
	if (state == TurnController._TURN_STATES.FIRE_X_POPUP) {

		shotsLeft = 0;
		keepUnitUp = true;
	}
	if (state == TurnController._TURN_STATES.FIRE_X_SHOT) {

		shotsLeft = 1;
		keepUnitUp = true;
	}

	// Set shot count
	this.lightHandler.setLightCount(shotsLeft);

	if(this.moveOutDelay) {
		clearTimeout(this.moveOutDelay);
		this.moveOutDelay = null;
	}

	// RadarStrike.comboCount = 0;
	// BoardStrike.comboCount = 0;

	// Move board in and open button if done
    if (shotsLeft > 0 || keepUnitUp) {
		this.moveIn(/* onVisible: */ function() {

			self.buttonFire.open();
			// self.buttonFire.enable();
		});
	}
	else {
		var self = this;
		this.moveOutDelay = setTimeout(function() {
			self.moveOut();
		}, animateOutDelay);
	}
};

// handleBeginStep is called each step before processing other events.
FireUnit.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	this._animatorUIFire.updateTime(timePassed);

	// Bugfix: moved out of "moveOut" to here because the button
	// would propogate the click to the cap, opening it immediately again
	// if(this._movedIn == false && this.fireCap.isOpen)
	// 	this.fireCap.close();
};

FireUnit.prototype.handleRemove = function() {
	"use strict";

	console.log('fireunit.remove');

	if (this._timeoutCloseCap) {
		clearTimeout(this._timeoutCloseCap);
		this._timeoutCloseCap = null;
	}

	if(this.moveOutDelay) {
		clearTimeout(this.moveOutDelay);
		this.moveOutDelay = null;
	}

	if (this._board) {
		this._board = null;
	}

	if (this._tileIndex) {
		this._tileIndex = null;
	}

	if (this.enableButtonTimeout) {
		clearTimeout(this.enableButtonTimeout);
		this.enableButtonTimeout = null;
	}

	if (this.uiFireControl) {
		this.uiFireControl.hide();
		this.uiFireControl.free();
		this.uiFireControl = null;
	}

	if (this._animatorUIFire) {
		this._animatorUIFire = null;
	}

	if (this.lightHandler) {
		tbGame.removeToken(this.lightHandler);
		this.lightHandler = null;
	}

	if (this.buttonFire) {
		this.buttonFire = null;
	}

	if (this._shotsText) {
		this._shotsText = null;
	}

	if (this._standardShotText) {
		this._standardShotText = null;
	}

	if (this._specialWeaponsText) {
		this._specialWeaponsText = null;
	}

	if (this.uiFireControl) {
		this.uiFireControl = null;
	}

	if (this._screenShake) {
		this._screenShake.destroy();
		this._screenShake = null;
	}

	if (this._specialWeaponButtonManager) {
		if (this.onSpecialWeaponChange) {
			this._specialWeaponButtonManager.removeOnSelectedCallback(this.onSpecialWeaponChange);
		}
		this._specialWeaponButtonManager.destroy();
		this._specialWeaponButtonManager = null;
	}

	tbGame.removeToken(this.uiFireControl);
};

FireUnit.prototype.getSpecialWeaponButtonManager = function() {
	return this._specialWeaponButtonManager;
}

FireUnit.prototype.moveIn = function(onVisible){

	if (this._movedIn) return;
	this._movedIn = true;

	// TODO: Hack to prevent it from creating before the data about the special weapon being received.
	if (!this._specialWeaponButtonManager) {

		// console.log('HOI TOO SOON');
		this._specialWeaponButtonManager = new SpecialWeaponButtonManager(this);

		// if (UserDataController.isTimedMatch() ) {

		// 	var specialWeaponData = UserDataController.getSpecialWeaponData();
  //           if (specialWeaponData) {
  //               specialWeaponData.clearCooldowns();
  //           }

		// 	this._specialWeaponButtonManager.updateStateFromData(true);
		// }


		this._board._targetReticle.setSpecialWeaponButtonManager(this._specialWeaponButtonManager);

		this._specialWeaponButtonManager.addOnSelectedCallback(this.onSpecialWeaponChange);
	}

	// doesnt make sense but heck they wanted me to use this
	tgfAudio.play(a_fireunit_moveout);

	this._animatorUIFire.pause();
	this._animatorUIFire.removeAllKeys();
	this._animatorUIFire.setTime(0);

	var delayTime = 150;
	var doneTime = 600;

	this._animatorUIFire.addKey(this._animatorUIFireTrackY, 0, this.uiFireControl.baseContainer.container.y, tbEase.easeOutCubic, 2 );
	this._animatorUIFire.addKey(this._animatorUIFireTrackY, delayTime, this.uiFireControl.baseContainer.container.y, tbEase.easeOutCubic, 2 );
	this._animatorUIFire.addKey(this._animatorUIFireTrackY, doneTime, tgfScale(tgfGraphics.areaHeight - this.uiFireControl.height + 6)); // Applied offset


	if (onVisible) {
		var onVisibleTrack = this._animatorUIFire.addTrack("function", this, function(value) {
			if (value == 1) {
				onVisible();

				this._animatorUIFire.pause();
			}
		});

		// Make sure the values are false on both time and delay, and done by the end.
		this._animatorUIFire.addKeys(onVisibleTrack, [{time: 0, value: 0}, {time: doneTime, value: 1}]);
	}

	this._animatorUIFire.resumeForced();
}

FireUnit.prototype.hasMovedOut = function(){ // It's time for the baby bird to leave the nest
	return !this._movedIn;
}

FireUnit.prototype.moveOut = function(){

	if (!this._movedIn) return;

	this._movedIn = false;

	tgfAudio.play(a_fireunit_moveout);

	var self = this;
	this._timeoutCloseCap = setTimeout(function() {
		self.buttonFire.close();
	}, 250);


	// Show the click to fire popup when no fires have been shot yet
	if(this.lightHandler.lightCount == 3)
		this._board.showClickToFire();

	this._animatorUIFire.pause();
	this._animatorUIFire.removeAllKeys();
	this._animatorUIFire.setTime(0);


	this._animatorUIFire.addKey(this._animatorUIFireTrackY, 0, this.uiFireControl.baseContainer.container.y , tbEase.easeInCubic, 2 );
	this._animatorUIFire.addKey(this._animatorUIFireTrackY, 650, this.uiFireControl.baseContainer.container.y , tbEase.easeInCubic, 2 );
	this._animatorUIFire.addKey(this._animatorUIFireTrackY, 950, tgfScale(tgfGraphics.areaHeight));

	this._animatorUIFire.resumeForced();
}

/** Check if it's allowed to fire based on the state of the turn */
FireUnit.prototype.canFire = function(turnState) {
	switch (turnState) {
		case TurnController._TURN_STATES.FIRE1:
		case TurnController._TURN_STATES.FIRE2:
		case TurnController._TURN_STATES.FIRE3:
		case TurnController._TURN_STATES.FIRE_X_SHOT: {
			console.log('TRO::FU::onFire -> state = ', turnState);
			return true;
			break;
		};
		default: {
			if (turnState == TurnController._TURN_STATES.TURN_OVER) {
				console.log('TRO::FU::onFire RETURN ? TURN OVER!!', turnState);
			}
			else {
				console.log('TRO::FU::onFire RETURN ?state = ', turnState);
			}
			return false;
		};
	}
}

FireUnit.prototype.handleKeyDown = function(keyCode) {
	if (!(typeof CheatManager !== 'undefined')) {
		return;
	}

	if (keyCode === tbKeyCodes.vkW) {
		CheatManager.armageddon(this.buttonFire);
	} else if (keyCode === tbKeyCodes.vkO) {
		var allanims = Object.keys(tgfDialogs.BattleshipOnboardingAnimationDialog.ANIMATIONS)
		var randomanim = allanims[Math.floor(Math.random() * allanims.length)]
		var test = new tgfDialogs.BattleshipOnboardingAnimationDialog({
			animationClip: tgfDialogs.BattleshipOnboardingAnimationDialog.ANIMATIONS[randomanim]
		});
		test.show();
	}
}

//******************************************************
//*****    Token Resource: FireCap
//******************************************************

// ***************************************
// Definition of game token FireCap
// ***************************************

// The constructor for the FireCap game token. 
var FireCap = function(button, container, x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth; 
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;

	this.button = button;
	this.container = container;
	this.fireCap = s_pla_fire_cap.clone();
	this.fireCap.add(container);
	this.fireCap.setPosition(x, y);

	this.close();

	// Add it to the game engine
	tbGame.addToken(this);
};

// handleAdd is called when the token is (re-) added to the game. 
FireCap.prototype.handleAdd = function() {
	"use strict";
};

// handleRemove is called when the token is removed from the game.
FireCap.prototype.handleRemove = function() {
	"use strict";
	
	if (this.button) {
		this.button = null;
	}

	if (this.container) {
		this.container = null;
	}

	if (this.fireCap) {
		this.fireCap = null;
	}
};

// handleBeginStep is called each step before processing other events.
FireCap.prototype.handleBeginStep = function(timePassed) {
	"use strict";
};

FireCap.prototype.isInRect = function(x,y) {
	var containerTransform = this.container.container.transform.localTransform;
	var tx = containerTransform.tx + this.fireCap.x;
	var ty = containerTransform.ty - this.fireCap.y;
	var txw = tx + this.fireCap.width;
	var tyh = tx + this.fireCap.height;

	if (x < tx || x > txw || y < ty || y > tyh)
		return false;

	return true;
}

FireCap.prototype.open = function() {
	this.fireCap.gotoAndStop(1);
	this.isOpen = true;
	this.button.reactOnDown = true;
	this.button.isActive = true;
	this.button.canClick = true;
}

FireCap.prototype.close = function() {
	this.fireCap.gotoAndStop(0);
	this.isOpen = false;
	this.button.reactOnDown = false;
	this.button.isActive = false;
	this.button.canClick = false;
}

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
FireCap.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";
	if (this.isInRect(x, y) && this.isOpen == false)
		return true;

	return false;
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
FireCap.prototype.handleTouchUp = function(finger, x, y) { 
	"use strict";

	if (this.isInRect(x, y) && this.isOpen == false) {
		this.open();
		return true;
	}
	return false;
};

// handleKeyDown is called if the key with the given keyCode is pressed.
FireCap.prototype.handleKeyDown = function(keyCode) { 
	"use strict";
};

// handleKeyUp is called if the key with the given keyCode is released.
FireCap.prototype.handleKeyUp = function(keyCode) { 
	"use strict";
};

// handleAlarm is called if a global alarm is reached.
FireCap.prototype.handleAlarm = function(alarm) { 
	"use strict";
};

// handleSpecial is called if a special or user-defined event happens.
FireCap.prototype.handleSpecial = function(id, args) { 
	"use strict";
};

// handleEndStep is called each step after processing other events (before draw).
FireCap.prototype.handleEndStep = function(timePassed) { 
	"use strict";
};

// handleDraw is called at the end of a step to draw the token.
FireCap.prototype.handleDraw = function() {
	"use strict";
};



//******************************************************
//*****    Script Resource: FireButton
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

function FireButton(x, y) {

	this._active = false;
	this.container = new tbContainer();
	this.container.setPosition(x,y);

	this.x = x;
	this.y = y;

	imageX = 3;
	imageY = -68;


	// fire-cap back
	this.imageCapBack = s_pla_fire_cap.clone();
	this.imageCapBack.setPosition(0, 133);
	this.imageCapBack.gotoAndStop(1);
	this.imageCapBack.add(this.container);

	// fire button
	this.imageFireButton = s_pla_fire_button.clone();
	this.imageFireButton.setPosition(3, -68);
	this.imageFireButton.gotoAndStop(1);
	this.container.addChild(this.imageFireButton);

	// fire-cap front
	this.imageCapFront = s_pla_fire_cap.clone();
	this.imageCapFront.setPosition(0, 133);
	this.imageCapFront.gotoAndStop(0);
	this.imageCapFront.add(this.container);

	this._hitArea = tbGraphics.drawRectangle(-100, -169, 200, 226, 0xffffff, 0x0000ff, 0, 0.00000001);
	this.container.container.addChild(this._hitArea);

	this.imageGlowRadius = s_pla_fire_button_glow_red.clone();
	this.imageGlowRadius.setAlpha(0);
	this.imageGlowRadius.setPosition(3, -68);
	this.imageGlowRadius.add(this.container);

	// icon
	this.iconY = -30;

	this.fireButtonIcon = s_pla_fire_button_icon_00.clone();
	this.fireButtonIcon.setPosition(33, this.iconY - (this._active ? 20 : 0));
	this.container.addChild(this.fireButtonIcon);

	var self = this;
	this._hitArea.on('pointerdown', function() {
		
		self.fire();

		// console.log('pointerup');
	});

	this.close();
}

FireButton.prototype.constructor = FireButton;

FireButton.prototype.setSpecialWeaponImage = function (specialWeaponType) { 
	
	this.container.removeChild(this.fireButtonIcon);
	this.fireButtonIcon = null;

	switch(specialWeaponType) {
		default:
		case SpecialWeaponData.SpecialWeapon.default:
			this.iconY = -30;

			this.fireButtonIcon = s_pla_fire_button_icon_00.clone();
			break;

		case SpecialWeaponData.SpecialWeapon.airStrike: 
			this.iconY = -10;

			this.fireButtonIcon = s_pla_fire_button_icon_01.clone();
			break;

		case SpecialWeaponData.SpecialWeapon.bomb:
			this.iconY = -10;

			this.fireButtonIcon = s_pla_fire_button_icon_02.clone();
			break;

		case SpecialWeaponData.SpecialWeapon.torpedo:
			this.iconY = -20;

			this.fireButtonIcon = s_pla_fire_button_icon_04.clone();
			break;

		case SpecialWeaponData.SpecialWeapon.scatter:
			this.iconY = -35;

			this.fireButtonIcon = s_pla_fire_button_icon_05.clone();
			break;
	};

	this.fireButtonIcon.setPosition(33, this.iconY - (this._active ? 20 : 0));
	this.container.addChild(this.fireButtonIcon);
}

FireButton.prototype.enable = function() {

	this._active = true;
	this._hitArea.interactive = true;
	this._hitArea.buttonMode = true;
	
	this.imageFireButton.gotoAndStop(0);
	this.fireButtonIcon.setPosition(33, this.iconY - (this._active ? 20 : 0));

	this.imageGlowRadius.setAlpha(1);
}

FireButton.prototype.disable = function() {
	
	this._active = false;
	this._hitArea.interactive = false;
	this._hitArea.buttonMode = false;

	this.imageFireButton.gotoAndStop(1);
	this.fireButtonIcon.setPosition(33, this.iconY - (this._active ? 20 : 0));
	
	this.imageGlowRadius.setAlpha(0);
}


FireButton.prototype.open = function() {
	
	this.imageCapFront.setAlpha(0);
	this.imageCapBack.setAlpha(1);

	//this.enable();
}

FireButton.prototype.close = function() {
	this.imageCapFront.setAlpha(1);
	this.imageCapBack.setAlpha(0);

	//this.disable();
}


FireButton.prototype.fire = function() {

	if (this.onFire && this.onFire()) {
		//tgfAudio.play(a_radar_strike);
	}
}

FireButton.prototype.toggle = function() {

	this._active = !this._active;

	if (this._active) {
		this.enable();
	}
	else {
		this.disable();
	}
}
//******************************************************
//*****    Token Resource: SpecialWeaponButton
//******************************************************

// The constructor for the SpecialWeaponButton game token.
var SpecialWeaponButton = function(manager, container, powerupType, x, y, slotIndex) {
	"use strict";
	// Properties used by the engine
	this.layer = 0;
	this.visible = true;
	this.active = true;
	this.manager = manager;
	this.container = container;

	this.slotIndex = slotIndex;

	this.x = x;
	this.y = y;

	this.type = powerupType;
	this.setupImages(container);



	var self = this;

	// console.log('button-container::', this.container);




	if (powerupType > 0) {

		this._refreshAnimation = new WeaponRefreshAnimation(this, x, y, slotIndex);

		/*
		this.iconAddAnimation = new BattleshipComponents.SpineAnimation({
			x: 0,
			y: 0,
			animation: specialweapons_add_icon,
			onLoad: function () {

				// console.log('add-icon -> added');
				self._animationIconReady = true;

				self.iconAddAnimation.animator.animation.alpha = 0;
				self.iconAddAnimation.container.setPosition(self.x + 36, self.y + 36);
				self.iconAddAnimation.playAnimation('animation_small_lock_on_button', true);

				self.setState(self._state);
			}
		});
		*/

		//this.container.dialog.addComponent(this.iconAddAnimation);
		//this.iconAddAnimation.show();
		// this.iconAddAnimation.hide();

	}

	//	TODO
	//
	// 	please use this in stead of engine-native handleTouchDown
	//
	if (this.images.up) {
		this.images.up.sprite.on('pointerdown', this.doHandleTouchDown.bind(this) );
		this.images.up.sprite.interactive = true;
		this.images.up.sprite.buttonMode = true;
	}

	// Add it to the game engine
	tbGame.addToken(this);
};

SpecialWeaponButton.prototype.constructor = SpecialWeaponButton;

// SpecialWeaponButton.prototype.handleTouchDown = function(finger, x, y) {
SpecialWeaponButton.prototype.doHandleTouchDown = function(touchInfo) {
	"use strict";

	console.log('SpecialWeaponButton.handleTouchDown');

	if (!this.container || !this.container.container) {
		console.warn('SpecialWeaponButton.container already removed');
		return;
	}

	if (!this.images.up || this._selected)
		return;

	var transform = {
		x: this.images.up.x + this.container.container.x,
		y: this.images.up.y + this.container.container.y
	};
	var width = this.images.up.sprite.width;
	var height = this.images.up.sprite.height;

	// if (x < transform.x || x > transform.x + width ||
	// 	y < transform.y || y > transform.y + height)
	// 	return;

	if (this.isLocked()) {
		// Do not show that renew popup anymore.
		//this.manager.openRenewPopup(null, null, true);
		console.log("Special Weapon is locked");
	}
	else {
		// Manager deselects others, selects this one.
		this.manager.setSelected(this.slotIndex);
	}

};

SpecialWeaponButton.prototype.isSelected = function() {
	return this._state === SpecialWeaponData.SpecialWeaponState.down;
};

SpecialWeaponButton.prototype.isLocked = function() {
	return this._state === SpecialWeaponData.SpecialWeaponState.locked;
};

SpecialWeaponButton.prototype.isInactive = function() {
	return this._state === SpecialWeaponData.SpecialWeaponState.inactive;
};

SpecialWeaponButton.prototype.canBeState = function(state) {

	switch (state) {
		case SpecialWeaponData.SpecialWeaponState.up:
			if (this.isInactive())
				return false;

			return !!this.images.up;

		case SpecialWeaponData.SpecialWeaponState.down:
			if (this.isLocked() || this.isInactive())
				return false;

			return !!this.images.down;

		case SpecialWeaponData.SpecialWeaponState.locked:
			if (this.isInactive())
				return false;

			return !!(this.images.locked || this.add);

		case SpecialWeaponData.SpecialWeaponState.inactive:
			return !!this.images.inactive;
	}

	return false;
}

SpecialWeaponButton.prototype.getStateString = function(state) {

	switch (state) {
		case SpecialWeaponData.SpecialWeaponState.up:
			return "SpecialWeaponData.SpecialWeaponState.up";
		case SpecialWeaponData.SpecialWeaponState.down:
			return "SpecialWeaponData.SpecialWeaponState.down";
		case SpecialWeaponData.SpecialWeaponState.locked:
			return "SpecialWeaponData.SpecialWeaponState.down";
		case SpecialWeaponData.SpecialWeaponState.inactive:
			return "SpecialWeaponData.SpecialWeaponState.down";
	}

	return "Unknown State";
}

SpecialWeaponButton.prototype.getFallbackState = function(state) {

	switch (state) {
		case SpecialWeaponData.SpecialWeaponState.inactive:
		case SpecialWeaponData.SpecialWeaponState.up:
			if (this.canBeState(SpecialWeaponData.SpecialWeaponState.down))
				return SpecialWeaponData.SpecialWeaponState.down;

		default:
		case SpecialWeaponData.SpecialWeaponState.locked:
		case SpecialWeaponData.SpecialWeaponState.down:
			if (this.canBeState(SpecialWeaponData.SpecialWeaponState.inactive))
				return SpecialWeaponData.SpecialWeaponState.inactive;
			break;
	}
}

SpecialWeaponButton.prototype.setSelected = function() {

	var state = SpecialWeaponData.SpecialWeaponState.down;
	if (this.canBeState(state)) {
		return this.setState(state);
	}
	return false;
};

SpecialWeaponButton.prototype.setLocked = function() {

	var state = SpecialWeaponData.SpecialWeaponState.locked;
	if (this.canBeState(state)) {
		return this.setState(state);
	}
	return false;
};

SpecialWeaponButton.prototype.setInactive = function() {

	var state = SpecialWeaponData.SpecialWeaponState.inactive;
	if (this.canBeState(state)) {
		return this.setState(state);
	}
	return false;
};

// SpecialWeaponButton.prototype.setFlicker = function(state) {

// 	var info = specialWeaponData ? specialWeaponData.getWeaponInfo(i) : SpecialWeaponData.SpecialWeaponState.inactive;
//     this.specialWeapons[i].setState(info.state);
// }

SpecialWeaponButton.prototype.setState = function(state, flicker) {
	"use strict";

	// Hide all
	if (this.images.down) this.images.down.setAlpha(0);
	if (this.images.up) this.images.up.setAlpha(0);
	if (this.images.locked) this.images.locked.setAlpha(0);
	if (this.images.inactive) this.images.inactive.setAlpha(0);
	if (this.add) this.add.setAlpha(0);

	if (!this.canBeState(state)) {
		console.warn("Cannot set button to state " + this.getStateString(state) + " setting it to " + this.getFallbackState(state));
		state = this.getFallbackState(state);
	}

	console.log('SWB.setState', state, flicker);

	if (this.iconAddAnimation && this._animationIconReady) {// && this.iconAddAnimation.animator && this.iconAddAnimation.animator.animator) {

		// this.iconAddAnimation.hide();
		this.iconAddAnimation.animator.animation.alpha = 0;
	}

	this._state = state;
	switch (this._state) {
		case SpecialWeaponData.SpecialWeaponState.up:
			if (flicker && this.images && this.images.up) {

				this._refreshAnimation.playAnimation();
				return true;
			}
			else {

				if (this.images && this.images.up) this.images.up.setAlpha(1);
				else console.warn('SWM.setState -> up not found');
			}

			break;

		case SpecialWeaponData.SpecialWeaponState.down:
			if (this.images && this.images.down) this.images.down.setAlpha(1);
			else console.warn('SWM.setState -> down not found');



			break;

		case SpecialWeaponData.SpecialWeaponState.locked:

			if (this.images && this.images.locked) this.images.locked.setAlpha(1);
			else console.warn('SWM.setState -> locked not found');
			// if (this.add) this.add.setAlpha(1);
			if (this.add) this.add.setAlpha(0);

			if (this.iconAddAnimation && this._animationIconReady && this._supportAddAds) {// && this.iconAddAnimation.animator && this.iconAddAnimation.animator.animator) {
				// this.iconAddAnimation.show();
				this.iconAddAnimation.animator.animation.alpha = 1;
			}

			break;

		case SpecialWeaponData.SpecialWeaponState.inactive:

			this.createLockIcon();

			if (this._refreshAnimation) this._refreshAnimation.setLocked(true);

			if (this.images && this.images.inactive) this.images.inactive.setAlpha(1);
			else console.warn('SWM.setState -> inactive not found');
			break;
	}


	return true;
};

SpecialWeaponButton.prototype.handleRemove = function(timePassed) {
	"use strict";

	console.log('SpecialWeaponButton::handleRemove');

	this._destroyed = true;

	if (this.manager) {
		this.manager = null;
	}
	if (this.container) {
		this.container = null;
	}
	if (this.type) {
		this.type = null;
	}
}

SpecialWeaponButton.prototype.handleBeginStep = function(timePassed) {

	if (this._refreshAnimation) {

		this._refreshAnimation.update(timePassed);
	}
}

SpecialWeaponButton.prototype.handleEndStep = function(timePassed) {
	"use strict";
};

SpecialWeaponButton.prototype.destroy = function() {

	tbGame.removeToken(this);
}

SpecialWeaponButton.prototype.createLockIcon = function() {

	console.log("SpecialWeaponButton::createLockIcon");

	// Add a lock icon
	var lockIcon = s_sp_lock.clone();
	var lockOffsetX = lockIcon.width / 2 + 12;
	var lockOffsetY = lockIcon.height / 2 - 18;

	lockIcon.setPosition(this.x + lockOffsetX, this.y + lockOffsetY);
	this.container.addChild(lockIcon);

	var font = f_autoradiographic_italic.clone();
	font.setText(WeaponUnlockChart.getLockText(this.type));
	font.setFontSize(38);
	font.setStrokeWidth(5);
	font.setStrokeColor('#424a01');
	font.setFillColor('#d4d4a8');
	font.setAlign('center');
	font.setBaseline('middle');

	font.setPosition(lockIcon.width / 2 - 2, lockIcon.height / 2 + 9);
	lockIcon.addChild(font);
}

SpecialWeaponButton.prototype.getTooltipText = function() {

	// TODO: Use tgfDictionary.getText() to get the right text when localization is updated

	var textTip = tgfDictionary.getText('specialWeapons_unlockText');

	var rank = "";

	for (var i = 0; i < WeaponUnlockChart.weaponData.length; i += 1) {

		if (WeaponUnlockChart.weaponData[i].weapon === this.type) {
			rank = WeaponUnlockChart.weaponData[i].lockText;
			break;
		}
	}


	textTip = textTip.split('{0}').join(rank);
	return textTip;//"Reach rank 2 to unlock this special weapon";
}

SpecialWeaponButton.prototype.getTooltipIcon = function() {
	for (var i = 0; i < WeaponUnlockChart.weaponRankUnlocks.length; i += 1) {
		if (WeaponUnlockChart.weaponRankUnlocks[i].weapon === this.type) {
			var rank = WeaponUnlockChart.weaponRankUnlocks[i].rank;

			return RankIndicator.createFromScore(RankChart.ranks[rank - 1].value);
		}
	}

	return "";
}

SpecialWeaponButton.prototype.setupImages = function(container) {
	"use strict";


	this.images = {};
	if (this.type === 0) { // default weapon
		this.images.down = s_button_standard_down.clone();
		this.images.up = s_button_standard_up.clone();
		this.images.locked = null; // can't be locked
		this.images.inactive = null; // can't be inactive
	}
	else {
		switch(this.type) {
			case 1: {
				this.images.down = typeof(s_button_special_weapon_down_01) !== 'undefined' ? s_button_special_weapon_down_01 : null;
				this.images.up = typeof(s_button_special_weapon_up_01) !== 'undefined' ? s_button_special_weapon_up_01 : null;
				this.images.inactive = typeof(s_button_special_weapon_lock_down_01) !== 'undefined' ? s_button_special_weapon_lock_down_01 : null;
				this.images.locked = typeof(s_button_special_weapon_lock_down_01) !== 'undefined' ? s_button_special_weapon_lock_down_01 : null;
				break;
			};
			case 2: {
				this.images.down = typeof(s_button_special_weapon_down_02) !== 'undefined' ? s_button_special_weapon_down_02 : null;
				this.images.up = typeof(s_button_special_weapon_up_02) !== 'undefined' ? s_button_special_weapon_up_02 : null;
				this.images.inactive = typeof(s_button_special_weapon_lock_down_02) !== 'undefined' ? s_button_special_weapon_lock_down_02 : null;
				this.images.locked = typeof(s_button_special_weapon_lock_down_02) !== 'undefined' ? s_button_special_weapon_lock_down_02 : null;
				break;
			};
			case 3: {
				this.images.down = typeof(s_button_special_weapon_down_03) !== 'undefined' ? s_button_special_weapon_down_03 : null;
				this.images.up = typeof(s_button_special_weapon_up_03) !== 'undefined' ? s_button_special_weapon_up_03 : null;
				this.images.inactive = typeof(s_button_special_weapon_lock_down_03) !== 'undefined' ? s_button_special_weapon_lock_down_03 : null;
				this.images.locked = typeof(s_button_special_weapon_lock_down_03) !== 'undefined' ? s_button_special_weapon_lock_down_03 : null;
				break;
			};
			case 4: {
				this.images.down = typeof(s_button_special_weapon_down_04) !== 'undefined' ? s_button_special_weapon_down_04 : null;
				this.images.up = typeof(s_button_special_weapon_up_04) !== 'undefined' ? s_button_special_weapon_up_04 : null;
				this.images.inactive = typeof(s_button_special_weapon_lock_down_04) !== 'undefined' ? s_button_special_weapon_lock_down_04 : null;
				this.images.locked = typeof(s_button_special_weapon_lock_down_04) !== 'undefined' ? s_button_special_weapon_lock_down_04 : null;
				break;
			};
			case 5: {
				this.images.down = typeof(s_button_special_weapon_down_05) !== 'undefined' ? s_button_special_weapon_down_05 : null;
				this.images.up = typeof(s_button_special_weapon_up_05) !== 'undefined' ? s_button_special_weapon_up_05 : null;
				this.images.inactive = typeof(s_button_special_weapon_lock_down_05) !== 'undefined' ? s_button_special_weapon_lock_down_05 : null;
				this.images.locked = typeof(s_button_special_weapon_lock_down_05) !== 'undefined' ? s_button_special_weapon_lock_down_05 : null;
				break;
			};
			case 6: {
				this.images.down = typeof(s_button_special_weapon_down_06) !== 'undefined' ? s_button_special_weapon_down_06 : null;
				this.images.up = typeof(s_button_special_weapon_up_06) !== 'undefined' ? s_button_special_weapon_up_06 : null;
				this.images.inactive = typeof(s_button_special_weapon_lock_down_06) !== 'undefined' ? s_button_special_weapon_lock_down_06 : null;
				this.images.locked = typeof(s_button_special_weapon_lock_down_06) !== 'undefined' ? s_button_special_weapon_lock_down_06 : null;
				break;
			};
			case 7: {
				this.images.down = typeof(s_button_special_weapon_down_07) !== 'undefined' ? s_button_special_weapon_down_07 : null;
				this.images.up = typeof(s_button_special_weapon_up_07) !== 'undefined' ? s_button_special_weapon_up_07 : null;
				this.images.inactive = typeof(s_button_special_weapon_lock_down_07) !== 'undefined' ? s_button_special_weapon_lock_down_07 : null;
				this.images.locked = typeof(s_button_special_weapon_lock_down_07) !== 'undefined' ? s_button_special_weapon_lock_down_07 : null;
				break;
			};
		}
	}

	// Add all images to the container.
	Object.keys(this.images).forEach(function(key, index) {
		if (this.images[key]) {

			// Clone if exists
			this.images[key] = this.images[key].clone();
			this.images[key].setPosition(this.x - this.images[key].sprite.width * 0.5, this.y - this.images[key].sprite.height * 0.5);
			container.addChild(this.images[key]);
		}
	}.bind(this));


	var md = UserDataController.getMatchData();
    if (md && md.isTimed) {

        // dont add 'add'-icon
        this._supportAddAds = false;
    }
    else {

        // add 'add'-icon normally
        this._supportAddAds = true;

		this.add = s_button_add.clone();
		var defaultImage = this.images.up ? this.images.up : this.images.inactive;
		this.add.setPosition(this.x + this.add.sprite.width * 0.25, this.y + this.add.sprite.height * 0.25);
		// container.addChild(this.add);
    }
};



//******************************************************
//*****    Script Resource: SpecialWeaponButtonManager
//******************************************************


var SpecialWeaponButtonManager = function(fireUnit) {

    this.container = fireUnit.uiFireControl.baseContainer;
    this.timeOutShowPopup = null;
    this._showingPopup = false;
    this.callbacks = [];

    // Reference to RadarToken is needed to hide the 'select a cell' tooltip
    this.radarToken = fireUnit._board;

    // default selected
    this.selected = 0;

    var buttonStart = 573;
    var buttonEnd = 959;
    var buttonOffset = (buttonEnd - buttonStart) / 3;

    this.specialWeapons = [
        // Standard
        new SpecialWeaponButton(this, this.container, SpecialWeaponData.SpecialWeapon.default, 400, 550, 0),

        // Special weapons
        new SpecialWeaponButton(this, this.container, SpecialWeaponData.SpecialWeapon.airStrike, buttonStart, 550, 1),
        new SpecialWeaponButton(this, this.container, SpecialWeaponData.SpecialWeapon.bomb, buttonStart+buttonOffset, 550, 2),

        new SpecialWeaponButton(this, this.container, SpecialWeaponData.SpecialWeapon.torpedo, buttonStart+buttonOffset*2, 550, 3),
        new SpecialWeaponButton(this, this.container, SpecialWeaponData.SpecialWeapon.scatter, buttonStart+buttonOffset*3, 550, 4),

    ];

    this.updateStateFromData();

    this.standardWeapon = this.specialWeapons[SpecialWeaponData.SpecialWeapon.default];
    this.setSelected(SpecialWeaponData.SpecialWeapon.default);

    TurnController.addTurnListener(this.onTurnUpdate, this);
}

SpecialWeaponButtonManager.prototype.constructor = SpecialWeaponButtonManager;

SpecialWeaponButtonManager.prototype.destroy = function() {

    if (this.timeOutShowPopup) {
        clearInterval(this.timeOutShowPopup);
        this.timeOutShowPopup = null;
    }

    if (this.specialWeapons) {
        for (var i = 0; i < this.specialWeapons.length; i++) {
            this.specialWeapons[i].destroy();
            this.specialWeapons[i] = null;
        }
    }

    if (this.uiSpecialActivatePopup) {
        this.uiSpecialActivatePopup.free();
        this.uiSpecialActivatePopup = null;
    }

    this.specialWeapons = null;
}

SpecialWeaponButtonManager.prototype.onTurnUpdate = function(state) {

    // This is the 3 Strikes you can do per round. FIRE1 is the first shot, FIRE2, second, etc.
    console.log('onTurnUpdate SWBM.state', state, TurnController._TURN_STATES);

    switch (state) {
        case TurnController._TURN_STATES.FIRE1: // 70
        case TurnController._TURN_STATES.FIRE2: // 80
        case TurnController._TURN_STATES.FIRE3: // 90
        case TurnController._TURN_STATES.FIRE_X_SHOT: { // 92

            console.log('SpecialWeaponButtonManager.inventory', UserDataController.getSpecialWeaponData().getInventory());
            console.log('SpecialWeaponButtonManager.hasUsed', UserDataController.getSpecialWeaponData().hasUsed());

            this._isEnabled = true;
            if (state == TurnController._TURN_STATES.FIRE1) {

                var swd = UserDataController.getSpecialWeaponData();
                //swd.clearCooldowns();

                if (swd && swd.hasUsed() && !this._turnStartAdWatchedOnce) {

                    //this.openRenewPopup(null, true);
                }
            }
            break;
        };
        default : {
            this._isEnabled = false;
            break;
        };
    }

}


SpecialWeaponButtonManager.prototype.updateStateFromData = function(keepSelected, flicker) {

    flicker = flicker || false;

    if (flicker) {
        keepSelected = false;
    }

    console.log('SWBM.updateStateFromData', keepSelected, flicker);

    var selected;
    if (keepSelected) {
        selected = this.selected;
    }

    var specialWeaponData = UserDataController.getSpecialWeaponData();
    for (var i = 0; i < this.specialWeapons.length; i++) {
        var type = this.specialWeapons[i].type;
        var info = specialWeaponData ? specialWeaponData.getWeaponInfo(type) : SpecialWeaponData.SpecialWeaponState.inactive;
        this.specialWeapons[i].setState(info.state, flicker);
    }

    if (keepSelected) {
        // Try re-selecting our previous one
        if (!this.specialWeapons[selected].isLocked() && !this.specialWeapons[selected].isInactive()) {
            this.setSelected(selected);
        }
        else {
            // otherwise select default weapon
            this.setSelected(SpecialWeaponData.SpecialWeapon.default);
        }
    }
}

SpecialWeaponButtonManager.prototype.addOnSelectedCallback = function(callback) {
    this.callbacks.push(callback);
}

SpecialWeaponButtonManager.prototype.removeOnSelectedCallback = function(callback) {

    var index = this.callbacks.indexOf(callback);
    if(index < 0) return;

    this.callbacks.splice(index, 1);
}

SpecialWeaponButtonManager.prototype.getSelectedSpecialWeaponType = function() {
    return this.specialWeapons[this.selected].type;
}

SpecialWeaponButtonManager.prototype.setSelected = function(buttonId) {

    if (!this._isEnabled) {

        console.log('SpecialWeaponButtonManager.setSelected unavailable for this TurnState');
        return;
    }

    if (this.specialWeapons[buttonId].isInactive()) {
        this.showUnlockTooltip(this.specialWeapons[buttonId]);
        return;
    }

    if (!this.specialWeapons[buttonId].canBeState(SpecialWeaponData.SpecialWeaponState.down))
        return;

    tgfAudio.play(a_select_special);

    // Deselect all
    for(var i = 0; i < this.specialWeapons.length; i++) {

        if (buttonId == i) {
            continue;
        }

        if (this.specialWeapons[i].isSelected()) {
            this.specialWeapons[i].setState(SpecialWeaponData.SpecialWeaponState.up);
        }
    }

    // Select correct one.
    this.selected = buttonId;
    if (!this.specialWeapons[buttonId].setSelected()) {
        console.warn("Special weapon button " + i + " could not be selected");
    }

    for (var i = 0; i < this.callbacks.length; i++) {
        this.callbacks[i](this.getSelectedSpecialWeaponType());
    }
}

/** Show a tooltip that explains how the specified special weapon can be unlocked */
SpecialWeaponButtonManager.prototype.showUnlockTooltip = function(specialWeaponButton) {

    // If another tooltip is still open, hide and remove it
    if (this.inactiveWeaponTooltip) {
        this.inactiveWeaponTooltip.hideTooltip();
    }

    var self = this

    this.inactiveWeaponTooltip = new tgfDialogs.TooltipDialog({
        arrowX: specialWeaponButton.x,
        y : specialWeaponButton.y - 200 + tgfGraphics.areaHeight / 2, // Applied offset
        iconImage: specialWeaponButton.getTooltipIcon(),
        text: specialWeaponButton.getTooltipText(),
        onDisappeared: function() {
            // Show the 'select a cell' tooltip when the special weapon tooltip has disappeared
            self.radarToken.reappearClickToFire();
        }
    });

    console.log(specialWeaponButton.getTooltipIcon())
    this.inactiveWeaponTooltip.show();


    this.radarToken.hideClickToFire();
}

SpecialWeaponButtonManager.prototype.openRenewPopup = function(buttonId, turnStart, skipPopup) {

    console.log('SpecialWeaponButtonManager.openRenewPopup');

     if (!this._isEnabled) {

        console.log('SpecialWeaponButtonManager.openRenewPopup unavailable for this TurnState');
        return;
    }


    var md = UserDataController.getMatchData();

    if (md && md.isTimed) {

        return;
    }


    var self = this;

    if (skipPopup) {

        AnalyticsService.reportEvent("interaction", "interaction", {
            eventType: "button_open_rewarded"
        });

        AdManager.setTrackingData('special_weapon', null);
        AdManager.playAd(self, function(e) {

            console.log('AM::SpecialWeapons.playAdCallback');

            var specialWeaponData = UserDataController.getSpecialWeaponData();
            if (specialWeaponData && e === 0) {
                specialWeaponData.clearCooldowns();
            }

            if (turnStart) {
                self._turnStartAdWatchedOnce = true;
            }

            self.updateStateFromData(true, true);

        });

        return;
    }
    else {

        // proceed normally
    }

    var showPopup = function() {

        //BattleshipsAnalytics.reportOpenRenewPopup();



        if (!self.uiSpecialActivatePopup) {

            self.uiSpecialActivatePopup = new tgfDialogs.BattleshipRenewSpecialWeaponsPopup({
                x: 0,
                y: -80,
                positionX: tgfGraphics.areaWidth/2,
                positionY: tgfGraphics.areaHeight * 0.75,
                height: 580,
                big: true,
                shadow: true,
                stars: false,
                manager: self
            });

            self.uiSpecialActivatePopup.setButtonCallback(function() {

                AnalyticsService.reportEvent("interaction", "interaction", {
                    eventType: "button_activate",
                    id: "special_weapon"
                })
                AnalyticsService.reportEvent("interaction", "interaction", {
                    eventType: "button_open_rewarded"
                });

                AdManager.setTrackingData('special_weapon', null);
                AdManager.playAd(self, function(e) {

                    console.log('AM::SpecialWeapons.playAdCallback');

                    var specialWeaponData = UserDataController.getSpecialWeaponData();
                    if (specialWeaponData && e === 0) {
                        specialWeaponData.clearCooldowns();
                    }

                    if (turnStart) {
                        self._turnStartAdWatchedOnce = true;
                    }

                    self.updateStateFromData(true, true);

                });
            })

            self.uiSpecialActivatePopup.onExit = function() {

                console.log('onExit', self._showingPopup);
                // self._showingPopup = false;
            }
            self.uiSpecialActivatePopup.onHide = function() {

                console.log('onHide', self._showingPopup);
                self._showingPopup = false;
            }
        }

        // only show when not
        if (self._showingPopup == false) {

            self._showingPopup = true;
            self.uiSpecialActivatePopup.show();
        }
    }

    // console.log(this.uiSpecialActivatePopup);

    if (!this._showingPopup) {

        showPopup();
    }
    else {
        // this.timeOutShowPopup = setTimeout(showPopup, 400);
        // this.uiSpecialActivatePopup.hide(false);
    }
}

//******************************************************
//*****    Script Resource: WeaponRefreshAnimation
//******************************************************

var WeaponRefreshAnimation = function(weapon, x, y, slotIndex) {

	this._weapon = weapon;
	this._container = weapon.container;

	this.imageCircle = s_circle.clone();
	this.imageCircle.setPosition(x, y);

	this.slotIndex = slotIndex;
	this.delay = (this.slotIndex - 1) * 100;


	var self = this;

	this._isLocked = false;

	this._flickerImage = weapon.images.up;
	// console.log('flickerImage', this._flickerImage);

	this._animator = new tbAnimator(this.imageCircle.sprite);
	this._animatorTrackAlpha = this._animator.addTrack("alpha"); 
	this._animatorTrackFlicker = this._animator.addTrack("function", this, function(value) { 

		if (this._flickerImage) {
			this._flickerImage.setAlpha(value);
		}
	});
	this._animatorTrackScale = this._animator.addTrack("function", this, function(value) { 

		if (self.imageCircle && self.imageCircle.sprite) {
			
			self.imageCircle.sprite.scale.x = value;
			self.imageCircle.sprite.scale.y = value;
		}
	});

	this._animator.addKey(this._animatorTrackAlpha, 0, 0);
	this._animator.addKey(this._animatorTrackAlpha, 0 + this.delay, 1);

	this._animator.addKey(this._animatorTrackScale, 0 + this.delay, 3, tbEase.easeInCubic, 1.75);
	this._animator.addKey(this._animatorTrackScale, 1200 + this.delay, 0, tbEase.easeOutCubic, 1.75);
	this._animator.addEvent(this, 1200 + this.delay, function() {

		self._weapon.setState(SpecialWeaponData.SpecialWeaponState.up);
	});

	var flickerStart = 1200 + this.delay;
	this._animator.addKey(this._animatorTrackFlicker, flickerStart += 100, 0.25, tbEase.easeInCubic, 1.4);
	this._animator.addKey(this._animatorTrackFlicker, flickerStart += 90, 1, tbEase.easeOutCubic, 1.4);
	this._animator.addKey(this._animatorTrackFlicker, flickerStart += 80, 0.25, tbEase.easeInCubic, 1.4);
	this._animator.addKey(this._animatorTrackFlicker, flickerStart += 70, 1, tbEase.easeOutCubic, 1.4);
	this._animator.addKey(this._animatorTrackFlicker, flickerStart += 60, 0.25, tbEase.easeInCubic, 1.4);
	this._animator.addKey(this._animatorTrackFlicker, flickerStart += 50, 1, tbEase.easeOutCubic, 1.4);
	
	var circleOutStart = 1100 + this.delay;
	this._animator.addKey(this._animatorTrackScale, circleOutStart, 0, tbEase.easeInCubic, 1.5);
	this._animator.addKey(this._animatorTrackScale, circleOutStart + 800, 1.25, tbEase.easeOutCubic, 1.5);
	this._animator.addKey(this._animatorTrackAlpha, circleOutStart + 600, 1, tbEase.easeInCubic, 1.5);
	this._animator.addKey(this._animatorTrackAlpha, circleOutStart + 650, 0, tbEase.easeOutCubic, 1.5);


	this._animator.pause();
	this._animator.setTime(0);


	if (this._container) {
		this._container.addChild(this.imageCircle);
	}

	// setTimeout(function() {

	// 	this.playAnimation();
	// }.bind(this), 3000);

	// setTimeout(function() {

	// 	this.playAnimation();
	// }.bind(this), 9000);

	// setTimeout(function() {

	// 	this.playAnimation();
	// }.bind(this), 15000);
}

WeaponRefreshAnimation.prototype.constructor = WeaponRefreshAnimation;

WeaponRefreshAnimation.prototype.playAnimation = function() {

	if (this._container) {
		this._container.addChild(this.imageCircle);
	}

	if (this._isLocked) return;

	this._animator.pause();
	this._animator.setTime(0);

	this._animator.resumeForced();	
}

WeaponRefreshAnimation.prototype.setLocked = function(value) {

	this._isLocked = value;
}

WeaponRefreshAnimation.prototype.update = function(timePassed) {

	if (this._animator) {

		// console.log(this.imageCircle.sprite.scale);
		this._animator.updateTime(timePassed);
	}

	// console.log(this.imageCircle.scale);
}
//******************************************************
//*****    Script Resource: WinConditions
//******************************************************

var WinConditions = {

	//HITS_REQUIRED: 8
	HITS_REQUIRED: 17
}

//******************************************************
//*****    Script Resource: AdSettings
//******************************************************

var AdSettings = {

	// REWARD_COOLDOWN_EXTRA_SHOT: 1000,
	REWARD_COOLDOWN_EXTRA_SHOT: 10000,
	REWARD_COOLDOWN_SPECIAL_WEAPONS: 3000
	// REWARD_COOLDOWN_SPECIAL_WEAPONS: 180000
}
//******************************************************
//*****    Script Resource: ShipUtils
//******************************************************

var ShipUtils = {};


ShipUtils.shipDestroyed = function(value) {

	var shipType = ShipUtils.getTypeByTileValue(value);
}

ShipUtils.getSize = function(id) {
    switch (id) {
        case 1: return 5;
        case 2: return 4;
        case 3: return 3;
        case 4: return 3;
        case 5: return 2;
        default: return 0;
    };
}

ShipUtils.getTypeByTileValue = function(value) {
    switch (value) {
        case 1: return 1;
        case 2: return 2;
        case 3: return 3;
        case 4: return 4;
        case 5: return 5;
        case 11: return 1;
        case 12: return 2;
        case 13: return 3;
        case 14: return 4;
        case 15: return 5;
        default: return 0;
    };
}
//******************************************************
//*****    Script Resource: WeaponBase
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var WeaponBase = function() {
    "use strict";

    // The number that corresponds to the SpecialWeapons enum
    this.weaponID = WeaponBase.SpecialWeapons.default;

    // The required offsets to prevent the reticles from moving outside the board
    this.requiredOffsets = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
    };

    // The amount of reticles the special uses
    this.reticlesAmount = 1;

    this.isRotated = false;
    this.canRotate = false;

    // The names of the animation to load them
    this.explosionAnimationName = "Special_weapon_01";
    this.missileAnimationName = "Missile";

    this.shootSound = a_radar_strike;

    // The offset to calculate the position where the missile should land
    // {0, 0} is top left of the tile and {1, 1} is bottom right
    this.pivot = {
        x: 0.5,
        y: 0.5
    };
}

WeaponBase.prototype.contructor = WeaponBase;

WeaponBase.SpecialWeapons = {
    default: 0,
	airStrike: 1,
	bomb: 2,
	radar: 3,
	torpedo: 4,
	scatter: 5,
}

/** Makes a tile object that has the properties x, y and index */
WeaponBase.prototype.makeTile = function(x, y) {
    return { x: x, y: y, index: y * TileMapValues.ROWS + x };
}

WeaponBase.prototype.makeTileCross = function(x, y, mapWidth, mapHeight) {
    var tiles = [];

    for (var i = 0; i < mapWidth; i++) {
        tiles.push(this.makeTile(i, y));
    }

    for (var i = 0; i < mapHeight; i++) {
        if (i === y) {
            // Skip the center tile the second time
            continue;
        }
        tiles.push(this.makeTile(x, i));
    }

    return tiles;
}

WeaponBase.prototype.makeTileSquare = function(x, y, width, height) {
    var tiles = [];

    for (var i = x; i <= width; i++) {
        for (var j = y; j <= height; j++) {
            tiles.push(this.makeTile(i, j));
        }
    }

    return tiles;
}

/** Adjusts the x position so that the reticles won't go outside the board */
WeaponBase.prototype.adjustX = function(x) {
    if (x < this.requiredOffsets.left) {
        return this.requiredOffsets.left;
    }
    else if (x > TileMapValues.ROWS - 1 - this.requiredOffsets.right) {
        return TileMapValues.ROWS - 1 - this.requiredOffsets.right;
    }
    return x;
}

/** Adjusts the y position so that the reticles won't go outside the board */
WeaponBase.prototype.adjustY = function(y) {
    if (y < this.requiredOffsets.top) {
        return this.requiredOffsets.top;
    }
    else if (y > TileMapValues.ROWS - 1 - this.requiredOffsets.bottom) {
        return TileMapValues.ROWS - 1 - this.requiredOffsets.bottom;
    }
    return y;
}

WeaponBase.prototype.onMissileFire = function(missile, radarStrikes, onDoneCallback, container) {
    "use strict";

    missile.fireAnimation.setOnComplete(function() {
        for (var i = 0; i < radarStrikes.length; i++) {
            radarStrikes[i].show();
        }

        if (onDoneCallback) onDoneCallback();
        this.createExplosion({x: missile.position.x, y: missile.position.y}, radarStrikes, container);
    }.bind(this));
}

WeaponBase.prototype.createExplosion = function(worldPos, strikes, container) {
    "use strict";

    var explosion = new RadarExplosion(worldPos.x, worldPos.y, this, container);

    // Play the explosion animation
    explosion.playAnimation(function () {

        // Call the onExplosion event of the weapon when the animation starts playing
        this.onExplosion(explosion, strikes, function () {

            // Destroy the explosion when it's finished
            explosion.destroy(function () {
                explosion = null;

            }.bind(this));
        }.bind(this));
    }.bind(this));
}

WeaponBase.prototype.onExplosion = function(explosion, radarStrikes, onDoneCallback) {
    "use strict";
    explosion.explosionAnimation.setOnComplete(function() {
        if (onDoneCallback) onDoneCallback();
    });
}

WeaponBase.prototype.generateShotTiles = function(x, y) {
    return [this.makeTile(x, y)];
}

WeaponBase.prototype.generateHighlightCenters = function(x, y) {
    return [this.makeTile(x, y)]
}

WeaponBase.prototype.generateHighlightTiles = function(x, y, mapWidth, mapHeight) {
    return this.makeTileCross(x, y, mapWidth, mapHeight);
}

/** Changes the state of the rotation */
WeaponBase.prototype.rotate = function() {
    "use strict";

    // Invert the rotation state
    this.isRotated = !this.isRotated;
}

/** Returns whether the missile should move from front to back or the other way around */
WeaponBase.prototype.getMissileDirection = function(tileToBeHit) {
    return tileToBeHit.ty >= TileMapValues.COLS / 2;
}

/** Returns the name of the explosion animation */
WeaponBase.prototype.getExplosionAnimationName = function () {
    return this.explosionAnimationName;
}

/** Returns the name of the missile animation */
WeaponBase.prototype.getMissileAnimationName = function(frontToBack) {
    
    return this.missileAnimationName + "_" + (frontToBack ? "top_to_bottom" : "bottom_to_top");
}
//******************************************************
//*****    Script Resource: SpecialWeaponAirStrike
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var SpecialWeaponAirStrike = function() {
    "use strict";

    WeaponBase.prototype.contructor.call(this);

    // Base class values
    this.reticlesAmount = 5;
    this.weaponID = WeaponBase.SpecialWeapons.airStrike;

    // How much the reticles expand from the middle
    this.expandOffset = 2;

    this.canRotate = true;

    this.explosionAnimationName = "Special_weapon_01";
    this.missileAnimationName = "Special_weapon_01";

    this.shootSound = a_shoot_airstrike;

    // The offsets to prevent the reticles from going outside the board
    this.requiredOffsets.top = 2;
    this.requiredOffsets.left = 0;
    this.requiredOffsets.right = 0;
    this.requiredOffsets.bottom = 2;
}

// Inheritance
tgfComponents.inherit(SpecialWeaponAirStrike, WeaponBase);
SpecialWeaponAirStrike.prototype.contructor = SpecialWeaponAirStrike;

SpecialWeaponAirStrike.prototype.onMissileFire = function(missile, radarStrikes, onDoneCallback, container) {
    "use strict";
    var strikeIterator = 0;

    // Sort the strikes so they appear in the correct order
    radarStrikes = this.sortStrikes(radarStrikes, missile.frontToBack);

    // Show the strikes in order
    missile.fireAnimation.animation.state.onEvent = function(trackIndex, event) {
        // Show a strike
        if (strikeIterator < radarStrikes.length) {
            radarStrikes[strikeIterator].show();
        }

        // Execute the explosion event
        if (strikeIterator == Math.ceil(radarStrikes.length / 2)) {
            this.createExplosion({x: missile.position.x, y: missile.position.y}, radarStrikes, container);
        }

        strikeIterator++;
    }.bind(this);

    missile.fireAnimation.setOnComplete(function() {
        if (onDoneCallback) onDoneCallback();
    });
}

SpecialWeaponAirStrike.prototype.sortStrikes = function(radarStrikes, frontToBack) {
    "use strict";

    console.log("before sort: ", radarStrikes);
    radarStrikes.sort(function(a, b) {
        // Compare either the x or y pos depending on the rotation
        var compareA = this.isRotated ? a.worldX : a.worldY;
        var compareB = this.isRotated ? b.worldX : b.worldY;

        // Swap the compares if the Missile goes from back to front
        if (!frontToBack) {
            var swap = compareA;
            compareA = compareB;
            compareB = swap;
        }

        // Sort the strikes so that they appear in the correct order
        if (compareA < compareB) return -1;
        if (compareA > compareB) return 1;
        return 0;
    }.bind(this));
    console.log("after sort: ", radarStrikes);

    return radarStrikes;
}

SpecialWeaponAirStrike.prototype.generateShotTiles = function(x, y) {
    "use strict";

    var tiles = [];
    for(var i = -this.expandOffset; i <= this.expandOffset; i++) {
        // Calculate the x and y position based on the rotation state (vertical or horizontal)
        var xi = this.isRotated ? x + i : x;
        var yi = !this.isRotated ? y + i : y;

        tiles.push(WeaponBase.prototype.makeTile(xi, yi));
    }
    return tiles;
}

/** The AirStrike special swaps the offsets when rotating */
SpecialWeaponAirStrike.prototype.rotate = function() {
    "use strict";

    WeaponBase.prototype.rotate.call(this);

    // Swap left and top offset
    var swap = this.requiredOffsets.top;
    this.requiredOffsets.top = this.requiredOffsets.left;
    this.requiredOffsets.left = swap;

    // Swap right and bottom offset
    swap = this.requiredOffsets.right;
    this.requiredOffsets.right = this.requiredOffsets.bottom;
    this.requiredOffsets.bottom = swap;
}

/** Returns whether the missile should move from front to back or the other way around */
WeaponBase.prototype.getMissileDirection = function(tileToBeHit) {
    if (this.isRotated) {
        return tileToBeHit.tx >= TileMapValues.ROWS / 2;
    }
    return tileToBeHit.ty >= TileMapValues.COLS / 2;
}

SpecialWeaponAirStrike.prototype.getMissileAnimationName = function(frontToBack) {
    var frontToBackString = this.isRotated ? "left_to_right" : "top_to_bottom";
    var backToFrontString = this.isRotated ? "right_to_left" : "bottom_to_top";

    return this.missileAnimationName + "_" + (frontToBack ? frontToBackString : backToFrontString);
}

//******************************************************
//*****    Script Resource: SpecialWeaponBomb
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

SpecialWeaponBomb = function() {
    "use strict";

    WeaponBase.prototype.contructor.call(this);

    // Base class values
    this.reticlesAmount = 5;
    this.weaponID = WeaponBase.SpecialWeapons.bomb;

    this.canRotate = true;

    this.explosionAnimationName = "Special_weapon_02";
    this.missileAnimationName = "Special_weapon_02";

    this.shootSound = a_shoot_bomb;

    // The offsets to prevent the reticles from going outside the board
    this.requiredOffsets.top = 1;
    this.requiredOffsets.left = 1;
    this.requiredOffsets.right = 1;
    this.requiredOffsets.bottom = 1;
}

tgfComponents.inherit(SpecialWeaponBomb, WeaponBase);
SpecialWeaponBomb.prototype.contructor = SpecialWeaponBomb;

SpecialWeaponBomb.prototype.onMissileFire = function(missile, radarStrikes, onDoneCallback, container) {
    "use strict";

    missile.fireAnimation.setOnComplete(function() {
        // Only show the center strike
        for (var i = 0; i < radarStrikes.length; i++) {
            if (radarStrikes[i].isCenterTile) {
                radarStrikes[i].show();
                break;
            }
        }
        if (onDoneCallback) onDoneCallback();
        this.createExplosion({x: missile.position.x, y: missile.position.y}, radarStrikes, container);
    }.bind(this));
}

SpecialWeaponBomb.prototype.onExplosion = function(explosion, radarStrikes, onDoneCallback) {
    "use strict";
    var strikeIterator = 0;

    console.log("Amount of radarstrikes ",  radarStrikes.length);
    explosion.explosionAnimation.animation.state.onEvent = function(trackIndex, event) {
        // Show a strike
        if (strikeIterator < radarStrikes.length && !radarStrikes[strikeIterator].isCenterTile) {
            radarStrikes[strikeIterator].show();
        }
        strikeIterator++;
    }

    WeaponBase.prototype.onExplosion.call(this, explosion, radarStrikes, onDoneCallback);
}

SpecialWeaponBomb.prototype.generateShotTiles = function(x, y) {
    "use strict";

    var tiles = [];

    // Calculate the offset based on if it's rotated or not
    var diagonalOffset = this.isRotated ? 0 : 1;

    tiles.push(WeaponBase.prototype.makeTile(x, y));

    tiles.push(WeaponBase.prototype.makeTile(x - 1, y - diagonalOffset));
    tiles.push(WeaponBase.prototype.makeTile(x + diagonalOffset, y - 1));

    tiles.push(WeaponBase.prototype.makeTile(x - diagonalOffset, y + 1));
    tiles.push(WeaponBase.prototype.makeTile(x + 1, y + diagonalOffset));

    return tiles;
}

/** Returns the name of the animation */
SpecialWeaponBomb.prototype.getExplosionAnimationName = function() {
    return this.explosionAnimationName + "_" + (!this.isRotated ? "diagonal" : "vertical");
}
//******************************************************
//*****    Script Resource: SpecialWeaponTorpedo
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var SpecialWeaponTorpedo = function() {
    "use strict";

    WeaponBase.prototype.contructor.call(this);

    // Base class values
    this.reticlesAmount = 4;
    this.weaponID = WeaponBase.SpecialWeapons.torpedo;

    // How much the reticles expand from the middle
    this.expandOffset = 2;

    this.canRotate = false;

    // The names of the animation to load them
    this.explosionAnimationName = "Special_weapon_04";
    this.missileAnimationName = "Special_weapon_04";

    this.shootSound = a_shoot_torpedo;

    // The offsets to prevent the reticles from going outside the board
    this.requiredOffsets.left = 1;
    this.requiredOffsets.top = 1;

    // The offset to calculate the position where the missile should land
    this.pivot = {
        x: 0,
        y: 0
    };
}

// Inheritance
tgfComponents.inherit(SpecialWeaponTorpedo, WeaponBase);
SpecialWeaponTorpedo.prototype.contructor = SpecialWeaponTorpedo;

SpecialWeaponTorpedo.prototype.generateShotTiles = function(x, y) {
    "use strict";
    var tiles = [];

    tiles.push(this.makeTile(x, y));
    tiles.push(this.makeTile(x - 1, y));
    tiles.push(this.makeTile(x, y - 1));
    tiles.push(this.makeTile(x - 1, y - 1));

    return tiles;
}

SpecialWeaponTorpedo.prototype.generateHighlightCenters = function(x, y) {
    return [this.makeTile(x, y), this.makeTile(x - 1, y - 1), this.makeTile(x - 1, y), this.makeTile(x, y - 1)]
}

SpecialWeaponTorpedo.prototype.generateHighlightTiles = function(x, y, mapWidth, mapHeight) {
    var tiles = this.makeTileCross(x, y, mapWidth, mapHeight)
        .concat(this.makeTileCross(x - 1, y - 1, mapWidth, mapHeight));

    return tiles;
}

SpecialWeaponTorpedo.prototype.onMissileFire = function(missile, radarStrikes, onDoneCallback, container) {
    "use strict";
    missile.fireAnimation.setOnComplete(function() {
        if (onDoneCallback) onDoneCallback();
        this.createExplosion({x: missile.position.x, y: missile.position.y}, radarStrikes, container);
    }.bind(this));
}

SpecialWeaponTorpedo.prototype.onExplosion = function(explosion, radarStrikes, onDoneCallback) {
    "use strict";

    for (var i = 0; i < radarStrikes.length; i++) {
        setTimeout(function (strikeIterator) {
            console.log(radarStrikes);
            radarStrikes[strikeIterator].show();
        }, 70 * i, i);
    }

    WeaponBase.prototype.onExplosion.call(this, explosion, radarStrikes, onDoneCallback);
}
//******************************************************
//*****    Script Resource: SpecialWeaponScattershot
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var SpecialWeaponScattershot = function() {
    "use strict";

    WeaponBase.prototype.contructor.call(this);

    // Base class values
    this.reticlesAmount = 4;
    this.weaponID = WeaponBase.SpecialWeapons.scatter;

    // How much the reticles expand from the middle
    this.expandOffset = 2;

    this.canRotate = false;

    // The names of the animation to load them
    this.explosionAnimationName = "Special_weapon_05";
    this.missileAnimationName = "Special_weapon_05";

    this.shootSound = a_shoot_scattershot;

    // The offsets to prevent the reticles from going outside the board
    this.requiredOffsets.top = 2;
    this.requiredOffsets.right = 2;
    this.requiredOffsets.bottom = 2;
    this.requiredOffsets.left = 2;

    // The offset to calculate the position where the missile should land
    this.pivot = {
        x: 0.5,
        y: 0.5
    };

    this.lastTiles = [];
    this.lastTilesTime = 0;
    this.lastCenter = null;
}

// Inheritance
tgfComponents.inherit(SpecialWeaponScattershot, WeaponBase);
SpecialWeaponScattershot.prototype.contructor = SpecialWeaponScattershot;

SpecialWeaponScattershot.prototype.generateShotTiles = function(x, y) {
    "use strict";
    var tiles = [];

    if (this.lastTilesTime + 700 < Date.now()) {
        for (var i = 0; i < 4; i++) {
            var randomX = Math.floor(Math.random() * 5 - 2);
            var randomY = Math.floor(Math.random() * 5 - 2);
            var tile = this.makeTile(x + randomX, y + randomY)
            var isDuplicate = false;
            for (var j = 0; j < tiles.length; j++) {
                if (tile.x === tiles[j].x && tile.y === tiles[j].y) {
                    i--;
                    isDuplicate = true;
                }
            }
            if (!isDuplicate) {
                tiles.push(tile);
            }
        }

        this.lastTiles = tiles;
        this.lastTilesTime = Date.now();
        this.lastCenter = this.makeTile(x, y)
    } else {
        var currentCenter = this.makeTile(x, y);
        if (!(currentCenter.x === this.lastCenter.x && currentCenter.y === this.lastCenter.y)) {
            var difference = this.makeTile(currentCenter.x - this.lastCenter.x, currentCenter.y - this.lastCenter.y);
            for (var i = 0; i < this.lastTiles.length; i++) {
                this.lastTiles[i].x = this.lastTiles[i].x + difference.x;
                this.lastTiles[i].y = this.lastTiles[i].y + difference.y;
            }
            this.lastCenter = currentCenter;
        }

        tiles = this.lastTiles;
    }

    return tiles;
}

SpecialWeaponScattershot.prototype.generateHighlightTiles = function(x, y, mapWidth, mapHeight) {
    var tiles = this.makeTileCross(x, y, mapWidth, mapHeight)
        .concat(this.makeTileSquare(x - 2, y - 2, x + 2, y + 2));

    return tiles;
}

SpecialWeaponScattershot.prototype.onMissileFire = function(missile, radarStrikes, onDoneCallback, container) {
    "use strict";
    missile.fireAnimation.setOnComplete(function() {
        if (onDoneCallback) onDoneCallback();
        this.createExplosion({x: missile.position.x, y: missile.position.y}, radarStrikes, container);
    }.bind(this));
}

SpecialWeaponScattershot.prototype.createExplosion = function(worldPos, strikes, container) {
    "use strict";

    for (var i = 0; i < strikes.length; i++) {
        setTimeout(function(strike) {
            var explosion = new RadarExplosion(strike.worldX + TileMapValues.WIDTH / 2, strike.worldY + TileMapValues.HEIGHT / 2, this, container);

            // Play the explosion animation
            explosion.playAnimation(function () {

                // Call the onExplosion event of the weapon when the animation starts playing
                this.onExplosion(explosion, strike, function () {

                    // Destroy the explosion when it's finished
                    explosion.destroy(function () {
                        explosion = null;

                    }.bind(this));
                }.bind(this));
            }.bind(this));
        }.bind(this), 100 * i, strikes[i]);
    }
}

SpecialWeaponScattershot.prototype.onExplosion = function(explosion, radarStrike, onDoneCallback) {
    "use strict";

    setTimeout(function() {
        console.log(radarStrike);
        radarStrike.show();
        WeaponBase.prototype.onExplosion.call(this, explosion, [radarStrike], onDoneCallback);
    }.bind(this), 200);
}
//******************************************************
//*****    Script Resource: UserDataController
//******************************************************


var UserDataController = (function() {


	var _UserDataController = function() {

		this._data = {};
		this._data.id = 'fb123379';

		this._currentMatchId = null;

		this._dataMatch = null;
		this._dataBattle = null;

		this._extraShotData = null;
		this._specialWeaponData = null;

		this._groupMatchMap = null;

		// default values
		this._boardResult = {};
		this._radarResult = {};

		window.ud = this;
	}

	_UserDataController.prototype.constructor = _UserDataController;


	_UserDataController.prototype.initialize = function(id, data) {

		// TODO - parse data
		this._data.id = id;
	}

	_UserDataController.prototype.setCurrentMatchId = function(matchId) {

		this._currentMatchId = matchId;
	}

	_UserDataController.prototype.getCurrentMatchId = function() {

		return this._currentMatchId;
	}

	_UserDataController.prototype.setExtraShotData = function(extraShotData) {

		this._extraShotData = extraShotData;
	}

	_UserDataController.prototype.getExtraShotData = function() {

		return this._extraShotData;
	}


	_UserDataController.prototype.setSpecialWeaponData = function(specialWeaponData) {
		this._specialWeaponData = specialWeaponData;
	}

	_UserDataController.prototype.getSpecialWeaponData = function() {

		return this._specialWeaponData;
	}

	_UserDataController.prototype.setRankData = function(rankData) {
		this._rankData = rankData;
	}

	_UserDataController.prototype.getRankData = function() {

		return this._rankData;
	}

	_UserDataController.prototype.setAppUsageData = function(appUsageData) {

		this._appUsageData = appUsageData;
	}

	_UserDataController.prototype.getAppUsageData = function() {

		return this._appUsageData;
	}


	_UserDataController.prototype.setEntryMatchId = function(entryMatchId) {

		this._entryMatchId = entryMatchId;
	}

	_UserDataController.prototype.getEntryMatchId = function() {

		return this._entryMatchId;
	}

	_UserDataController.prototype.setGroupMatchIdMap = function(groupMatchMap) {

		this._groupMatchMap = groupMatchMap;
	}

	_UserDataController.prototype.getGroupMatchIdMap = function() {

		return this._groupMatchMap;
	}

	_UserDataController.prototype.isTimedMatch = function() {

		var md = this._dataMatch;

		if (md && md.isTimed) {
			return true;
		}
		else {
			return false;
		}
	}

	_UserDataController.prototype.setMatch = function(matchId, dataMatch, dataBattle, specialWeaponData) {

		this._currentMatchId = matchId;

		this._dataMatch = dataMatch;
		this._dataBattle = dataBattle;

		// AAARGH NOOOOOO
		// this._specialWeaponData = specialWeaponData;
	}

	_UserDataController.prototype.getMatchData = function() {

		return this._dataMatch;
	}

	_UserDataController.prototype.getBattleData = function() {

		return this._dataBattle;
	}

	_UserDataController.prototype.clearMatch = function() {

		this._currentMatchId = null;

		this._dataMatch = null;
		this._dataBattle = null;
		// this._specialWeaponData = null;
	}

	_UserDataController.prototype.getData = function() {

		return this._data;
	}


	_UserDataController.prototype.getExperience = function() {

		return this._experience || 0;
	}

	_UserDataController.prototype.getField = function(name) {

		var fieldValue = null;

		if (this._data[name]) fieldValue = this._data[name];

		return fieldValue;
	}


	_UserDataController.prototype.setBoardResult = function(boardResult) {

		this._boardResult = boardResult;
	}

	_UserDataController.prototype.setRadarResult = function(radarResult) {

		this._radarResult = radarResult;
	}

	_UserDataController.prototype.getBoardResult = function() {

		// this._boardResult = {
		// 	shots: 8,
		// 	hits: 8,
		// 	misses: 8,
		// }

		return this._boardResult;
	}

	_UserDataController.prototype.getRadarResult = function() {

		// this._radarResult = {
		// 	shots: 8,
		// 	hits: 8,
		// 	misses: 8,
		// }

		return this._radarResult;
	}


	return new _UserDataController();
}());

//******************************************************
//*****    Script Resource: MatchData
//******************************************************

var MatchData = function() {

	this.players = [];

	// player-data hashmap by id - see addPlayer
	this.playerTurn = 1;
	this.playerState = 0;
	this.playerData = {};

	this.contextID = null;

	// add player-id when she opens result screen
	this.matchDone = [];
	this.isRandom = false;
	this.isGroupMatch = false;

	this.specialWeaponsUsed = [0,0];
	
	// TRO VARS
	this.isTimed = false;
	this.serverTime = null;
	this.lastActiveUser = null;
	
	this._locked = false;
}

MatchData.prototype.constructor = MatchData;

MatchData.prototype.parseData = function(rawData) {

	this._locked = false;

	var data = rawData;

	this.players = data.players;
	this.playerTurn = data.playerTurn;
	this.playerState = data.playerState;
	this.playerData = {};

	this.specialWeaponsUsed = rawData.specialWeaponsUsed || this.specialWeaponsUsed;
	if (this.specialWeaponsUsed.length < 2) this.specialWeaponsUsed = [0,0];

	var arrPlayerData = data.playerData;
	var len = Object.keys(arrPlayerData).length;


	for (var i = 0; i < len; i++) {

		// console.log('MD:key', i, Object.keys(arrPlayerData)[i]);
		if (!Object.keys(arrPlayerData)[i]) continue;


		var old_key = Object.keys(arrPlayerData)[i];
		var new_key = 'player' + parseInt(i+1);

		Object.defineProperty(this.playerData, new_key, Object.getOwnPropertyDescriptor(data.playerData, old_key));
	}

	this.contextID = data.contextID;
	this.matchDone = data.matchDone || [];
	
	this.isRandom = data.isRandom || false;
	this.isGroupMatch = data.isGroupMatch || false;

	// TRO parsing
	this.isTimed = data.isTimed || false;
	this.serverTime = data.serverTime || null;
	this.lastActiveUser = data.lastActiveUser || null;
}



MatchData.prototype.registerSpecialWeapon = function() {

	var playerIndex = this.getPlayerIndex(tgfHooks.getPlayerID());
	var amount = this.specialWeaponsUsed[playerIndex];

	this.specialWeaponsUsed[playerIndex]++;

	console.log('MD.SW::registerSpecialWeapon', this.specialWeaponsUsed[playerIndex]);
}

MatchData.prototype.getSpecialWeaponUsages = function() {

	var playerIndex = this.getPlayerIndex(tgfHooks.getPlayerID());


	var swUsed = 0;
	if (this.specialWeaponsUsed && this.specialWeaponsUsed[playerIndex]) {
		swUsed = this.specialWeaponsUsed[playerIndex];
	}

	console.log('MD.SW::getSpecialWeaponUsages', this.specialWeaponsUsed);
	console.log('MD.SW::swUsed', swUsed);
	
	return swUsed;
}

MatchData.prototype.addPlayer = function(playerId, data) {


	// console.log('MD:addPlayer', playerId, data, this.players, this.playerData);
	
	// hacky BOT fix <-- BATTLE-351 data-rewrite
	if ((this.players.indexOf(playerId) >= 0) && playerId == 'BOT') { 

		this.playerData['player' + parseInt(Object.keys(this.playerData).length+1)] = data;
	}
	// end hacky fix


	if (this.players.length == 2) return;

	this.players.push(playerId);

	// add extra player data to hashmap: name, etc
	data = data || {};

	// console.log('MD:addPlayer', playerId, data);


	var len = Object.keys(this.playerData).length;
	this.playerData['player' + parseInt(len+1)] = data;

	// console.log('MD:addPlayer.playerData', this.playerData);
}

MatchData.prototype.updatePlayerAvatar = function() {

	// skip this!!

	

	// var playerId = tgfHooks.getPlayerID();

	// for (var i = 0; i < Object.keys(this.playerData).length; i++) {

	// 	var p = this.playerData[ Object.keys(this.playerData)[i] ];
		
	// 	if (p && p.id == playerId) {
	// 		this.playerData[ Object.keys(this.playerData)[i] ].photo = FBInstant.player.getPhoto();
	// 		break;
	// 	}
	// }
}


MatchData.prototype.isRandomOpponent = function() {
	
	return this.isRandom;
}

MatchData.prototype.getCurrentPlayer = function() {

	var playerTurn;

	if (this.players.length <= 1) {

		playerTurn = null;
	}
	else {

		playerTurn =  this.players[this.playerTurn % this.players.length];
	}

	return playerTurn;
}

MatchData.prototype.getPlayerIndex = function(playerId) {

	return this.players.indexOf(playerId);
}


MatchData.prototype.getPlayerData = function(playerId) {

	var pd = null;

	for (var i = 0; i < Object.keys(this.playerData).length; i++) {

		var p = this.playerData[ Object.keys(this.playerData)[i] ];
		// console.log('MatchData.getPlayerData', i, playerId, '->', p);
		// console.log('MatchData->UserDataController.getData().id', UserDataController.getData().id);
		if (p && p.id == playerId) {
			pd = p;
			break;
		}
	}

    return pd;
    // return this.playerData[ playerId ];
}


MatchData.prototype.getOpponentData = function(playerId) {

	var opponentData = {
		id: "-1",
		name: tgfDictionary.getText('LobbyPending'),
		photo: '[DEFAULT]'
	};

	for (var i = 0; i < this.players.length; i++) {
		if (this.players[i] != playerId) {

			tempOpponentData = this.getPlayerData(this.players[i]);
			if (tempOpponentData) { 
				opponentData = tempOpponentData;
			}
			else {
				// console.log('TEMP', tempOpponentData, playerId, this.players[i]);
			}
			break;
		}
	}

	return opponentData;
}


MatchData.prototype.isRandomOpponent = function() {

	return this.isRandom;
}

MatchData.prototype.isRematch = function() {

	return (this.matchDone.indexOf(UserDataController.getData['id']) >= 0)
}

MatchData.prototype.canSendUpdate = function() {

	return (this.isRandom == false);
}
//******************************************************
//*****    Script Resource: BattleData
//******************************************************

var BattleData = function() {

	this.boards = [];
	this.lastAction = [];

	this._locked = false;

	this.version = '';
}

BattleData.prototype.constructor = BattleData;


BattleData.prototype.parseData = function(rawData) {

	// this._locked = true;

	var data = rawData;

	this.lastAction = [];

	// If the action is an integer, it should be upgraded to the new standard
	for (var i = 0; i < data.lastAction.length; i++) {

		var action = data.lastAction[i];
		var isNumber = Number.isInteger(action);
		if (isNumber) this.lastAction.push(BattleData.patchToActionElement(action)); // No rotation or strike info needed, is regular strike.
		else this.lastAction.push(action); // Already an action element
	}

	this.boards = data.boards;

	this.version = _version;

	// console.log('BD::VERSION', this);
}


BattleData.generateActionElement = function(center, tiles, strikeType, rotateID) {
	return {
		center: center,
		tiles: tiles.concat(),
		strikeID: strikeType,
		rotateID: rotateID
	}
};

BattleData.patchToActionElement = function(action) {
	return BattleData.generateActionElement(action, [ action ], SpecialWeaponData.SpecialWeapon.default, 0);
};


BattleData.prototype.addBoard = function(board) {

	this.boards.push(board);
}

BattleData.prototype.hasBoard = function(playerIndex) {

	// ie: player1 -> player index 0 -> len 1
	return this.boards.length > playerIndex;
}


BattleData.prototype.getBoard = function(playerIndex) {

	// TODO: add error message

	var board = null;

	if (playerIndex < this.boards.length ) {

		board = this.boards[playerIndex];
	} 

	return board;
}

BattleData.prototype.setOpponentBoard = function(playerIndex, mapData) {

	// TODO: add error message
	this.boards[ ( (playerIndex + 1) % this.boards.length) ] = mapData;
}

BattleData.prototype.getOpponentBoard = function(playerIndex) {

	// TODO: add error message
	return this.boards[ ( (playerIndex + 1) % this.boards.length) ];
}

BattleData.prototype.syncBoardToMap = function(boardIndex, mapArray) {
	// todo
}
//******************************************************
//*****    Script Resource: UserMatches
//******************************************************

var UserMatches = (function() {

	var _UserMatches = function() {

		this._matches = [];

		this._matchesSynced = false;
	}

	_UserMatches.prototype.constructor = _UserMatches;




	_UserMatches.prototype.setDelayedTrackingMatch = function(type, messageType, matchId) {

		this._delayedTrackingEntryMatch = {
			type: type,
			messageType: messageType,
			matchId: matchId,
		};
	},

	_UserMatches.prototype.matchSyncingCompromised = function () {

		// matches need to be resynced because of disconnect
		this._matchesSynced = false;
	}

	_UserMatches.prototype.initialize = function(callback) {

		var self = this;

		// no disconnect, lobby should be good -> callback
		// TODO: re-enable this when sync status is more accurate
		// if (this._matchesSynced) {

		// 	console.log('UM::synced -> no-load');
		// 	callback();
			
		// 	return;
		// }
		
		console.log('UM::synced -> normal-load');

		// load lobby normally
		this._matches = [];
		
		this._userData = UserDataController.getData();
		
		// always do this
		this._backendService = BackendServiceProvider.getService();

		
		OpponentOnlineManager.initialize();

		// console.log('initialize UserMatches');

		

	    var listMatches = null;
		// this._backendService.listMatches(['state', 'battle', 'rematch'], function(data) {
		this._backendService.listMatches(['state', 'rematch'], function(data) {

			listMatches = data;	
			
			self._matchesSynced = true;
	    	// console.log('onListMatchesDone:', data, Object.keys(listMatches).length, Object.keys(listMatches));


			// loop through matches
		    if (Object.keys(listMatches).length > 0) {

		    	var matches = Object.keys(listMatches);
				var len = Object.keys(listMatches).length;
				var matchId = null;

				var playerId = UserDataController.getData().id;

				for (var i = 0; i < len; i++) {

					var matchId = String(matches[i]);
					var matchData = listMatches[matchId];


					if (this._delayedTrackingEntryMatch) {

						if (this._delayedTrackingEntryMatch.matchId == matchId) {

							if (matchData.state) {

								var userMatchesGameType = 'challenge';

								if (matchData.state.isRandom && matchData.state.isRandom == true) userMatchesGameType = 'random';
								if (matchData.state.isTimed && matchData.state.isTimed == true) userMatchesGameType = 'instant_play';

								BattleshipsAnalytics.reportClickedFacebookMessage(this._delayedTrackingEntryMatch.type, this._delayedTrackingEntryMatch.messageType, userMatchesGameType);
							}
							else {
								
								BattleshipsAnalytics.reportClickedFacebookMessage(this._delayedTrackingEntryMatch.type, this._delayedTrackingEntryMatch.messageType);
							}
							
							this._delayedTrackingEntryMatch = null;
						}
					}


					if (!matchData.state.matchDone) matchData.state.matchDone = [];
					
					var playerTurn;

					// if only one player?
					if (matchData.state.players.length == 1) {
						playerTurn = -1;
					} 
					else {
						playerTurn = matchData.state.players[matchData.state.playerTurn % matchData.state.players.length];
					}
					

					var opponentData = {
						name: tgfDictionary.getText('LobbyPending'),
						photo: '[DEFAULT]'
					};

					var md = matchData.state;

					for (var j = 0; j < md.players.length; j++) {
						if (md.players[j] != playerId) {

							// opponentData = md.playerData[md.players[j]];
							// console.log(md.playerData);
							// console.log(md.playerData[md.players[j]] );
							// console.log(md.playerData[j]);
							// console.log( Object.keys(md.playerData)[j] );
							// console.log('===');
							// --------------------------------------
							//
							// !! SCARY FIX !!
							//
							// --------------------------------------
							var tmd = new MatchData();
							tmd.parseData(md);

							// opponentData = md.playerData[Object.keys(md.playerData)[j] ];
							opponentData = tmd.getOpponentData(playerId);

							// console.log(i, opponentData.id);

							OpponentOnlineManager.registerUserId(opponentData.id);

							// console.log('oppo-data', tmd.getOpponentData(playerId) );
							// if (!opponentData) {

							// }
							// console.log('oppo', i, playerId, md.players[j], Object.keys(md.playerData)[j], opponentData);
							break;
						}
					}

					var opponentData = opponentData;
					
					var completed = false; // (matchData.state.matchDone.length > 0) ? true : false;
					if (matchData.state.matchDone.indexOf(this._userData.id) >= 0 ) {
						completed = true;

						// console.log('RM:UM', matchData.rematch);

						if (matchData.rematch) {
							var rm = new RematchData();
							rm.parseData(matchData.rematch);

							// console.log('RM:UM-> rm', rm);
							// window.__rm = rm;
							// console.log('RM:UM->', this._userData.id, rm, rm.getPlayer(this._userData.id));
							
							if (rm.getPlayer(this._userData.id) ) {
								completed = false;
								playerTurn = -1;
							} 
							else {
								if ( rm.getPlayersAgreed() >= 1 ) {

									completed = false;
									playerTurn = tgfHooks.getPlayerID();
								}
							}
						}
					}

					// debug ONLY
					// if (!completed) {
					// 	matchData.state.matchDone.push(this._userData.id);
					// 	completed = true;
					// }
					// end debug only

					// console.log('UM::matchData.state.isTimed', matchData.state.isTimed);

					if (matchData.state.isTimed == true) {

						var tooLate = false;

						if (matchData.state.serverTime) {
							
							var diff = TimeManager.getTime().server - matchData.state.serverTime;

							console.log('UM time-diff ->', matchData.state.serverTime, TimeManager.getTime().server, diff);

							if (diff > 60000) {
								// too late
								tooLate = true;
							}
						}

						if (matchData.state.matchDone.length == 0 && !tooLate) {						

							UserDataController.setCurrentMatchId(matchId);
						}
						else if (matchData.state.matchDone.length == 1 && (matchData.state.matchDone[0] != tgfHooks.getPlayerID()) && !tooLate ) {
							
							UserDataController.setCurrentMatchId(matchId);
						}
						else {

							BackendServiceProvider.getService().removePlayerFromMatches([matchId], function() {

								console.log('UM.removed from finished TRO', matchId);
							},
							function() {

								console.log('UM.failed to remove from finished TRO', matchId);
							})

							matchData = null;
						}
					}

					if (matchData) {

						this._matches.push({id: matchId, data: matchData, turn:playerTurn, opponentData: opponentData, completed: completed});
					}

					// console.log('push match', this._matches.length);
				}
				console.log('MATCHES READY::', this._matches);


				// fetch opponent-online statuses once
				// if (this._isRegisteredOnce) {

				// 	if (callback) callback();
				// }
				// else {
				// else {

					// this._isRegisteredOnce = true;
					OpponentOnlineManager.getOpponentStatuses(function(result) {

						console.log(result);
						
						if (callback) callback();

					}.bind(this));
				// }


			}
			else {
				console.log('no MATCHES FOUND');
				if (callback) callback();
			}

	    }.bind(this));
	}

	_UserMatches.prototype.fetchMatches = function() {

	}

	_UserMatches.prototype.updateMatches = function() {

	}

	_UserMatches.prototype.updateMatch = function(matchId, type, data) {

		var rawMatch = null;
		var updateLobby = false;

		for (var i = 0; i < this._matches.length; i++) {

			if (matchId == this._matches[i].id) {
				rawMatch = this._matches[i];
				
				if (type == 'NEXT_TURN') {
					
					rawMatch.turn = UserDataController.getData().id;
					updateLobby = true;
				}
				else if (type == "BOARD_READY") {
					
					console.log('UserMatches.updateMatch-->BOARD_READY', data);
					if (data && data.msg && data.msg.data && data.msg.data.userData) {

						rawMatch.opponentData = data.msg.data.userData;
					}
					// rawMatch.turn = UserDataController.getData().id;
				}

				console.log('RAWMATCH:', rawMatch);

				break;
			}
		}


		if (updateLobby) {

			tbGame.addSpecial('lobby-refresh');
		}
	}

	_UserMatches.prototype.getMatches = function(callback, filtered) {

		var data;

		if (!this._userData) return callback(this._matches); 

		// console.log('	getMatches', this._userData.id, this._matches);

		if (filtered) {

			data = {};
			data.active = [];
			data.inactive = [];
			data.done = [];

			var match;

			for (var i = 0; i < this._matches.length; i++) {

				match = this._matches[i];

				if (match.data.state.isGroupMatch) {
					continue;
				}

				if (match.completed == true) {

					data.done.push(match);
				}
				else if (match.turn == this._userData.id) {

					data.active.push(match); 
				}
				else {
					data.inactive.push(match);
				}
			}
		}
		else {
			data = this._matches.concat();
		}
		

		if (callback) callback(data);
	}

	_UserMatches.prototype.getMatchByContext = function(contextID) {

		var data = null;
		var nextMatchId = null;
		
		// console.log('getMatchByContext', contextID);
		this.getMatches(function(d) {
			data = d;
		}, false);

		// console.log(data);	
		// console.log('UserMatches.getMatchByContext?contextID=', contextID);

		for (var i = 0; i < data.length; i++) {

			if (data[i].data.state.contextID == contextID) {

				nextMatchId = data[i].id;
				// console.log('	match selected with index/context', i, contextID, '->', nextMatchId);
				break;
			}				
		}

		return nextMatchId;
	}

	_UserMatches.prototype.getNextActiveMatch = function() {

		var data = null;
		return data;
		
		// console.log('getNextActiveMatch');
		this.getMatches(function(d) {
			data = d;
		}, true);

		// console.log(data);
		// console.log(d);

		var currentMatchId = UserDataController.getCurrentMatchId();
		var nextMatchId = null;
		var nextMatch = null;

		// console.log('UserMatches.getNextActiveMatch?currentMatchId=', currentMatchId, data.active);

		for (var i = 0; i < data.active.length; i++) {

			if (data.active[i].id != currentMatchId) {

				nextMatchId = data.active[i].id;
				nextMatch = data.active[i];
				// console.log('	next match selected at index', i, '->', nextMatchId, nextMatch);
				break;
			}				
		}

		return nextMatch;
	}

	_UserMatches.prototype.setMatchById = function(id, overwriteMatch) {

		var match = this.getMatchById(id);

		if (match) {
			match = overwriteMatch;
		}
	}

	_UserMatches.prototype.getMatchByIdRaw = function(id) {

		var match;

		for (var i = 0; i < this._matches.length; i++) {

			if (id == this._matches[i].id) {
				match = this._matches[i];

				break;
			}
		}

		return match;
	}

	_UserMatches.prototype.getMatchById = function(id) {

		var match;

		for (var i = 0; i < this._matches.length; i++) {

			if (id == this._matches[i].id) {
				match = this._matches[i].data;

				break;
			}
		}

		return match;
	}

	_UserMatches.prototype.getMatchForUser = function(userId) {

		var match = null;
		var matches = [];

		for (var i = 0; i < this._matches.length; i++) {

			var mi = this._matches[i];

			var state = mi.data.state;

			if (state) {

				var players = state.players;

				if (players) {

					if (players.indexOf(userId) >= 0) {
						matches.push(mi);
					}
				}
			}
		}

		if (matches.length > 0) {
			var enterableMatches = [];
			for (var i = 0; i < matches.length; i++) {
				// able to enter matches that are in our turn or in completed matches (rematch)
				if (matches[i].turn !== userId || matches[i].completed) {
					enterableMatches.push(matches[i]);
				}
			}

			if (enterableMatches.length > 0) {
				match = enterableMatches[Math.floor(Math.random() * enterableMatches.length)];
			}
		}

		return match;
	}

	_UserMatches.prototype.getMatchesAmount = function() {

		if (!this._matches) return 0;

		return this._matches.length;
	}


	_UserMatches.prototype.getMatchLobbyStateById = function(id) {

		var match;

		for (var i = 0; i < this._matches.length; i++) {

			if (id == this._matches[i].id) {
				match = this._matches[i];

				break;
			}
		}

		return match;
	}

	return new _UserMatches();
}())

//******************************************************
//*****    Script Resource: SpecialWeaponData
//******************************************************

var SpecialWeaponData = function(setupDefault) {
	// Keeps track of the states of the special weapons
	this.states = [];
	// This are all the default states for every special weapon
	this._defaultStates = [];

	this.availableAt = TimeManager.getTime().serverTime;

	this.setDefaultState(SpecialWeaponData.SpecialWeapon.default, SpecialWeaponData.SpecialWeaponState.down, 0, 0);

	this.setDefaultState(SpecialWeaponData.SpecialWeapon.airStrike, SpecialWeaponData.SpecialWeaponState.inactive, 0, 1);
	this.setDefaultState(SpecialWeaponData.SpecialWeapon.bomb, SpecialWeaponData.SpecialWeaponState.inactive, 0, 1);
	this.setDefaultState(SpecialWeaponData.SpecialWeapon.radar, SpecialWeaponData.SpecialWeaponState.inactive, 0, 1);
	this.setDefaultState(SpecialWeaponData.SpecialWeapon.torpedo, SpecialWeaponData.SpecialWeaponState.inactive, 0, 1);
	this.setDefaultState(SpecialWeaponData.SpecialWeapon.scatter, SpecialWeaponData.SpecialWeaponState.inactive, 0, 1);

	this.states = this._defaultStates;

	this.selectedSpecialWeapon = null;

	this._weapons = {
		default: new WeaponBase(),
		airStrike: new SpecialWeaponAirStrike(),
		bomb: new SpecialWeaponBomb(),
		radar: null,
		torpedo: new SpecialWeaponTorpedo(),
		scatter: new SpecialWeaponScattershot(),
	}
}

SpecialWeaponData.SpecialWeapon = {
	default: 0,
	airStrike: 1,
	bomb: 2,
	radar: 3,
	torpedo: 4,
	scatter: 5,
};

SpecialWeaponData.SpecialWeaponState = {
	up: 0,
	down: 1,
	locked: 2,
	inactive: 3
};

SpecialWeaponData.prototype.constructor = SpecialWeaponData;

SpecialWeaponData.getSpecialWeaponTypeString = function(specialWeaponType) {

	var specialWeaponTypeString = "";
	switch(specialWeaponType) {
		default:
		case SpecialWeaponData.SpecialWeapon.default:
			specialWeaponTypeString = "default";
			break;
		case SpecialWeaponData.SpecialWeapon.airStrike:
			specialWeaponTypeString = "air_strike";
			break;
		case SpecialWeaponData.SpecialWeapon.bomb:
			specialWeaponTypeString = "bomb";
			break;
		case SpecialWeaponData.SpecialWeapon.radar:
			specialWeaponTypeString = "radar";
			break;
		case SpecialWeaponData.SpecialWeapon.torpedo:
			specialWeaponTypeString = "torpedo";
			break;
		case SpecialWeaponData.SpecialWeapon.scatter:
			specialWeaponTypeString = "scatter";
			break;
	};
	return specialWeaponTypeString;
};

/** Returns a state object of the special weapon. See the _makeState function for an example what it returns. */
SpecialWeaponData.prototype.getWeaponInfo = function(specialWeaponType) {
	return this.states[specialWeaponType];
}

/** Updates the state when the special weapon was fired */
SpecialWeaponData.prototype.onFire = function(specialWeaponType) {

	console.log('SpecialWeaponData.onFire', specialWeaponType);

	if (!this.states[specialWeaponType]) {
		return;
	}

	var md = UserDataController.getMatchData();
	AnalyticsService.reportEvent("interaction", "interaction", {
		eventType: "shot",
		value: md.playerTurn
	});

	// update cooldown
	this.states[specialWeaponType].currentCooldown = this.states[specialWeaponType].totalCoolDown;

	// update lock
	if (this.states[specialWeaponType].currentCooldown != 0) {
		this.states[specialWeaponType].state = SpecialWeaponData.SpecialWeaponState.locked;
	}

	// not a normal shot?
	if (specialWeaponType > 0) {
		var name = SpecialWeaponData.getSpecialWeaponTypeString(specialWeaponType);
		AnalyticsService.reportEvent("interaction", "interaction", {
			eventType: "special_weapon",
			id: name
		});

		// register special weapon for result purposes
		if (md) {
			md.registerSpecialWeapon();
		}

		// save usage of powerup, not changing current availableAt
		this.usePowerup(this.availableAt, function() {
			console.log('SPECIAL SAVED');
		});

		BattleshipsAnalytics.reportSpecialWeaponUsed(specialWeaponType);
	}
}

/** Sends a message to BackendServiceProvider to save that the player has used a special weapon */
SpecialWeaponData.prototype.usePowerup = function(timeFuture, callback) {

	// console.log('ESD::', this.availableAt, timeFuture, timeFuture - this.availableAt);

	this.availableAt = timeFuture;

	this.saveData(callback);
}

SpecialWeaponData.prototype.hasWeaponAvailable = function() {
	for (var i = 1; i < this.states.length; i++) {
		if ((this.states[i].state == SpecialWeaponData.SpecialWeaponState.up ||
			this.states[i].state == SpecialWeaponData.SpecialWeaponState.down) &&
			i !== SpecialWeaponData.SpecialWeapon.radar) {
			return true;
		}
	}
	return false;
}

SpecialWeaponData.prototype.unlockWeapon = function(weapon) {

	// Stop if the weapon is unlocked already
	if (this.states[weapon].state != SpecialWeaponData.SpecialWeaponState.inactive) {
		return;
	}

	this.setState(weapon, SpecialWeaponData.SpecialWeaponState.up, 0, 1, false);
	this.saveData();

	console.log("SpecialWeaponData::unlockWeapon weapon " + SpecialWeaponData.getSpecialWeaponTypeString(weapon) + " unlocked");

	BattleshipsAnalytics.reportWeaponUnlock(SpecialWeaponData.getSpecialWeaponTypeString(weapon));

	AnalyticsService.reportEvent("interaction", "interaction", {
		eventType: "unlock",
		id: SpecialWeaponData.getSpecialWeaponTypeString(weapon)
	});
}

/** Checks for any weapon that can be unlocked and unlocks it */
SpecialWeaponData.prototype.updateUnlockableWeapons = function(rank) {

	var unlockableWeapons = WeaponUnlockChart.getUnlockableWeaponsByRank(rank);

	for (var i = 0; i < unlockableWeapons.length; i++) {
		this.unlockWeapon(unlockableWeapons[i]);
	}
}

SpecialWeaponData.prototype.saveData = function(callback) {
	var data = {
		'availableAt': this.availableAt,
		'states': this.states
	};

	if (callback) {
		callback.call();

	}

	StorageManager.set('specialWeapon', data);
}

/** Creates and returns a SpecialWeapon class based on the type. */
SpecialWeaponData.prototype.generateSpecialWeapon = function(specialWeaponType) {
	switch(specialWeaponType) {
		default:
		case SpecialWeaponData.SpecialWeapon.default:
			return this.selectedSpecialWeapon = this._weapons.default;
			break;
		case SpecialWeaponData.SpecialWeapon.airStrike:
			return this.selectedSpecialWeapon = this._weapons.airStrike;
			break;
		case SpecialWeaponData.SpecialWeapon.bomb:
			return this.selectedSpecialWeapon = this._weapons.bomb;
			break;
		case SpecialWeaponData.SpecialWeapon.radar:
			return this.selectedSpecialWeapon = this._weapons.radar;
			break;
		case SpecialWeaponData.SpecialWeapon.torpedo:
			return this.selectedSpecialWeapon = this._weapons.torpedo;
			break;
		case SpecialWeaponData.SpecialWeapon.scatter:
			return this.selectedSpecialWeapon = this._weapons.scatter;
			break;
	};
}

/** Returns the last generated special weapon. */
SpecialWeaponData.prototype.getSelectedSpecialWeapon = function() {
	return this.selectedSpecialWeapon;
}

SpecialWeaponData.prototype.clearCooldowns = function() {

	console.log('SWD::clearCooldowns');

	for (var i = 0; i < this.states.length; i++) {
		this.states[i].currentCooldown = 0;
		if (this.states[i].state == SpecialWeaponData.SpecialWeaponState.locked) {
			this.states[i].state = SpecialWeaponData.SpecialWeaponState.up;
		}
	}

	this.usePowerup(TimeManager.getTime().serverTime + AdSettings.REWARD_COOLDOWN_SPECIAL_WEAPONS, function() {
		console.log('SPECIAL REFRESHED + SAVED');
	});
}

SpecialWeaponData.prototype.clearWeapons = function() {

	console.log('SWD::clearWeapons');

	for (var i = 0; i < this.states.length; i++) {

		this.states[i].currentCooldown = 0;
		if (this.states[i].state == SpecialWeaponData.SpecialWeaponState.locked) {
			this.states[i].state = SpecialWeaponData.SpecialWeaponState.up;
		}

		if (i > 0) {

			this.states[i].currentCooldown = 1;
			this.states[i].state = SpecialWeaponData.SpecialWeaponState.locked;

			if (this._defaultStates[i].state == SpecialWeaponData.SpecialWeaponState.inactive ) {
				this.states[i].state = SpecialWeaponData.SpecialWeaponState.inactive;
			}
		}
	}

	// this.usePowerup(TimeManager.getTime().serverTime + AdSettings.REWARD_COOLDOWN_SPECIAL_WEAPONS, function() {
	// 	console.log('SPECIAL REMOVED + SAVED');
	// });
}

SpecialWeaponData.prototype.getInventory = function() {

	return this.states;
}

SpecialWeaponData.prototype.hasUsed = function() {

	var used = false;
	var state = null;

	for (var i = 1; i < this.states.length; i++) {

		state = this.states[i];

		if (state.state == SpecialWeaponData.SpecialWeaponState.locked) {

			used = true;
		}
	}

	return used;
}

SpecialWeaponData.prototype.parseData = function(data) {

	if (!data) {
		return;
	}

	// next time available
	this.availableAt = (data && data['availableAt']) ? data['availableAt'] : this.availableAt;

	if (data.states) {

		var states = data.states;

		for (var i = 0; i < states.length; i++) {
			// this.setState(states[i].type, states[i].state, states[i].currentCooldown, states[i].totalCoolDown);
			if (states[i].state === SpecialWeaponData.SpecialWeaponState.inactive) {
				states[i].state = this._defaultStates[i].state;
			}
			this.setState(states[i].type, states[i].state, states[i].currentCooldown, this._defaultStates[i].totalCoolDown);
		}
	}
}

SpecialWeaponData.prototype.setState = function(type, state, currentCooldown, totalCoolDown) {
	this.states[type] = this._makeState(type, state, currentCooldown, totalCoolDown);
}

SpecialWeaponData.prototype.setDefaultState = function(type, state, currentCooldown, totalCoolDown) {
	this._defaultStates[type] = this._makeState(type, state, currentCooldown, totalCoolDown);
}

/** Makes a state object with the parameters */
SpecialWeaponData.prototype._makeState = function(type, state, currentCooldown, totalCoolDown) {
	return {
		type: type,
		state: state,
		currentCooldown: currentCooldown,
		totalCoolDown: totalCoolDown
	};
}

//******************************************************
//*****    Script Resource: RematchData
//******************************************************

var RematchData = function() {

	this.rematchStarted = false;

	this.players = {};
}

RematchData.prototype.constructor = RematchData;

RematchData.prototype.parseData = function(rawData) {

	// console.log('RM:parseData');

	var data = rawData;

	this.rematchStarted = rawData.rematchStarted || false;		
	this.players = {};

	var rematchPlayers = rawData.players || {};

	var len = Object.keys(rematchPlayers).length;


	for (var i = 0; i < len; i++) {

		// console.log('key', i);
		if (!Object.keys(rematchPlayers)[i]) continue;


		var old_key = Object.keys(rematchPlayers)[i];
		var new_key = 'player' + parseInt(i+1);

		// console.log('RM:parseData.old_key', old_key);

		if (old_key.indexOf('player') < 0) {


			var board = rematchPlayers[old_key];
			// console.log('	if', old_key, board);
			this.players[new_key] = {id: old_key, board:board};
		}
		else {
			
			// console.log('	else', rematchPlayers[old_key]);
			this.players[old_key] = rematchPlayers[old_key];
		}
	}

	// console.log('RM:parseData.players', this.players);

	// this.players = rematchPlayers;

}

RematchData.prototype.addPlayer = function(playerId, board) {

	var len = Object.keys(this.players).length;
	this.players['player' + parseInt(len+1)] = {id: playerId, board:board};

	// this.players[playerId] = board;
}

RematchData.prototype.getPlayersAgreed = function() {

	var players = Object.keys(this.players);
	return players.length;
}

RematchData.prototype.getPlayer = function(playerId) {

	var playerData = null;

	var players = Object.keys(this.players);

	// console.log('RM:RD:getPlayer.players', players);

	for (var i = 0; i < players.length; i++) {

		var key = Object.keys(this.players)[i];

		// console.log('RM:RD:getPlayer.players', this.players);
		// console.log('RM:RD:getPlayer', i, key, this.players[key]);
		
		if (this.players[key] && this.players[key].id) {

			if (this.players[key].id == playerId) {
				playerData = this.players[key];
				continue;
			}
		}
	}

	return playerData;
}

RematchData.prototype.getOpponent = function() {

	var opponentData = null;

	var userId = UserDataController.getData().id;

	var players = Object.keys(this.players);

	for (var i = 0; i < players.length; i++) {
		
		var key = Object.keys(this.players)[i];
		
		if (this.players[key] && this.players[key].id) {

			if (this.players[key].id != userId) {
				opponentData = this.players[key];
				continue;
			}
		}
	}
	
	return opponentData;
}
//******************************************************
//*****    Script Resource: ExtraShotData
//******************************************************

var ExtraShotData = function() {

	this.availableAt = TimeManager.getTime().serverTime;
}

ExtraShotData.prototype.constructor = ExtraShotData;

ExtraShotData.prototype.parseData = function(rawData) {

	// console.log('ESD.parseData', rawData, this.availableAt);

	this.availableAt = (rawData && rawData['availableAt']) ? rawData['availableAt'] : this.availableAt;
	// console.log('ESD.parseData::AFTER', this.availableAt);
}

ExtraShotData.prototype.isAvailable = function(timeCurrent) {

	var availableAt = this.availableAt;

	if (timeCurrent >= this.availableAt) {
		return true;
	}
	else {
		return false;
	}
}

ExtraShotData.prototype.usePowerup = function(timeFuture) {

	// console.log('ESD::', this.availableAt, timeFuture, timeFuture - this.availableAt);

	this.availableAt = timeFuture;

	var self = this;

	StorageManager.set('extraShot', {'availableAt': this.availableAt});
}

//******************************************************
//*****    Script Resource: AppUsageData
//******************************************************

var AppUsageData = function() {

	this.version = 1;

	this.__keys = {};

	this.lastTimeBooted = null;
}

AppUsageData.prototype.constructor = AppUsageData;

AppUsageData.prototype.parseData = function(rawData) {

	// check version
	this.version = rawData.version || this.version;

	this.__keys = rawData.__keys || this.__keys;

	//
	this.lastTimeBooted = rawData.lastTimeBooted || null;
}


AppUsageData.prototype.boot = function() {

	var serverTime = TimeManager.getTime().server;

	this.sinceLastTime = 0;

	if (this.lastTimeBooted) {

		this.sinceLastTime = serverTime - this.lastTimeBooted;
		this.previousTimeBooted = this.lastTimeBooted;
	}

	this.lastTimeBooted = serverTime;

	console.log('AUD::boot ->', this);

	this._save();
}

AppUsageData.prototype.setKeyPairValue = function(key, value, save) {

	if (save == undefined) save = true;

	this.__keys[key] = value;

	if (save) {

		this._save();
	}
}

AppUsageData.prototype.getKeyValue = function(key) {

	var value = null;


	if (this.__keys[key]) {

		value = this.__keys[key];
	}

	return value;
}


AppUsageData.prototype._save = function() {

	var saveCopy = {
		version: this.version,
		__keys: this.__keys,
		lastTimeBooted: this.lastTimeBooted
	}

	StorageManager.set('appUsage', saveCopy);
}

//******************************************************
//*****    Script Resource: RankData
//******************************************************

var RankData = function() {

	this.score = 0;
	this.wins = 0;
	this.shipsSunk = 0;
	this.losses = 0;

	this.rank = null;
	this.rankData = null;


	this._syncRank();
}

RankData.prototype.constructor = RankData;

RankData.prototype.parseData = function(rawData) {

	this.score = rawData.score || 0;

	if (Environment.get() == Environment._ENVS.MOCK) {
		this.score = 0;
	}
	
	this.wins = rawData.wins || 0;
	this.shipsSunk = rawData.shipsSunk || 0;
	this.losses = rawData.losses || 0;

	this._syncRank();
}


RankData.prototype.add = function(score, winner, shipsSunk) {

	var oldRank = RankChart.getRankData(this.score);

	this.score += score;

	var newRank = RankChart.getRankData(this.score);

	if (newRank.rank > oldRank.rank) {
		BattleshipsAnalytics.reportRankUp(newRank.rank);
		AnalyticsService.reportEvent("progression", "rank", {
			value: newRank.rank
		});
	}

	if (winner) {
		this.wins += 1;
	} else {
		this.losses += 1;
	}

	if (shipsSunk) {
		this.shipsSunk += shipsSunk;
	}

	this._syncRank();

	this._save();
}

RankData.prototype._syncRank = function() {

	this.rankData = RankChart.getRankData(this.score);
	this.rank = this.rankData.rank;
}

RankData.prototype._save = function() {

	var rankData = {
		score: this.score,
		wins: this.wins,
		shipsSunk: this.shipsSunk,
		losses: this.losses
	}

	console.log(rankData);

	StorageManager.set('rank', rankData);
};

//******************************************************
//*****    Script Resource: StorageManager
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var StorageManager = {
  _storagePrefix: 'battleship_',
  _dataKeys: [
    'extraShot',
    'specialWeapon',
    'rank',
    'appUsage',
    'numBoots',
    'sfxMute',
    'musicMute',
    'autoStart'
  ],
  _data: {},

  /**
   * Return the value of the corresponding key.
   *
   * @param [string] key - Key of the value.
   * @returns {*} value.
   */
  get: function (key) {
    return this._data[key];
  },

  /**
   * Set a new value in the localstorage.
   *
   * @param {string} key - Key of the value.
   * @param {*} value - New value
   */
  set: function (key, value) {
    console.log(key, value);
    window.localStorage.setItem(this._storagePrefix + key, this._stringify(value));

    this._data[key] = value;
  },

  /**
   * Remove saved value of the corresponding key.
   *
   * @param {string} key - Key of the value.
   */
  remove: function (key) {
    window.localStorage.removeItem(this._storagePrefix + key);
  },

  /**
   * Completely delete the localstorage.
   */
  clear: function () {
    window.localStorage.clear();
  },

  /**
   * Get all data and return it.
   *
   * @returns {Object} Object with all key value pairs.
   */
  loadSaveData: function () {
    for (var i = 0; i < this._dataKeys.length; i += 1) {
      console.log(this._dataKeys[i])
      this._data[this._dataKeys[i]] = this._parse(window.localStorage.getItem(this._storagePrefix + this._dataKeys[i]));
    }

    console.log("data", this._data)

    return this._data;
  },

  /**
   * Attempt to parse the data and return it.
   *
   * @param {*} value - Value that needs to be parsed.
   * @returns {*} Parsed value.
   * @private
   */
  _parse: function (value) {
    try {
      value = JSON.parse(value)
    } catch (error) {
      console.log(error);
    }

    return value;
  },

  /**
   * Stringify the value and return it.
   *
   * @param {*} value - Value that needs to be stringified.
   * @returns {string} - Stringified value.
   * @private
   */
  _stringify: function (value) {
    return JSON.stringify(value);
  },
};

//******************************************************
//*****    Script Resource: RoomListener
//******************************************************

var RoomListener = function(options) {

	this._board = options.board;
	this._radar = options.radar;


	this._listeners = [];
	// console.log('RoomListener', this._board, this._radar);

	TurnController.addTurnListener(this.onTurnUpdate, this);
};


RoomListener.prototype.constructor = RoomListener;


/**
 * Triggered when the player is connected to the remote room
 */
RoomListener.prototype.addListener = function(scope, callback) {

	this._listeners.push({scope: scope, callback: callback})
}

RoomListener.prototype.addBot = function(bot) {

	this._bot = bot;
	this._bot.enterRoom(this._matchId);
}


RoomListener.prototype.onTurnUpdate = function(state) {


	// get data
	var userData = UserDataController.getData();

	var bd = UserDataController.getBattleData();
	var md = UserDataController.getMatchData();

	// update player interaction
	if (md) {

		md.lastActiveUser = tgfHooks.getPlayerID();
		md.serverTime = TimeManager.getTime().server;
	}

	if (userData && bd && md) {

        if (this._room || this._bot) {
        	// all is good!
        }
        else {
        	console.warn('RoomListener.onTurnUpdate no Room found!');
        	return;
        }
    }
    else {
        console.warn('RoomListener.onTurnUpdate no matchData found!');
        return;
    }


	switch(state) {
		case TurnController._TURN_STATES.TURN_START : {

			setTimeout(function() {

				// console.log('starting turn');

				TurnController.advanceFrom(TurnController._TURN_STATES.TURN_START);

			}, 2000);

			break;
		};
		case TurnController._TURN_STATES.FIRE1 : {

			// console.log('TurnController.onTurnUpdate -> FIRE1');

			var index = md.getPlayerIndex(userData.id);

			// opponent shots are applied to board, save board to battle-data
			bd.lastAction = [];
			bd.boards[index] = this._board.getTileMap().getMap().concat();

			// save match state + applied board + empty lastAction

			if (!this._bot) {

				this._room.saveMatchData(['state', 'battle'], [ md, bd ]);
			}
			break;
		};
		case TurnController._TURN_STATES.FIRE2 : {

			// console.log('TurnController.onTurnUpdate -> FIRE2');
			// this._radar.getTileMap().toStringMap('FIRE2');

			if ( this._hasEnded() == false ) {

				// save match state + battle lastAction

				if (!this._bot) {

					this._room.saveMatchData(['state', 'battle'], [md, bd]);
				}
			}

			break;
		};
		case TurnController._TURN_STATES.FIRE3 : {

			// console.log('TurnController.onTurnUpdate -> FIRE3');
			// this._radar.getTileMap().toStringMap('FIRE3');

			if ( this._hasEnded() == false) {

				// save match state + battle lastAction
				if (!this._bot) {
					this._room.saveMatchData(['state', 'battle'], [md, bd]);
				}
			}

			break;
		};
		case TurnController._TURN_STATES.FIRE_X_POPUP :
		case TurnController._TURN_STATES.FIRE_X_SHOT : {

			if ( this._hasEnded() == false ) {

				// save match state + battle lastAction
				if (!this._bot) {
					this._room.saveMatchData(['state', 'battle'], [md, bd]);
				}
			}

			break;
		};
		case TurnController._TURN_STATES.TURN_OVER : {

			// console.log('RoomListener.onTurnUpdate -> TURN_OVER');
			// this._radar.getTileMap().toStringMap('TURN_OVER');

			if ( this._hasEnded() ) {

				// do nothing - let endGame handle it
			}
			else {

				this._endTurn();
			}

			break;
		};
		case TurnController._TURN_STATES.GAME_ENDED : {

			// game-ended

			break;
		}
	}
}

// TRO EVENTS
RoomListener.prototype.sendPing = function(count, payload) {

	payload = payload || {};

	var msg = {};
	msg.text = 'PING';
	msg.data = payload;

	this.sendMessage(msg);
}

RoomListener.prototype.sendPingPing = function(payload) {

	payload = payload || {};

	var msg = {};
	msg.text = 'PING_PING';
	msg.data = payload;

	this.sendMessage(msg);
}

RoomListener.prototype.sendSyncMatch = function() {

	var state = UserDataController.getMatchData();
	var battle = UserDataController.getBattleData();

	var msg = {};
	msg.text = 'SYNC_MATCH';
	msg.data = {md: state, bd: battle};

	this.sendMessage(msg);
}


RoomListener.prototype.sendStartedTurn = function() {

	var msg = {};
	msg.text = 'STARTED_TURN';
	msg.data = { time: TimeManager.getTime().server };

	this.sendMessage(msg);
}

RoomListener.prototype.sendSingleShot = function(shotInfo) {

	var msg = {};
	msg.text = 'SINGLE_SHOT';
	msg.data = { time: TimeManager.getTime().server, shot: shotInfo };

	this.sendMessage(msg);
}

RoomListener.prototype.sendTarget = function(index) {

	var msg = {};
	msg.text = 'TARGET';
	msg.data = { time: TimeManager.getTime().server, target: index };

	this.sendMessage(msg);
}

RoomListener.prototype.sendDoneTurn = function(turnAction) {

	turnAction = turnAction || [];

	var msg = {};
	msg.text = 'DONE_TURN';
	msg.data = { time: TimeManager.getTime().server, lastAction: turnAction };

	this.sendMessage(msg);
}

RoomListener.prototype.sendTurnTimedOut = function() {

	var msg = {};
	msg.text = 'TURN_TIMED_OUT';
	msg.data = { time: TimeManager.getTime().server };

	this.sendMessage(msg);
}

RoomListener.prototype.sendForfeit = function() {

	var msg = {};
	msg.text = 'FORFEIT';
	msg.data = { time: TimeManager.getTime().server, playerId: tgfHooks.getPlayerID() };

	this.sendMessage(msg);
}

RoomListener.prototype.sendNextTurn = function(lastAction) {

	lastAction = lastAction || [];

	var msg = {};
	msg.text = 'NEXT_TURN';
	msg.data = lastAction;

	this.sendMessage(msg);
}
// END TRO EVENTS


RoomListener.prototype._endTurn = function() {
	var userData = UserDataController.getData();

	var bd = UserDataController.getBattleData();
	var md = UserDataController.getMatchData();
	console.log(bd, md)
	this.sendNextTurn(bd.lastAction);

	md.playerTurn++;
	md.playerState = TurnController._TURN_STATES.TURN_OVER;
	md.serverTime = TimeManager.getTime().server;
	md.lastActiveUser = tgfHooks.getPlayerID();

	// wait for a bit end own turn (timing-tweak)
	var self = this;
	this._timeoutEndTurn = setTimeout(function() {

		// self.sendMessage(msg);
		TurnController.advanceTo(TurnController._TURN_STATES.WAITING);


		// update battleData 'radar' after sending shots
		var index = md.getPlayerIndex(userData.id);
		bd.setOpponentBoard(index, self._radar.getTileMap().getMap().concat() );
	}, 2500);
}

RoomListener.prototype._checkEndgame = function() {

	if (this._hasEnded()) {
		tbGame.addSpecial('game-complete-win', result);
	}
}

RoomListener.prototype._hasEnded = function() {
	var result = this._radar.getTileMap().getResult();
	return (result.hits >= WinConditions.HITS_REQUIRED);
}


RoomListener.prototype.connected = function(sourceRoom) {

	// console.log('RoomListener.connected');

	this._room = sourceRoom;
	this._matchId = this._room.matchID;


	if (this.onConnected) this.onConnected(sourceRoom);
};

/**
 * Triggered if the room becomes unresponsive
 */
RoomListener.prototype.unstableConnectionStarted = function(sourceRoom) {

	console.log('RoomListener.unstableConnectionStarted');
};

/**
 * Triggered if the connection gets normalized
 */
RoomListener.prototype.connectionNormalized = function(sourceRoom) {

	console.log('RoomListener.connectionNormalized');
};

/**
 * Triggered if the player gets disconnected from the remote room
 */
RoomListener.prototype.disconnected = function(sourceRoom) {

	console.log('RoomListener.disconnected');
};

RoomListener.prototype.sendMessage = function(msg) {

	// console.log('RoomListener.sendMessage', msg.text);

	if (this._bot) {
		// do single player stuff directly
		this._bot.handleRoomMessage(msg);
	}
	else {
		// send message normally
		this._room.sendMessage(msg);
	}
}

/**
 * Triggered when a message comes from the remote room (other user or server event)
 * @param msg The message
 */
RoomListener.prototype.messageReceived = function(msg, sourceRoom) {

	// console.log('RoomListener.messageReceived', msg.text);

	var id = UserDataController.getField('id');
	var md = UserDataController.getMatchData();
	var bd = UserDataController.getBattleData();

	if (md == null) {
		console.warn('RoomListener.messageReceived -> match terminated: skipping message');
		return;
	}


	var text = msg.text;
	var data = msg.data;

	switch (text) {
		case 'REMATCH_BOARD_READY' : {

			var playerId = md.getPlayerData(id).id;
			var opponentId = md.getOpponentData(id).id;

			md.players = [playerId, opponentId];
			md.matchDone = [];

			bd.boards = data.boards;

			break;
		};
		case 'BOARD_READY' : {

			// console.log('BOARD_READY', data.userId, data.userData);
			md.addPlayer(data.userId, data.userData);
			// console.log('BOARD_READY:AFTER');
			bd.boards = data.boards;

			break;
		};
		case 'NEXT_TURN' :
		{

			// TRO special
			if (data.turn) {

				console.log('TRO::TURN_RECEIVED -->', data, msg);

				md.playerTurn = parseInt(data.turn);
				bd.lastAction = data.lastAction;

				msg.data = data.lastAction;

				console.log('	TRO::TURN_PROCESSED -->', msg);
			}
			else {

				md.playerTurn++;
				bd.lastAction = data;
			}

			if (this._board && this._board.targetReticle) {
				this._board.targetReticle.hideReticle();
			}

			TurnController.advanceTo(TurnController._TURN_STATES.FEEDBACK_SHOWING);

			break;
		};
		case 'TURN_TIMED_OUT' : {

			// md.playerTurn++;
			// bd.lastAction = [];

			break;
		};
		case 'SINGLE_SHOT' : {

			// console.log('TRO::messageReceived -> SINGLE_SHOT', text, data);

			var shot = data.shot;

			if (shot && this._board) {
				this._board.addShotDirectly(shot, 0, true);
			}
			break;
		};
		case 'TARGET' : {

			var target = data.target;

			if (target && this._board && this._board.targetReticle) {
				this._board.targetReticle.setSingleTarget(target);
			}
			break;
		};
		case 'STARTED_TURN' : {

			// console.log('TRO::messageReceived -> STARTED_TURN', text, data);

			break;
		};
	}


	for (var i = 0; i < this._listeners.length; i++) {

		this._listeners[i].callback.call(this._listeners[i].scope, msg);
	}

	// console.log('md==UDC:md', (md == UserDataController.getMatchData() ) );

	if (this.onMessageReceived) this.onMessageReceived(msg);
};


RoomListener.prototype.destroy = function() {

	this._board = null;
	this._radar = null;

	if (this._timeoutEndTurn) {
		clearInterval(this._timeoutEndTurn);
		this._timeoutEndTurn = null;
	}

	this._listeners = null;

	this._bot = null;
	this._room = null;
}

//******************************************************
//*****    Script Resource: BotOpponent
//******************************************************

var BotOpponent = function(backendService, gameConnection) {

	console.log('BotOpponent::BotOpponent');

	this.id = 'BOT';
	this._backendService = backendService;
	this._gameConnection = gameConnection;


	var mapOptions = {
		rows: TileMapValues.ROWS,
		cols: TileMapValues.COLS,
		tileWidth: TileMapValues.WIDTH,
		tileHeight: TileMapValues.HEIGHT,
		dataMode: true
	};



	this._tiles = new TileMap(mapOptions);

	this.generateMap();
};


BotOpponent.prototype.constructor = BotOpponent;

BotOpponent.prototype.generateMap = function() {

	var arrTiles = [
		0,0,0,2,2,2,2,
		0,0,5,0,0,0,0,
		1,0,5,0,0,0,0,
		1,0,0,0,0,0,0,
		1,0,0,4,3,3,3,
		1,0,0,4,0,0,0,
		1,0,0,4,0,0,0
	];

	// var arrTiles = [
	// 	0,0,0,0,0,0,0,0,
	// 	11,0,0,12,12,12,12,0,
	// 	11,0,0,0,0,0,0,0,
	// 	11,0,0,0,0,0,0,0,
	// 	11,0,15,15,0,0,0,13,
	// 	1,0,0,0,0,0,0,13,
	// 	0,0,0,14,14,14,0,13,
	// 	0,0,0,0,0,0,0,0
	// ];

	this._tiles.setMap(arrTiles);
};

BotOpponent.prototype.setupBoard = function(room) {

	md = UserDataController.getMatchData();
	bd = UserDataController.getBattleData();

	//swd = UserDataController.getSpecialWeaponData();

	this._matchData = new MatchData();
	this._matchData.parseData(md);

	this._battleData = new BattleData();
	this._battleData.parseData(bd);

	// this._specialWeaponData = new SpecialWeaponData();
	// this._specialWeaponData.parseData(swd);

	// this._matchData.addPlayer(this.id, {id: this.id, name: 'BOT', photo: ''});

	var playerIndex = 1;//this._matchData.getPlayerIndex(this.id);

	// console.log('BOT.setupBoard' );

	if (this._battleData.hasBoard(playerIndex)) {

		// console.log('already have a board');
		this._tiles.setMap(this._battleData.getBoard(playerIndex).concat());
	}
	else {

		this._createdBoard = true;
		// add board
		// console.log('adding bot board');
		this._battleData.addBoard( this._tiles.getMap().concat() );
	}


	// fake save other player
	this._room = room;
	// room.saveMatchData(['state', 'battle'], [this._matchData, this._battleData]);

	var socket = this._socket;

	console.log(this._matchData == UserDataController.getMatchData());


	var self = this;
	if (self._timeoutSetupBoard) {
    	clearTimeout(self._timeoutSetupBoard);
    	self._timeoutSetupBoard = null;
    }
	self._timeoutSetupBoard = setTimeout(function() {

		if (self._createdBoard ) {

			var userData = {
				id: self.id,
				name: CaptainManager.getName(),
				photo: 'bot-image'
			};

			// send board-ready message
			var msg = {};
			msg.text = 'BOARD_READY';
			msg.data = { boards: self._battleData.boards, userData: userData, userId: self.id };

			// socket.send(JSON.stringify(msg) );
			self._matchData.addPlayer(self.id, {id: self.id, name: 'BOT', photo: ''});

			self._gameConnection.getRoomListener().messageReceived( (msg) );
		}

		// is it bot turn?
		self._checkTurn();

	}, 0);
}

BotOpponent.prototype.start = function() {

	this._shotArray = [];

	var arrTemp = this._battleData.boards[0].concat();

	// fetch all 'unshot' tiles
	for (var i = 0; i < arrTemp.length; i++) {
		if (arrTemp[i] < 9) {
			this._shotArray.push(i);
		}
	}

	function shuffle(a) {
	    var j, x, i;
	    for (i = a.length; i; i--) {
	        j = Math.floor(Math.random() * i);
	        x = a[i - 1];
	        a[i - 1] = a[j];
	        a[j] = x;
	    }
	}

	// console.log('bot.start', this._shotArray.length);
	// shuffle shots, random shooting order
	shuffle(this._shotArray);
}

BotOpponent.prototype._checkTurn = function() {

	var playerTurn = this._matchData.getCurrentPlayer();
	// console.log('bot._checkTurn', playerTurn, this.id);

	// if (this._matchData.playerTurn > 1) {
		console.warn('BOTTING WAITING WITH TURN', this._matchData.playerTurn);

		if (this.id == playerTurn) {

			var self = this;
			if (self._timeoutTakeTurn) {
		    	clearTimeout(self._timeoutTakeTurn);
		    	self._timeoutTakeTurn = null;
		    }
			self._timeoutTakeTurn = setTimeout(function() {

				self.takeTurn();

			}, 2500)
		}
		return;
	// }
	// else if (this.id == playerTurn) {
	// 	this.takeTurn();
	// }
	// else {
	// 	// console.log('	Bot: not my turn');
	// }
}

var firstTurn = true;

BotOpponent.prototype.takeTurn = function() {

	// console.log('bot.taking turn');

	if (!this._shotArray) throw new Error('BOT UNABLE TO SHOOT');


	var shots = [];

	for (var i = 0; i < 3; i++) {
		var shot = this._shotArray.splice(0,1)[0];
		if (shot === undefined) continue;

		shots.push(BattleData.patchToActionElement(shot));
	}

	// Special Weapon Test
	// var type = SpecialWeaponData.SpecialWeapon.airStrike;
	// var x = 4;
	// var y = 2;
	// var center = y * 8 + x;
	// var tiles = (new SpecialWeaponData()).generateShotTileIndices(type, x, y, false);
	// shots.push(BattleData.generateActionElement(center, tiles, type, 0));

	// var type = SpecialWeaponData.SpecialWeapon.bomb;
	// var x = 2;
	// var y = 2;
	// var center = y * 8 + x;
	// var tiles = (new SpecialWeaponData()).generateShotTileIndices(type, x, y, false);
	// shots.push(BattleData.generateActionElement(center, tiles, type, 0));

	// console.log('	shots after', this._shotArray.length, 'using:', shots);

	var self = this;
	if (self._timeoutEndTurn) {
    	clearTimeout(self._timeoutEndTurn);
    	self._timeoutEndTurn = null;
    }
	self._timeoutEndTurn = setTimeout(function() {

		self._matchData.playerTurn += 1;
		self._matchData.playerState = TurnController._TURN_STATES.TURN_OVER;
		self._battleData.lastAction = shots;
		// self._room.saveMatchData(['state', 'battle'], [self._matchData, self._battleData]);

		var msg = {};
		msg.text = 'NEXT_TURN';
		msg.data = shots;

		self._gameConnection.getRoomListener().messageReceived( (msg) );
		// self._socket.send(JSON.stringify(msg) );
	}, 800 + Math.random() * 200);
}

BotOpponent.prototype.enterRoom = function(matchId) {

	// console.log('BOT.enterRoom', matchId, 'using id', this.id);

	// this._backendService._serverSimulator.addPlayerBotForMatch(this, matchId, this.id);
	this.joinedRoom(null, matchId, null)
};


BotOpponent.prototype.joinedRoom = function(userId, matchId, socket) {

	this._socket = this._gameConnection.getRoomListener();
	// this._socket = socket;
}

BotOpponent.prototype.handleRoomMessage = function(msg) {

	// console.log('bot.handleRoomMessage', msg);

	var text = msg.text;
	var data = msg.data;

	var index = this._matchData.getPlayerIndex(this.id);

	switch (text) {
		case 'NEXT_TURN' : {

			// console.log('	player ended turn, my index = ', index);

			// taking message increases turn
			this._matchData.playerState = TurnController._TURN_STATES.FEEDBACK_READY;
			this._matchData.playerTurn++;


			// handle player lastAction
			for (var i = 0; i < data.length; i++) {
				this._tiles.strikeTileByIndex(data[i]);
			}

			// update board, reset last action
			this._battleData.lastAction = [];
			this._battleData.boards[index] = this._tiles.getMap().concat();
			this._battleData.boards[0] = UserDataController.getBattleData().getBoard(0).concat();

			// console.log('bot -> take next turn' );
			// this._tiles.toStringMap('BotMap - after player shots');

			// save updated map
			// DISABLED this._room.saveMatchData(['state', 'battle'], [this._matchData, this._battleData]);

			break;
		}
	}

	this._checkTurn();
	// this.takeTurn();
}

BotOpponent.prototype.disconnectedFromRoom = function() {

	console.log('bot.disconnectedFromRoom');
}

BotOpponent.prototype.destroy = function() {

    if (this._timeoutSetupBoard) {
    	clearTimeout(this._timeoutSetupBoard);
    	this._timeoutSetupBoard = null;
    }

    if (this._timeoutTakeTurn) {
    	clearTimeout(this._timeoutTakeTurn);
    	this._timeoutTakeTurn = null;
    }

    if (this._timeoutEndTurn) {
    	clearTimeout(this._timeoutEndTurn);
    	this._timeoutEndTurn = null;
    }

    this._gameConnection = null;
    this._backendService = null;
    this._room = null;

    this._tiles = null;

    this._socket = null;
    this._matchData = null;
    this._battleData = null;
    this._shotArray = null;
}

//******************************************************
//*****    Script Resource: AdvancedAI
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var AdvancedAIOpponent = function(backendService, gameConnection) {
    
    console.log('AdvancedAIOpponent::AdvancedAIOpponent');
    
    BotOpponent.prototype.constructor.call(this, backendService, gameConnection);
    
    this.shipShotsHit = [ 0, 0, 0, 0, 0, 0 ];
    this._shotArray = [];
};

tgfDialogs.inherit(AdvancedAIOpponent, BotOpponent);


// AdvancedAIOpponent.prototype = BotOpponent.prototype; // Base class
// AdvancedAIOpponent.prototype.constructor = AdvancedAIOpponent; // constructor


AdvancedAIOpponent.prototype.generateMap = function() {
    
    var amountOfTiles = TileMapValues.COLS * TileMapValues.ROWS;
    var arrTiles = new Array(amountOfTiles).fill(0);
    
    // Go over each ship, in random order
    var shipPlaceOrder = this.shuffle([1, 2, 3, 4, 5]);
    for (var shipIndex = 0; shipIndex < shipPlaceOrder.length; shipIndex++) {
        var shipID = shipPlaceOrder[shipIndex];
        var shipLength = this.getShipSize(shipID);

        // If shipIndex = 0, all locations fit (no ships are placed). Otherwise, find the fitting spots.
        var horFittingLocations = [];
        var verFittingLocations = [];

        // Go over each tile
        for (var tileIndex = 0; tileIndex < arrTiles.length; tileIndex++) {
            var tileY = Math.floor(tileIndex / TileMapValues.COLS);
            var tileX = tileIndex - (tileY * TileMapValues.COLS);

            // See if it fits horizontally.
            var horizontalSpaceLeft = TileMapValues.COLS - tileX;
            if (horizontalSpaceLeft > shipLength) {
                var fits = true;
                for (var horOffset = 0; horOffset < shipLength; horOffset++) {
                    if (arrTiles[tileIndex + horOffset] != 0) {
                        fits = false;
                        break;
                    }
                }

                // If it fits, j is a fitting location.
                if (fits) horFittingLocations.push(tileIndex);
            }

            // See if it fits vertically.
            var verticalSpaceLeft = TileMapValues.ROWS - tileY;
            if (verticalSpaceLeft > shipLength) {
                var fits = true;
                for (var verOffset = 0; verOffset < shipLength; verOffset++) {
                    if (arrTiles[tileIndex + verOffset * TileMapValues.ROWS] != 0) {
                        fits = false;
                        break;
                    }
                }

                // If it fits, j is a fitting location.
                if (fits) verFittingLocations.push(tileIndex);
            }
        }

        var vertical = Math.random() > 0.5;

        // Choose a random axis
        if (vertical && verFittingLocations.length != 0) {
            var baseIndex = verFittingLocations[Math.floor(Math.random() * verFittingLocations.length)];

            for (var shipTile = 0; shipTile < shipLength; shipTile++) {
                arrTiles[baseIndex + shipTile * TileMapValues.COLS] = shipID; 
            }
        }
        else if (!vertical && horFittingLocations.length != 0) {
            var baseIndex = horFittingLocations[Math.floor(Math.random() * horFittingLocations.length)];

            for (var shipTile = 0; shipTile < shipLength; shipTile++) {
                arrTiles[baseIndex + shipTile ] = shipID; 
            }
        }
        else  {

            // The randomly chosen axis doesn't work out, choose the other one
            if (verFittingLocations.length != 0) {
                var baseIndex = verFittingLocations[Math.floor(Math.random() * verFittingLocations.length)];
    
                for (var shipTile = 0; shipTile < shipLength; shipTile++) {
                    arrTiles[baseIndex + shipTile * TileMapValues.COLS] = shipID; 
                }
            }
            else if (horFittingLocations.length != 0) {
                var baseIndex = horFittingLocations[Math.floor(Math.random() * horFittingLocations.length)];
    
                for (var shipTile = 0; shipTile < shipLength; shipTile++) {
                    arrTiles[baseIndex + shipTile ] = shipID; 
                }
            }
        }

    }

    var message = "";
    for (var i = 0; i < arrTiles.length; i++) {
        message += this.getShipSize(arrTiles[i]) + " ";
        if (i % TileMapValues.COLS == TileMapValues.COLS - 1)
            message += "\n";
    }

    console.log(message);

	this._tiles.setMap(arrTiles);
};

AdvancedAIOpponent.prototype.start = function() {

    this.getUnshotTiles();

    for (var tile = this.randomTile(); tile != null; tile = this.randomTile()) {
        
        this.shootAtTile(tile);

        // If we're not hitting a tile, just retry.
        if (tile.value == 0) {
            //console.log("Firing a totally random shot at tile ", tile);
            continue;
        }

        // We found a tile that is a hit.
        var shipIndex = tile.value > 10 ? tile.value - 10 : tile.value;
        var shipSize = this.getShipSize(shipIndex);
        tile.y = Math.floor(tile.index / TileMapValues.COLS);
        tile.x = tile.index - (tile.y * TileMapValues.COLS);

        //console.log("Found a ship tile: ", tile);

        var relativeTiles = this.shuffle([
            this.getRelativeTile(tile, { x: -1, y: 0 }),
            this.getRelativeTile(tile, { x: 1, y: 0 }),
            this.getRelativeTile(tile, { x: 0, y: 1 }),
            this.getRelativeTile(tile, { x: 0, y: -1 })
        ]);

        // For every valid surrounding tile
        for (var i = 0; i < relativeTiles.length; i++) {
            var relativeTile = relativeTiles[i];
            if (relativeTile == null || relativeTile.value > 9) // Avoid shot or invalid tiles
                continue;
            
            // Shoot at the tile if it's valid (we're checking if it hits)
            //console.log("Firing a random relative shot at ", relativeTile);
            this.shootAtTile(relativeTile);

            // If it hits
            if (relativeTile.value == 0)
                continue;

            // Keep shooting in same direction
            //console.log("Hit something with our relative shot! ", relativeTile);
            var shootInOtherDirection = this.shootInDirection(shipIndex, shipSize, relativeTile);
            
            // Shoot in other direction if we haven't finished it off yet
            if (shootInOtherDirection && this.shipShotsHit[shipIndex] != shipSize) {
                var newTile = tile;
                newTile.relativePos = {
                    x: -relativeTile.relativePos.x,
                    y: -relativeTile.relativePos.y,
                };

                if (!newTile) {
                    console.error("Shooting in other direction lead to a tile that is invalid. Is a ship going outside of our map?");
                    debugger;
                }

                this.shootInDirection(shipIndex, shipSize, newTile);
            }
            break;
        }
    }
}

AdvancedAIOpponent.prototype.shootInDirection = function (shipIndex, shipSize, relTile) {
    
    var newTile = this.getRelativeUnshotTile(relTile, relTile.relativePos);
    var shootInOtherDirection = true;

    while (newTile && this.shipShotsHit[shipIndex] != shipSize) {
        this.shootAtTile(newTile);
        //console.log("keep firing at ship: ", newTile);

        // Shoot in that direction until we miss.
        if (newTile.value == 0)
            break;

        // Other direction should not be executed when we're not firing at this ship. 
        if (newTile.value != shipIndex)
            shootInOtherDirection = false;

        newTile = this.getRelativeUnshotTile(newTile, relTile.relativePos);
    }

    return shootInOtherDirection;
}

AdvancedAIOpponent.prototype.shuffle = function(array) {
    var currentIndex = array.length, temporaryValue, randomIndex;
    while (0 !== currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    return array;
}

AdvancedAIOpponent.prototype.getUnshotTiles = function() {
    
    this.boardTiles = this._battleData.boards[0].concat();
    this.unshotTiles = [];

    for (var i = 0; i < this.boardTiles.length; i++) {
        if (this.boardTiles[i] < 9) {
            this.unshotTiles.push({ 
                index: i, 
                value: this.boardTiles[i] 
            });
        }
        else if (this.boardTiles[i] > 10) {
            var shipID = this.boardTiles[i] - 10;
            this.this.shipShotsHit[shipID]++;
        }
    }
};

AdvancedAIOpponent.prototype.randomTile = function() {
    if (this.unshotTiles.length == 0 || this.hasWon())
        return null;

    // Find ship that we haven't killed yet
    for(var i = 1; i <= 5; i++) {
        if (this.shipShotsHit[i] == this.getShipSize(i) || this.shipShotsHit[i] == 0) {
            continue;
        }

        // Find a tile that we already hit
        var hitTiles = [];
        var tilesToShoot = [];
        for(var j = 0; j < this.boardTiles.length; j++) {
            var unshotTile = { value: this.boardTiles[j], index: j };

            if (unshotTile.value == i + 10)
                hitTiles.push(unshotTile); 
            else if (unshotTile.value == i) 
                tilesToShoot.push(unshotTile); 
        }

        // If we don't know the direction
        if (hitTiles.length == 1) {
            return hitTiles[0];
        }

        // If we do, straight up shoot all of it because lmao
        else if (hitTiles.length != 0) {
            for(var j = 0; j < tilesToShoot.length; j++) {
                this.shootAtTile(tilesToShoot[j]);
            }
        }
    }

    // If it's the first shot, we can't get the last shot, so shoot anywhere
    if (this._shotArray.length == 0) {
        var index = Math.floor(Math.random() * this.unshotTiles.length);
        return this.unshotTiles[index];
    }

    // get last shot
    var lastShot = this._shotArray[this._shotArray.length - 1];
    var lastShotY = Math.floor(lastShot / TileMapValues.COLS);
    var lastShotX = lastShot - (lastShotY * TileMapValues.COLS);

    // Copy array of unshot tiles, and remove the tiles surrounding our last shot (so they're not taken from random) 
    var tempArray = this.unshotTiles.concat();

    // Find shots that are valid (unshot and on map)
    for (var y = -2; y <= 2; y++) {

        // Is not off-map (y)
        var curShotY = lastShotY + y;
        if (curShotY < 0 || curShotY >= TileMapValues.ROWS)
            continue;

        for (var x = -2; x <= 2; x++) {

            // Is not off-map (x)
            var curShotX = lastShotX + x;
            if (curShotX < 0 || curShotX >= TileMapValues.COLS)
                continue;

            var curShotIndex = curShotY * TileMapValues.COLS + curShotX;

            // Remove it from the shots available to the bot    
            for (var i = 0; i < tempArray.length; i++) {
                if (tempArray[i].index == curShotIndex) {
                    tempArray.splice(i, 1);
                    break;
                }
            }
        }
    }

    if (tempArray.length > 0) {
        var index = Math.floor(Math.random() * tempArray.length);
        return tempArray[index];
    }
}

AdvancedAIOpponent.prototype.posToIndex = function(pos) {
    return pos.y * TileMapValues.COLS + pos.x;
}

AdvancedAIOpponent.prototype.getRelativeTile = function(targetTile, posOffset) {

    var relativeTile = {
        x: targetTile.x + posOffset.x, 
        y: targetTile.y + posOffset.y
    };

    if (relativeTile.x < 0 || relativeTile.x >= TileMapValues.COLS ||
        relativeTile.y < 0 || relativeTile.y >= TileMapValues.ROWS)
        return null;

    relativeTile.relativePos = posOffset;
    relativeTile.index = this.posToIndex(relativeTile);
    relativeTile.value = this.boardTiles[relativeTile.index];
    return relativeTile;
}

AdvancedAIOpponent.prototype.getRelativeUnshotTile = function(targetTile, posOffset) {
    
    tile = this.getRelativeTile(targetTile, posOffset);
    if (!tile) return null;
    if (tile.value > 9) return null;

    return tile;
}
                    
AdvancedAIOpponent.prototype.shootAtTile = function(tileToRemove) {

    // Can't shoot at invalid tiles.
    if (!tileToRemove || this.boardTiles[tileToRemove.index] > 9)
        return;

    if (this.boardTiles[tileToRemove.index] != 0)
        this.shipShotsHit[this.boardTiles[tileToRemove.index]]++;

    this._shotArray.push(tileToRemove.index);

    if (this.boardTiles[tileToRemove.index] <= 9)
        this.boardTiles[tileToRemove.index] += 10;

    for(var j = 0; j < this.unshotTiles.length; j++) {
        if (this.unshotTiles[j].index == tileToRemove.index) {
            this.unshotTiles.splice(j, 1);
            break;
        }
    }
}

AdvancedAIOpponent.prototype.getShipSize = function(id) {
    switch (id) {
        case 1: return 5;
        case 2: return 4;
        case 3: return 3;
        case 4: return 3;
        case 5: return 2;
        default: return 0;
    }
}

AdvancedAIOpponent.prototype.hasWon = function() {
    
    for(var j = 1; j <= 5; j++) {
        if (this.shipShotsHit[j] != this.getShipSize(j))
            return false;
    }
    return true;
}

AdvancedAIOpponent.prototype.destroy = function() {

    BotOpponent.prototype.destroy.call(this);

    this._tiles = null;
    this._shotArray = null;
    this._battleData = null;
}
//******************************************************
//*****    Script Resource: CaptainManager
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var CaptainManager = {
  _captains: [
    { name: 'CaptainRobin', photo: s_avatar_captain_robin },
    { name: 'CaptainMaverick', photo: s_avatar_captain_maverick },
    { name: 'CaptainRHighstreets', photo: s_avatar_captain_rhighstreets },
    { name: 'CaptainHyung', photo: s_avatar_captain_hyung },
    { name: 'CaptainCarol', photo: s_avatar_captain_carol },
    { name: 'CaptainBrock', photo: s_avatar_captain_brock },
  ],

  getName: function() {
    return this._captains[this._getIndex()].name;
  },

  getTurnText: function() {
    return this._captains[this._getIndex()].name + 'Turn';
  },

  getPhoto: function() {
    return this._captains[this._getIndex()].photo;
  },

  _getIndex: function() {
    var rank = StorageManager.get('rank');
    var index = 0;

    if (rank) {
      var games = rank.wins;
      index = games % this._captains.length;
    }

    return index;
  }
};

//******************************************************
//*****    Script Resource: GameConnectionController
//******************************************************

var GameConnectionController = function (options) {

  var matchTypeNormal = 'BS_RANDOM';
  var matchTypeTRO = 'BS_RANDOM_TRO';

  this.MATCHING_TYPE_ID = matchTypeTRO;

  this._board = options.board;
  this._radar = options.radar;

}

GameConnectionController.prototype.constructor = GameConnectionController;

GameConnectionController.prototype.setup = function (preFetchedData) {

  var self = this;
  var userData = UserDataController.getData();

  // get match-id
  var matchId = UserDataController.getCurrentMatchId();
  this._initialMatchData = null;
  this._initialBattleData = null;
  this._initialRematchData = null;

  this.afterSetup(matchId);
}

GameConnectionController.prototype.afterSetup = function (matchId) {
  this._roomListener = new RoomListener({board: this._board, radar: this._radar});
  this._roomListener.onMessageReceived = this.onRoomMessageReceived.bind(this);
  //this._roomListener.onConnected = this.onRoomConnected.bind(this);
  this.setupMatch(matchId);
};


GameConnectionController.prototype.setupMatch = function () {
  this._matchId = null;

  this.enterNewMatch();
}

GameConnectionController.prototype.enterNewMatch = function () {
  if (this.requestShipPlacement) this.requestShipPlacement();
};

GameConnectionController.prototype.completeShipPlacement = function () {

  this.createNewMatch();
}

GameConnectionController.prototype.createNewMatch = function () {

  // console.log('GCC::GCC.createNewMatch');
  var self = this;

  // get user-data
  var userData = UserDataController.getData();

  // match data
  var matchData = new MatchData();
  matchData.addPlayer(userData.id, {
    id: UserDataController.getData().id,
    name: "You",
    photo: '[NO_IMAGE]'
  });
  matchData.playerTurn = 1; // PLAYER TURN SHOULD ALWAYS START AT EINS

  // battle data
  var battleData = new BattleData();
  battleData.addBoard(this._board.getTileMap().getMap().concat());

  // special weapons data
  var specialWeaponData = new SpecialWeaponData(true);

  this._matchData = matchData;
  this._battleData = battleData;
  this._specialWeaponData = specialWeaponData;


  // create bot?
  this._bot = new AdvancedAIOpponent(this._backendService, this);

  UserDataController.setMatch('BOT-BATTLE', this._matchData, this._battleData, this._specialWeaponData);
  this.onDone({type: 'practice', player: 'player-1'});
}


GameConnectionController.prototype.setBotBattle = function () {

  this._isBottleBattle = true;
}

GameConnectionController.prototype.getBotBattle = function () {

  return this._isBottleBattle;
}


GameConnectionController.prototype.addBot = function () {

  if (this._bot) {

    // console.log('GCC::GCC.addBot');

    this._roomListener.addBot(this._bot);
    this._bot.setupBoard(this._room);
    this._bot.start();
  }
}


GameConnectionController.prototype.onRoomMessageReceived = function (message) {

  // console.log('GCC::GCC.onRoomMessageReceived', message.text);

  var text = message.text;
  var data = message.data;

  switch (text) {
    case 'REMATCH_BOARD_READY' : {

      var md = UserDataController.getMatchData();
      var bd = UserDataController.getBattleData();
      var id = UserDataController.getField('id');
      var myIndex = md.getPlayerIndex(id);

      this._radar.setOpponentMap(bd.getOpponentBoard(myIndex).concat());

      break;
    }
      ;
    case 'BOARD_READY' : {
      // opponent board is ready - ONCE PER GAME

      // console.log('GCC::GCC.onRoomMessageReceived -> BOARD_READY');

      var md = UserDataController.getMatchData();
      var bd = UserDataController.getBattleData();
      var id = UserDataController.getField('id');
      var myIndex = md.getPlayerIndex(id);

      var opponentBoard = bd.getOpponentBoard(myIndex).concat();

      this._radar.setOpponentMap(bd.getOpponentBoard(myIndex).concat());

      if (this._bot) {

        // console.log('GCC::bot should autodecide on turn');
      }

      break;
    }
      ;
    case 'NEXT_TURN' : {
      // check whose turn it is
      // console.log('GCC::opponent finished his turn');
      break;
    }
  }
}

GameConnectionController.prototype.destroy = function () {

  if (this._roomListener) {
    this._roomListener.destroy();
    this._roomListener.onMessageReceived = null;
    this._roomListener.onConnected = null;

    this._roomListener = null;
  }

  if (this._bot) {

    this._bot.destroy();
    this._bot = null;
  }

  this._room = null;

  this._matchData = null;
  this._battleData = null;
  this._rematchData = null;
  this._specialWeaponData = null;


  if (this._backendService) {

    this._backendService.leaveRoom();
    this._backendService = null;
  }
}


GameConnectionController.prototype.getRoomListener = function () {

  return this._roomListener;
}

GameConnectionController.prototype.saveEndGame = function (arrPlayerIds) {

  var userData = UserDataController.getData();

  var md = UserDataController.getMatchData();
  if (md == null) {

    console.warn('GameConnectionController.saveEndGame -> NO MATCH FOUND');
    return;
  }

  for (var i = 0; i < arrPlayerIds.length; i++) {

    if (md.matchDone.indexOf(arrPlayerIds[i]) >= 0) {

      // dont add
    } else {

      md.matchDone.push(arrPlayerIds[i]);
    }
  }

  var bd = UserDataController.getBattleData();

  // send end game message
  var msg = {};
  msg.text = 'NEXT_TURN';
  msg.data = bd.lastAction;

  md.playerTurn++;
  md.playerState = TurnController._TURN_STATES.TURN_OVER;

  // advance engdame
  TurnController.advanceEndGame();


  // send message, but not for losing 2nd player
  if (arrPlayerIds.length < 2) {

    this._roomListener.sendMessage(msg);
  }


  // update battleData 'radar' after sending shots
  var index = md.getPlayerIndex(userData.id);
  bd.setOpponentBoard(index, this._radar.getTileMap().getMap().concat());
}

//******************************************************
//*****    Script Resource: MatchmakingController
//******************************************************

var MatchmakingController = function(onDone, onError) {

	this._onDone = onDone;
	this._onError = onError;
}

MatchmakingController.prototype.constructor = MatchmakingController;


MatchmakingController.prototype.messageReceived = function(msg, source) {

	console.log('MatchmakingController.message-received-listener', msg['@class'], this);
	var type = msg['@class'];

	switch (type) {

		case '.MatchNotFoundMessage' : {

			console.log('MatchNotFoundMessage', msg);

			if (this._onError) this._onError();

			break;
		}
		case '.MatchFoundMessage' : {

			console.log('MatchFoundMessage', msg);

			this._matchData = msg['matchData'];
			this._participants = msg['participants'];
			
			console.log('	_matchData', this._matchData);
			console.log('	_participants', this._participants);

			break;
		}
		case '.ChallengeStartedMessage' : {

			console.log('ChallengeStartedMessage', msg);

			var challenge = msg['challenge'];
			var challengeId = challenge["challengeId"]
			this._challengeId = challengeId;

			var players = challenge["scriptData"]["players"];

			var player1 = players["player1"];
			var player2 = players["player2"];

			this._player1 = player1;
			this._player2 = player2;

			
			this._player1Data = {};
			this._player2Data = {};
			var participant;
			var participantData;

			for (var i = 0; i < this._participants.length; i++) {

				participant = this._participants[i];
				participantData = participant['participantData'];
				if (participantData["id"] == this._player1) {

					this._player1Data = participantData;
				}
				else {
					
					this._player2Data = participantData;
				}
			}

			this._setupGame();

			break;
		}
	}
}

MatchmakingController.prototype._setupGame = function() {

	var md = new MatchData();
	var bd = new BattleData();

	var data1 = {};
	data1["id"] = this._player1Data["id"];
	data1["name"] = this._player1Data["name"];
	data1["photo"] = this._player1Data["photo"];

	var data2 = {};
	data2["id"] = this._player2Data["id"];
	data2["name"] = this._player2Data["name"];
	data2["photo"] = this._player2Data["photo"];

	md.addPlayer(this._player1, data1);
	md.addPlayer(this._player2, data2);

	md.contextID = "RANDOM";
	md.isRandom = true;

	bd.addBoard(this._player1Data['board']);
	bd.addBoard(this._player2Data['board']);

	// console.log('matchData', md);
	// console.log('battleData', bd);

	var dataWrapper = {};
	dataWrapper['id'] = this._challengeId;
	dataWrapper['state'] = md;
	dataWrapper['battle'] = bd;

	if (this._onDone) this._onDone(dataWrapper);
}
//******************************************************
//*****    Script Resource: Sequencer
//******************************************************

var Sequencer = (function() {

	var _Sequencer = function() {

		var self = this;

		this._promiseMoments = {};
		
		// TODO:: move all blocking moments into separate array, loop through instead of individual intervals
		// this._promiseBlocking = []; 

		this._intervals = {};

		// ui-blocker
		this._blocker = null;
		this._blockCounter = 0;
	}


	_Sequencer.prototype.preload = function(momentOrMoments) {

		this.require(momentOrMoments, false);
	}

	_Sequencer.prototype.require = function(momentOrMoments, blocking) {

		if (blocking) {
			this._addBlocker();
		}

		var moments = (Array.isArray(momentOrMoments)) ? momentOrMoments : [momentOrMoments];
		
		var self = this;

		var promises = [];

		for (var i = 0; i < moments.length; i++) {

			moment = moments[i];
			if (this._promiseMoments[moment]) {

				promises.push(this._promiseMoments[moment]);
				
			}
			else {

				var promise = this._makePromise(moment);
				promise.blocking = blocking;

				// console.log('SP::SQ::require ->', this.moment, 'promise added');

				this._promiseMoments[this.moment] = promise;
				promises.push(this._promiseMoments[this.moment]);
			}
		}

		return Promise.all(promises);
	};


	_Sequencer.prototype._makePromise = function(moment) {

		var self = this;

		var promise = new Promise(function(resolve, reject) {

			// if total == 0 -> resolve!
			if (tbLoader.getLoadedItemsInMoment(moment).total == 0) {

				resolve();
				return;
			}

			self._intervals[moment] = setInterval(function() {

				var loadInfo = tbLoader.getLoadedItemsInMoment(moment);
				// console.log('SP::SQ::require -> loaded.items.moment', loadInfo, SpineLoader.getMomentSpines(moment));

				if (loadInfo.total > 0 && loadInfo.total == loadInfo.loaded) {


					var spinesReady = SpineLoader.prepSpinesForMoment(moment);

					if (spinesReady) {

						clearInterval(self._intervals[moment]); 
						self._intervals[moment] = null;
						delete self._intervals[moment];

						if (promise.blocking) {

							self._removeBlocker();
						}

						resolve();
					}
				};

			}, 10);

			tbLoader.addMoment(this.moment);
    		tbLoader.startLoading(this.moment);
		});

		return promise;
	};

	_Sequencer.prototype._addBlocker = function() {

		this._blockCounter++;

		if (this._blockCounter == 1) {
			
			if (!this._blocker) {

				this._blocker = new tbContainer(1366, 1366);
				
				var blockerShape = tbGraphics.drawRectangle(0, 0, tgfGraphics.areaWidth, tgfGraphics.areaHeight, 0x000000, null, null, 0.0001);

				this._blocker.container.addChild(blockerShape);

				this._blocker.container.on('pointerdown', function(e) {
					console.log('congrats!!');
				});		

				this._blocker.container.buttonMode = true;
				this._blocker.container.interactive = true;
			}

			tgfGraphics.addChild(this._blocker.container);
		}
	}

	_Sequencer.prototype._removeBlocker = function() {
		
		this._blockCounter--;

		if (this._blocker && this._blocker.container && this._blockCounter == 0) {

			tgfGraphics.removeChild(this._blocker.container);
		}
	}

	_Sequencer.prototype._tick = function() {

		// unused for now
	}

	return new _Sequencer();
}());
//******************************************************
//*****    Script Resource: SpineLoader
//******************************************************

var SpineLoader = (function() {

	var _SpineLoader = function() {

		this._moments = [];
		this._spines = {};
	}

	_SpineLoader.prototype.constructor = _SpineLoader;

	_SpineLoader.prototype.initialize = function() {
		
		tbGame.addToken(this);
		tbGame.addTokenTags(this, ['spine-loader']);
	}

	_SpineLoader.prototype.prepSpinesForMoment = function(moment) {

		var spines = this.getMomentSpines(moment);

		var spinesPrepped = true;

		if (spines && spines.length) {

			for (var i = 0; i < spines.length; i++) {
				if (!spines[i].spineData) {
					spinesPrepped = false;
					break;
				}
			}
		}

		return spinesPrepped;
	}

	_SpineLoader.prototype.getMomentSpines = function(moment) {

		return this._spines[moment];
	}


	_SpineLoader.prototype.addMoment = function(moment, spine) {

		if (this._moments.indexOf(moment) >= 0) {
			
			
			// console.log('SP::SPL::.push', moment, spine);

			this._spines[moment] = this._spines[moment] || [];
			if (this._spines[moment].indexOf(spine) < 0) {

				this._spines[moment].push(spine);

				// console.log('SP::SPL::.pushed', moment, this._spines[moment].length, this._spines[moment]);
			}
		}
		else {

			this._moments.push(moment);

			this._spines[moment] = this._spines[moment] || [];
			this._spines[moment].push(spine);

			// console.log('SP::SPL::.push-initial', moment, this._spines[moment].length, this._spines[moment]);
		}
	}

	_SpineLoader.prototype.handleSpecial = function(id, data) {


		if (id == 'Load Complete') {			
			
			// console.log('SP::SPL::handleSpecial', moment, this._moments);
			var moment = data.moment;

			if (this._moments.indexOf(moment) >= 0) {
			
				var spines = this._spines[moment];

				// console.log('SP::SPL::handleSpecial', moment, 'exists ? spines =', spines.length, spines);

				for (var i = 0; i < spines.length; i++) {

					// console.log('SP::SPL::handleSpecial', i, spines[i]);

					spines[i].startLoading();
				}				
			}
		}
	}

	return new _SpineLoader();
}());


// overwriting default tbSpine loading
tbSpine.prototype.startLoading = function(moment, location) {
	"use strict";

	// console.log('SP::SPL::', moment, this.name, this._startedLoading);

	var texReady = this.checkTexture();

	if (texReady) {

		// console.log('SP::SPL::.texReady');
		this._loadSkeleton();
	}
	else {


		if (this._startedLoading) {

			// console.log('SP::SPL::.PENDING', this.texture);
		}
		else {

			// console.log('SP::SPL::.NOT-READY', this.texture, this.texture.loading);

			this._startedLoading = true;

			SpineLoader.addMoment(this.texture.loading, this);
		}
	}
};
//******************************************************
//*****    Script Resource: AvatarFetcher
//******************************************************


var AvatarFetcher = (function() {

    var _AvatarFetcher = function() {
        this.avatarReferences = {};

    }

    _AvatarFetcher.prototype.constructor = _AvatarFetcher;

    _AvatarFetcher.prototype.clearReferences = function() {
        this.avatarReferences = {};
    }

    _AvatarFetcher.prototype.getDefaultImage = function(width, height, defaultImageRef) {

        defaultImageRef = defaultImageRef || s_avatar_player;

        width = width || 200;
        height = height || 200;

        var defaultImage = defaultImageRef.clone();

        var x = defaultImage.sprite.width/2;
        var y = defaultImage.sprite.height/2;
        var r = defaultImage.sprite.width/2;

        var mask = tbGraphics.drawDisk(x, y, r, 0xffffff, null, 0);

        defaultImage.sprite.addChild(mask);

        defaultImage.setMask(mask);
        defaultImage.setScale(width / defaultImage.width, height / defaultImage.height);

        return defaultImage;
    }

    _AvatarFetcher.prototype.getPlayerImage = function(width, height) {

        return this.getDefaultImage(width, height, s_avatar_player);
    }

    _AvatarFetcher.prototype.getOpponentImage = function(width, height) {
        return this.getDefaultImage(width, height, CaptainManager.getPhoto());
    }

    return new _AvatarFetcher;
}());

//******************************************************
//*****    Script Resource: TooltipDialog
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************
tgfSettings.dialogDefaults.tooltipDialog = {
	arrowX: 0,
	text: null,
	onDisappeared: null
}

tgfDialogs.TooltipDialog = function(properties) {
	"use strict";
	this.name = "TooltipDialog";         // The name of the dialog
	this.initialize(tgfSettings.dialogDefaults.tooltipDialog);
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.TooltipDialog, tgfDialogs.Base);

tgfDialogs.TooltipDialog.prototype.doPrepare = function() {
	this.background = new tgfComponents.Picture({
		image: s_pla_dia_special_weapon,
		x: tgfGraphics.areaWidth / 2,
	});
	this.addComponent(this.background);

	this.arrow = new tgfComponents.Picture({
		image: s_pla_dia_special_weapon_arrow,
		x: this.arrowX - tgfGraphics.areaWidth / 2,
		y: 77,
	});
	this.background.addComponent(this.arrow);

	if (this.iconImage) {
		this.icon = this.iconImage;

		setTimeout(function() {
			this.addChild(this.iconImage);

			this.icon.setPosition(350, 1010)

		}.bind(this), 0)

	}

	if (this.text) {
		var text = new tgfComponents.Label({
			text: this.text,
			x:  -300 + this.icon.width / 2 + 20,
			y: -5,
			font: {
				fontFace: f_babas_bold.fontFace,
				fillColor: '#ffffcc',
				fontSize: 38,
				strokeWidth: 4,
				strokeColor: "#002d57",
				align: "left",
				baseline: "middle",
			},
			width: 600,
			splitLines: true,
			fitToBox: false
		});
		this.background.addComponent(text);
	}
};

tgfDialogs.TooltipDialog.prototype.doShow = function() {

	this._animator = new tbAnimator();
	this._animatorTrack = this._animator.addTrack('function', this, function(value) {

		if (value == 0) {
			this.hideTooltip();

			if (this.onDisappeared) this.onDisappeared();
		}
		else {
			this.baseContainer.setAlpha(value);
		}
	});

	this._animator.addKey(this._animatorTrack, 0, 1, tbEase.easeLinear, 1);
	this._animator.addKey(this._animatorTrack, 2500, 1, tbEase.easeLinear, 1);
	this._animator.addKey(this._animatorTrack, 3000, 0, tbEase.easeLinear, 1);

	this._animator.setTime(0);
};

tgfDialogs.TooltipDialog.prototype.handleBeginStep = function(timePassed) {

	if (this._animator) {
		this._animator.updateTime(timePassed);
	}
}

tgfDialogs.TooltipDialog.prototype.hideTooltip = function() {

	if (this._animator) {

		this._animator.pause();
		this._animator.removeAllKeys();
		this._animator.removeEvents();
	}

	this.hide();
	this.free();
}

//******************************************************
//*****    Script Resource: TimeManager
//******************************************************

var TimeManager = (function(){


	var _TimeManager = function() {

		this._initialized = false;
		this._serverTimeDiff = null;

		this._sessionTime = 0;
	}

	_TimeManager.prototype.constructor = _TimeManager;

	_TimeManager.prototype.initialize = function (callback) {

		console.log('TM::initialize');

		if (this._initialized) {

			if (this._syncDone) {

				// callback();
			}
callback();
			return;
		}

		this._initialized = true;

		var onSynced = function() {

			this._syncDone = true;

			if (callback) callback();
		}.bind(this);

		this._syncServerTime(onSynced);
	};


	_TimeManager.prototype.getTime = function() {
		//
		// var now = Date.now();
		//
		// return {
		// 	serverTime: now,
		// 	server: 0,
		// };

		if (this._updateCache) {
			this._updateCache = false;

			var self = this;
			var now = Date.now();

			var prev = this._cachedTime;

			this._cachedTime = {offset: 0, time: now, serverTime: now, server: now };

			if (prev) {

				var delta = this._cachedTime.serverTime - prev.serverTime;
				self._sessionTime += delta;
				self._serverTime += delta;

				// console.log('TM::._serverTime', self._serverTime);
				// console.log('TM:delta', delta, 'session', self._sessionTime);
			}

			this._timeoutUpdateCache = setTimeout(function() {

				clearTimeout(self._timeoutUpdateCache);

				self._updateCache = true;
				self.getTime();

			}, 1000);
		}

		// console.log('TM:TimeManager.getTime', this._cachedTime.serverTime, this._cachedTime);

		return this._cachedTime;
	};

	_TimeManager.prototype._syncServerTime = function (callback) {
		"use strict";
		var now = Date.now();
		var serverTime = now;

		this._serverTime = serverTime;
		this._serverTimeDiff = serverTime - now;

		this._updateCache = true;

		this.getTime();

		if (callback) {
			callback();
		}
	};

	return new _TimeManager();
}());

//******************************************************
//*****    Script Resource: TimeTracker
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var TimeTracker = {
	events: {},

	startTracking: function(eventName) {
		this.events[eventName] = Date.now();
	},

	fireEvent: function(eventName, eventCall, args) {
		if (!args) {
			args = [];
		}
		args[args.length] = Date.now() - this.events[eventName];
		eventCall.apply(null, args);
	}
}
//******************************************************
//*****    Script Resource: PauseManager
//******************************************************

var PauseManager = function(initialState) {
	
	this._listeners = [];

	this._statePause = initialState || PauseManager.pauseStates.PAUSE_ENABLED;
}

PauseManager.pauseStates = {
	PAUSE_DISABLED: 0,
	PAUSE_ENABLED: 1//,
	// PAUSED: 2,
	// UNPAUSED: 3
};

PauseManager.prototype.constructor = PauseManager;


PauseManager.prototype.setState = function(stateValue) {
	
	// console.log('IM:PM.setState', stateValue);
	
	if (this._statePause == stateValue) return;

	this._statePause = stateValue;

	this._updateState(this._statePause);
}


PauseManager.prototype._updateState = function() {

	// console.log('IM:PM._updateState', this._statePause);

	for (var i = 0; i < this._listeners.length; i++) {

		this._listeners[i].callback.call(this._listeners[i].scope, this._statePause);
	}
}

PauseManager.prototype.getState = function() {
	
	return this._statePause;
}

PauseManager.prototype.addListener = function(scope, callback) {

	if (callback && scope) {
		
		this._listeners.push({scope: scope, callback: callback});
		callback.call(scope, this._statePause);
	}
	else {
		throw new Error('PauseManager.addListener -> missing scope and/or callback');
	}
}


PauseManager.prototype.removeListener = function(listener) {

  //   var index = array.indexOf(listener);

  //   if (index >= 0) {

		// this._listeners.splice(index, 1);
  //   }
}


PauseManager.prototype.clearListeners = function() {
	
	this._listeners = [];
}

PauseManager.prototype.destroy = function() {
	
	this._listeners = [];	
}

//******************************************************
//*****    Script Resource: PokeManager
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var PokeManager = (function(){

	var _PokeManager = function() {

	}

	_PokeManager.prototype.constructor = _PokeManager;
	
	_PokeManager.prototype.poke = function(data, id) {

		if (window.localStorage && data && data.data && data.data.state) {

			console.log('PokeManager.poke');
			// console.log('	', data);
			// console.log('	', data.id);
			// console.log('	', data.turn);
			// console.log('	', id);
			// console.log('	', data.data.state);
			// console.log('	', data.data.state.playerTurn.toString());

			window.localStorage.setItem("poke_" + data.id.toString(), data.data.state.playerTurn.toString());
			// console.log( window.localStorage.getItem("poke_" + data.id.toString()) );
		}
	};

	_PokeManager.prototype.clearPoke = function(data) {

		if (window.localStorage && data) {
			
			window.localStorage.removeItem("poke_" + data.id.toString() );
		}
	}

	_PokeManager.prototype.getStatus = function(data, id) {

		var turnStatus = -1;

		// console.log(data.id.toString());
		// console.log( window.localStorage.getItem("poke_" + data.id.toString()) );

		if (window.localStorage) {

			// console.log('get here?');
			turnStatus = window.localStorage.getItem("poke_" + data.id.toString() );
		}

		return turnStatus;		
	};

	return new _PokeManager();

}());
//******************************************************
//*****    Script Resource: NotificationManager
//******************************************************

var NotificationManager = (function() {

	var _NotificationManager = function() {

		this.NOTIFICATIONS = {
			WEAPONS_LOADED: 'weapons_loaded'
		}

		this._notifications = {};
	}

	_NotificationManager.prototype.showNotification = function(type) {

		switch(type) {
			case this.NOTIFICATIONS.WEAPONS_LOADED : {

				this._showWeaponsLoaded();
				break;
			}
		}
	}

	_NotificationManager.prototype._showWeaponsLoaded = function(type) {

		var self = this;

		if (this._notifications[type] != null) return;

		var dialog = new tgfDialogs.UiEmpty({
			x: tgfGraphics.areaWidth/2,
			y: tgfGraphics.areaHeight
		});

		dialog.label = f_wurmics_bravo.clone();//new tgfComponents.Label({
		dialog.label.fontSize = 35;
		dialog.label.fillColor = "#000000";
		// dialog.label.stroke = "#000000";
		dialog.label.setAlign("center");
		dialog.label.strokeWidth = 0;

		// dialog.label.baseline = 'bottom';
		dialog.label.setBaseline('middle');
		dialog.label.setWordWrap(true, 460);
		dialog.label.setText(tgfDictionary.getText('TroSpecialWeaponActivated'));//'TEMP TEXT HERE multiple rows');
		dialog.label.setStyle();
			

		dialog.character = new BattleshipComponents.SpineAnimation({ 
			x: tgfGraphics.visibleWidth/2 - (844.77/2) + 64,
			y: -625/2 + 34 + 100, 
			animation: specialweapons_confirmation,
			doUpdateVisuals: function(timePassed) {

				if (window.child1) {
					// console.log('CHAR::', window.child1.x);
					// console.log('CHAR::', window.child1[4]);
					// console.log('CHAR::', window.child1.children[0].position.x);
				}

				if (dialog.label && dialog.label.font) {


					var bubble = dialog.character.animation.animation.slotContainers[1].children[0];
					// dialog.label.setPosition(dialog.character.x - bubble.x, dialog.character.y - bubble.y - dialog.label.textHeight());


					if (window.child1) {
						dialog.label.setPosition(dialog.character.x + window.child1[4].x - 200 , dialog.character.y - window.child1[4].y - 104);
						var sx = window.child1[4].scaleX;
						var sy = window.child1[4].scaleY;

						dialog.label.setScale(sx, sy);
					}

					// var bubble = dialog.character;//.children[0];
					dialog.character.addChild(dialog.label.font)
					// bubble.addChild(dialog.label.font)
					// console.log('DL::', bubble);
					// console.log('DL::', );
					// dialog.label.x = .1;
				}

			},
			onLoad: function () { 
				
				setTimeout(function() {

					console.log('CHAR::', dialog.character);
					console.log('CHAR::', dialog.character.container.container.children);
					console.log('CHAR::', dialog.character.container.container.children[0].children);
					console.log('CHAR::', dialog.character.container.container.children[0].children[1] );

					// window.child1 = dialog.character.container.container.children[0].children[2];
					window.child1 = dialog.character.container.container.children[0].skeleton.bones;
				}, 100)
				// console.log('CHAR::', dialog.character.animation);
				// console.log('CHAR::1', dialog.character.animation.animation.children[1]);
				// console.log('CHAR::1-0', dialog.character.animation.animation.children[1].children[0]);

				

				dialog.character.animator.animation.alpha = 1;
				dialog.character.playAnimation("animation", false, function() {

					console.log('character.done');
					self._notifications[type] = null;
					dialog.hide();
				});
			}
		});

		dialog.addComponent(dialog.character);
		// dialog.character.addComponent(dialog.label);

		this._notifications[type] = dialog;

		dialog.show();
	}


	return new _NotificationManager();
}());





// tgfComponents.SpineComponent.prototype.getSlot = function(slotIndex) {
// 	return this.spineClone.animation.slotContainers[slotIndex];
// };

// tgfComponents.SpineComponent.prototype._addFontToSlot = function(slotIndex, font) {

// 	var image = s_tgf_transparent.clone();

// 	image.addChild(font);

// 	var slot = this.getSlot(slotIndex);

// 	slot.addChild(image.sprite);

// 	image.setRotation(this.imageToSlotRotation);

// 	if(this.flipImagesToSlot) {
// 		image.setScale(-1, 1);
// 	}
// };

// tgfComponents.SpineComponent.prototype.addLabelToSlot = function(slotIndex, label) {

// 	this.labelsToSlots.push({
// 		slotIndex: slotIndex,
// 		label: label
// 	});

// 	if(this.spineClone) {
// 		var font;

// 		if(!(label.font instanceof tbVectorFont)) {
// 			font = new tbVectorFont();
	
// 			font.setProperties(label.font);

// 			font.setText(label.text);

// 			font.setPosition(label.x, label.y);
// 		} else {
// 			font = label.font;
// 		}

// 		this._addFontToSlot(slotIndex, font);
// 	}
// };
//******************************************************
//*****    Script Resource: MessagingLoader
//******************************************************

var MessagingLoader = function() {

	this._loadProgress = 0;
}

MessagingLoader.prototype.constructor = MessagingLoader;


MessagingLoader.prototype.startInitialLoading = function() {

	console.log('ML::startInitialLoading');
	tgfHooks.execute("afterInitializing");
}

MessagingLoader.prototype.getLoadingProgress = function() {

	var lp = tgfFunctions.loadPercentage();

	if (lp > this._loadProgress) {
		this._loadProgress = lp;
	}
	console.log('ML::getLoadingProgress', this._loadProgress);

	return this._loadProgress;
}
//******************************************************
//*****    Script Resource: ShortcutManager
//******************************************************

var ShortcutManager = (function() {

	var _ShortcutManager = function() {
	}

	_ShortcutManager.prototype.constructor = _ShortcutManager;

	_ShortcutManager.prototype.initialize = function(messagingService) {

		if (FBInstant && FBInstant.canCreateShortcutAsync) {
			
			FBInstant.canCreateShortcutAsync().then(function(canCreateShortcut) {

				console.log('ScM::.initialize.canCreateShortcutAsync -> success ? can-do = ' + canCreateShortcut);				

			}, function(e) {

				console.log('ScM::.initialize.canCreateShortcutAsync -> error', e);				
			});
		}
		else {

			console.log('ScM::.initialize.FBInstant.call issue!');
		}


		// UNCOMMENT FOR TESTING PURPOSES ONLY 
		// this.testShortcut();
	}


	_ShortcutManager.prototype.testShortcut = function() {

		if (!messagingPlatformService) return;

		var appUsageData = UserDataController.getAppUsageData();
		var shortcutAttempt = appUsageData.getKeyValue('shortcutAttempt');

		var timeServer = TimeManager.getTime().server;


		if (!shortcutAttempt) {

			console.log('ScM.testShortcut -> fresh', shortcutAttempt, timeServer);
			appUsageData.setKeyPairValue('shortcutAttempt', timeServer, true);
		}
		else {
			
			var secondsElapsed = Math.round((timeServer - shortcutAttempt) / 1000);
			var secondsDay = 60 * 60 * 24;

			if (secondsElapsed >= secondsDay) {

				console.log('ScM.testShortcut -> exists', shortcutAttempt, timeServer, secondsElapsed);
				appUsageData.setKeyPairValue('shortcutAttempt', timeServer, true);
			}
			else {

				console.log('ScM.testShortcut -> time-out not done', secondsElapsed, secondsDay);
				return;
			}
		}

		this._testShortcut();
	}

	_ShortcutManager.prototype.testHubEntry = function(entryData) {

		switch (entryData) {
			case 'games_hub' : 
			case 'web_games_hub' : {

				var appUsageData = UserDataController.getAppUsageData();
				var bootTimes = appUsageData.getKeyValue('numBoots') || 0;

				var shouldShow = (bootTimes - 3) % 1; // <-- used to be % 2
				console.log('HE::', bootTimes, shouldShow);
				if (bootTimes >= 3 && shouldShow == 0) {

					console.log('HE::testing!', bootTimes, shouldShow);
					this._testShortcut();
				}
				break;
			};
			default: {

				// cant touch this
				break;
			};
		}
	}

	_ShortcutManager.prototype._testShortcut = function() {

		if (messagingPlatformService && messagingPlatformService.createShortcut) {

			messagingPlatformService.createShortcut().then(function() {

				console.log('ScM::._testShortcut -> success');				
			},
			function(e) {

				console.log('ScM::._testShortcut -> failed', e);			
			});
		}
		else if (!messagingPlatformService) {

			console.log('ScM::.testShortcut -> messagingService not initialized');
		}
		else {
			console.log('ScM::.testShortcut -> can\'t create shortcut');
		}
	}

	return new _ShortcutManager();

}());
//******************************************************
//*****    Script Resource: LobbyHeader
//******************************************************

// ***************************************
// tgfComponents.Template
//
// This is an empty template for a new component
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 25-9-2015
// ***************************************

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.componentLobbyHeader = {

	_imageBackgroundProfile: s_background_profile,

	components: []
};

// The constructor for the component
/**
 * @constructor tgfComponents.LobbyHeader
 * @base tgfComponents.Base
 */
tgfComponents.ComponentLobbyHeader = function(properties) {
	"use strict";
	this.name = "LobbyHeader";			// The name of the component
	// Initialize properties
	this.initialize(tgfSettings.componentDefaults.componentLobbyHeader);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ComponentLobbyHeader, tgfComponents.Base);


// Processing required when preparing the component for use
tgfComponents.ComponentLobbyHeader.prototype.doPrepare = function() {
	"use strict";

	// Offset is applied to all positions
	var offsetX = 298;
	var offsetY = 0;

	this._positions = {
		progressBarX: offsetX + 202,
		progressBarY: offsetY + 62,
		progressTextY: offsetY + 60,

		currentRankTextX: offsetX + 100,
		currentRankTextY: offsetY + 186,

		nextRankTextX: offsetX + 670,
		nextRankTextY: offsetY + 28,

		// Badges and profile picture are not relative from the LobbyHeader so they require an extra calculation
		currentRankBadgeX: this.x + offsetX + 148,
		currentRankBadgeY: this.y + offsetY + 197.5,
		nextRankBadgeX: this.x + offsetX + 706,
		nextRankBadgeY: this.y + offsetY + 78.5,
		profilePicX: this.x + offsetX + 100,
		profilePicY: this.y + offsetY + 120,

		battlesWonTextX: offsetX + 300,
		battlesWonTextY: offsetY + 148,

		shipsDestroyedTextX: offsetX + 300,
		shipsDestroyedTextY: offsetY + 204,

		// The stats of the value are relative from the battlesWonText or shipsDestroyedText
		statsValueTextX: 362,
		statsValueTextY: 0,
	};

	this._rankData = UserDataController.getRankData();

	// console.log(JSON.stringify(this._rankData));
	// TODO fix rank data

	this._rankProgress = RankChart.getRankProgress(this._rankData.score).progress;

	this._isMaxRank = this._rankData.rank == RankChart.getHighestRank().rank;

	this._frontContainer = new tgfComponents.Container({});

	this._backContainer = new tgfComponents.Container({});
	console.log(this._backContainer)

    this._backgroundProfile = new tgfComponents.Picture({
		x: 0,
		y: 0,
		image: this._imageBackgroundProfile
	});
	this.addComponent(this._backContainer);
	this.addComponent(this._frontContainer);
	this._frontContainer.addComponent(this._backgroundProfile);

	// Make the bar fit so that it doesn't overlap the progress border
	var barScaleX = 0.785;
	var barScaleY = 0.7;
	this._barWidth = s_progress_filling.width * barScaleX;
	this._barHeight = s_progress_filling.height * barScaleY;

	this._progressBarMask = tbGraphics.drawRectangle(this._positions.progressBarX, this._positions.progressBarY, this._barWidth, this._barHeight, 0xff0000, null, 0, 0.5);

	this._progressBar = new tgfComponents.Picture({
		x: this._positions.progressBarX,
		y: this._positions.progressBarY,
		image: s_progress_filling.clone(),
		mask: this._progressBarMask
	});
	this._progressBar.mask = this._progressBarMask;

	this._progressBar.xScale = barScaleX;
	this._progressBar.yScale = barScaleY;

	this._createAvatarPhoto();

	this._labelBattlesWon = this._createBattlesWonLabel(this._rankData.wins);
	this._labelWinStreak = this._createDestroyedShipsLabel(this._rankData.shipsSunk);
	this._labelProgress = this._createProgressLabel();

	this._currentRankLabel = this._createRankIndicatorLabel(this._positions.currentRankTextX, this._positions.currentRankTextY);
	this._nextRankLabel = this._createRankIndicatorLabel(this._positions.nextRankTextX, this._positions.nextRankTextY, true);

	this._backgroundProfile.addComponent(this._labelBattlesWon);
	this._backgroundProfile.addComponent(this._labelWinStreak);

	this._backgroundProfile.addComponent(this._currentRankLabel);
	this._backgroundProfile.addComponent(this._nextRankLabel);

	this._backgroundProfile.addComponent(this._labelProgress);
	this._backgroundProfile.addComponent(this._progressBar);


	this._currentRankBadge = RankIndicator.createFromRankData(RankChart.getRankData(this._rankData.score));
	this._nextRankBadge = RankIndicator.createFromRankData(RankChart.getNextDataByScore(this._rankData.score), true);

	// Position the rank badges a frame later when the base container is initialized
	setTimeout(function() {

		// Add the current rank badge
		this._backgroundProfile.addChild(this._currentRankBadge);
		this._currentRankBadge.setPosition(this._positions.currentRankBadgeX, this._positions.currentRankBadgeY);

		// Add the gray next rank badge if the player is not max rank yet
		if (!this._isMaxRank) {
			this._backgroundProfile.addChild(this._nextRankBadge);
			this._nextRankBadge.setPosition(this._positions.nextRankBadgeX, this._positions.nextRankBadgeY);
		}

		// The progress bar also need to change its position a frame later so that the mask won't mess up
		this._progressBar.setPosition(this._progressBar.x - this._barWidth * (1 - this._rankProgress), this._progressBar.y);

	}.bind(this), 0);


	var i;
	// Add the child components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

tgfComponents.ComponentLobbyHeader.prototype.setPosition = function(x, y) {

	this._frontContainer.setPosition(x, y);
	this._backContainer.setPosition(x, y);
}

tgfComponents.ComponentLobbyHeader.prototype._createAvatarPhoto = function() {
	var profilePicSize = 160;
	var self = this;

	var res = AvatarFetcher.getPlayerImage(profilePicSize, profilePicSize);

	setTimeout(function() {
		if (res) {

			res.setPosition(
				self._positions.profilePicX - profilePicSize / 2,
				self._positions.profilePicY - profilePicSize / 2
			);

			if (self._backgroundProfile) {

				self._backContainer.addChild(res);
			}
		}
	}, 0);
};

tgfComponents.ComponentLobbyHeader.prototype._createRankIndicatorLabel = function(x, y, nextRank) {

	nextRank = nextRank || false;

	var text = nextRank ? (this._isMaxRank ? "MAX" : tgfDictionary.getText('profile_nextrank')) : tgfDictionary.getText('profile_rank');
	console.log(text);

	var font = f_autoradiographic_italic.clone();
	font.fontSize = 24;
	font.strokeWidth = 0;
	font.fillColor = '#001c35';

	var textProps = {
		text: text,
		font: font,
		x: x,
		y: y,
		align: 'right',
	};

	return new tgfComponents.Label(textProps);
}

tgfComponents.ComponentLobbyHeader.prototype._createBattlesWonLabel = function(value) {

	value = value || 0;

	var battlesWonLabel = this._createBattleStatLabel(
		this._positions.battlesWonTextX,
		this._positions.battlesWonTextY,
		tgfDictionary.getText('profile_battlesWon') + " ",
		value,
		'#b4bca1',
		'#001c35'
	);

	return battlesWonLabel.label;
}

tgfComponents.ComponentLobbyHeader.prototype._createDestroyedShipsLabel = function(value) {

	value = value || 0;

	var shipsDestLabel = this._createBattleStatLabel(
		this._positions.shipsDestroyedTextX,
		this._positions.shipsDestroyedTextY,
		tgfDictionary.getText('profile_shipsDestroyed') + " ",
		value,
		'#bdb592',
		'#350000'
	);

	return shipsDestLabel.label;
}

/** Creates a label for battle stats such as 'battles won' or 'ships destroyed' */

tgfComponents.ComponentLobbyHeader.prototype._createBattleStatLabel = function(x, y, text, value, textColor, outlineColor) {

	text = text || '';
	value = value || 0;

	var font = f_autoradiographic_italic.clone();
	font.fontSize = 32;
	font.fillColor = textColor || '#979e86';
	font.strokeWidth = 5;
	font.strokeColor = outlineColor || '#001c35';
	font.baseline = 'middle';

	console.log("Creating battle stat");
	console.log(x);
	var textProps = {
		text: text,
		font: font,
		x: x,
		y: y,
		align: 'left',
	};

	var valueFont = f_autoradiographic_italic.clone();
	valueFont.fontSize = 32;
	valueFont.fillColor = '#ffffcc';
	valueFont.strokeWidth = 5;
	valueFont.strokeColor = outlineColor || '#1a202a';
	valueFont.baseline = 'middle';

	console.log(x);
	var valueProps = {
		text: value.toLocaleString(),
		font: valueFont,
		x: this._positions.statsValueTextX,
		y: this._positions.statsValueTextY,
		align: 'right',
	}

	var label = new tgfComponents.Label(textProps);
	var valueLabel = new tgfComponents.Label(valueProps);
	label.addComponent(valueLabel);

	return { label: label, valueLabel: valueLabel, offsetX: 16 };
}

tgfComponents.ComponentLobbyHeader.prototype._createProgressLabel = function() {

	var font = f_autoradiographic_italic.clone();
	font.fontSize = 32;
	font.fillColor = '#ffffff';
	font.strokeWidth = 5;
    font.strokeColor = '#1a202a';

	var text = RankChart.formatRankProgress(this._rankData.score);

	var textProps = {
		text: text,
		font: font,
		x: this._positions.progressBarX + this._barWidth / 2,
		y: this._positions.progressTextY,
		align: 'center',
	};

	return new tgfComponents.Label(textProps);
}

// Processing required when freeing the component from use
tgfComponents.ComponentLobbyHeader.prototype.doFree = function() {
	"use strict";
};

// Processing required when showing the component
tgfComponents.ComponentLobbyHeader.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the component
tgfComponents.ComponentLobbyHeader.prototype.doHide = function() {
	"use strict";
};

// Processing required when activating the component
tgfComponents.ComponentLobbyHeader.prototype.doActivate = function() {
	"use strict";
};

// Processing required when deactivating the component
tgfComponents.ComponentLobbyHeader.prototype.doDeactivate = function() {
	"use strict";
};


// Called at the beginning of each step
tgfComponents.ComponentLobbyHeader.prototype.doBeginStep = function(timePassed) {
	"use strict";
};

// Called when a touch is started or if a mouse button is pressed
tgfComponents.ComponentLobbyHeader.prototype.doTouchDown = function(finger, x, y) {
	"use strict";
};

// Called when a touch is ended or if a mouse button is released
tgfComponents.ComponentLobbyHeader.prototype.doTouchUp = function(finger, x, y) {
	"use strict";
};

// Called when the position of the mouse wheel is changed
tgfComponents.ComponentLobbyHeader.prototype.doMouseWheel = function(delta, x, y) {
	"use strict";
};

// Called immediately when a touch is started or if a mouse button is pressed
tgfComponents.ComponentLobbyHeader.prototype.doImmediateTouchDown = function(finger, x, y) {
	"use strict";
};

// Called immediately when a touch is ended or if a mouse button is released
tgfComponents.ComponentLobbyHeader.prototype.doImmediateTouchUp = function(finger, x, y) {
	"use strict";
};

// Called if the key with the given keyCode is pressed
tgfComponents.ComponentLobbyHeader.prototype.doKeyDown = function(keyCode) {
	"use strict";
};

// Called if the key with the given keyCode is released
tgfComponents.ComponentLobbyHeader.prototype.doKeyUp = function(keyCode) {
	"use strict";
};

// Called if a global alarm is reached
tgfComponents.ComponentLobbyHeader.prototype.doAlarm = function(alarm) {
	"use strict";
};

// Called if a special or user-defined event happens
tgfComponents.ComponentLobbyHeader.prototype.doSpecial = function(id, args) {
	"use strict";
};

// Called at the end of each step
tgfComponents.ComponentLobbyHeader.prototype.doEndStep = function(timePassed) {
	"use strict";
};

// Called just before drawing (also when not active)
tgfComponents.ComponentLobbyHeader.prototype.doUpdateVisuals = function(timePassed) {
	"use strict";
};

// Called when the component must be drawn (relative to position 0, 0)
tgfComponents.ComponentLobbyHeader.prototype.doDraw = function() {
	"use strict";
};

// Called after drawing the sub-components
tgfComponents.ComponentLobbyHeader.prototype.doEndDraw = function() {
	"use strict";
};


//******************************************************
//*****    Script Resource: NextUnlockable
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************
tgfSettings.componentDefaults.NextUnlockable = {

};
tgfComponents.NextUnlockable = function(properties) {
  "use strict";
  this.name = "NextUnlockable";			// The name of the component
  // Initialize properties
  this.initialize(tgfSettings.componentDefaults.NextUnlockable);
  // Set user properties
  if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.NextUnlockable, tgfComponents.Base);

// Processing required when preparing the component for use
tgfComponents.NextUnlockable.prototype.doPrepare = function() {

  this._rankData = UserDataController.getRankData();

  var specialWeapon = this.getNextUnlockable(this._rankData.rankData.rank);

  if (!specialWeapon) {
    this.hide();
    return;
  }

  var nextRankData = RankChart.ranks[specialWeapon.rank - 1];

  var nextWeaponRank = { rank: specialWeapon.rank, icon: nextRankData.icon, iconGrey: nextRankData.iconGrey, value: this._rankData.rankData.value };

  var name = '';

  switch(specialWeapon.weapon) {
    case SpecialWeaponData.SpecialWeapon.airStrike:
      name = 'Air Strike';
      break;
    case SpecialWeaponData.SpecialWeapon.bomb:
      name = 'Bomb';
      break;
     case SpecialWeaponData.SpecialWeapon.torpedo:
      name = 'Torpedo';
      break;
    case SpecialWeaponData.SpecialWeapon.scatter:
      name = 'Scatter';
      break;
  }

  this._title = new tgfComponents.Label(this.createTextProperties('NextUnlockableSpecialWeaponTitle', 0, 30, 35, '#fff', '#001c35', 'center', 500));

  this._weaponName = new tgfComponents.Label(this.createTextProperties(name, -140, 134, 50, '#fff', '#001c35', 'left'));
  this._description = new tgfComponents.Label(this.createTextProperties('NextUnlockableSpecialWeaponDescription', -140, 179, 30, '#fff', '#001c35', 'left'));

  this._icon = new tgfComponents.Picture({
    x: -240,
    y: 104,
    image: this.getIcon(specialWeapon).clone()
  });

  this._bottomBackground = tbGraphics.drawRectangle(0, 490, tbGraphics.width, 128, "#000000");
  this._bottomBackground.alpha = 0.5;

  this.addChild(this._bottomBackground)
  this.addComponent(this._title)
  this.addComponent(this._icon)
  this.addComponent(this._weaponName);
  this.addComponent(this._description);
  this._rankIndicator = RankIndicator.createFromRankData(nextWeaponRank);
  setTimeout(function() {
    var textWidth = Math.max(this._weaponName.textWidth, this._description.textWidth);

    this.addChild(this._rankIndicator);
    this._rankIndicator.setPosition(570 + this._rankIndicator.width / 2 + textWidth, 570);
    console.log(this._rankIndicator.width / 2 , textWidth)
  }.bind(this), 0)
};

tgfComponents.NextUnlockable.prototype.getNextUnlockable = function(rank) {
  for (var i = 0; i < WeaponUnlockChart.weaponRankUnlocks.length; i += 1) {
    if (rank < WeaponUnlockChart.weaponRankUnlocks[i].rank) {
      return WeaponUnlockChart.weaponRankUnlocks[i];
    }
  }

  return null;
};


tgfComponents.NextUnlockable.prototype.getIcon = function(specialWeapon) {
  var icon = null;

  switch(specialWeapon.weapon) {
    case 1:
      icon = s_button_special_weapon_up_01;
      break;
    case 2:
      icon = s_button_special_weapon_up_02;
      break;

    case 4:
      icon = s_button_special_weapon_up_04;
      break;
    case 5:
      icon = s_button_special_weapon_up_05;
      break;
    default:
  }

  return icon;
};

tgfComponents.NextUnlockable.prototype.createTextProperties = function(key, x, y, size, color, outlineColor, align, wordWrapWidth) {
  text = tgfDictionary.getText(key) || '';

  var font = f_autoradiographic_italic.clone();
  font.fontSize = size || 32;
  font.fillColor = color || '#979e86';
  font.strokeWidth = 5;
  font.strokeColor = outlineColor || '#001c35';
  font.baseline = 'middle';

  if (wordWrapWidth) {
    font.setWordWrap(true, wordWrapWidth)
  }

  var textProps = {
    text: text,
    font: font,
    x: x,
    y: y,
    align: align,
  };

  return textProps;
};

//******************************************************
//*****    Script Resource: RankChart
//******************************************************

var RankChart = function() {

}

RankChart.prototype.constructor = RankChart;

window.rankChart = RankChart;

RankChart.getRankData = function(score) {

	var rankData = null;

	for (var i = 0; i < RankChart.ranks.length; i++) {

		var testRank = RankChart.ranks[i];

		if (score >= testRank.value) {
			// accepted! -> next
			rankData = testRank;
		}
		else {

			break;
		}
	}

	return rankData;
};

RankChart.getNextDataByRank = function(rank) {

	rank = rank || 1;
	rank = Math.min(rank, (RankChart.ranks.length - 1));

	return RankChart.ranks[rank];
}

RankChart.getNextDataByScore = function(score) {
	
	var rankData = RankChart.getRankData(score);

	return RankChart.getNextDataByRank(rankData.rank);
}

RankChart.getRankProgress = function(score) {

	var currentRank = RankChart.getRankData(score);
	var nextRank = RankChart.getNextDataByRank(currentRank.rank);

	var from = currentRank.value;
	var to = nextRank.value;
	var progress;

	if (from < to) {
		progress = (score - from) / (to - from);
	}
	else {
		progress = 1;
	}

	return {
		current: currentRank,
		next: nextRank,
		from: from,
		to: to,
		progress:progress
	};
}

RankChart.getHighestRank = function() {
	return RankChart.ranks[RankChart.ranks.length - 1];
}

/** Returns a string formatted so that it shows the progress to the next rank like this: 10/100 */
RankChart.formatRankProgress = function(score) {
	var fromScoreText, toScoreText;

	var currentRankData = RankChart.getRankData(score);
	var nextRankData = RankChart.getNextDataByScore(score);

	var isMax = RankChart.getHighestRank().value == currentRankData.value;

	if (isMax) {
		fromScoreText = Math.round(score).toLocaleString(tgfDictionary.currentLanguage);
		toScoreText = "MAX";
	}
	else {
		fromScoreText = Math.round(score - currentRankData.value).toLocaleString(tgfDictionary.currentLanguage);
		toScoreText = (nextRankData.value - currentRankData.value).toLocaleString(tgfDictionary.currentLanguage);
	}

	return "" + fromScoreText + "  " + toScoreText;
}

RankChart.ranks = [
	{rank: 1,  icon: s_ui_icon_rank01_04, icon_grey: s_ui_icon_rank01_04_grey, value: 0 },
	{rank: 2,  icon: s_ui_icon_rank01_04, icon_grey: s_ui_icon_rank01_04_grey, value: 80 },
	{rank: 3,  icon: s_ui_icon_rank01_04, icon_grey: s_ui_icon_rank01_04_grey, value: 295 },
	{rank: 4,  icon: s_ui_icon_rank01_04, icon_grey: s_ui_icon_rank01_04_grey, value: 618 },
	
	{rank: 5,  icon: s_ui_icon_rank02_59, icon_grey: s_ui_icon_rank02_59_grey, value: 1048 },
	{rank: 6,  icon: s_ui_icon_rank02_59, icon_grey: s_ui_icon_rank02_59_grey, value: 1585 },
	{rank: 7,  icon: s_ui_icon_rank02_59, icon_grey: s_ui_icon_rank02_59_grey, value: 2230 },
	{rank: 8,  icon: s_ui_icon_rank02_59, icon_grey: s_ui_icon_rank02_59_grey, value: 2983 },
	{rank: 9,  icon: s_ui_icon_rank02_59, icon_grey: s_ui_icon_rank02_59_grey, value: 3843 },
	
	{rank: 10, icon: s_ui_icon_rank03_1014, icon_grey: s_ui_icon_rank03_1014_grey, value: 4810 },
	{rank: 11, icon: s_ui_icon_rank03_1014, icon_grey: s_ui_icon_rank03_1014_grey, value: 5885 },
	{rank: 12, icon: s_ui_icon_rank03_1014, icon_grey: s_ui_icon_rank03_1014_grey, value: 7068 },
	{rank: 13, icon: s_ui_icon_rank03_1014, icon_grey: s_ui_icon_rank03_1014_grey, value: 8358 },
	{rank: 14, icon: s_ui_icon_rank03_1014, icon_grey: s_ui_icon_rank03_1014_grey, value: 9755 },
	
	{rank: 15, icon: s_ui_icon_rank04_1519, icon_grey: s_ui_icon_rank04_1519_grey, value: 11260 },
	{rank: 16, icon: s_ui_icon_rank04_1519, icon_grey: s_ui_icon_rank04_1519_grey, value: 12873 },
	{rank: 17, icon: s_ui_icon_rank04_1519, icon_grey: s_ui_icon_rank04_1519_grey, value: 14593 },
	{rank: 18, icon: s_ui_icon_rank04_1519, icon_grey: s_ui_icon_rank04_1519_grey, value: 16420 },
	{rank: 19, icon: s_ui_icon_rank04_1519, icon_grey: s_ui_icon_rank04_1519_grey, value: 18355 },

	{rank: 20, icon: s_ui_icon_rank05_2024, icon_grey: s_ui_icon_rank05_2024_grey, value: 20398 },
	{rank: 21, icon: s_ui_icon_rank05_2024, icon_grey: s_ui_icon_rank05_2024_grey, value: 22548 },
	{rank: 22, icon: s_ui_icon_rank05_2024, icon_grey: s_ui_icon_rank05_2024_grey, value: 24805 },
	{rank: 23, icon: s_ui_icon_rank05_2024, icon_grey: s_ui_icon_rank05_2024_grey, value: 27170 },
	{rank: 24, icon: s_ui_icon_rank05_2024, icon_grey: s_ui_icon_rank05_2024_grey, value: 29643 },
	
	{rank: 25, icon: s_ui_icon_rank06_2529, icon_grey: s_ui_icon_rank06_2529_grey, value: 32223 },
	{rank: 26, icon: s_ui_icon_rank06_2529, icon_grey: s_ui_icon_rank06_2529_grey, value: 34910 },
	{rank: 27, icon: s_ui_icon_rank06_2529, icon_grey: s_ui_icon_rank06_2529_grey, value: 37705 },
	{rank: 28, icon: s_ui_icon_rank06_2529, icon_grey: s_ui_icon_rank06_2529_grey, value: 40608 },
	{rank: 29, icon: s_ui_icon_rank06_2529, icon_grey: s_ui_icon_rank06_2529_grey, value: 43618 },

	{rank: 30, icon: s_ui_icon_rank07_3034, icon_grey: s_ui_icon_rank07_3034_grey, value: 46735 },
	{rank: 31, icon: s_ui_icon_rank07_3034, icon_grey: s_ui_icon_rank07_3034_grey, value: 49960 },
	{rank: 32, icon: s_ui_icon_rank07_3034, icon_grey: s_ui_icon_rank07_3034_grey, value: 53293 },
	{rank: 33, icon: s_ui_icon_rank07_3034, icon_grey: s_ui_icon_rank07_3034_grey, value: 56733 },
	{rank: 34, icon: s_ui_icon_rank07_3034, icon_grey: s_ui_icon_rank07_3034_grey, value: 60280 },
	
	{rank: 35, icon: s_ui_icon_rank08_3539, icon_grey: s_ui_icon_rank08_3539_grey, value: 63935 },
	{rank: 36, icon: s_ui_icon_rank08_3539, icon_grey: s_ui_icon_rank08_3539_grey, value: 67698 },
	{rank: 37, icon: s_ui_icon_rank08_3539, icon_grey: s_ui_icon_rank08_3539_grey, value: 71568 },
	{rank: 38, icon: s_ui_icon_rank08_3539, icon_grey: s_ui_icon_rank08_3539_grey, value: 75545 },
	{rank: 39, icon: s_ui_icon_rank08_3539, icon_grey: s_ui_icon_rank08_3539_grey, value: 79630 },
	
	{rank: 40, icon: s_ui_icon_rank09_4044, icon_grey: s_ui_icon_rank09_4044_grey, value: 83823 },
	{rank: 41, icon: s_ui_icon_rank09_4044, icon_grey: s_ui_icon_rank09_4044_grey, value: 88123 },
	{rank: 42, icon: s_ui_icon_rank09_4044, icon_grey: s_ui_icon_rank09_4044_grey, value: 92530 },
	{rank: 43, icon: s_ui_icon_rank09_4044, icon_grey: s_ui_icon_rank09_4044_grey, value: 97045 },
	{rank: 44, icon: s_ui_icon_rank09_4044, icon_grey: s_ui_icon_rank09_4044_grey, value: 101668 },
	
	{rank: 45, icon: s_ui_icon_rank10_4549, icon_grey: s_ui_icon_rank10_4549_grey, value: 106398 },
	{rank: 46, icon: s_ui_icon_rank10_4549, icon_grey: s_ui_icon_rank10_4549_grey, value: 111235 },
	{rank: 47, icon: s_ui_icon_rank10_4549, icon_grey: s_ui_icon_rank10_4549_grey, value: 116180 },
	{rank: 48, icon: s_ui_icon_rank10_4549, icon_grey: s_ui_icon_rank10_4549_grey, value: 121233 },
	{rank: 49, icon: s_ui_icon_rank10_4549, icon_grey: s_ui_icon_rank10_4549_grey, value: 126393 },
	
	{rank: 50, icon: s_ui_icon_rank11_5054, icon_grey: s_ui_icon_rank11_5054_grey, value: 131660 }
];
//******************************************************
//*****    Script Resource: RankIndicator
//******************************************************

var RankIndicator = function() {
    
}

RankIndicator.createFromScore = function(score, isGrey) {

    isGrey = isGrey || false;

    var rankData = RankChart.getRankData(score);

    return this.createFromRankData(rankData, isGrey);
}

RankIndicator.createFromRankData = function(rankData, isGrey) {

    isGrey = isGrey || false;

    var offset = {x: -1.5, y: 1};

    var image = isGrey ? rankData.icon_grey.clone() : rankData.icon.clone();
    var fontRank = f_autoradiographic_italic.clone();
    
    fontRank.setFontSize(34);
    fontRank.setAlign('center');
    fontRank.setBaseline('middle');

    fontRank.setFillColor('#ffffcc');
    fontRank.setStrokeWidth(4);
    fontRank.setStrokeColor('#002d57');

    fontRank.setText('' + rankData.rank);
    fontRank.setPosition(image.width / 2 + offset.x, image.height / 2 + offset.y);

    fontRank.setStyle();

    image.addChild(fontRank);
    return image;
}
//******************************************************
//*****    Script Resource: RankBar
//******************************************************

var RankBar = function(container) {

	this._container = container;

	this._currentScore = 0;
	this._scoreToNextRank = 0;

	this.glowSpeed = 2;
	this._glowProgress = 0;

	this._toRewardScore = 0;
	this._currentRewardScore = 0;

	// The amount of time it takes in milliseconds to increase the rank bar by the amount of score added
	this._progressTime = 500;
	this._rewardProgressTime = 600;

	this._rankUpGlowTime = 700;
	this._rankUpGlowAmount = 3;

	this._state = RankBar.States.idle;
	this._prevState = RankBar.States.idle;
}

RankBar.prototype.constructor = RankBar;

RankBar.States = {
	idle: 0,
	fadeIn: 1,
	animateBar: 2,
	animateRewardBar: 3,
	rewardBarGlowing: 4,
	fillingRewardBar: 5,
	decreaseRewardBar: 6,
	rankUp: 7,
}

/** Creates a new rankbar with the correct visuals depending on the score/xp */
RankBar.prototype.init = function(score) {

	this._progressBarBG = s_progress_bar.clone();
	this._progressFilling = s_progress_filling.clone();
	this._progressBorder = s_progress_border.clone();

	var fillBarOffsetX = 0;
	var fillBarOffsetY = 3;
	var borderOffsetX = 16;
	var borderOffsetY = -8;

	this._progressBorder.setPosition(borderOffsetX, borderOffsetY);
	this._progressFilling.setPosition(-this._progressFilling.width, 0);

	var barContainerOffsetX = borderOffsetX + fillBarOffsetX - this._progressBorder.width / 2;
	var barContainerOffsetY = borderOffsetY + fillBarOffsetY - this._progressBorder.height / 2;

	this._barContainer = new tbContainer();
	this._barContainer.setPosition(barContainerOffsetX, barContainerOffsetY);

	this._rewardContainer = new tbContainer();
	this._rewardContainer.setPosition(barContainerOffsetX, barContainerOffsetY);

	this._rankBadgeOffsetX = this._progressBarBG.width / -2 + 24;
	this._rankBadgeOffsetY = -6;

	this._rankCircleOutline = s_progress_circle.clone();
	this._rankCircleOutline.setPosition(this._rankBadgeOffsetX + 1.5, this._rankBadgeOffsetY);

	var progressTextOffsetX = -32;
	var progressTextOffsetY = -30;

	this._fontRank = f_autoradiographic_italic.clone();
	this._fontRank.setFontSize(40);
	this._fontRank.setFillColor('#ffffff');
	this._fontRank.setStrokeWidth(5);
    this._fontRank.setStrokeColor('#1a202a');
    this._fontRank.setAlign('right');
	this._fontRank.setPosition(this._progressBarBG.width / 2 + progressTextOffsetX, progressTextOffsetY);

	this.setRank(score);
	this._newScore = this._currentScore;
	this._firstRankValue = RankChart.getNextDataByScore(0).value;

	// progressBubbleFilling is the yellow bar that indicates how much xp can be gained as a reward for watching an ad
	this._progressBubbleFilling = s_progress_bubble_filling.clone();
	this._progressBubbleFilling.setPosition(-this._progressBubbleFilling.width, 0);

	this._barMask = tbGraphics.drawRectangle(0, 0, this._progressFilling.width, this._progressFilling.height, 0xff0000, null, 0, 0.25);
	this._progressFilling.setMask(this._barMask);
	this._progressBubbleFilling.setMask(this._barMask);

	this._container.addChild(this._progressBarBG);
	this._container.addChild(this._barContainer);
	this._barContainer.addChild(this._progressBubbleFilling);
	this._barContainer.addChild(this._progressFilling);
	this._container.addChild(this._progressBorder);
	this._container.addChild(this._rewardContainer);
	this._container.addChild(this._rankCircleOutline);
	this._container.addChild(this._rankBadge);
	this._container.addChild(this._fontRank);
	this._barContainer.addChild(this._barMask);

	this.updateBarPosition(score);

	this._barAnimator = new tbAnimator();
	this._barAnimatorTrack = this._barAnimator.addTrack('function', this, this.updateScore);

	this._rewardAnimator = new tbAnimator();
	this._rewardAnimatorTrack = this._rewardAnimator.addTrack('function', this, this.updateReward);

	this._rankUpAnimator = new tbAnimator();
	this._rankUpAnimatorTrack = this._rankUpAnimator.addTrack('alpha', this._progressFilling.sprite);

	tbGame.addToken(this);
}

RankBar.prototype.fadeIn = function(fromYPos, toYPos, time, onDoneCallback)
{
	this._container.setAlpha(0);

	if (!this._fadeAnimator) {
		this._fadeAnimator = new tbAnimator();
		this._fadeAnimatorTrack = this._fadeAnimator.addTrack('function', this, function(value) {

			console.log("update alpha", value);
			this._container.setPosition(this._container.x, fromYPos + (toYPos - fromYPos) * value);
			this._container.setAlpha(value);

			if (value == 1) {
				if (onDoneCallback) onDoneCallback();

				this.setState(RankBar.States.idle);
			}
		});
	}
	else {
		this._fadeAnimator.pause();
		this._fadeAnimator.removeAllKeys();
	}

	this._fadeAnimator.addKey(this._fadeAnimatorTrack, 0, 0, tbEase.easeLinear, 1);
	this._fadeAnimator.addKey(this._fadeAnimatorTrack, time, 1, tbEase.easeLinear, 1);

	this._fadeAnimator.setTime(0);
	this._fadeAnimator.resumeForced();

	this.setState(RankBar.States.fadeIn);
}

/** Whether the rankbar has reached the max rank */
RankBar.prototype.isMaxRank = function() {
	return RankChart.getHighestRank().value == this._currentRankData.value;
}

RankBar.prototype.setState = function(state) {
	this._prevState = this._state;
	this._state = state;
}

/** Creates the teasing bar that shows how much xp can be gained as a reward for watching an ad
 * @param onRewardBarFinishCallback A callback function that triggers when the reward bar has finished its animation and is fully visible
 */
RankBar.prototype.createRewardBar = function(rewardScore, onRewardBarFinishCallback) {

	this._totalRewardScore = rewardScore;

	if (this.isMaxRank()) {
		onRewardBarFinishCallback();
		return;
	}

	this._currentRewardScore = 0;

	var toNextRankScore = this._nextRankData.value - this._currentScore;

	this._toRewardScore = Math.min(toNextRankScore, rewardScore);

	this._onRewardBarFinished = onRewardBarFinishCallback;

	// progressBubbleFillingGlow is the glow effect that appears when the reward bar is fully visible
	this._progressBubbleFillingGlow = s_progress_bubble_filling_glow.clone();
	this._progressBubbleFillingGlow.setAlpha(0);
	this._progressBubbleFillingGlow.setPosition(-this._progressBubbleFilling.width, 0);

	var maskX = this._progressFilling.x + this._progressFilling.width;
	var maskY = this._progressBubbleFillingGlow.height / -4;
	var maskWidth = this._progressFilling.width - (this._progressFilling.x + this._progressFilling.width) + 30;
	var maskHeight = this._progressBubbleFillingGlow.height;

	this._rewardMask = tbGraphics.drawRectangle(maskX, maskY, maskWidth, maskHeight, 0xff0000, null, 0, 0.5);
	this._progressBubbleFillingGlow.setMask(this._rewardMask);

	// The glow effect gets in a different container than the other bars because it needs to be in front of the border
	this._rewardContainer.addChild(this._progressBubbleFillingGlow);
	this._rewardContainer.addChild(this._rewardMask);


	this._rewardAnimator.pause();
	this._rewardAnimator.removeAllKeys();

	this._rewardAnimator.addKey(this._rewardAnimatorTrack, 0, 0, tbEase.easeOutCircular, 1.2);
	this._rewardAnimator.addKey(this._rewardAnimatorTrack, this._rewardProgressTime, this._toRewardScore, tbEase.easeOutCircular, 1.2);

	this._rewardAnimator.setTime(0);
	this._rewardAnimator.resumeForced();


	this.setState(RankBar.States.animateRewardBar);
}

RankBar.prototype.fillRewardBar = function(onFilledCallback) {

	if (!this.isMaxRank()) {
		this._progressBubbleFillingGlow.setAlpha(0);
	}

	this._newScore = this._currentScore;

	this.addScore(this._totalRewardScore, onFilledCallback);

	this.setState(RankBar.States.fillingRewardBar);
}

RankBar.prototype.decreaseRewardBar = function() {

	this.setState(RankBar.States.decreaseRewardBar);

	this._rewardAnimator.pause();
	this._rewardAnimator.removeAllKeys();

	this._rewardAnimator.addKey(this._rewardAnimatorTrack, 0, this._toRewardScore, tbEase.easeOutCircular, 1.2);
	this._rewardAnimator.addKey(this._rewardAnimatorTrack, this._rewardProgressTime, 0, tbEase.easeOutCircular, 1.2);

	this._rewardAnimator.setTime(0);
	this._rewardAnimator.resumeForced();

	this._progressBubbleFillingGlow.setAlpha(0);
}

RankBar.prototype.handleSpecial = function(id, data) {

	console.log('RankBar.handleSpecial', id, data);

	switch (id) {
		case 'badge_done' : {

			console.log('RankBar -> data = ', data);

			var score = data.score;
			var amount = data.amount;
			var total = score * amount;

			this.addScore(total, function() {
				console.log('score added');

				tbGame.addSpecial('reward_added', {});
			});

			break;
		};
		case 'double_tease' : {

			if (AdManager.supportsRewarded() ) {

				this.createRewardBar(data.score, function() {

					console.log('double_tease callback::', data.score);
				});
			}

			break;
		};
		case 'end_round_score': {

			this.setRoundTotalScore(data.score);

			break;
		};
		case 'claim_reward_xp': {

			this.fillRewardBar(function() {

				console.log("Reward bar is filled");
			});
		}
		default: {
			// ignore
		}
	}
}

/** Makes the rankbar glow a couple of times which is used for ranking up */
RankBar.prototype.startRankUpGlowing = function() {

	if (this._progressBubbleFilling) {
		this._progressBubbleFilling.setAlpha(0);
	}

	this._rankUpAnimator.pause();
	this._rankUpAnimator.removeAllKeys();

	this._rankUpAnimator.addKey(this._rankUpAnimatorTrack, 0, 1, tbEase.easeLinear, 1);

	for (var i = 0; i < this._rankUpGlowAmount; i++) {

		var toTime = this._rankUpGlowTime * (i + 1);
		var fromTime = toTime -  this._rankUpGlowTime / 2;

		this._rankUpAnimator.addKey(this._rankUpAnimatorTrack, fromTime, 0, tbEase.easeLinear, 1);
		this._rankUpAnimator.addKey(this._rankUpAnimatorTrack, toTime, 1, tbEase.easeLinear, 1);
	}

	this._rankUpAnimator.setTime(0);
	this._rankUpAnimator.resumeForced();
}

/** Triggers an animation and updates the rank in the progress bar */
RankBar.prototype.updateRank = function(score, animate, options) {

	var self = this;

	options = options || {};

	animate = animate || false;

	if (animate) {

		this.startRankUpGlowing();
		this.setState(RankBar.States.rankUp);

		tgfAudio.pause(this._expGainSound);

		// TODO: Play rankup sound when rankup animation is implemented
		//tgfAudio.play(a_rank_up);
	}

	var rankUp = new tgfDialogs.BattleshipRankUpDialog({
		x: 0,
		y: 0,
		score: score,
		rankFrom: options.rankFrom,
		rankTo: options.rankTo,
		callback: function() {
			this.setRank(score);
			rankUp.hide(true);
			rankUp.free();

			var onDone = function() {
				this.setState(this._prevState);
				
				if (options.onDone) {
					options.onDone();
				}

				tgfAudio.resume(this._expGainSound);
			}.bind(this)

			var unlockedWeapon = WeaponUnlockChart.getUnlockableWeaponAtRank(RankChart.getRankData(score).rank);

			if (unlockedWeapon) {
				var type;
				switch (unlockedWeapon) {
					case SpecialWeaponData.SpecialWeapon.airStrike:
						type = tgfDialogs.BattleshipChestOpenDialog.REWARDS.AIRSTRIKE
						break;
					case SpecialWeaponData.SpecialWeapon.torpedo:
						type = tgfDialogs.BattleshipChestOpenDialog.REWARDS.TORPEDO
						break;
					case SpecialWeaponData.SpecialWeapon.bomb: {
						type = tgfDialogs.BattleshipChestOpenDialog.REWARDS.ROCKET
						break;
					}
					case SpecialWeaponData.SpecialWeapon.scatter:
					default: {
						type = tgfDialogs.BattleshipChestOpenDialog.REWARDS.SCATTER
						break;
					}
				}
				var dialog = new tgfDialogs.BattleshipChestOpenDialog({
					rewardType: type,
					onClose: onDone
				});
				dialog.show();
			} else {
				onDone()
			}
		}.bind(this)
	});

	rankUp.show();
	tgfAudio.play(a_rank_up);
}

/** Sets or changes the rank and updates the rank badge */
RankBar.prototype.setRank = function(score) {

	this._currentRankData = RankChart.getRankData(score);
	this._nextRankData = RankChart.getNextDataByScore(score);
	this._progressData = RankChart.getRankProgress(score);

	this._currentScore = score;
	this._scoreToNextRank = this._progressData.to;

	if (!this.isMaxRank() && this._state == RankBar.States.fillingRewardBar) {
		this.updateRewardBarPosition(this._newScore);
	}

	if (this._progressBubbleFilling) {
		this._progressBubbleFilling.setAlpha(1);
	}

	if (this._rankBadge) {
		this._container.removeChild(this._rankBadge);
	}

	this._rankBadge = RankIndicator.createFromRankData(this._currentRankData);
	this._rankBadge.setPosition(this._rankBadgeOffsetX, this._rankBadgeOffsetY);

	this._container.addChild(this._rankBadge);

	this._fontRank.setText(RankChart.formatRankProgress(this._currentScore));// + " : " + Math.round(this._currentScore) );
}

/** Updates the amount of score stored in the progress bar and visually updates it */
RankBar.prototype.updateScore = function(value) {

	this._currentScore = this.isMaxRank() ? value : Math.min(value, this._nextRankData.value);

	this.updateBarPosition(this._currentScore);
	this._fontRank.setText(RankChart.formatRankProgress(this._currentScore));// + " : " + Math.round(this._currentScore) );

	if (!this.isMaxRank() && this._currentScore == this._nextRankData.value) {

		this.updateRank(this._currentScore, true);
	}

	else if (this._onScoreAdded && this._currentScore == this._newScore) {

		if (this._onScoreAdded) {

			this._onScoreAdded();
		}

		this.setState(RankBar.States.idle);

		tgfAudio.stop(this._expGainSound, 0);
	}
}

/** Updates the teasing bar that shows how much xp can be gained as a reward for watching an ad */
RankBar.prototype.updateReward = function(value) {

	this._currentRewardScore = value;

	this.updateRewardBarPosition(this._currentScore + this._currentRewardScore);

	if (this._state != RankBar.States.decreaseRewardBar && this._currentRewardScore == this._toRewardScore) {

		if (this._onRewardBarFinished) this._onRewardBarFinished();

		this.setState(RankBar.States.rewardBarGlowing);
	}
}

RankBar.prototype.handleBeginStep = function(timePassed) {

	switch(this._state) {
		case RankBar.States.fadeIn: {
			console.log("fading in");
			this._fadeAnimator.updateTime(timePassed);
		}
		break;
		case RankBar.States.fillingRewardBar:
		case RankBar.States.animateBar: {

			this._barAnimator.updateTime(timePassed);
		}
		break;
		case RankBar.States.animateRewardBar:
		case RankBar.States.decreaseRewardBar: {

			this._rewardAnimator.updateTime(timePassed);
		}
		break;
		case RankBar.States.rewardBarGlowing: {

			this.updateRewardGlowing(timePassed);
		}
		break;
		case RankBar.States.rankUp: {

			this._rankUpAnimator.updateTime(timePassed);
		}
		break;
	}
}

/** Fades the reward progress bar in and out */
RankBar.prototype.updateRewardGlowing = function(timePassed) {

	this._glowProgress += this.glowSpeed * (timePassed / 1000);
	this._glowProgress = Math.min(Math.max(this._glowProgress, 0), 1);

	if (this._glowProgress == 1 || this._glowProgress == 0) {
		this.glowSpeed = -this.glowSpeed;
	}

	this._progressBubbleFillingGlow.setAlpha(this._glowProgress);
}

/** Updates the position of the progress bar according the amount of score */
RankBar.prototype.updateBarPosition = function(score) {

	this._progressData = RankChart.getRankProgress(score);
	var progress = 1 - this._progressData.progress;

	if (score == this._nextRankData.value) {
		progress = 0;
	}

	this._progressFilling.setPosition(progress * -this._progressFilling.width, 0);
}

/** Updates the position of the teasing bar that indicates how much xp can be gained as a reward for watching an ad */
RankBar.prototype.updateRewardBarPosition = function(score) {

	var progress = 1 - RankChart.getRankProgress(score).progress;

	if (score == this._nextRankData.value) {
		progress = 0;
	}

	this._progressBubbleFilling.setPosition(progress * -this._progressFilling.width, 0);
	this._progressBubbleFillingGlow.setPosition(this._progressBubbleFilling.x, 0);
}

/**
 * Adds a certain amount of score to the current score that is stored
 * @param onScoreAddedCallback A callback function that triggers when the score is visually applied to the progress bar
 */
RankBar.prototype.addScore = function(amount, onScoreAddedCallback) {

	this.changeScore(this._newScore + amount, onScoreAddedCallback);
}

RankBar.prototype.setRoundTotalScore = function(endScore, onScoreAddedCallback) {

	this._stopBar();

	var diff = endScore - this._newScore;

	var rankDataNow = RankChart.getRankData(this._newScore);
	var rankDataAfter = RankChart.getRankData(endScore);

	var self = this;

	var onDone =  function() {

		self.updateBarPosition(endScore);
		tbGame.addSpecial('reward_added', {});
	};


	if (rankDataAfter.rank > rankDataNow.rank) {

		this.updateRank(endScore, true, {rankFrom: rankDataNow, rankTo: rankDataAfter, onDone: onDone});
	}
	else {



		setTimeout(function() {

			self._currentScore = endScore;
			self._newScore = 0;

			self.setRank(endScore);


			onDone();
		}, 1);
	}
}

/**
 * Changes the current score that is stored in the progress bar
 * @param onScoreAddedCallback A callback function that triggers when the score is visually applied to the progress bar
 */
RankBar.prototype.changeScore = function(newScore, onScoreAddedCallback) {

	this._onScoreAdded = onScoreAddedCallback;
	this._newScore = newScore;

	this._barAnimator.pause();
	this._barAnimator.removeAllKeys();

	var scoreFrom = this._currentScore;

	console.log('RB::.changeScore', scoreFrom, newScore);

	this._barAnimator.addKey(this._barAnimatorTrack, 0, scoreFrom, tbEase.easeOutCubic, 1.2);
	this._barAnimator.addKey(this._barAnimatorTrack, this._progressTime, newScore, tbEase.easeOutCubic, 1.2);

	this._barAnimator.setTime(0);
	this._barAnimator.resumeForced();

	this._expGainSound = tgfAudio.play(a_experience_gain);
	tgfAudio.setLooping(this._expGainSound, true);

	this.setState(RankBar.States.animateBar);
}

RankBar.prototype._stopBar = function() {

	if (this._barAnimator) {

		this._barAnimator.pause();
		this._barAnimator.removeAllKeys();

		this.setState(RankBar.States.idle);
	}
}

RankBar.prototype.destroy = function() {

	tbGame.removeToken(this);
}

//******************************************************
//*****    Script Resource: RewardBadge
//******************************************************

var RewardBadge = function(animation, type, score, amount) {

	var self = this;

	this._type = type;
	this._score = score;
	this._amount = amount;
	this._animationSpeed = 1.5;

	this._positionOffset = -100;

	this._badge = new BattleshipComponents.SpineAnimation({
		x: tgfGraphics.areaWidth/2,
		y: tgfGraphics.areaHeight/2 + 180 - 100, // Applied offset
	animation: animation,
		onLoad: function () {

			self._labelType.setAlpha(0);
			self._labelScore.setAlpha(0);
			self._badge.animator.animation.alpha = 0;
		}
	});

	var postfix = amount > 1 ? " (x" + amount + ")" : "";

	var typeProps = {
		text: RewardTypes.getNameByType(type) + postfix,
		font: {
			fontFace: f_babas_bold.fontFace,
			fillColor: '#ffffcc',
			fontSize: 40,
			strokeWidth: 4,
			strokeColor: "#002d57"
		},
		x: 0,
		y: 230,
		align: 'center'
	};

	var scoreProps = {
		text: "" + (score * amount),
		font: {
			fontFace: f_impact.fontFace,
			fillColor: ['#ffbf02', '#ff7d1c'],
			fontSize: 42,
			strokeWidth: 6,
			strokeColor: "#002d57"
		},
		x: 0,
		y: 280,
		align: 'left'
	};

	this._labelType = new tgfComponents.Label(typeProps);
	this._labelScore = new tgfComponents.Label(scoreProps);
	this._badge.addComponent(this._labelType);
	this._badge.addComponent(this._labelScore);

	this._plusSign = s_result_add.clone();
	this._plusSign.setAlpha(0);

	// Add plusSign a frame later when labelScore is initialized
	var self = this;
	setTimeout(function() {
		self._labelScore.addChild(self._plusSign);
	}, 0);

	console.log('BADGE::animation ->', animation);//this._badge);
}

RewardBadge.prototype.constructor = RewardBadge;

RewardBadge.prototype.play = function() {

	var self = this;

	Doors.shake(450/this._animationSpeed);

	this._labelType.baseX = this._labelType.x;
	this._labelType.baseY = this._labelType.y + 100;
	this._labelScore.baseX = this._labelScore.x;
	this._labelScore.baseY = this._labelScore.y + 100;

	this._animatorFonts = new tbAnimator(this._labelType.font.font);
	this._animatorFontsTrackF = this._animatorFonts.addTrack('function', this, this._updateFontAnimation);

	this._animatorFonts.addKey(this._animatorFontsTrackF, 0, 0, tbEase.easeOutCubic, 1.2);
	this._animatorFonts.addKey(this._animatorFontsTrackF, 400/this._animationSpeed, 0, tbEase.easeOutCubic, 1.2);
	this._animatorFonts.addKey(this._animatorFontsTrackF, 620/this._animationSpeed, 1, tbEase.easeOutCubic, 1.2);

	self._badge.animator.setSpeed(this._animationSpeed);
	self._badge.animator.animation.alpha = 1;
	self._badge.playAnimation('animation', false, function() {
		console.log('badge finished');

		self._done();
	});

	tgfAudio.play(a_badge_reward);
}

RewardBadge.prototype.skip = function() {

	this._done();
}


RewardBadge.prototype._done = function() {

	if (this._doneCalledOnce) return;

	this._doneCalledOnce = true;

	tbGame.addSpecial('badge_done', {score: this._score, amount: this._amount});
}

RewardBadge.prototype.reward = function() {

}

RewardBadge.prototype.next = function(stepIncrease, onDoneCallback) {

	if (this._positionOffset >= 2) return;

	var stepFrom = this._positionOffset;

	this._positionOffset += stepIncrease;
	// if (this._positionOffset > 2) this._positionOffset = 2;

	var speed = 350/this._animationSpeed;
	var distance = Math.min(tgfGraphics.visibleWidth / 2, 500);

	this._updateAnimator(speed, distance, onDoneCallback);
}

RewardBadge.prototype._updateAnimator = function(speed, distance, onDoneCallback) {

	var badgeContainer = this._badge;

	if (!this._animator) {

		this._movingOut = true;

		this._animator = new tbAnimator(badgeContainer);
		this._animatorTrackX = this._animator.addTrack('x');


		// stop and reverse font animation
		this._animatorFonts.pause();
		this._animatorFonts.removeAllKeys();

		this._animatorFonts.addKey(this._animatorFontsTrackF, 0, 1, tbEase.easeInCubic, 1.2);
		this._animatorFonts.addKey(this._animatorFontsTrackF, 150/this._animationSpeed, 0, tbEase.easeInCubic, 1.2);

		this._animatorFonts.setTime(0);
		this._animatorFonts.resumeForced();
	}

	this._animator.pause();
	this._animator.removeAllKeys();

	this._animator.addKey(this._animatorTrackX, 0, badgeContainer.x, tbEase.easeInOutCubic, 1.3);
	this._animator.addKey(this._animatorTrackX, speed, badgeContainer.x - (distance * this._positionOffset), tbEase.easeInOutCubic, 1.3);

	if (onDoneCallback) {
		this._animator.addEvent(this._animatorTrackX, speed, onDoneCallback);
	}

	this._animator.setTime(0);
	this._animator.resumeForced();
}

RewardBadge.prototype._updateFontAnimation = function(value) {

	// console.log('FontTrackFunction', value);

	this._labelType.setAlpha(value);
	this._labelScore.setAlpha(value);
	this._plusSign.setAlpha(value);

	if (this._movingOut) {

		this._labelType.setPosition(this._labelType.baseX - (50 * (1-value)), this._labelType.baseY - (100));
		this._labelScore.setPosition(this._labelType.baseX - (50 * (1-value)), this._labelScore.baseY - (100));
	}
	else {

		this._labelType.setPosition(this._badge.x, this._labelType.baseY - (100 * value));
		this._labelScore.setPosition(this._badge.x, this._labelScore.baseY - (100 * value));
	}

	this._plusSign.setPosition(this._labelScore.x - this._plusSign.width - 6, this._labelScore.y + 12);
}

RewardBadge.prototype.tick = function(delta) {

	if (this._animator) {

		this._animator.updateTime(delta);
	}

	if (this._animatorFonts) {

		this._animatorFonts.updateTime(delta);
	}
}

RewardBadge.prototype.getComponent = function() {

	return this._badge;
}

//******************************************************
//*****    Script Resource: RewardController
//******************************************************

var RewardController = function(container) {

	this._badges = [];
	this._rewards = [];

	this._badgeStacks = [];
	this._container = container;

	this._rewardRoundScore = 0;
	this._doubleExperience = false;

	tbGame.addToken(this);
}

RewardController.prototype.constructor = RewardController;


RewardController.prototype.setup = function(rewardData) {

	this._rewardData = rewardData;

	for (var i = 0; i < rewardData.length; i++) {

		var reward = this._createReward(rewardData[i]);

		this._rewards.push(reward);
	}

	this._endRoundScore = UserDataController.getRankData().score + this._rewardRoundScore;

	return this._rewards;
}

RewardController.prototype.start = function() {

	this._next();
}

RewardController.prototype.skip = function() {

	this._skipAnimation = true;

	if (this._activeBadge) {
		this._activeBadge.skip();
	}

	if (!this._skippableSequenceCompleted) {
		AnalyticsService.reportEvent("interaction", "interaction", {
			eventType: "skip_animation"
		});
		OldAnalyticsService.reportDesignEvent(["ux", "skip_animation", "gameend"]);
	}
}

RewardController.prototype.doubleExperience = function() {

	this._doubleExperience = true;
}


RewardController.prototype._createReward = function(rewardData) {

	var animation = RewardTypes.getAnimationByType(rewardData.type);
	var score = RewardTypes.getScoreByType(rewardData.type);

	var type = rewardData.type;
	var amount = rewardData.amount;

	this._rewardRoundScore += (score * amount);

	var badge = new RewardBadge(animation, type, score, amount);

	return badge;
}

RewardController.prototype._next = function() {

	if (this._rewards.length > 0 && !this._skipAnimation) {

		// move active badges over
		this._moveBadges(1);


		this._activeBadge = this._rewards.splice(0,1)[0];
		this._activeBadge.play();

		this._badges.push(this._activeBadge);
	}
	else {

		console.log('badges done rewarding');


		if (this._skipAnimation && !this._skippedOnce) {

			this._skippedOnce = true;
			tbGame.addSpecial('end_round_score', {score: this._endRoundScore});
			return;
		}

		if (this._badges.length == 0) {

			console.log("badges skip stacking");
			tbGame.addSpecial('double_tease', {score: this._rewardRoundScore});
			return;
		}

		// move badges out of screen
		this._moveBadges(2, function() {

			this._addBadgeStacks();

		}.bind(this));
	}
}

RewardController.prototype._addBadgeStacks = function() {

	var interspace = 150;
	var start = Math.ceil(this._rewardData.length / -2);
	var center = tgfGraphics.areaWidth / 2;
	var offset = this._rewardData.length % 2 == 0 ? interspace / 2 : 0;
	var current = 0;

	// Adds a single stack
	var addStack = function() {

		var multiplier = start + current;
		var posX = center + offset + interspace * multiplier;
		var posY = 760; // Applied offset

		var badgeStack = new BadgeStack(this._container, this._rewardData[current].type, posX, posY);
		this._badgeStacks.push(badgeStack);

		badgeStack.startStackingAnimation(this._rewardData[current].amount, this._skipAnimation, function() {
			current++;

			// Keeping adding new stacks until its done
			if (current < this._rewardData.length) {
				addStack();
			}
			else {
				console.log("badges done stacking");
				tbGame.addSpecial('double_tease', {score: this._rewardRoundScore});
			}

		}.bind(this));
	}.bind(this);

	addStack();
}

RewardController.prototype._moveBadges = function(step, onDoneCallback) {

	for (var i = 0; i < this._badges.length; i++) {

		var callback = i == this._badges.length - 1 ? onDoneCallback : null;

		this._badges[i].next(step, callback);
	}
}

RewardController.prototype.handleBeginStep = function(timePassed) {

	for (var i = 0; i < this._badges.length; i++) {

		this._badges[i].tick(timePassed);
	}
}

RewardController.prototype.getRoundReward = function() {

	var multiplier = 1;
	if (this._doubleExperience) multiplier = 2;

	var roundReward = this._rewardRoundScore * multiplier;
	return roundReward;
}

RewardController.prototype.getBaseRoundRewardAdded = function() {

	return this._endRoundScore;
}

RewardController.prototype.handleSpecial = function(id, data) {

	switch (id) {
		case 'badge_done': {

			break;
		};
		case 'reward_added': {

			this._next();
			break;
		};
		case 'double_tease': {

			this._skippableSequenceCompleted = true;
			break;
		};
	}
}

RewardController.prototype.destroy = function() {

	tbGame.removeToken(this);
}

//******************************************************
//*****    Script Resource: RewardTypes
//******************************************************

var RewardTypes = {
	VICTORY: 'victory',
	LOST: "lost",
	DESTROYED: 'destroyed',
	SURVIVED: 'survived',
	SPECIAL_WEAPON: 'special_weapon',
}

RewardTypes.getScoreByType = function(type) {

	var score = null;

	// console.log('RewardTypes.getAnimationByType', type);

	switch (type) {
		case RewardTypes.VICTORY : {

			score = 25;
			break;
		};

		case RewardTypes.LOST : {
			score = 15;

			break;
		};

		case RewardTypes.DESTROYED : {

			score = 15;
			break;
		};

		case RewardTypes.SURVIVED : {

			score = 15;
			break;
		};

		case RewardTypes.SPECIAL_WEAPON : {

			score = 10;
			break;
		};
	}

	return score;
}

RewardTypes.getAnimationByType = function(type) {

	var animation = null;

	// console.log('RewardTypes.getAnimationByType', type);

	switch (type) {
		case RewardTypes.VICTORY : {

			animation = badge_victory;
			break;
		};

		case RewardTypes.LOST : {

			animation = badge_lost;
			break;
		};

		case RewardTypes.DESTROYED : {

			animation = badge_destroyed;
			break;
		};

		case RewardTypes.SURVIVED : {

			animation = badge_survived;
			break;
		};

		case RewardTypes.SPECIAL_WEAPON : {

			animation = badge_special_weapon;
			break;
		};
	}

	return animation;
}

RewardTypes.getNameByType = function(type) {

	var name = null;

	// console.log('RewardTypes.getnameByType', type);

	switch (type) {
		case RewardTypes.VICTORY : {

			name = tgfDictionary.getText('badge_victory');//'VICTORY';
			break;
		};

		case RewardTypes.LOST : {

			name = tgfDictionary.getText('badge_defeat');//'BATTLE COMPLETED';
			break;
		};

		case RewardTypes.DESTROYED : {

			name = tgfDictionary.getText('badge_shipDestroyed');//'SHIPS DESTROYED';
			break;
		};

		case RewardTypes.SURVIVED : {

			name = tgfDictionary.getText('badge_shipSurvived');//'SHIPS SURVIVED';
			break;
		};

		case RewardTypes.SPECIAL_WEAPON : {

			name = tgfDictionary.getText('badge_specialWeapon');//'SPECIAL WEAPONS USED';
			break;
		};
	}

	return name;
}

RewardTypes.getBadgeStackByType = function(type, stackAmount) {

	var data = this.getBadgeDataByType(type);
	var badgeContainer = new tbContainer();

	var stackOffset = {x: -4, y: -4};
	var shadowOffset = {x: 0, y: 3};

	var shadow = data.shadow.clone();
	shadow.setPosition(shadowOffset.x, shadowOffset.y);
	badgeContainer.addChild(shadow);

	for (var i = 0; i < stackAmount; i++) {

		var badge = data.icon.clone();
		badge.setPosition(stackOffset.x * i, stackOffset.y * i);

		badgeContainer.addChild(badge);
	}

	return badgeContainer;
}

RewardTypes.getBadgeDataByType = function(type) {

	var badgeData = null;

	switch (type) {
		case RewardTypes.VICTORY : {

			badgeData = {icon: s_icon_victory, shadow: s_icon_victory_shadow};
			break;
		};

		case RewardTypes.LOST : {

			badgeData = {icon: s_icon_lost, shadow: s_icon_lost_shadow};
			break;
		};

		case RewardTypes.DESTROYED : {

			badgeData = {icon: s_icon_destroyed, shadow: s_icon_destroyed_shadow};
			break;
		};

		case RewardTypes.SURVIVED : {

			badgeData = {icon: s_icon_survived, shadow: s_icon_survived_shadow};
			break;
		};

		case RewardTypes.SPECIAL_WEAPON : {

			badgeData = {icon: s_icon_special_weapon, shadow: s_icon_special_weapon_shadow};
			break;
		};
	}

	return badgeData;
}
//******************************************************
//*****    Script Resource: BadgeStack
//******************************************************

var BadgeStack = function(container, rewardType, offsetX, offsetY) {

    offsetX = offsetX || 0;
    offsetY = offsetY || 0;

    this._container = container;

    this._badgeData = RewardTypes.getBadgeDataByType(rewardType);

    this._stackContainer = new tbContainer();
    this._stackContainer.setPosition(container.x + offsetX, container.y + offsetY);
    this._container.addChild(this._stackContainer);
    
    this._totalStackAmount = 0;
    this._currentStackAmount = 0;
    this._startedAnimation = false;

    this._beginOffset = {x: 0, y: -16};
    this._stackOffset = {x: -4, y: -4};
    this._shadowOffset = {x: 0, y: 5};
    this._stackTime = 100;
    
	tbGame.addToken(this);
}

/** Creates the text at the bottom of the badge that indicates how many badges are stacked */
BadgeStack.prototype.createBadgeTotalText = function() {

    this._badgeTotalFont = f_impact.clone();

    this._badgeTotalFont.setFontFace(f_impact.fontFace);
    this._badgeTotalFont.setFillColor(['#ffbf02', '#ff7d1c']);
    this._badgeTotalFont.setFontSize(42);
    this._badgeTotalFont.setStrokeWidth(5);
    this._badgeTotalFont.setStrokeColor('#002d57');
    this._badgeTotalFont.setAlign('left');
    this._badgeTotalFont.setPosition(0, 70);

    this.updateBadgeTotalText();

    this._timesSign = s_result_times.clone();
    this._timesSign.setPosition(-this._timesSign.width, 86);

    this._stackContainer.addChild(this._timesSign);
    this._stackContainer.addChild(this._badgeTotalFont);
}

BadgeStack.prototype.updateBadgeTotalText = function() {
    
    if (this._badgeTotalFont) {
        this._badgeTotalFont.setText(this.getBadgeTotalText());
    }
    else {
        this.createBadgeTotalText();
    }
}

BadgeStack.prototype.getBadgeTotalText = function() {
    return "" + this._currentStackAmount;
}

BadgeStack.prototype.startStackingAnimation = function(stackAmount, skipAnimation, onDoneCallback) {

    if (skipAnimation) {

        this._stackTime = 1;
    }

    this._animator = new tbAnimator();

    this._totalStackAmount = stackAmount;
    this._onStackedCallback = onDoneCallback;

    this.addBadgeToStack();

    this._startedAnimation = true;
}

BadgeStack.prototype.createBadge = function(withShadow) {

    if (withShadow) {

        this._shadow = this._badgeData.shadow.clone();
	    this._stackContainer.addChild(this._shadow);
    }

    var badge = this._badgeData.icon.clone();
    this._stackContainer.addChild(badge);

    return badge;
}

/** Adds the first badge of the stack */
BadgeStack.prototype.addFirstBadge = function() {

    var badge = this.createBadge(true);
    badge.setPosition(0, this._beginOffset.y);
    badge.setAlpha(0);

    this._shadow.setPosition(this._shadowOffset.x, this._beginOffset.y + this._shadowOffset.y);
    this._shadow.setAlpha(0);

    this._animator.pause();
    this._animator.removeAllKeys();
    
    this._animatorTrack = this._animator.addTrack('function', this, function (value) {

        var alpha = 1 - value / this._beginOffset.y;

        badge.setPosition(0, value);
        badge.setAlpha(alpha);

        this._shadow.setPosition(badge.x + this._shadowOffset.x, badge.y + this._shadowOffset.y);
        this._shadow.setAlpha(alpha);

        if (value == 0) this.addBadgeToStack(badge);
    });

    // From beginOffsetY to 0
    this._animator.addKey(this._animatorTrack, 0, this._beginOffset.y, tbEase.easeLinear, 1.2);
    this._animator.addKey(this._animatorTrack, this._stackTime, 0, tbEase.easeLinear, 1.2);

    this._animator.setTime(0);
    this._animator.resumeForced();

    this._currentStackAmount++;
}

/** Adds a new badge to the stack */
BadgeStack.prototype.addBadgeToStack = function(prevBadge) {

    prevBadge = prevBadge || null;

    // Add the first badge (it has a different animation)
    if (this._currentStackAmount == 0) {
        this.addFirstBadge();
        return;
    }

    this.updateBadgeTotalText();

    // When all the badges are stacked
    if (this._currentStackAmount == this._totalStackAmount) {
        
        if (this._onStackedCallback) {
            this._onStackedCallback();
        }
        this._startedAnimation = false;
        return;
    }

    var nextBadge = this.createBadge(this._currentStackAmount == 0);

    var end = prevBadge.y + this._stackOffset.y;
    var start = end + this._beginOffset.y;

    nextBadge.setPosition(prevBadge.x, prevBadge.y);
    nextBadge.setAlpha(0);

    this._animator.pause();
    this._animator.removeAllKeys();


    this._animatorTrack = this._animator.addTrack('function', this, function (value) {

        nextBadge.setPosition(nextBadge.x, value);
    });

    // From the previous badge, to the start, to the end
    this._animator.addKey(this._animatorTrack, 0, prevBadge.y, tbEase.easeLinear, 1.2);
    this._animator.addKey(this._animatorTrack, this._stackTime/2, start, tbEase.easeLinear, 1.2);
    this._animator.addKey(this._animatorTrack, this._stackTime, end, tbEase.easeLinear, 1.2);


    this._animatorTrackAlphaAndX = this._animator.addTrack('function', this, function (progress) {

        nextBadge.setPosition(progress * this._stackOffset.x + prevBadge.x, nextBadge.y);
        nextBadge.setAlpha(progress);

        if (progress == 1) this.addBadgeToStack(nextBadge);
    });

    // From 0 to 1. Used for the alpha and x position
    this._animator.addKey(this._animatorTrackAlphaAndX, 0, 0, tbEase.easeLinear, 1.2);
    this._animator.addKey(this._animatorTrackAlphaAndX, this._stackTime, 1, tbEase.easeLinear, 1.2);


    this._animator.setTime(0);
    this._animator.resumeForced();

    this._currentStackAmount++;
}

BadgeStack.prototype.handleBeginStep = function(timePassed) {

    if (!this._startedAnimation) return;

    this._animator.updateTime(timePassed);
}

RankBar.prototype.destroy = function() {

	tbGame.removeToken(this);
}
//******************************************************
//*****    Script Resource: Doors
//******************************************************

var Doors = (function() {

	var _Doors = function() {

	};

	_Doors.prototype.initialize = function() {

		if (this._doors) {

			this.layerOnTop();
			return;
		}

		this._container = new tgfDialogs.Base({

		});


		var self = this;
		this._doors = new BattleshipComponents.SpineAnimation({ 
			x: tgfGraphics.areaWidth/2, 
			y: tgfGraphics.areaHeight/2,// + 100, 
			animation: doors,
			onLoad: function () { 
				
				console.log('doors.onLoad', doors);
				self._ready = true;

				// self.close();
			}
		});

		this._container.addComponent(this._doors);
		this._container.show();
	}

	_Doors.prototype.layerOnTop = function() {

		this._container.baseContainer.add(this._container.parentDialog);
	}

	_Doors.prototype.open = function() {

		if (!this._ready) return;

		this._doors.playAnimation("doors_open", false, function () {

			tbGame.addSpecial("doors_opened", {});
		});

		tgfAudio.play(a_open_gate);
	}

	_Doors.prototype.shake = function(delay) {

		if (!this._ready) return;

		delay = delay || 0;

		var self = this;

		setTimeout(function() {
			
			self._doors.playAnimation("doors_shake", false, function () {

				tbGame.addSpecial("doors_shaken", {});
			});

		}, delay);

	}

	_Doors.prototype.close = function() {

		if (!this._ready) return;

		this._doors.playAnimation("doors_close", false, function () {

			tbGame.addSpecial("doors_closed", {});
		});

		tgfAudio.play(a_close_gate);
	}

	_Doors.prototype.constructor = _Doors;

	return new _Doors();	
}());
//******************************************************
//*****    Token Resource: OnboardingManager
//******************************************************

// ***************************************
// Definition of game token OnboardingManager
// ***************************************

// The constructor for the OnboardingManager game token.
var OnboardingManager = function(x, y, depth) {
	"use strict";
	// Properties used by the engine
	this.depth = depth;
	this.layer = 0;
	this.visible = true;
	this.active = true;
	// Your own properties
	this.x = x;
	this.y = y;
	// Add it to the game engine
	tbGame.addToken(this);
};

OnboardingManager.prototype.startCounting = function() {
	if (!ABTestInstance.isFeatureSupported(tgfSettings.abTests.features.ONBOARDING_HAND)) {
		return;
	}

	if (this._isRandomMatch()) {
		return;
	}

	this.resetTimer();

	this._isCounting = true;

	this._evaluateTimerDuration();
};

OnboardingManager.prototype.stopCounting = function() {
	this._isCounting = false;
};

OnboardingManager.prototype.resetTimer = function() {
	this._timeSinceInput = 0;
};

OnboardingManager.prototype._evaluateTimerDuration = function() {
	this._timeBeforeAnimation = 3000;

	if (this._hasSpecialWeaponAvailable() && this._isExistingUser()) {
		this._timeBeforeAnimation = 8000;
	} else if (this._hasSpecialWeaponAvailable() && !this._isOnFirstShot()) {
		this._timeBeforeAnimation = 3000;
	} else if (!this._isOnFirstShot()) {
		this._timeBeforeAnimation = 8000;
	} else if (this._isExistingUser()) {
		this._timeBeforeAnimation = 8000;
	}
};

OnboardingManager.prototype._getAnimationName = function() {
	var animation = tgfDialogs.BattleshipOnboardingAnimationDialog.ANIMATIONS.NORMAL_SHOT;
	if (this._hasSpecialWeaponAvailable() && (this._isExistingUser() || !this._isOnFirstShot())) {
		animation = tgfDialogs.BattleshipOnboardingAnimationDialog.ANIMATIONS.SPECIAL_WEAPON;
	}
	return animation;
};

OnboardingManager.prototype._hasSpecialWeaponAvailable = function() {
	var data = UserDataController.getSpecialWeaponData();
	return data.hasWeaponAvailable();
};

OnboardingManager.prototype._isExistingUser = function() {
	var rankData = UserDataController.getRankData();
	return rankData && (rankData.wins > 0 || rankData.losses > 0);
};

OnboardingManager.prototype._isOnFirstShot = function() {
	var state = TurnController.getState();
	return state === TurnController._TURN_STATES.FIRE1;
};

OnboardingManager.prototype._hasShotLeft = function() {
	var state = TurnController.getState();
	return (state === TurnController._TURN_STATES.FIRE1 ||
		state === TurnController._TURN_STATES.FIRE2 ||
		state === TurnController._TURN_STATES.FIRE3 ||
		state === TurnController._TURN_STATES.FIRE_X_SHOT);
};

OnboardingManager.prototype._isRandomMatch = function() {
	var matchData = UserDataController.getMatchData();
	return matchData && matchData.isRandomOpponent();
};

OnboardingManager.prototype._onTurnUpdate = function() {
	if (this._hasShotLeft()) {
		this.startCounting();
	} else {
		if (this._dialog) {
			this._dialog.hide();
			this._dialog.free();
			this._dialog = null;
		}
		this.stopCounting();
	}
}

OnboardingManager.prototype._hasPopupOpen = function() {
	if (playController.uiIngameMenu.isVisible) {
		return true;
	}

	var specialWeaponButtonManager = playController.getFireUnit().getSpecialWeaponButtonManager();
	var popup = null;
	if (specialWeaponButtonManager) {
		popup = specialWeaponButtonManager.uiSpecialActivatePopup
	}

	if (popup && popup.isVisible) {
		return true;
	}

	return false;
};

// handleAdd is called when the token is (re-) added to the game.
OnboardingManager.prototype.handleAdd = function() {
	"use strict";

	this._timeSinceInput = 0;

	this._isCounting = false;

	this._timeBeforeAnimation = 0;

	this._dialog = null;

	TurnController.addTurnListener(this._onTurnUpdate, this);
};

// handleRemove is called when the token is removed from the game.
OnboardingManager.prototype.handleRemove = function() {
	"use strict";

	if (this._dialog) {
		this._dialog.hide();
		this._dialog.free();
		this._dialog = null;
	}

	TurnController.removeTurnListener(this._onTurnUpdate, this);
};

// handleBeginStep is called each step before processing other events.
OnboardingManager.prototype.handleBeginStep = function(timePassed) {
	"use strict";
	if (!this._isCounting) {
		return;
	}

	this._timeSinceInput += timePassed

	if (this._timeSinceInput > this._timeBeforeAnimation && !this._hasPopupOpen()) {
		this._dialog = new tgfDialogs.BattleshipOnboardingAnimationDialog({
			animationClip: this._getAnimationName(),
			onDone: this.startCounting.bind(this)
		});

		console.log(this._dialog)
		this._dialog.show();

		this.stopCounting();
	}
};

// handleTouchDown is called when a touch is started or if a mouse button is pressed.
OnboardingManager.prototype.handleTouchDown = function(finger, x, y) {
	"use strict";

	if (this._dialog) {
		this.startCounting();
		this._dialog.hide();
		this._dialog.free();
		this._dialog = null;
	} else {
		this.resetTimer();
	}
};

// handleTouchUp is called when a touch is ended or if a mouse button is released.
OnboardingManager.prototype.handleTouchUp = function(finger, x, y) {
	"use strict";
};

// handleKeyDown is called if the key with the given keyCode is pressed.
OnboardingManager.prototype.handleKeyDown = function(keyCode) {
	"use strict";
};

// handleKeyUp is called if the key with the given keyCode is released.
OnboardingManager.prototype.handleKeyUp = function(keyCode) {
	"use strict";
};

// handleAlarm is called if a global alarm is reached.
OnboardingManager.prototype.handleAlarm = function(alarm) {
	"use strict";
};

// handleSpecial is called if a special or user-defined event happens.
OnboardingManager.prototype.handleSpecial = function(id, args) {
	"use strict";
};

// handleEndStep is called each step after processing other events (before draw).
OnboardingManager.prototype.handleEndStep = function(timePassed) {
	"use strict";
};

// handleDraw is called at the end of a step to draw the token.
OnboardingManager.prototype.handleDraw = function() {
	"use strict";
};


//******************************************************
//*****    Script Resource: ComponentBattleshipButton
//******************************************************

// ***************************************
// tgfComponents.ComponentBattleshipButton
//
// This is an empty ComponentBattleshipButton for a new component
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 25-9-2015
// ***************************************

// TODO: Everywhere replace ComponentBattleshipButton and ComponentBattleshipButton by the appropriate name

// Directives for jslint
/*global tbEase, tbVectorFont, tbGraphics, tbImage, tbSurface, tbGame */
/*global tgfComponents, tgfScale, tgfEffects, tgfDictionary, tgfAudio, tgfSettings */


tgfSettings.componentDefaults.componentBattleshipButton = {
	components: []                  // Components to add as children
};

// The constructor for the component
/**
 * @constructor
 * @base tgfComponents.ComponentBattleshipButton
 */
tgfComponents.ComponentBattleshipButton = function(properties) {
	"use strict";

	this._bsButtonFont = f_babas_bold.clone();
	this._font = this._bsButtonFont;
    this._font.align = 'center';
    this._font.baseline = "middle";
    this._font.fontSize = properties.fontSize ? properties.fontSize : 36;
	// this._font.fontStyle = 'italic';
    this._font.fillColor = '#ffffff';
    
    properties = properties || {};
	properties.text = properties.text || ''; 
	properties.fontDown = this._font; 
	properties.fontUp = this._font; 
	properties.iconDownScale = 1,
	properties.fontDownScale = 1,
	properties.image = properties.image || s_button_blue; 
	properties.createFromSlices = (properties.image == s_tgf_transparent) ? false : true; 
	properties.nineSliceOffsetX = properties.nineSliceOffsetX || 16; 
	properties.nineSliceOffsetY = properties.nineSliceOffsetY || 16; 
	properties.width = properties.width || 420; 
	properties.width += 8; // (2 x 4 from both sides)
	properties.height = properties.height || 86;
	properties.fitToBox = false;
	properties.interactive = properties.interactive !== undefined ? properties.interactive : true;
	properties.soundUp = properties.soundUp || a_button_click;

	tgfComponents.Button.prototype.constructor.call(this, properties);

	this.name = "ComponentBattleshipButton";			// The name of the component
	// Initialize properties
	// this.initialize(tgfSettings.componentDefaults.componentBattleshipButton);
	// Set user properties

    this._font.height = properties.height - 10;

	// console.log('CBB.image', properties.image, properties.text);


	var shadowColor;

	if (properties.image == s_button_green) {
		this._font.fontSize = properties.fontSize ? properties.fontSize : 40;
		this._font.strokeColor = "#4d5a00";
		this._font.strokeWidth = 4;
		this._font.fillColor = '#ffffcc';
		shadowColor = '#4d5a00';

	}
	else if (properties.image == s_button_gray) {
		this._font.fontSize = properties.fontSize ? properties.fontSize : 40;
		this._font.strokeWidth = 4;
		//this._font.strokeColor = "#4d5a00";
		this._font.fillColor = '#ffffcc';
		shadowColor = '#000000';
	}
	else if (properties.image == d_buttons_yellow) {
		this._font.fontSize = properties.fontSize ? properties.fontSize : 60;
		this._font.strokeWidth = 4;
		this._font.strokeColor = "#923300";
		this._font.fillColor = '#ffffcc';
		shadowColor = '#923300';
	}
	else { // blue
		this._font.fontSize = properties.fontSize ? properties.fontSize : 40;
		this._font.strokeWidth = 4;
		this._font.strokeColor = "#002d57";
		this._font.fillColor = '#ffffcc';
		shadowColor = '#002d57';
	}

	this._font.setShadow({
		active: true,
		blur: 0,
		color: shadowColor,
		offsetX: 0,
		offsetY: 3
	});

	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base component
tgfComponents.inherit(tgfComponents.ComponentBattleshipButton, tgfComponents.Button);

tgfComponents.ComponentBattleshipButton.prototype.doPrepare = function() {

	console.log('ComponentBattleshipButton.doPrepare', this.text);
	this._buttonPivot = {x: this.width/2, y: this.height/2};
	
	this.x += this._buttonPivot.x;
	this.y += this._buttonPivot.y;
	
	tgfComponents.Button.prototype.doPrepare.call(this);

	// console.log(this._imageNineSlices);
	// this._imageNineSlices[0].image.pivot.x = this._buttonPivot.x;
	// this._imageNineSlices[0].image.pivot.y = this._buttonPivot.y;

	// this._imageNineSlices[1].image.pivot.x = this._buttonPivot.x;
	// this._imageNineSlices[1].image.pivot.y = this._buttonPivot.y;

	this._imageRef = this.image.sprite;
	if (!this._imageRef) this._imageRef = this.image.image;

	this._imageRef.pivot.x = this._buttonPivot.x;
	this._imageRef.pivot.y = this._buttonPivot.y;

	this._imageRef.buttonMode = this.interactive;
	this._imageRef.interactive = this.interactive;

	this._font.setPosition(this._font.x, this._font.y + 3 - (this._font.strokeWidth + this._font.shadow.distance) * 0.5 );

	// While our text is larger than 80% of the button's width, size it down until it fits.
	// setTimeout(function() {
        var prefWidth = this.icon ? this.width * 0.5 : this.width * 0.8;
		while (this._font.font.width > prefWidth) {
			this._font.font.style.fontSize--;
			this._font.font.calculateBounds();
            //this._font.font.y = this.height / 2 - this._font.font.height / 2;
            
            // Make sure that the downstate doesn't mess with the font position
            this._fontPositionX = this._font.font.x;
            this._fontPositionY = this._font.font.y;
		}
        
	// }.bind(this), 0)
}

tgfComponents.ComponentBattleshipButton.prototype.setText = function(text) {
	this._font.setText(text);
}

tgfComponents.ComponentBattleshipButton.prototype.setInteraction = function(boolInteractive) {

	this._imageRef.buttonMode = boolInteractive;
	this._imageRef.interactive = boolInteractive;
}


tgfComponents.ComponentBattleshipButton.prototype.changeImageFrame = function(frame) {

	tgfComponents.Button.prototype.changeImageFrame.call(this, frame);

	if (this.fontText) {

		this._fontPositionX = this._fontPositionX || this.fontText.x;
		this._fontPositionY = this._fontPositionY || this.fontText.y;

		switch (frame) {
			case 0 : {

				this.fontText.setAlpha(1);
				this.fontText.setPosition(this._fontPositionX, this._fontPositionY);
				break;
			}
			case 1 : {

				if (this.image != s_tgf_transparent) {

					this.fontText.setAlpha(0.5);
				}
				this.fontText.setPosition(this._fontPositionX, this._fontPositionY + 4);
				break;
			}
		}
	}

	if (this.icon) {
		
		this._iconPositionX = this._iconPositionX || this.icon.x;
		this._iconPositionY = this._iconPositionY || this.icon.y;

		switch (frame) {
			case 0 : {

				this.icon.setAlpha(1);
				this.icon.setPosition(this._iconPositionX, this._iconPositionY);
				break;
			}
			case 1 : {

				this.icon.setAlpha(0.5);
				this.icon.setPosition(this._iconPositionX, this._iconPositionY + 4);
				break;
			}
		}
	}
}


tgfComponents.ComponentBattleshipButton.prototype.doFree = function() {

	// console.log('CBB.doFree');


	if (this._bsButtonFont) {
		// console.log('CBB.doFree - font available');
		if (this._bsButtonFont.font) {

			// console.log('CBB.doFree font available - font destroyed');

			this._bsButtonFont.font.destroy();
			this._bsButtonFont.font = null;
		}
		this._bsButtonFont = null;
	}

	tgfComponents.Button.prototype.doFree.call(this);	
}
//******************************************************
//*****    Script Resource: BattleshipLobbyDialog
//******************************************************

// ***************************************
// tgfDialogs.DialogLobby
//
// A template for new dialogs
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// TODO: Everywhere replace Template and template by the appropriate name

// Directives for jslint
/*global tgfSettings, tgfDialogs, tgfComponents */

tgfSettings.dialogDefaults.battleshipDialogLobby = {

	// listOffset: [
	// 	{
	// 		x: 0,
	// 		y: 440,
	// 	},
	// 	{
	// 		x: 0,
	// 		y: 400 // 130
	// 	},
	// 	{
	// 		x: 0,
	// 		y: 0
	// 	}
	// ],
	backgroundImage: s_background_main,
	buttonSize: {
		width: 460,
		height: 108,
		fontSize: 54,
	},

	paddingBottom: 60,
	//
	// componentLobbyListClass: tgfComponents.ComponentBattleshipLobbyList,
	// componentLobbyListItemClass: tgfComponents.BattleshipLobbyListItem
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.BattleshipDialogLobby = function(properties) {
	"use strict";
	tgfDialogs.DialogLobby.prototype.constructor.call(this, properties);

	console.log('BSLobby::BattleshipDialogLobby');

	this.name = "BattleshipDialogLobby";         // The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.battleshipDialogLobby);

	// this.backgroundImage = null;

	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }

};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.BattleshipDialogLobby, tgfDialogs.Base);

// ***************************************
// Specific methods for this dialog
// ***************************************


// ***************************************
// Internal methods
// ***************************************


// ***************************************
// Preparing and showing
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
// tgfDialogs.BattleshipDialogLobby.prototype.doPrepare = function() {



// 	tgfDialogs.DialogLobby.prototype.doPrepare.call(this);
// };


tgfDialogs.BattleshipDialogLobby.prototype.doPrepare = function() {
console.log(this)
	if (this.backgroundImage) {

		this._backgroundImage = this.backgroundImage.clone();
		this.baseContainer.addChild(this._backgroundImage);
	}

	window.lobby = this;
	// this.baseContainer.container.alpha = .25;
	// console.log('BSLobby::BattleshipDialogLobby:doPrepareCustom');

	this._backgroundImage.setPosition(-1, -1);
	this._backgroundImage.setDimensions(1368, 1368);

	this.lobbyHeader = new tgfComponents.ComponentLobbyHeader({
		y: 92
	});

	this.unlockable = new tgfComponents.NextUnlockable({
		y: 400,
		x: this.canvas.canvasWidth / 2,
	});

	this.topPixiContainer = new tbContainer();
	this.topContainer = new tgfComponents.Container({
		baseContainer: this.topPixiContainer,
		x: 0,
		y: 0,
		width: this.canvas.canvasWidth,
		height: 200
	});

    this.headerImage = new tgfComponents.Picture({
		x: this.canvas.canvasWidth / 2,
		y: -2,
        image: s_ui_header_lobby
    });

	var logoScale = 1.25;
	this.logo = new tgfComponents.Picture({
		x: this.canvas.canvasWidth / 2 - ((s_logo.width * logoScale) / 2),
		y: 0,
		image: s_logo,
	});

	this.logo.setScale(logoScale, logoScale);

	this.addComponent(this.topContainer);
	this.addComponent(this.lobbyHeader);
	this.addComponent(this.unlockable);
	this.addComponent(this.headerImage);
	this.addComponent(this.logo);


	this.buttonNewBattle = new tgfComponents.ComponentBattleshipButton({
		text: tgfDictionary.getText("Play"),
		image: s_button_green,
		width: this.buttonSize.width,
		height: this.buttonSize.height,
		x: tgfGraphics.areaWidth / 2,
		y: tgfGraphics.areaHeight - 302, // Changed the position of the button
		fontSize: this.buttonSize.fontSize,
	});

	// Add the stars in the NewBattle button a frame later when the button is properly initialized
	setTimeout(function() {

		var starRight = s_star_green.clone();
		var starLeft = s_star_green.clone();

		var starOffsetX = 40;
		var starOffsetY = -5;
		var starHalfWidth = s_star_green.width / 2;
		var starHalfHeight = s_star_green.height / 2;
		var starYPos = this.buttonNewBattle.image.height / 2 + starOffsetY - starHalfHeight;

		starRight.setPosition(
			this.buttonNewBattle.image.width / 2 + this.buttonNewBattle.fontText.font.width / 2 + starOffsetX - starHalfWidth,
			starYPos
		);
		starLeft.setPosition(
			this.buttonNewBattle.image.width / 2 - this.buttonNewBattle.fontText.font.width / 2 - starOffsetX - starHalfWidth,
			starYPos
		);

		this.buttonNewBattle.image.addChild(starRight);
		this.buttonNewBattle.image.addChild(starLeft);

	}.bind(this), 0);


	this.buttonNewBattle.onClick = function() {

		if (this._clickedOnce) {
			console.error('Already started new battle!!');
			return;
		}

		this._clickedOnce = true;
		tbGame.addSpecial('room-create');
	}

	this.addComponent(this.buttonNewBattle);

	tgfGraphics.addChild(this.topPixiContainer.container, 'battleshiplobbydialg.topPixiContainer');

	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

tgfDialogs.BattleshipDialogLobby.prototype.handleBeginStep = function(timePassed) {

	if (this._animatorScreenTransition) {

		this._animatorScreenTransition.updateTime(timePassed);
	}

	// var areaHeight = this._listActive.getHeight() + this._listInactive.getHeight() + this._listDone.getHeight() + this.paddingTop + this.paddingBottom + 2 * this.listSpacing + this.listOffset[0].y + this.listOffset[1].y + this.listOffset[2].y;
	// if (this._scrollBox) {
	//
	// 	this._scrollBox.areaHeight = areaHeight;
	// }


	// The lobby header should only move with the scrollbox when scrolling down
	if (this._scrollBox) {

		var scrollY = this._scrollBox.scrollContainer.y;

		if (scrollY > 0) {
			this.lobbyHeader.setPosition(0, 0);
		}
		else {
			this.lobbyHeader.setPosition(0, scrollY);
		}
	}
}

tgfDialogs.BattleshipDialogLobby.prototype.onRoomCreate = function() {

	console.log('BSLobby::onRoomCreated');

	BattleshipsAnalytics.reportClickedNewGameInLobby();
	AnalyticsHelper.reportButtonClick("new");

	UserDataController.clearMatch();

	this._gotoRoom();
}


tgfDialogs.BattleshipDialogLobby.prototype._gotoRoom = function() {

	this.hide();
	// flowController.currentAction = flowController.actionHideTitleScreen;
}


tgfDialogs.BattleshipDialogLobby.prototype.handleSpecial = function(id, args) {
	tgfDialogs.DialogLobby.prototype.handleSpecial.call(this, id, args);
};


tgfDialogs.BattleshipDialogLobby.prototype.show = function() {

	//console.log('BSLobby::BattleshipDialogLobby.show');

	BattleshipsAnalytics.reportScreenLobby();
	AnalyticsService.setScreenName("lobby")

	console.log("shooow")
	tgfDialogs.DialogLobby.prototype.show.call(this);
}

tgfDialogs.BattleshipDialogLobby.prototype.onShow = function() {

	this.fadeArea = this.fadeArea || tbGraphics.drawRectangle(0, 0, tbGraphics.width, tbGraphics.height, "#000000");
	this.fadeArea.alpha = 1;

	tgfGraphics.addChild(this.fadeArea, 'battleshipDialogLobby.fadeArea');


	if (this._animatorScreenTransition) {
		this._animatorScreenTransition = null;
	}

	this._animatorScreenTransition = new tbAnimator(this.fadeArea);
	this._animatorScreenTransitionTrackX = this._animatorScreenTransition.addTrack('alpha');
	// this._animatorScreenTransition.addKey(this._animatorScreenTransitionTrackX, 0, 0, tbEase.easeOutCubic, 1);
	this._animatorScreenTransition.addKey(this._animatorScreenTransitionTrackX, 0, 1, tbEase.easeOutCubic, 1);
	this._animatorScreenTransition.addKey(this._animatorScreenTransitionTrackX, 150, 1, tbEase.easeOutCubic, 1);
	this._animatorScreenTransition.addKey(this._animatorScreenTransitionTrackX, 300, 0, tbEase.easeOutCubic, 1);


	// console.log('BSLobby::listContainer', this._listContainer, this._listContainer.container);

	// this._animatorMoveIn = new tbAnimator(this._listContainer.baseContainer.container);
	// this._animatorMoveInTrackY = this._animatorMoveIn.addTrack('y');
	// this._animatorTopTrackY = this._animatorMoveIn.addTrack('y', this.topPixiContainer.container);

	// this._animatorMoveIn.addKey(this._animatorMoveInTrackY, 0, tgfGraphics.areaHeight, tbEase.easeOutCubic, 1);
	// this._animatorMoveIn.addKey(this._animatorMoveInTrackY, 350, tgfGraphics.areaHeight, tbEase.easeOutCubic, 1);
	// this._animatorMoveIn.addKey(this._animatorMoveInTrackY, 1000, 0, tbEase.easeOutCubic, 1);
	// this._animatorMoveIn.addKey(this._animatorTopTrackY, 600, -200, tbEase.easeOutCubic, 1);
	// this._animatorMoveIn.addKey(this._animatorTopTrackY, 1100, 0, tbEase.easeOutCubic, 1);


	// console.log('BSLobby::BattleshipDialogLobby.onShow');
}

tgfDialogs.BattleshipDialogLobby.prototype.doShow = function() {

	// console.log('BSLobby::BattleshipDialogLobby.doShow');
	BattleshipAudioManager.playMusic(a_lobby_music);
}


tgfDialogs.BattleshipDialogLobby.prototype.hide = function() {

	if (this._timeoutUpdate) {
		clearTimeout(this._timeoutUpdate);
		this._timeoutUpdate = null;
	}

	// console.log('BSLobby::BattleshipDialogLobby.hide');
	if (this._hidden) return;
	this._hidden = true;

	this.fadeArea = this.fadeArea || tbGraphics.drawRectangle(0, 0, tbGraphics.width, tbGraphics.height, "#000000");
	this.fadeArea.alpha = 0;
	tgfGraphics.addChild(this.fadeArea, 'battleshipDialogLobby.fadeArea');

	if (this._animatorScreenTransition) {
		this._animatorScreenTransition = null;
	}

	this._animatorScreenTransition = new tbAnimator(this.fadeArea);
	this._animatorScreenTransitionTrackX = this._animatorScreenTransition.addTrack('alpha');

	this._animatorScreenTransition.addKey(this._animatorScreenTransitionTrackX, 0, 0, tbEase.easeOutCubic, 1);
	this._animatorScreenTransition.addKey(this._animatorScreenTransitionTrackX, 150, 1, tbEase.easeOutCubic, 1);
	this._animatorScreenTransition.addEvent(this, 150, function() {

		// console.log('BSLobby::now iam happy');
		tgfDialogs.DialogLobby.prototype.hide.call(this);

	}.bind(this));
}


tgfDialogs.BattleshipDialogLobby.prototype.onHide = function() {

	// console.log('BSLobby::BattleshipDialogLobby.onHide');
	// tgfDialogs.DialogLobby.prototype.onHide.call(this);
}

tgfDialogs.BattleshipDialogLobby.prototype.doHide = function() {

	// console.log('BSLobby::BattleshipDialogLobby.doHide');
	// tgfDialogs.DialogLobby.prototype.doHide.call(this);
	flowController.currentAction = flowController.actionHideTitleScreen;
}

tgfDialogs.BattleshipDialogLobby.prototype.doFree = function() {

	console.log('BSLobby::BattleshipDialogLobby.doFree');

	if (this._timeoutUpdate) {
		clearInterval(this._timeoutUpdate);
		this._timeoutUpdate = null;
	}

	if (tgfDialogs.DialogLobby.prototype.doFree)
		tgfDialogs.DialogLobby.prototype.doFree.call(this);


	if (this.topContainer) {

		if (this.topContainer.container) {

			tgfGraphics.removeChild(this.topContainer.container);
			this.topContainer.container.destroy({children: true});
			this.topContainer.container = null;
		}
		this.topContainer = null;
	}

	if (this.topPixiContainer) {
		if (this.topPixiContainer.container) {
			tgfGraphics.removeChild(this.topPixiContainer.container);
			this.topPixiContainer.container.destroy({children: true});
			this.topPixiContainer.container = null;
		}
		this.topPixiContainer = null;
	}

	if (this.logo) {
		this.logo = null;
	}

	if (this.fadeArea) {
		tgfGraphics.removeChild(this.fadeArea);
		this.fadeArea.destroy();
		this.fadeArea = null;
	}

	flowController.currentAction = flowController.actionHideTitleScreen;
}

//******************************************************
//*****    Script Resource: BattleshipResultDialog
//******************************************************

// Directives for jslint
/*global tgfSettings, tgfDialogs, tgfComponents */

var resultDialogEase = {
	littleBounce: function(a, b, c, d) { return tbEase.easeOutBounce(a, b, c, d, 10, 16); },
	littleOvershoot: function(time, begin, change, duration) { return tbEase.easeOutOvershoot(time, begin, change, duration, 2, 8); }
}

var resultDialogConfig = {
	BlueFont:  {
		fontSize: 32,
		fillColor: "#ACB9D5",
		strokeColor: "#ACB9D5",
		fontStyle: "normal"
	},
	RedFont:  {
		fontSize: 32,
		fillColor: "#C4A9A9",
		strokeColor: "#C4A9A9",
		fontStyle: "normal"
	},
	WhiteFont:  {
		fontSize: 42,
		fillColor: "#FFF",
		strokeColor: "#CCC"
	},
	BlueNameFont:  {
		fontSize: 32,
		fillColor: "#061F3B",
		strokeColor: "#010911",
		fontStyle: "normal"
	},
	RedNameFont:  {
		fontSize: 32,
		fillColor: "#340101",
		strokeColor: "#160000",
		fontStyle: "normal"
	},
	ShareFont:  {
		fontSize: 52
	},
	ProceedFont:  {
		fontSize: 36
	},
}

tgfSettings.dialogDefaults.battleshipResultDialog = {};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.BattleshipResultDialog = function(isWinner, properties) {
	"use strict";
	this.name = "BattleshipResultDialog";			// The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.battleshipResultDialog);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }

	this.namedComponents = {};
	this.showAnimators = [];
	this.hideAnimators = [];

	this.isWinner = isWinner;
	this.hidden = true;

	// redundant, but added for clarity
	this.playerForfeit = this.playerForfeit || false;


    var udc = UserDataController;

    this._resultDetails = {};
    this._resultDetails.left = {};
    this._resultDetails.right = {};


    if (udc.getMatchData() == null) {

    	// test data only, should not be here
	    var playerData = {name: 'left'};
	    var opponentData = {name: 'right'};
    }
    else {

		var playerData = udc.getMatchData().getPlayerData(udc.getData().id);
	    var opponentData = udc.getMatchData().getOpponentData(udc.getData().id);
    }

    var resultRadar = udc.getRadarResult();
    var resultBoard = udc.getBoardResult();

    this._resultDetails.left = playerData;
    this._resultDetails.leftResult = resultRadar;
    this._resultDetails.right = opponentData;
    this._resultDetails.rightResult = resultBoard;

	Doors.initialize();
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.BattleshipResultDialog, tgfDialogs.Base);

// Processing required when preparing the dialog for use
tgfDialogs.BattleshipResultDialog.prototype.doPrepare = function() {
	"use strict";

	var self = this;

	this.components = [];

	tgfAudio.play(this.isWinner ? a_result_win : a_result_lose);

	Doors.close();

	this.baseContainer.setAlpha(0);
	this.prepareResult();

	this.prepareLeft();
	this.prepareRight();
	this.prepareMiddle();

	this._setupRewards();
	this._addDoubleExperience();

	this._hasShared = false;
};



tgfDialogs.BattleshipResultDialog.prototype._setupRewards = function() {

	var md = UserDataController.getMatchData();

	var self = this;

	var rewardData = [];

	if (this.playerForfeit) {
		// no xp for you
	}
	else {

		if (this.isWinner) {

			rewardData.push({type: RewardTypes.VICTORY, amount: 1});

			// fill ENV-MOCK rewards
			if (Environment.get() == Environment._ENVS.MOCK) {

				rewardData.push({type: RewardTypes.SURVIVED, amount: 2});
				rewardData.push({type: RewardTypes.DESTROYED, amount: 5});
				rewardData.push({type: RewardTypes.SPECIAL_WEAPON, amount: 12});
			}
		}
		else {
			rewardData.push({type: RewardTypes.LOST, amount: 1});
		}

		if (md) {

			// survived
			var shipsSurvived = 5 - this._resultDetails.rightResult.ships.destroyed.length;

			if (shipsSurvived > 0) {

				rewardData.push({type: RewardTypes.SURVIVED, amount: shipsSurvived});
			}

			// destroyed
			var shipsDestroyed = this._resultDetails.leftResult.ships.destroyed.length;
			this._shipsDestroyed = shipsDestroyed;

			if (shipsDestroyed > 0) {

				rewardData.push({type: RewardTypes.DESTROYED, amount: shipsDestroyed});
			}

			// specials
			var swUsed = md.getSpecialWeaponUsages();
			if (swUsed > 0) {

				rewardData.push({type: RewardTypes.SPECIAL_WEAPON, amount: swUsed});
			}
		}
	}

	this._rewardController = new RewardController(this.baseContainer);
	var rewardBadges = this._rewardController.setup(rewardData);

	var score = this._rewardController.getRoundReward();
	AnalyticsHelper.reportMatchEnd(this.isWinner, score);

	console.log("Gamesnacks Send Score / Level Complete");
	if(!this.playerForfeit && this.isWinner){
		//GAMESNACKS.sendScore(score);
		//GAMESNACKS.levelComplete(0);
	}else{
		//GAMESNACKS.gameOver();
	}

	for (var i = 0; i < rewardBadges.length; i++) {

		this.addComponent(rewardBadges[i].getComponent());
	}

	this.barContainer = new tbContainer();
	this.barContainer.setPosition(tgfGraphics.areaWidth/2, 600);
	this.barContainer.setAlpha(0);

	var rankData = UserDataController.getRankData();

	this.rankBar = new RankBar(this.barContainer);
	this.rankBar.init(rankData.score);

	this.baseContainer.addChild(this.barContainer);

	setTimeout(function() {

		this.rankBar.fadeIn(780, 660, 250, function() { // Applied offset

			this._rewardController.start();

			// add skippable click
			tgfGraphics.pixiContainer.interactive = true;
			tgfGraphics.pixiContainer.buttonMode = false;
			tgfGraphics.pixiContainer.once('pointerdown', function(e) {

				tgfGraphics.pixiContainer.interactive = false;

				if (self._rewardController) {
					self._rewardController.skip();
				}
			});

		}.bind(this));
	}.bind(this), 1000);
}

tgfDialogs.BattleshipResultDialog.prototype._addDoubleExperience = function() {

	
	this.containerDoubleExperience = new tgfComponents.Container({
		x: 0,
		y: 0
	});
	setTimeout(function() {
		this.containerDoubleExperience.setPosition(0, 300); // Applied offset
	}.bind(this));

	/*
	this.buttonDoubleExperience = new tgfComponents.ComponentBattleshipButton({
		text: tgfDictionary.getText("endscreen_doubleReward"),//'Double Reward',//tgfDictionary.getText("ExtraShotPopupButtonActive"),
		icon: s_movie_icon_orange,
		iconPosition: 'left',
		iconTextDistance: -s_movie_icon_orange.width/2,
		image: d_buttons_yellow,
		width: 560,
		height: 86 * 1.45,
		x: tgfGraphics.areaWidth/2,
		y: tgfGraphics.areaHeight/2 + 510, // Applied offset
		baseContainer: this.containerDoubleExperience,
	});
	*/

	this.buttonExit = new tgfComponents.ComponentBattleshipButton({
		text: tgfDictionary.getText("ExtraShotPopupButtonCancel"),
		image: s_tgf_transparent,
		width: 350 / 2,
		height: 86,
		x: tgfGraphics.areaWidth/2,
		y: tgfGraphics.areaHeight/2 + 628, // Applied offset
		baseContainer: this.containerDoubleExperience,
	});

	this._createTotalExperienceText();

	this.addComponent(this.containerDoubleExperience);
	//this.containerDoubleExperience.addComponent(this.buttonDoubleExperience);
	this.containerDoubleExperience.addComponent(this.buttonExit);
}

tgfDialogs.BattleshipResultDialog.prototype._createTotalExperienceText = function() {

	this._totalExperienceContainer = new tgfComponents.Container({
		y: tgfGraphics.areaHeight/2 + 350 - 100 // Applied offset
	})

	var text = tgfDictionary.getText('endscreen_totalExperience');//"TOTAL EXPERIENCE";

	var font = f_autoradiographic_italic.clone();
	font.fontSize = 40;
	font.strokeWidth = 4;
	font.strokeColor = '#002d57';
	font.fillColor = '#ffffcc';
	font.baseline = 'middle';

	font.shadow.active = true;
	font.shadow.color = '#002d57';

	var labelScore = new tgfComponents.Label({
		text: this._rewardController.getRoundReward().toLocaleString(),
		font: {
			fontFace: f_impact.fontFace,
			fillColor: ['#ffbf02', '#ff7d1c'],
			fontSize: 42,
			strokeWidth: 6,
			strokeColor: "#002d57",
			baseline: 'middle'
		},
		x: tgfGraphics.areaWidth/2,
		y: 46 - 100, // Applied offset
		align: 'center',
		baseContainer: this._totalExperienceContainer
	});

	var plusSign = new tgfComponents.Picture ({
		image: s_result_add.clone(),
		x: 0,
		y: -s_result_add.height/2, // Applied offset
		baseContainer: this._totalExperienceContainer
	});

	plusSign.doPrepare = function(args) {

		console.log("labelScore width =", labelScore.getWidth());
		tgfComponents.Picture.prototype.doPrepare.call(this, args);
		this.setPosition(this.x - labelScore.getWidth()/2 - s_result_add.width - 6, this.y + 2);
	};

	labelScore.addComponent(plusSign);

	var totalExperienceLabel = new tgfComponents.Label({
		text: text,
		font: font,
		x: tgfGraphics.areaWidth/2,
		y: 0 - 100, // Applied offset
		align: 'center',
		baseContainer: this._totalExperienceContainer
	});

	this._totalExperienceContainer.addComponent(totalExperienceLabel);
	this._totalExperienceContainer.addComponent(labelScore);

	this.addComponent(this._totalExperienceContainer);

	setTimeout(function() {
		this._totalExperienceContainer.setAlpha(0);
	}.bind(this), 0);

}

tgfDialogs.BattleshipResultDialog.prototype._showTotalExperience = function() {

	this._animatorTotalExperience = new tbAnimator(this._totalExperienceContainer.baseContainer.container);
	this._animatorTotalExperienceTrackY = this._animatorTotalExperience.addTrack('y');
	this._animatorTotalExperienceTrackA = this._animatorTotalExperience.addTrack('alpha');


	var end = this._totalExperienceContainer.baseContainer.container.y + 100; // Applied offset
	var start = end + 50;
	this._totalExperienceContainer.baseContainer.container.y = start;

	this._animatorTotalExperience.addKey(this._animatorTotalExperienceTrackY, 0, start);
	this._animatorTotalExperience.addKey(this._animatorTotalExperienceTrackY, 300, end);

	this._animatorTotalExperience.addKey(this._animatorTotalExperienceTrackA, 0, 0);
	this._animatorTotalExperience.addKey(this._animatorTotalExperienceTrackA, 300, 1);
}

tgfDialogs.BattleshipResultDialog.prototype._addAvatar = function(isLeft) {

	// this._isBotBattle = isBotBattle;

	// add avatar
	var self = this;
	this._onAvatarReady = function(res) {

		if (res) {

			setTimeout(function() {

				if (isLeft) {

					// res.setPosition(938 - 38, 29);
					res.setPosition(938 - 40, 0); // Applied offset
					if (self.leftBackground && self.leftBackground.image) {

						self.leftBackground.image.addChild( res );
					}
				}
				else {

					// res.setPosition(38, 29);
					res.setPosition(40, 28);
					if (self.rightBackground && self.rightBackground.image) {
						self.rightBackground.image.addChild( res );
					}
				}
			}, 0);
		}
	};


	// avatar fetcher
	// var photoURL;
	var avatarWidth = 202;
	var avatarHeight = 202;
	var pendingImage;
	// load player avatar
	if (isLeft == true) {
		var pendingImage = AvatarFetcher.getPlayerImage(avatarWidth, avatarHeight);
		//photoURL = this._resultDetails.left.photo ? this._resultDetails.left.photo : "";
	}
	// load opponent avatar || robot
	else {
		var pendingImage = AvatarFetcher.getOpponentImage(avatarWidth, avatarHeight);
		//photoURL = this._resultDetails.right.photo ? this._resultDetails.right.photo : "";
	}

	console.log('RESULTDETAILS', this._resultDetails)
	console.log('    ', this.leftBackground);
	console.log('    ', this.rightBackground);

	// if (photoURL.indexOf('http') >= 0) {
	//
	// 	console.log('adding player image');
	// 	AvatarFetcher.loadAvatar(photoURL, this._onAvatarReady, avatarWidth, avatarHeight, 0, 0);
	// }
	// else {

		console.log('adding bot image');

		// var pendingImage = AvatarFetcher.getOpponentImage(avatarWidth, avatarHeight);

		setTimeout(function() {

			if (isLeft) {

				pendingImage.setPosition(938 - 40, 28);
				this.leftBackground.image.addChild( pendingImage );
			}
			else {

				pendingImage.setPosition(32, 28);
				this.rightBackground.image.addChild( pendingImage );
			}

		}.bind(this), 0);
	//}
}

tgfDialogs.BattleshipResultDialog.prototype.getSound = function(isWinner, sideString) {

	if (isWinner) {
		if (sideString == "left") return a_result_win_left;
		/* if (sideString == "right") */ return a_result_win_right;
	}
	else {
		if (sideString == "left") return a_result_lose_left;
		/* if (sideString == "right")  */ return a_result_lose_right;
	}
}

tgfDialogs.BattleshipResultDialog.prototype.prepareSide = function(sideContainer, side) {

	var isPlayerSide = side < 0;
	var isOpponentSide = side > 0;
	var sideString = isOpponentSide ? "right" : "left";
	var inverseSideString = isPlayerSide ? "right" : "left";
	var isWinner = isPlayerSide ? this.isWinner : !this.isWinner;

	this[sideString + "Sound"] = tgfAudio.play(this.getSound(isWinner, sideString));
	tgfAudio.setLooping(this[sideString + "Sound"], true);

	this[sideString + "Animation"] = new BattleshipComponents.SpineAnimation({
		x: isOpponentSide ? -445 : 445,
		y: -90,
		animation: (isWinner ? result_win : result_lose),
		xScale: side
	});
	sideContainer.addComponent(this[sideString + "Animation"]);

	this[sideString + "Background"] = new tgfComponents.Picture ({
		x: isOpponentSide ? 445 : -445,
		y: 0,
		image: isOpponentSide ? _s_result_turnindicator_opponent : _s_result_turnindicator_player,
	});
	sideContainer.addComponent(this[sideString + "Background"]);

	this[sideString + "NameBackground"] = new tgfComponents.Picture ({
		x: isOpponentSide ? -295 : 295,
		y: 100,
		image: isOpponentSide ? s_overlay_name_opp : s_overlay_name_pla
	})
	sideContainer.addComponent(this[sideString + "NameBackground"]);

	// Limit the name to 12 characters
	var name = tgfDictionary.getText(this._resultDetails[sideString].name);
	if (!name) {
		name = "Robot"
	} else if (name.length > 16) {
		name = name.substring(0, 16) + "...";
	}

	this[sideString + "NameBackground"] = new tgfComponents.Label({
		x: isOpponentSide ? -545 : 545,
		y: 85,
		text: name,
		font: { fontFace: f_babas_bold_no_shadow.fontFace },
		fontSettings: resultDialogConfig.BlueNameFont,
		align: inverseSideString,
		fitToBox: false,
		baseline: 'top'
	});

	for (var attr in this[sideString + "NameBackground"].fontSettings) {
		this[sideString + "NameBackground"].font[attr] = this[sideString + "NameBackground"].fontSettings[attr];
	}
	sideContainer.addComponent(this[sideString + "NameBackground"]);

	this._addAvatar(isPlayerSide);
};

tgfDialogs.BattleshipResultDialog.prototype.prepareLeft = function() {

	this.leftContainer = new tgfComponents.Container({
		x: 0,
		y: tgfGraphics.areaHeight / 3
	})
	this.prepareSide(this.leftContainer, -1);
	this.addComponent(this.leftContainer);
};

tgfDialogs.BattleshipResultDialog.prototype.prepareRight = function() {

	this.rightContainer = new tgfComponents.Container({
		x: tgfGraphics.areaWidth,
		y: tgfGraphics.areaHeight / 3
	});
	this.prepareSide(this.rightContainer, 1);
	this.addComponent(this.rightContainer);
};

tgfDialogs.BattleshipResultDialog.prototype.prepareMiddle = function() {

	this.middleContainer = new tgfComponents.Container({
		x: tgfGraphics.areaWidth / 2,
		y: tgfGraphics.areaHeight / 3
	});

	this.versusIcon = new tgfComponents.Picture({
		x: 0,
		y: 20,
		image: s_overlay_results_vs,
	});
	this.middleContainer.addComponent(this.versusIcon);


	this.addComponent(this.middleContainer);
};

tgfDialogs.BattleshipResultDialog.prototype.prepareResult = function() {
	//
	// this.buttonShare = new tgfComponents.ComponentBattleshipButton ({
	// 	posRelativeToParent: true,
	// 	text: tgfDictionary.getText('ResultScreenButtonTextShare'),
	// 	fontSettings: resultDialogConfig.ProceedFont,
	// 	image: s_button_blue,
	// 	width: 250,
	// 	height: 102,
	// 	x: 0 + 560/2 - 125,
	// 	y: tgfGraphics.areaHeight/2 + 396
	// });

	//
	// this.buttonLobby = new tgfComponents.ComponentBattleshipButton ({
	// 	posRelativeToParent: true,
	// 	text: tgfDictionary.getText('ResultScreenButtonTextBackToLobby'),
	// 	animations: [{ type: "scale", ease: resultDialogEase.littleOvershoot, delay: 1050 }],
	// 	fontSettings: resultDialogConfig.ProceedFont,
	// 	image: s_button_blue,
	// 	width: 250,
	// 	height: 102,
	// 	x: 0 - 560/2 + 125,
	// 	y: tgfGraphics.areaHeight/2 + 396
	// });


	var rematchText = tgfDictionary.getText('PlayAgain');
	if ( UserDataController.isTimedMatch() ) {
		rematchText = tgfDictionary.getText('TroResultScreenButtonTextNextMatch');//'Next Match';
	}

	var gametype = BattleshipsAnalytics.getGameType();
	if (gametype != 'challenge') {

		setTimeout(function() {

			ShortcutManager.testShortcut();
		}, 2000);
	}

	this.buttonRematch = new tgfComponents.ComponentBattleshipButton ({
		posRelativeToParent: true,
		text: rematchText,
		fontSettings: resultDialogConfig.ShareFont,
		image: s_button_green,
		width: 560,
		height: 102,
		x: 0,
		y: tgfGraphics.areaHeight/2 + 396 + 132 - 100 // Applied offset
	});


	var buttons = [ /* this.buttonShare, this.buttonLobby, */ this.buttonRematch ];
	for (var i = 0; i < buttons.length; i++) {
		var button = buttons[i];
		if (!button.fontSettings)
			continue;

		for (var attr in button.fontSettings) {
			button._font[attr] = button.fontSettings[attr];
		}
	}

	this.containerResumeGameplay = new tgfComponents.Container({
		x: tgfGraphics.areaWidth/2,
		y: 0,
	});
	setTimeout(function() {
		this.containerResumeGameplay.setPosition(0, 400);
	}.bind(this), 0);

	this.addComponent(this.containerResumeGameplay);
	// this.containerResumeGameplay.addComponent(this.buttonShare);
	this.containerResumeGameplay.addComponent(this.buttonRematch);
	// this.containerResumeGameplay.addComponent(this.buttonLobby);
};

tgfDialogs.BattleshipResultDialog.prototype.prepareAnimations = function() {

	this.animators = [];

	// All these containers need to be prepared before the animations can start.
	if (!this.leftContainer.baseContainer || !this.rightContainer.baseContainer)// || !this.resultContainer.baseContainer)
		return;

	var makeAnimation = function(component, variable, fromValue, toValue, delay, duration, ease) {

		var type = typeof this;
		var curAnimator = null;
		if (this && this.makeAnimation)
			curAnimator = this;
		else if (!component.animator)
			curAnimator = new tbAnimator(component);
		else curAnimator = component.animator;

		var track = curAnimator.addTrack(variable);

		curAnimator.addKey(track, 0, fromValue, ease);

		if (delay > 0) {
			curAnimator.addKey(track, delay, fromValue, ease);
		}

		var durationFrame = delay + duration;

		curAnimator.addKey(track, durationFrame, toValue, ease);
		curAnimator.setTime(0);
		curAnimator.pause();

		if (!curAnimator.makeAnimation) curAnimator.makeAnimation = makeAnimation.bind(curAnimator);

		component.animator = curAnimator;
		return curAnimator;
	};

	// this.makeAnimation = makeAnimation;

																				// 	Elem		begin									end						delay	dur		ease
	this.animators.push(makeAnimation(this.leftContainer.baseContainer.container, 	'x', 		-this.leftBackground.image.width,		0,						500,	750,	resultDialogEase.littleBounce));
	this.animators.push(makeAnimation(this.rightContainer.baseContainer.container,	'x', 		tgfGraphics.areaWidth, 					0,						500,	750,	resultDialogEase.littleBounce));

	this.animators.push(makeAnimation(this.versusIcon,								'xScale', 	0,										1,						1250,	500,	resultDialogEase.littleOvershoot).
						makeAnimation(this.versusIcon,								'yScale', 	0,										1,						1250,	500,	resultDialogEase.littleOvershoot));

	// this.animators.push(makeAnimation(this.baseContainer.container, 'y', 		0,				-100,						2000,	1000,	resultDialogEase.littleBounce));
};

tgfDialogs.BattleshipResultDialog.prototype.handleSpecial = function(id, args) {

	// console.log('BattleshipResultDialog.handleSpecial', id, args);

	if (id == 'double_tease') {


		console.log('creating animator');

		this._showTotalExperience();

		//this.buttonDoubleExperience.onClick = this._handleOfferAccept.bind(this);
		this.buttonExit.onClick = this._handleOfferDecline.bind(this);

		this.animatorDoubleXP = new tbAnimator(this.containerDoubleExperience.baseContainer.container);
		this.animatorDoubleXPTrackY = this.animatorDoubleXP.addTrack('y');
		this.animatorDoubleXPTrackA = this.animatorDoubleXP.addTrack('alpha');

		if (!AdManager.supportsRewarded() || this.playerForfeit ) {

			var self = this;

			setTimeout(function() {

				self._endResultFlow();

			}, 1100);
			return;
		}

		// this.animatorDoubleXP.addKey(this.animatorDoubleXPTrackY, 0, 400, tbEase.easeInOutCubic, 1.4);
		// this.animatorDoubleXP.addKey(this.animatorDoubleXPTrackY, 450, -100, tbEase.easeInOutCubic, 1.4); // Applied offset
		// this.animatorDoubleXP.addEvent(this, 600, function() {

		// 	this.buttonDoubleExperience.animator = this.buttonDoubleExperience.animator || new tbAnimator(this.buttonDoubleExperience);
		// 	this.buttonDoubleExperience.trackScaleX = this.buttonDoubleExperience.trackScaleX || this.buttonDoubleExperience.animator.addTrack('xScale');
		// 	this.buttonDoubleExperience.trackScaleY = this.buttonDoubleExperience.trackScaleY || this.buttonDoubleExperience.animator.addTrack('yScale');

		// 	this.buttonDoubleExperience.animator.pause();
		// 	this.buttonDoubleExperience.animator.removeAllKeys();
		// 	this.buttonDoubleExperience.animator.removeEvents();

		// 	// Start state
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleX, 0, 	1.0, tbEase.easeOutCubic);
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleY, 0, 	1.0, tbEase.easeOutCubic);

		// 	// Shrink
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleX, 250, 0.9, tbEase.easeOutCubic);
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleY, 250, 0.6, tbEase.easeOutCubic);

		// 	// Boing Y
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleX, 400, 0.9, tbEase.easeOutElastic, 4.0);
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleY, 400, 1.2, tbEase.easeOutElastic, 4.0);

		// 	// Boing X
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleX, 450, 1.2, tbEase.easeOutElastic, 4.0);
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleY, 450, 1.0, tbEase.easeOutElastic, 4.0);

		// 	// Reset
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleX, 800, 1.0, tbEase.easeOutCubic);
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleY, 800, 1.0, tbEase.easeOutCubic);

		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleX, 1200, 1.0, tbEase.easeOutCubic);
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleY, 1200, 1.0, tbEase.easeOutCubic);

		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleX, 2000, 1.0, tbEase.easeOutCubic);
		// 	this.buttonDoubleExperience.animator.addKey(this.buttonDoubleExperience.trackScaleY, 2000, 1.0, tbEase.easeOutCubic);

		// 	this.buttonDoubleExperience.animator.setLooping(true);


		// 	this.buttonDoubleExperience.animator.setTime(0);
		// 	this.buttonDoubleExperience.animator.resumeForced();
		// });

		// console.log('created animator', this.animatorDoubleXP);
	}
}

tgfDialogs.BattleshipResultDialog.prototype.handleBeginStep = function(timePassed) {
	"use strict";

	// if (this.rankBar) {
	// 	this.rankBar.update(timePassed);
	// }

	// if (this.buttonDoubleExperience && this.buttonDoubleExperience.animator) {
	// 	this.buttonDoubleExperience.animator.updateTime(timePassed);
	// }

	if (this._animatorTotalExperience) {
		this._animatorTotalExperience.updateTime(timePassed);
	}


	// Have to do it here because the baseContainers aren't up yet and I need to animate those instead of the containercomponents because otherwise nothing animates
	if (!this.preparedAnimations && this.hidden == false) {
		this.preparedAnimations = true;
		this.prepareAnimations();

		for (var i = 0; i < this.animators.length; i += 1) {
			this.animators[i].setTime(0);
			this.animators[i].resumeForced();
		}

		setTimeout(function () {
			tgfAudio.play(a_loseanimation_board_out);
			BattleshipAudioManager.playMusic(a_result_music);
		}.bind(this), 2300);

		this._timeoutInit = setTimeout(function() {
			this.baseContainer.setAlpha(1);
		}.bind(this), 33);
	}

	if (this.animatorDoubleXP) {
		this.animatorDoubleXP.updateTime(timePassed);
	}

	if (this.animatorResume) {
		this.animatorResume.updateTime(timePassed);
	}

	for (var i = 0; i < this.animators.length; i++) {
		if (this.animators[i].currentTime >= this.animators[i].duration) {
			this.animators[i].pause();
		}
		else if (this.preparedAnimations) {
			this.animators[i].updateTime(timePassed);

			// sigh
			this.versusIcon.image.setPosition(this.versusIcon.x, this.versusIcon.y);
			this.versusIcon.image.setScale(this.versusIcon.xScale, this.versusIcon.yScale);
		}
	}
};

tgfDialogs.BattleshipResultDialog.prototype._handleOfferAccept = function() {

	if (this._handleOfferInternal()) return;

	var self = this;
	self._hideDoubleXP();

	AnalyticsService.reportEvent("interaction", "interaction", {
		eventType: "button_open_rewarded"
	});

	AdManager.setTrackingData('gameend', 'double_reward');
	AdManager.playAd(self, function(e) {
		if (e === -1) {
			self._endResultFlow();
			self.rankBar.decreaseRewardBar();
			return
		}
		self._rewardController.doubleExperience();

		// console.log('ResultDialog::DoubleXP.playAdCallback');

		setTimeout(function() {

			self.rankBar.fillRewardBar(function() {

				self._endResultFlow();
			})
		}, 500);
	});
}

tgfDialogs.BattleshipResultDialog.prototype._handleOfferDecline = function() {

	BattleshipsAnalytics.reportDeclineDoubleReward();
	AnalyticsService.reportEvent("interaction", "interaction", {
		eventType: "button_decline",
	});

	if (this._handleOfferInternal()) return;

	this._hideDoubleXP();
	this._endResultFlow();
	this.rankBar.decreaseRewardBar();
}

tgfDialogs.BattleshipResultDialog.prototype._handleOfferInternal = function() {

	var offer = this._offerHandled;

	if (!offer) {
		offer = false
	}
	this._offerHandled = true;

	return offer;
}

tgfDialogs.BattleshipResultDialog.prototype._hideDoubleXP = function() {

	this.containerDoubleExperience.baseContainer.container.mouseChildren = false;
	//this.buttonDoubleExperience.image.sprite.interactive = false;
	//this.buttonDoubleExperience.image.sprite.mouseChildren = false;
	this.buttonExit.image.sprite.interactive = false;
	this.buttonExit.image.sprite.mouseChildren = false;


	this.animatorDoubleXP.pause();
	this.animatorDoubleXP.removeAllKeys();
	this.animatorDoubleXP.removeEvents();

	// this.animatorDoubleXP.addKey(this.animatorDoubleXPTrackY, 0, 0, tbEase.easeInCubic);
	// this.animatorDoubleXP.addKey(this.animatorDoubleXPTrackY, 250, -40, tbEase.easeInCubic);
	this.animatorDoubleXP.addKey(this.animatorDoubleXPTrackA, 0, 1, tbEase.easeInCubic);
	this.animatorDoubleXP.addKey(this.animatorDoubleXPTrackA, 250, 0, tbEase.easeInCubic);

	this.animatorDoubleXP.setTime(0);
	this.animatorDoubleXP.resumeForced();
}


tgfDialogs.BattleshipResultDialog.prototype._endResultFlow = function() {

	var rankData = UserDataController.getRankData();
	rankData.add(this._rewardController.getRoundReward(), this.isWinner, this._shipsDestroyed);

	// Unlocks all the special weapons that can be unlocked
	var specialWeaponData = UserDataController.getSpecialWeaponData();
	if (specialWeaponData) {
		specialWeaponData.updateUnlockableWeapons(rankData.rank);
	}

	this._animatorTotalExperience.pause();
	this._animatorTotalExperience.removeAllKeys();
	this._animatorTotalExperience.removeEvents();

	this._animatorTotalExperience.addKey(this._animatorTotalExperienceTrackA, 0, 1);
	this._animatorTotalExperience.addKey(this._animatorTotalExperienceTrackA, 250, 0);

	// this.buttonShare.onClick = this._handleShareClick.bind(this);
	// this.buttonLobby.onClick = this._handleLobbyClick.bind(this);
	this.buttonRematch.onClick = this._handleRematchClick.bind(this);

	this.animatorResume = new tbAnimator(this.containerResumeGameplay.baseContainer.container);
	this.animatorResumeTrackY = this.animatorResume.addTrack('y');

	this.animatorResume.addKey(this.animatorResumeTrackY, 100, 400, tbEase.easeOutCubic, 1.4);
	this.animatorResume.addKey(this.animatorResumeTrackY, 550, 0, tbEase.easeOutCubic, 1.4);


	this._animatorTotalExperience.setTime(0);
	this._animatorTotalExperience.resumeForced();

}
//
//
// tgfDialogs.BattleshipResultDialog.prototype._handleLobbyClick = function() {
//
// 	var self = this;
//
// 	console.log('buttonLobby');
//
// 	BattleshipsAnalytics.reportClickedBackToLobbyInResultScreen();
// 	AnalyticsHelper.reportButtonClick("lobby");
//
// 	if (self._hasShared == false) {
// 		// BattleshipsAnalytics.reportNotShared();
// 	}
// 	else {
// 		BattleshipsAnalytics.reportHasShared();
// 	}
//
// 	self.free();
// 	flowController.endPlay();
// }

tgfDialogs.BattleshipResultDialog.prototype._handleRematchClick = function() {

	var self = this;
	StorageManager.set('autoStart', true);

	console.log('buttonRematch', UserDataController.getCurrentMatchId() );

	BattleshipsAnalytics.reportClickedRematchInResultScreen();
	AnalyticsHelper.reportButtonClick("rematch");

	if (self._hasShared == false) {
		// BattleshipsAnalytics.reportNotShared();
	}
	else {
		BattleshipsAnalytics.reportHasShared();
	}

	if ( UserDataController.isTimedMatch() ) {
		UserDataController.setEntryMatchId('NEW');
	} else {
		UserDataController.setEntryMatchId(UserDataController.getCurrentMatchId());
	}

	self.free();
	flowController.endPlay();
}

// Processing required when freeing the dialog from use
tgfDialogs.BattleshipResultDialog.prototype.doFree = function() {
	"use strict";


	console.log('BattleshipResultDialog::doFree');

	if (this.leftSound) tgfAudio.stop(this.leftSound);
	if (this.rightSound) tgfAudio.stop(this.rightSound);

	if (this._onAvatarReady) {

		this._onAvatarReady = null;
	}

	if (this.rankBar) {

		this.rankBar.destroy();
	}
	if (this._rewardController) {

		this._rewardController.destroy();
	}

	this.removeAllComponents();

	if (this._timeoutInit) {
		clearTimeout(this._timeoutInit);
		this._timeoutInit = null;
	}

	if (Doors) {
		Doors.open();
	}
};

// Processing required when showing the dialog
tgfDialogs.BattleshipResultDialog.prototype.doShow = function() {
	"use strict";

	console.log('BattleshipResultDialog.doShow');

	BattleshipsAnalytics.reportScreenGameEnd();
	AnalyticsService.setScreenName("gameend")

	this.hidden = false;
};

tgfDialogs.BattleshipResultDialog.prototype.show = function() {
	Sequencer.require(["reward_badges", "badge_animations", "result_screen"], true)
	.then(function() {
		tgfDialogs.BattleshipResultDialog.uber.show.call(this);
	}.bind(this))
	.catch(function(reason) {
		throw reason;
	}.bind(this));
};

// Processing required when hiding the dialog
tgfDialogs.BattleshipResultDialog.prototype.doHide = function() {
	"use strict";
	console.log('BattleshipResultDialog.doHide');

	this.free();
};

//******************************************************
//*****    Script Resource: BattleshipMatchResult
//******************************************************

tgfSettings.dialogDefaults.matchResultDialog = {
	components: [

    ]

};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.MatchResultDialog = function(isWinner, onEvent, radar, properties) {
	"use strict";
	this.name = "MatchResultDialog";			// The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.matchResultDialog);
	// Set user properties
    if (properties !== undefined) { this.setProperties(properties); }

    var topOffset = 25 - 80; // Applied offset
    this._adChecked = false;
    this._score = 0;
    this.playerForfeit = this.playerForfeit || false;

	this.topBackground = tbGraphics.drawRectangle(0, 0, tbGraphics.width, tbGraphics.height * 0.5 + topOffset, "#000000");
    this.topBackground.alpha = 0;

	this.bottomBackground = tbGraphics.drawRectangle(0, tbGraphics.height * 0.5 + topOffset, tbGraphics.width, tbGraphics.height * 0.5 - topOffset, "#000000");
    this.bottomBackground.alpha = 0;

    tgfGraphics.addChild(this.topBackground, 'matchResult.topBack');
    tgfGraphics.addChild(this.bottomBackground, 'matchResult.bottomBack');

    this.isWinner = isWinner;
    this.darkenAnimation = false;
    this.animationPaused = false;
    this.animationType = this.isWinner ? matchresult_win : matchresult_lose;
    this.onEvent = onEvent;

    if (this.isWinner) {
        this._winnerText = f_babas_regular.clone();
        this._winnerText.setFontSize(93);
        this._winnerText.setFillColor("#ffffcc");
        this._winnerText.setStrokeColor("#e17f00");
        this._winnerText.setStrokeWidth(4);
        this._winnerText.setAlign("center");
        this._winnerText.setBaseline("middle");
		this._winnerText.setShadow({
			active: true,
			color: "#972f0b",
			offsetX: 0,
			offsetY: 5,
			blur: 0,
		});
        // this._winnerText.setFontStyle("italic");
        this._winnerText.setText(tgfDictionary.getText("YouWin"));
        tgfGraphics.addChild(this._winnerText.font, 'MatchResultDialog.winnerText');

        // BattleshipAudioManager.playMusic(a_win_placeholder);
    }
    else {
        this._winnerText = f_babas_regular.clone();
        this._winnerText.setFontSize(93);
        this._winnerText.setFillColor("#ffffcc");
        this._winnerText.setStrokeColor("#394458");
        this._winnerText.setStrokeWidth(5);
        this._winnerText.setAlign("center");
        this._winnerText.setBaseline("middle");
		this._winnerText.setShadow({
			active: true,
			color: "#001426",
			offsetX: 0,
			offsetY: 5,
			blur: 0,
		});
        // this._winnerText.setFontStyle("italic");
        this._winnerText.setText(tgfDictionary.getText("YouLose"));

        // BattleshipAudioManager.playMusic(a_lose_placeholder);
    }
    this._winnerText.setScale(0.001);

    if (this.animationType.spineData === undefined) {
        this.animationType.startLoading();
    }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.MatchResultDialog, tgfDialogs.UiEmpty);

// Processing required when preparing the dialog for use
tgfDialogs.MatchResultDialog.prototype.doPrepare = function() {
	"use strict";
	var i;
	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

tgfDialogs.MatchResultDialog.prototype.show = function() {
    Sequencer.require(["matchresult"], true)
    .then(function() {
        tgfDialogs.MatchResultDialog.uber.show.call(this);
    }.bind(this))
    .catch(function(reason) {
        throw reason;
    }.bind(this));
};

tgfDialogs.MatchResultDialog.prototype.showResults = function () {
    this.uiResultScreen.show();
    this.animation.setSpeed(1);
    this.darkenAnimation = true;
    this.tint = 255;
    this.fadeInBackground(0.5);
}

tgfDialogs.MatchResultDialog.prototype.setScore = function(score) {
    this._score = score;

    console.log(this._score);
}

tgfDialogs.MatchResultDialog.prototype.resumeAnimation = function () {
    this.animation.setSpeed(1);
}

tgfDialogs.MatchResultDialog.prototype.fadeInBackground = function(darkness) {

    this.fadeInTopBackground(darkness);
    this.fadeInBottomBackground(darkness);
};

tgfDialogs.MatchResultDialog.prototype.fadeInTopBackground = function(darkness) {
	"use strict";

    this._fadingTopBackground = true;
    this._topDarkness = darkness;
};

tgfDialogs.MatchResultDialog.prototype.fadeInBottomBackground = function(darkness) {
	"use strict";

    this._fadingBottomBackground = true;
    this._bottomDarkness = darkness;
};

tgfDialogs.MatchResultDialog.prototype.pauseFloater = function (isPaused) {
    this.animationPaused = isPaused;
}

tgfDialogs.MatchResultDialog.prototype.handleBeginStep = function(timePassed) {
    "use strict";
    var animationLoaded = this.animationType.spineData !== undefined;
	var animationShown = (this.animation !== undefined && this.animation !== null);

    var self = this;

	if(this._fadingTopBackground || this._fadingBottomBackground) {
        if (this._fadingTopBackground) {

            // Stop fading when we're near our target darkness
            if (Math.abs(this.topBackground.alpha - this._topDarkness) < 0.01)
                this._fadingTopBackground = false;

            // Go to target darkness
            else if (this.topBackground.alpha < this._topDarkness)
                this.topBackground.alpha += timePassed * 0.0005;
            else this.topBackground.alpha -= timePassed * 0.0005;
        }
        if (this._fadingBottomBackground) {

            // Stop fading when we're near our target darkness
            if (Math.abs(this.bottomBackground.alpha - this._bottomDarkness) < 0.01)
                this._fadingBottomBackground = false;

            // Go to target darkness
            else if (this.bottomBackground.alpha < this._bottomDarkness)
                this.bottomBackground.alpha += timePassed * 0.0005;
            else this.bottomBackground.alpha -= timePassed * 0.0005;
        }
    }
    else if (!this.shownWinner && animationLoaded && animationShown == false && !this._adChecked) {

      if (this._adCheckInProgress) return;
      this._adCheckInProgress = true;


      // result ad
      /*
      var startResultAd = function () {

          AdManager.setTrackingData('gameend', null);
          AdManager.forceInterstitialAd(null, function () {

              setTimeout(function () {

                  self._adChecked = true;
              }, 500);
          });
      };
      */

      // Google Snacks Score Set

      /*
      community.submitScore({
          score: this._score || 0,
          callback: function () {
              startResultAd();
          }
      });
      */

      self._adChecked = true;

  }
    // Don't load the animation while we're fading
    else if (!this.shownWinner && animationLoaded && animationShown == false) {

        this.shownWinner = true;

        this.animation = this.animationType.clone();
        this.animation.setAnimation("animation", false);
        this.animation.setPosition(tbGraphics.width / 2, tbGraphics.height / 2);

        this.uiResultScreen = new tgfDialogs.BattleshipResultDialog(this.isWinner, {playerForfeit: this.playerForfeit});
        tgfGraphics.addChild(this.animation.animation, 'MatchResultDialog.animation');
        tgfGraphics.addChild(this._winnerText.font, 'MatchResultDialog.winnerText');

        this.boneIndex = this.animation.animation.spineData.findBoneIndex("TEXT_BONE");


        var muted = StorageManager.get('sfxMute');
        BattleshipAudioManager.stopMusic();
        tgfAudio.play(this.isWinner ? a_win_stinger : a_lose_stinger);

        // Skip a frame before adding the text
        setTimeout(function() { this.updateBone = true; }.bind(this), 0);

        // Reveal ships event
        if (this.onEvent && !this.isWinner)
            this.animation.setEventCallback("Reveal Ships", function() {
                this.onEvent();
                this.animation.setSpeed(0.1);
            }.bind(this));


        this.animation.setEventCallback("a_winanimation_shimmer", function() { tgfAudio.play(a_winanimation_shimmer) });
        this.animation.setEventCallback("a_winanimation_stars", function() { tgfAudio.play(a_winanimation_stars) });
        this.animation.setEventCallback("a_loseanimation_board_out", function() { tgfAudio.play(a_loseanimation_board_out) });
        this.animation.setEventCallback("a_loseanimation_board_in", function() { tgfAudio.play(a_loseanimation_board_in) });

        // Darken the animation, show the result screen
		this.animation.setOnComplete(function () {
            this.showResults();

            if (this._winnerText && this._winnerText.font)
                tgfGraphics.addChild(this._winnerText.font, 'matchResultDialog.winnerText');
        }.bind(this));
    }

    if (this.darkenAnimation && this.tint > 128) {
        this.tint -= timePassed * 0.05;
        this.animation.animation.tint = (Math.round(this.tint) << 16) + (Math.round(this.tint) << 8) + Math.round(this.tint);
    }

    if (this.shownWinner && this.updateBone) {

        this.bone = this.animation.animation.skeleton.bones[this.boneIndex];

        this._winnerText.font.x = this.animation.x + this.bone.x;
        this._winnerText.font.y = tbGraphics.height - (this.animation.y + this.bone.y); // lol idk why the animation is upside down

        this._winnerText.setScale(this.bone.scaleX, this.bone.scaleY);
    }
};

// Processing required when freeing the dialog from use
tgfDialogs.MatchResultDialog.prototype.doFree = function() {
	"use strict";
    this.removeAllComponents();

    if (this.animation && this.animation.animation) {
        tgfGraphics.removeChild(this.animation.animation);
        this.animation.animation.destroy({children: true});
        this.animation.animation = null;
        this.animation = null;
    }

    this.topBackground.alpha = 0;
    this.bottomBackground.alpha = 0;

    if (this.topBackground) {
        tgfGraphics.removeChild(this.topBackground);
        this.topBackground = null;
    }

    if (this.bottomBackground) {
        tgfGraphics.removeChild(this.bottomBackground);
        this.bottomBackground = null;
    }

    if (this._winnerText) {

        if (this._winnerText.font) {
            tgfGraphics.removeChild(this._winnerText.font);
            this._winnerText.font.destroy();
            this._winnerText.font = null;
            this._winnerText.font = null;
        }
        this._winnerText = null;
    }

    if (this.uiResultScreen) {
        this.uiResultScreen.free();
        this.uiResultScreen = null;
    }
};

// Processing required when showing the dialog
tgfDialogs.MatchResultDialog.prototype.doShow = function() {
    "use strict";

};

// Processing required when hiding the dialog
tgfDialogs.MatchResultDialog.prototype.doHide = function() {
    "use strict";

};

//******************************************************
//*****    Script Resource: BattleshipPopupDialog
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipPopup = function(properties) {

	this.name = this.name || "BattleshipPopup";


	this._containerPositionX = properties.positionX || tgfGraphics.areaWidth/2;
	this._containerPositionY = properties.positionY || tgfGraphics.areaHeight/2;

	if (properties.customBackground) {
		this.backgroundImage = properties.customBackground
	} else {
		this.backgroundImage = properties.big ? s_big_popup : s_overlay_ready;
	}

	if (typeof properties.stars === 'undefined')
		properties.stars = true;

	if (properties.stars && typeof properties.starImage === 'undefined')
		this.starImage = s_star_blue.clone();

	if (properties.stars && typeof properties.starOffset === 'undefined')
		this.starOffset = 8;

	// Initialize properties
	this.initialize(properties);

	this.width = properties.width || this.backgroundImage.width;
	this.height = properties.height || this.backgroundImage.height;

	this._label = properties.label || '[DEFAULT-LABEL]';
	this._hasShadow = Boolean(properties.shadow || false);


	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
}

tgfDialogs.inherit(tgfDialogs.BattleshipPopup, tgfDialogs.Base);

tgfDialogs.BattleshipPopup.prototype.doPrepare = function() {
	"use strict";
	var i;

	// add container
	this._addContainer();

	// add (optional shadow)
	this._addShadow();

	// add background
	this._addBackground();

	// add label
	this._addHeaderLabel();

	// add custom
	this._addCustom();


	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};


tgfDialogs.BattleshipPopup.prototype._addShadow = function() {

	if (!this._hasShadow) return;

	this._shadow = new tbContainer(1366, 1366);

	var shadowShape = tbGraphics.drawRectangle(0, 0, tgfGraphics.areaWidth, tgfGraphics.areaHeight, 0x000001, null, null, 0.5);

	this._shadow.container.addChild(shadowShape);

	// this._shadow.container.on('pointerdown', function(e) {
	// 	console.log('congrats!!');
	// });


	this._shadow.container.buttonMode = false;
	this._shadow.container.interactive = true;


	tgfGraphics.addChild(this._shadow.container, 'BattleshipPopup.shadow');
	tgfGraphics.addChild(this.baseContainer.container, 'BattleshipPopup.container');
}


tgfDialogs.BattleshipPopup.prototype._addContainer = function() {

	this._popupContainer = new tgfComponents.Container({x:0, y:0, width: this.width, height: this.height, debugColor: 0x00ff00});

	this._popupContainer.doPrepare = function(args) {

		tgfComponents.Container.prototype.doPrepare.call(this._popupContainer, args);

		// set pivot + base rotation
		this._popupContainer.baseContainer.setPivot(this._popupContainer.width/2, this._popupContainer.height/2);
		this._popupContainer.baseContainer.setRotation(0 * Math.PI / 180);

		// center container
		this._popupContainer.baseContainer.setPosition(this._containerPositionX, this._containerPositionY);

		// add animator
		this._addAnimator();

	}.bind(this);

	this.addComponent(this._popupContainer);
}

tgfDialogs.BattleshipPopup.prototype._addBackground = function() {

	var background = new tgfComponents.Picture({
		x: 0,
		y: 0,
		width: this.width,
		height: this.height,
		createFromSlices: true,
		sliceMarginsArray: [30, this.big ? 180 : 80, 30, 40],
		image: this.backgroundImage
	});

	this._background = background;

	// this._popupContainer.doPrepare = function(args) {

	// 	tgfComponents.Container.prototype.doPrepare.call(this._popupContainer, args);

	// 	// set pivot + base rotation
	// 	this._popupContainer.baseContainer.setPivot(this._popupContainer.width/2, this._popupContainer.height/2);
	// 	this._popupContainer.baseContainer.setRotation(0 * Math.PI / 180);

	// 	// center container
	// 	this._popupContainer.baseContainer.setPosition(this._containerPositionX, this._containerPositionY);

	// }.bind(this);

	this._popupContainer.addComponent(background);
}

tgfDialogs.BattleshipPopup.prototype._addHeaderLabel = function() {

	this.fontLabel = f_babas_regular.clone();
	this.fontLabel.align = 'center';
	this.fontLabel.fontSize = 40;
	this.fontLabel.fillColor = '#ffffcc';

	//-------------------
	var textProps = {
		text: this._label,
		font: this.fontLabel,
		x: this.width/2,
		y: 19,
		height: 80,
		align: 'center',
		fitToBox: false,
		baseline: 'middle',
		splitLines: false
	};


	this._textTop = new tgfComponents.Label(textProps);
	this._popupContainer.addComponent(this._textTop);
	// this._textTop.font.setFontStyle("italic");


	if (this.stars) {

		this.starLeft = new tgfComponents.Picture({ image: this.starImage });
		this.starRight = new tgfComponents.Picture({ image: this.starImage });

		tgfComponents.Label.prototype.doPrepare.call(this._textTop);

		// While our text is larger than 60% of the button's width, size it down until it fits.
		var oldSize = this._textTop.font.font.width;
		while (this._textTop.font.font.width > this.width * 0.6) {
			this._textTop.font.font.style.fontSize--;
			this._textTop.font.font.calculateBounds();

		}

		var newScale = this._textTop.font.width / oldSize; // Scaling
		if (newScale <= 0.99) { // if scaled
			this.starLeft.setScale(newScale, newScale);
			this.starRight.setScale(newScale, newScale);
		}
		this._textTop.doPrepare = function(args) {

			tgfComponents.Label.prototype.doPrepare.call(this._textTop, args);

			this.starLeft.x = this._textTop.x - this.starOffset - this.starImage.sprite.width - this._textTop.getWidth() / 2;
			this.starLeft.y = 38 - this.starImage.sprite.height / 2;

			this.starRight.x = this._textTop.x + this.starOffset + this._textTop.getWidth() / 2;
			this.starRight.y = 38 - this.starImage.sprite.height / 2;

		}.bind(this);

		this._popupContainer.addComponent(this.starLeft);
		this._popupContainer.addComponent(this.starRight);
	}
}


tgfDialogs.BattleshipPopup.prototype._addAnimator = function() {

	this._animatorPopup = new tbAnimator(this._popupContainer.baseContainer.container);
	this._animatorPopupTrackX = this._animatorPopup.addTrack('x');
	this._animatorPopupTrackY = this._animatorPopup.addTrack('y');

	// this._animatorPopup.addKey(this._animatorPopupTrackY, 0, this._containerPositionY + tgfGraphics.areaHeight/2 * 1.5, tbEase.easeOutOvershoot, .85);
	// this._animatorPopup.addKey(this._animatorPopupTrackY, 1000, this._containerPositionY + tgfGraphics.areaHeight/2 * 1.5, tbEase.easeOutOvershoot, .85);
	// this._animatorPopup.addKey(this._animatorPopupTrackY, 1350, this._containerPositionY, tbEase.easeOutCubic);
	// this._animatorPopup.addKey(this._animatorPopupTrackY, 2500, this._containerPositionY, tbEase.easeInOvershoot, .85);
	// this._animatorPopup.addKey(this._animatorPopupTrackY, 2850, this._containerPositionY - tgfGraphics.areaHeight/2 * 1.5, tbEase.easeInOvershoot, .85);

	// this._animatorPopup.setLooping(true);

	// this._animatorPopup.setTime(0);
}


tgfDialogs.BattleshipPopup.prototype._addCustom = function() {

	// overwrite me!
}

// Processing required when freeing the dialog from use
tgfDialogs.BattleshipPopup.prototype.handleBeginStep = function(timePassed) {

	// animator
	if (this._animatorPopup) {

		this._animatorPopup.updateTime(timePassed);
	}

	this._customBeginStep(timePassed);

	// if (this._popupContainer) {
	// 	console.log('popp', this._popupContainer.container);
	// 	// this._popupContainer.container.y += .1;
	// }

	// test (pivot) rotation
	// this.__r = this.__r || 0;

	// if (this._popupContainer) {

	// 	this.__r += .085;

	// 	this._popupContainer.baseContainer.container.rotation = this.__r * Math.PI / 180;
	// }
}

tgfDialogs.BattleshipPopup.prototype._customBeginStep = function(timePassed) {

	// overwrite me
}

tgfDialogs.BattleshipPopup.prototype.doFree = function() {
	"use strict";
	this.removeAllComponents();

	if (this._animatorPopup) {
		this._animatorPopup.removeAllKeys();
		this._animatorPopup.removeEvents();
		this._animatorPopup = null;
	}

	if (this._hasShadow) {
		tgfGraphics.removeChild(this._shadow.container);
		this._shadow.container.destroy();
		this._shadow.container = null;
	}

	if (this.fontLabel)
	{
		if (this.fontLabel.font) {
			this.fontLabel.font.destroy();
			this.fontLabel.font = null;
		}
		this.fontLabel = null;
	}

	tgfGraphics.removeChild(this.baseContainer.container);
	// this.baseContainer.container.destroy();
	// this.baseContainer.container = null;
};

// Processing required when showing the dialog
tgfDialogs.BattleshipPopup.prototype.doShow = function() {
	"use strict";

	tgfAudio.play(a_popup_show);

	if (this._hasShadow) {
		this._shadow.setAlpha(1);
		// this._shadow.container.buttonMode = true;
		this._shadow.container.interactive = true;
	}
};

// Processing required when hiding the dialog
tgfDialogs.BattleshipPopup.prototype.doHide = function() {
	"use strict";

	// console.log('doHide');
	tgfAudio.play(a_popup_show);

	if (this._hasShadow) {
		this._shadow.setAlpha(0);
		this._shadow.container.buttonMode = false;
		this._shadow.container.interactive = false;
	}
};


tgfDialogs.BattleshipPopup.prototype.free = function(alsoChildren) {

	tbGame.removeToken(this);

	if (this._animatorPopup) {

		this._animatorPopup.pause();
		this._animatorPopup = null;
	}

	tgfDialogs.Base.prototype.hide.call(this, true);
	tgfDialogs.Base.prototype.free.call(this, true);
}

//******************************************************
//*****    Script Resource: BattleshipPlacementPopupDialog
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipPlacementPopup = function(properties) {

	this.name = "BattleshipPlacementPopup";
	properties = properties || {};
	// properties.label = tgfHooks.getContextID() != null ? tgfDictionary.getText("ShipPlacementTitleInContext") : tgfDictionary.getText("ShipPlacementTitle");
	properties.label = " "; // no title
	properties.stars = false; // no stars

	tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);
}

tgfDialogs.inherit(tgfDialogs.BattleshipPlacementPopup, tgfDialogs.BattleshipPopup);


tgfDialogs.BattleshipPlacementPopup.prototype.setAsRematch = function(boolValue) {

	this._isRematch = boolValue;

	if (this._isRematch && this.buttonConfirm) {
		this.buttonConfirm.text = tgfDictionary.getText("ShipPlacementConfirmRematch");
		this.buttonConfirm.drawText();
	}
}

tgfDialogs.BattleshipPlacementPopup.prototype.setButtonCallback = function(callback) {

	this._buttonCallback = callback;
}

tgfDialogs.BattleshipPlacementPopup.prototype._addCustom = function() {
	var self = this;

	var buttonImage = d_buttons_yellow;

	// this.buttonChallenge = new tgfComponents.ComponentBattleshipButton({
	// 	text: tgfDictionary.getText("PlacementPopupButtonChallengeAFriend"),
	// 	image: buttonImage,
	// 	width: 420,
	// 	height: 86,
	// 	x: this.width / 2,
	// 	y: 86 + 86/2 + 22,
	// 	fontSize: 40
	// });
	//
	// this.buttonRandom = new tgfComponents.ComponentBattleshipButton({
	// 	text: tgfDictionary.getText("InstantBattle"),
	// 	image: buttonImage,
	// 	width: 420,
	// 	height: 86,
	// 	x: this.width / 2,
	// 	y: 86 + 86/2 + 110 + 22,
	// 	fontSize: 40
	// });
	// this.buttonRandom.image.setAlpha(0.5);

	this.buttonPractice = new tgfComponents.ComponentBattleshipButton({
		text: tgfDictionary.getText("ToBattle"),
		image: buttonImage,
		width: 420,
		height: 86,
		x: this.width / 2 + 15,
		y: 86 + 86 / 2 + 110 + 110 + 22 + 100,
		fontSize: 40
	});


	// this.buttonChallenge.onClick = function() {
	//
	// 	// console.log('select challenge');
	// 	self._buttonCallback('challenge');
	// 	// tbGame.addSpecial('room-select', self.data);
	// };
	//
	// this.buttonRandom.onClick = function() {
	//
	// 	// console.log('select random');
	// 	self._buttonCallback('random');
	// 	// tbGame.addSpecial('room-select', self.data);
	// };

	this.buttonPractice.onClick = function () {

		// console.log('select practice');
		self._buttonCallback('practice');
		// tbGame.addSpecial('room-select', self.data);
	}

	// this._popupContainer.addComponent(this.buttonChallenge);
	// this._popupContainer.addComponent(this.buttonRandom);
	this._popupContainer.addComponent(this.buttonPractice);

	// else {
	//
	// 	this.buttonConfirm = new tgfComponents.ComponentBattleshipButton({
	// 		// text: (this._isRematch) ? tgfDictionary.getText("PlacementPopupStartRematch") : tgfDictionary.getText("PlacementPopupConfirmPlacement"),
	// 		text: (this._isRematch) ? tgfDictionary.getText("PlacementPopupConfirmPlacement") : tgfDictionary.getText("PlacementPopupConfirmPlacement"),
	// 		image: buttonImage,
	// 		width: 420,
	// 		height: 86,
	// 		x: this.width / 2,
	// 		y: 86 + 86/2 + 10,
	// 		fontSize: 40
	// 	});
	//
	// 	this.buttonConfirm.onClick = function() {
	//
	// 		// console.log('select challenge');
	//
	// 		if (self._isRematch) {
	//
	// 			self._buttonCallback('rematch');
	// 		}
	// 		else {
	//
	// 			self._buttonCallback('confirm');
	// 		}
	// 		// tbGame.addSpecial('room-select', self.data);
	// 	};
	//
	// 	this._popupContainer.addComponent(this.buttonConfirm);
	// }
}


tgfDialogs.BattleshipPlacementPopup.prototype.show = function(arg) {
	// console.log('BattleshipPlacementPopup Show');

	// console.log('BPP::.show');


	if (this._animatorPopup) {

		this._animatorPopup.pause();
		this._animatorPopup.removeAllKeys();
		this._animatorPopup.removeEvents();
	}

	var self = this;

	tgfDialogs.BattleshipPopup.prototype.show.call(self, arg);

	this.stupidonShow();
}

tgfDialogs.BattleshipPlacementPopup.prototype.onShow = function() {

	// console.log('BPP::.onShow');
}

tgfDialogs.BattleshipPlacementPopup.prototype.onHide = function() {

	// console.log('BPP::.onHide');
}

tgfDialogs.BattleshipPlacementPopup.prototype.stupidonShow = function() {

	// console.log('BPP::.stupidonShow');

	this._animatorPopup.pause();
	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	if (!this._firstCall) {
		this._firstCall = true;
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight/2;
	}

	if (this._popupContainer.baseContainer.container.y != this._containerPositionY) {
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight/2;
	}

	// Applied offset
	this._animatorPopup.addKey(this._animatorPopupTrackY, 300, this._popupContainer.baseContainer.container.y - 30, tbEase.easeOutOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 600, this._containerPositionY - 30, tbEase.easeOutCubic);
	// this._animatorPopup.addKey(this._animatorPopupTrackY, 100, this._popupContainer.baseContainer.container.y, tbEase.easeOutOvershoot, .65);
	// this._animatorPopup.addKey(this._animatorPopupTrackY, 400, this._containerPositionY, tbEase.easeOutCubic);

	this._animatorPopup.setTime(0);
	this._animatorPopup.resumeForced();
}


tgfDialogs.BattleshipPlacementPopup.prototype.hide = function(arg) {

	// console.log('BattleshipPlacementPopup hide');
	this.isShowing = false;

	// console.log('BPP::.hide');

	if (!this._animatorPopup) {
		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
		return;
	}

	this._animatorPopup.pause();
	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	this._animatorPopup.addKey(this._animatorPopupTrackY, 10, this._popupContainer.baseContainer.container.y, tbEase.easeInOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 260, this._containerPositionY - tgfGraphics.areaHeight/2, tbEase.easeOutCubic);
	this._animatorPopup.addEvent(this, 400, function() {

		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
	}.bind(this));

	this._animatorPopup.setTime(0);
	this._animatorPopup.resumeForced();
}

//******************************************************
//*****    Script Resource: BattleshipRenewSpecialWeaponsPopup
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipRenewSpecialWeaponsPopup = function(properties) {

	this.name = "BattleshipRenewSpecialWeaponsPopup";

	properties = properties || {};
	properties.label = tgfDictionary.getText("RenewSpecialWeaponPopupTitle");

	this.done = false;
	this._showingAd = false;

	if (properties.manager) {

		this.manager = properties.manager;
	}

	this.background = tbGraphics.drawRectangle(0, 0, tbGraphics.width, tbGraphics.height, "#000000");
	this.background.alpha = 0;
	tgfGraphics.addChild(this.background, 'BattleshipRenewSpecialWeaponsPopup.background');

	tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);
}

tgfDialogs.inherit(tgfDialogs.BattleshipRenewSpecialWeaponsPopup, tgfDialogs.BattleshipPopup);

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype._customBeginStep = function(timePassed) {


	if (this.background.animator) {
		this.background.animator.updateTime(timePassed);
	}

	for (var i = 0; i < this.iconImages.length; i++) {
		var icon = this.iconImages[i];

		if (!icon.animator) {
			break;
		}

		icon.animator.updateTime(timePassed);
		icon.y = icon.image.sprite.y;
	}

	if (this.buttonExtraShotActive.animator) {
		this.buttonExtraShotActive.animator.updateTime(timePassed);
	}



	if (!this._countDownEnabled) return;

	if (this.buttonExtraShotInactive && this.buttonExtraShotActive && this.buttonExtraShotInactive.fontText) {

		var specialWeaponData = UserDataController.getSpecialWeaponData();
		var time = TimeManager.getTime();

		var timeTo = specialWeaponData.availableAt;
		var timeNow = time.serverTime;

		var diff = Math.ceil(timeTo - timeNow) / 1000;


		if (diff <= 0) {
			diff = 0;

			this._canViewAd = true;

			this.buttonExtraShotInactive.setAlpha(0);
			this.buttonExtraShotActive.setAlpha(1);
		}
		else {

			this._canViewAd = false;
			this.buttonExtraShotInactive.setAlpha(1);
			this.buttonExtraShotActive.setAlpha(0);
		}

		var mins = Math.floor(diff / 60);
		var secs = Math.floor(diff - mins * 60);


		mins = (mins < 10) ? String('0' + mins) : String(mins);
		secs = (secs < 10) ? String('0' + secs) : String(secs);

		this.buttonExtraShotInactive.fontText.setText(String( mins + ':' + secs ));
	}
}

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.setButtonCallback = function(callback) {

	this._buttonCallback = callback;
}

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype._addCustom = function() {

	var self = this;

	var buttonDefinition = {
		width: 350,
		height: 86 * 1.45,
		x: 230,
		y: 550 - 95 - 66 - 16
	};

	var cancelButtonDefinition = {
		width: 350 / 2,
		height: 86,
		x: 230,
		y: 580 - 66 - 16
    };

	this.fontContent = {
		fontFace: f_babas_regular_no_shadow.fontFace,
		fillColor: "#001c35",
		align: 'center',
		fontSize: 28,
		wordWrap: true,
		wordWrapWidth: buttonDefinition.width,
		breakWords: true
	};

	// Align the title above the button.
	this._textTop.x = buttonDefinition.x;
	this._textTop.y += (80 - this._textTop.height) + 110;
	this._textTop.width = buttonDefinition.width * 1.2;
	this._textTop.splitLines = false;
	this._textTop.baseline = "middle";
	this._textTop.align = "center";
	this._textTop.wordWrap = false;

	var icons = [
		icon_sw_01, // AirStrike
		icon_sw_02, // Bomb
		// icon_sw_03, // Radar
		icon_sw_05, // Torpedo
		icon_sw_04, // Scattershot
	];

	this.iconImages = [];

	for (var i = 0; i < icons.length; i++) {
		this.iconImages.push(new tgfComponents.Picture({
			image: icons[i],
			x: 10 + i * 100,
			y: 5 - 80 // Applied offset
		}));
	}

	this.buttonExit = new tgfComponents.ComponentBattleshipButton({
		text: tgfDictionary.getText("ExtraShotPopupButtonCancel"),
		image: s_button_blue,
		width: cancelButtonDefinition.width,
		height: cancelButtonDefinition.height,
		x: cancelButtonDefinition.x,
		y: cancelButtonDefinition.y
	});

	this.character = new BattleshipComponents.SpineAnimation({
		x: this.width + 1,
		y: this.height - 22,
		animation: popup_reload,
		onLoad: function () {
			self.character.animator.animation.alpha = 0;
		}
	});

	this.infoLabel = new tgfComponents.Label({
		text: tgfDictionary.getText("RenewSpecialWeaponPopupContent"),
		font: this.fontContent,
		x: buttonDefinition.x,
		y: 530 - 95 - 66 - 16 - 95 - 50,
		width: buttonDefinition.width * 0.9,
        height: 150,
        baseline: 'middle',
		align: "center",
		fitToBox: false
    });

    this.infoLabel.doPrepare = function () {
        tgfComponents.Label.prototype.doPrepare.call(this);

		this.font.font.calculateBounds();
        var textWidth = this.font.font.width;
		var textHeight = this.font.font.height;

        var fontScale = 1;

        if (textWidth > this.width) {
            fontScale = this.width / textWidth;
        }
        if (textHeight > this.height) {
            fontScale = Math.min(fontScale, this.height / textHeight);
        }

        this.font.fontSize = Math.floor(this.font.fontSize * fontScale);
        this.font.setStyle();

    }.bind(this.infoLabel);


	this.buttonExtraShotInactive = new tgfComponents.ComponentBattleshipButton({
		text: '03:00',
		icon: s_button_ad_gray,
		iconPosition: 'right',
		iconTextDistance: 20,
		image: s_button_gray,
		width: buttonDefinition.width,
		height: buttonDefinition.height,
		x: buttonDefinition.x,
		y: buttonDefinition.y,
	});

	this.buttonExtraShotActive = new tgfComponents.ComponentBattleshipButton({
		text: tgfDictionary.getText("RenewSpecialWeaponPopupButtonActive"),
		icon: s_button_ad,
		iconPosition: 'right',
		iconTextDistance: 20,
		image: s_button_green,
		width: buttonDefinition.width,
		height: buttonDefinition.height,
		x: buttonDefinition.x,
		y: buttonDefinition.y,
	});

	this.buttonExtraShotInactive.onClick = function() {

		// console.log('special weapon refresh click');

		if (!self._canViewAd || self._refreshClicked) {

			// if (self.onExit) self.onExit();
			// self.hide(false);
			return;
		}


		self._refreshClicked = true;
		self._countDownEnabled = false;


		if (self._buttonCallback) {

			self._buttonCallback();
		}


		if (self.onExit) self.onExit();
		self.hide(false);
	};

	this.buttonExtraShotInactive.changeImageFrame = function(frame) {

		tgfComponents.ComponentBattleshipButton.prototype.changeImageFrame.call(self.buttonExtraShotInactive, frame);
		self.buttonExtraShotActive.changeImageFrame(frame);
	};

	this.buttonExit.onClick = function() {
		AnalyticsService.reportEvent("interaction", "interaction", {
			eventType: "button_decline",
			id: "special_weapon"
		});

		if (self.onExit) self.onExit();

		self.hide(false);
	}

	for (var i = 0; i < icons.length; i++) {
		this._popupContainer.addComponent(this.iconImages[i]);
	}

	this._popupContainer.addComponent(this.character);

	this._popupContainer.addComponent(this.infoLabel);
	this._popupContainer.addComponent(this.buttonExit);
	this._popupContainer.addComponent(this.buttonExtraShotActive);
	this._popupContainer.addComponent(this.buttonExtraShotInactive);

	setTimeout(function() {
		self.buttonExtraShotActive.icon.setPosition(self.buttonExtraShotActive.icon.x, self.buttonExtraShotActive.icon.y-5);
		self.buttonExtraShotInactive.icon.setPosition(self.buttonExtraShotInactive.icon.x, self.buttonExtraShotInactive.icon.y-5);
	}, 0);
}


tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.show = function(arg) {
	AnalyticsHelper.reportPopup("special_weapon", "open");
	tgfDialogs.BattleshipPopup.prototype.show.call(this, arg);
}

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.animateExtraShot = function() {

	// this.buttonExtraShotActive
	this.buttonExtraShotActive.animator = this.buttonExtraShotActive.animator || new tbAnimator(this.buttonExtraShotActive);
	this.buttonExtraShotActive.trackScaleX = this.buttonExtraShotActive.trackScaleX || this.buttonExtraShotActive.animator.addTrack('xScale');
	this.buttonExtraShotActive.trackScaleY = this.buttonExtraShotActive.trackScaleY || this.buttonExtraShotActive.animator.addTrack('yScale');

	this.buttonExtraShotActive.animator.pause();
	this.buttonExtraShotActive.animator.removeAllKeys();
	this.buttonExtraShotActive.animator.removeEvents();

	// Start state
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 0, 	1.0, tbEase.easeOutCubic);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 0, 	1.0, tbEase.easeOutCubic);

	// Shrink
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 250, 0.9, tbEase.easeOutCubic);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 250, 0.6, tbEase.easeOutCubic);

	// Boing Y
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 400, 0.9, tbEase.easeOutElastic, 4.0);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 400, 1.2, tbEase.easeOutElastic, 4.0);

	// Boing X
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 450, 1.2, tbEase.easeOutElastic, 4.0);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 450, 1.0, tbEase.easeOutElastic, 4.0);

	// Reset
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 800, 1.0, tbEase.easeOutCubic);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 800, 1.0, tbEase.easeOutCubic);

	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 1200, 1.0, tbEase.easeOutCubic);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 1200, 1.0, tbEase.easeOutCubic);

	this.buttonExtraShotActive.animator.setLooping(true);


	this.buttonExtraShotActive.animator.setTime(0);
	this.buttonExtraShotActive.animator.resumeForced();
}

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.showPlusOneButton = function() {

	var endTime = 400;

	for (var i = 0; i < this.iconImages.length; i++) {
		var icon = this.iconImages[i];

		var startTime = 300 + (50 * i);

		icon.animator = icon.animator || new tbAnimator(icon.image.sprite);
		icon.trackY = icon.trackY || icon.animator.addTrack('y');
		icon.trackAlpha = icon.trackAlpha || icon.animator.addTrack('alpha');

		icon.animator.pause();
		icon.animator.removeAllKeys();
		icon.animator.removeEvents();

		icon.animator.addKey(icon.trackY,		0,				   		0 - 180,	tbEase.easeOutOvershoot, 2);
		icon.animator.addKey(icon.trackY,		startTime,		   		0 - 180,	tbEase.easeOutOvershoot, 2);
		icon.animator.addKey(icon.trackY,		startTime + endTime,	-80,			tbEase.easeOutOvershoot, 2);

		icon.animator.addKey(icon.trackAlpha,	0, 						0, tbEase.easeOutCubic);
		icon.animator.addKey(icon.trackAlpha,	startTime, 				0, tbEase.easeOutCubic);
		icon.animator.addKey(icon.trackAlpha,	startTime + endTime,	1, tbEase.easeOutCubic);

		if (i == this.iconImages.length -1 ) {
			icon.animator.addEvent(this, startTime + endTime, function() {

				this.character.animator.animation.alpha = 1;
				this.character.playAnimation("intro", false, function () {
					this.character.playAnimation("loop", true);
				}.bind(this));

				this.animateExtraShot();
			}.bind(this));
		}

		icon.animator.setTime(0);
		icon.animator.resumeForced();
	}
}

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.onShow = function() {

	// console.log('onShow');
	for (var i = 0; i < this.iconImages.length; i++) {

		this.iconImages[i].image.sprite.alpha = 0; // useless when having animator running in background -> overwrites value next frame again
	}

	// re-enable countdown every time popup shows
	this._countDownEnabled = true;
	this._refreshClicked = false;

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	if (!this._firstCall) {
		this._firstCall = true;
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight;

		this.background.animator = new tbAnimator(this.background.sprite);
		this.background.animator.alphaTrack = this.background.animator.addTrack('alpha');
	}

	if (this._popupContainer.baseContainer.container.y != this._containerPositionY) {
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight;
	}

	this._animatorPopup.addKey(this._animatorPopupTrackY, 000, tgfGraphics.areaHeight + 1000, tbEase.easeOutOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 300, this._containerPositionY, tbEase.easeOutCubic);

	this.background.animator.addKey(this.background.animator.alphaTrack, 000, this.background.alpha);
	this.background.animator.addKey(this.background.animator.alphaTrack, 300, 1);
	// this._animatorPopup.addEvent(this, 300, function() {


	// }.bind(this));
	this.showPlusOneButton();

	this._animatorPopup.setTime(0);
	this.background.animator.setTime(0);
}



tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.removePopup = function(arg) {

	if (!this._animatorPopup) {
		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
		hideComponents();
		return;
	}

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	this._animatorPopup.addKey(this._animatorPopupTrackY, 10, tgfGraphics.areaHeight + 1000, tbEase.easeInOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 260, this._containerPositionY - tgfGraphics.areaHeight, tbEase.easeOutCubic);
	this._animatorPopup.addEvent(this, 400, function() {

		hideComponents();
		this._animatorPopup = null;
	}.bind(this));

	this._animatorPopup.setTime(0);
}

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.show = function() {
	Sequencer.require(["popup_reload"], true)
	.then(function() {
		tgfDialogs.BattleshipRenewSpecialWeaponsPopup.uber.show.call(this);
	}.bind(this))
	.catch(function(reason) {
		throw reason;
	}.bind(this));
};

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.hide = function(arg) {

	var clean = function() {
		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
		if (this.character && this.character.animator)
			this.character.animator.animation.alpha = 0;

		for (var i = 0; i < this.iconImages.length; i++) {
			if (this.iconImages[i] && this.iconImages[i].image)
				this.iconImages[i].image.sprite.alpha = 0;
		}
	}.bind(this);

	var hasBackground = this.background && this.background.alpha > 0.01;
	if (hasBackground) {
		// setup background animator
		this.backgroundAnimator = this.backgroundAnimator || new tbAnimator(this.background);
		this.backgroundAnimator.alphaTrack = this.backgroundAnimator.alphaTrack || this.backgroundAnimator.addTrack('alpha');

		this.backgroundAnimator.removeAllKeys();
		this.backgroundAnimator.removeEvents();

		this.backgroundAnimator.addKey(this.backgroundAnimator.alphaTrack, 000, this.background.alpha);
		this.backgroundAnimator.addKey(this.backgroundAnimator.alphaTrack, 260, 0);
		this.backgroundAnimator.addEvent(this, 400, function() {

			if (this.background) {
				tgfGraphics.removeChild(this.background);
				this.background = null;
			}

			if (!this._animatorPopup) {
				clean();
				return;
			}
		}.bind(this));
	}

	if (this.backgroundAnimator) {

		this.backgroundAnimator.setTime(0);
	}

	if (!this._animatorPopup) {

		// The background uncloaking cleans it, so it would be unnecessary.
		if (!hasBackground) {
			clean();
		}
		return;
	}

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	this._animatorPopup.addKey(this._animatorPopupTrackY, 10, this._popupContainer.baseContainer.container.y, tbEase.easeInOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 260, tgfGraphics.areaHeight + 1000, tbEase.easeOutCubic);
	this._animatorPopup.addEvent(this, 400, clean);

	this._animatorPopup.setTime(0);
	if (this.isVisible){
		AnalyticsHelper.reportPopup("special_weapon", "close");
	}
}

tgfDialogs.BattleshipRenewSpecialWeaponsPopup.prototype.doFree = function() {

	tgfDialogs.BattleshipPopup.prototype.doFree.call(this);

	if (this.fontContent)
	{
		if (this.fontContent.font) {
			this.fontContent.font.destroy();
			this.fontContent.font = null;
		}
		this.fontContent = null;
	}
}

//******************************************************
//*****    Script Resource: BattleshipIncorrectPlacementPopupDialog
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipIncorrectPlacementPopupDialog = function(properties) {
    
        this.name = "BattleshipIncorrectPlacementPopupDialog";
    
        properties = properties || {};
        properties.label = tgfDictionary.getText("ShipPlacementIncorrectTitle");
               
        tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);
    }
    
tgfDialogs.inherit(tgfDialogs.BattleshipIncorrectPlacementPopupDialog, tgfDialogs.BattleshipPopup);

tgfDialogs.BattleshipIncorrectPlacementPopupDialog.prototype.setButtonCallback = function(callback) {

    this._buttonCallback = callback;
}

tgfDialogs.BattleshipIncorrectPlacementPopupDialog.prototype._addCustom = function() {
    
    this.errorMessageLabel = new tgfComponents.Label({
        text: tgfDictionary.getText("ShipPlacementIncorrectDescription"),
		font: this.fontLabel,
		align: 'center',
        fitToBox: false,
        splitLines: true,
        baseline: 'middle',
        width: this._popupContainer.width * 0.8,
        height: 150,
        x: this._popupContainer.width / 2,
        y: this._popupContainer.height / 2 - 20
    });

    this._popupContainer.addComponent(this.errorMessageLabel);
}
    
    
tgfDialogs.BattleshipIncorrectPlacementPopupDialog.prototype.show = function(arg) {
    console.log('show');

    if (this._animatorPopup)
         this.onShow();

    tgfDialogs.BattleshipPopup.prototype.show.call(this, arg);
}

tgfDialogs.BattleshipIncorrectPlacementPopupDialog.prototype.onShow = function() {

    console.log('onShow');
    this.isShowing = true;

    this._animatorPopup.removeAllKeys();
    this._animatorPopup.removeEvents();

    if (!this._firstCall) {
        this._firstCall = true;
        this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight/2;
    }

	this._animatorPopup.addKey(this._animatorPopupTrackY, 100, this._popupContainer.baseContainer.container.y, tbEase.easeOutOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 400, this._containerPositionY, tbEase.easeOutCubic);

    this._animatorPopup.setTime(0);
}


tgfDialogs.BattleshipIncorrectPlacementPopupDialog.prototype.hide = function(arg) {

    this.isShowing = false;

    if (!this._animatorPopup) {
        tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
        return;		
    }

    this._animatorPopup.removeAllKeys();
    this._animatorPopup.removeEvents();

	this._animatorPopup.addKey(this._animatorPopupTrackY, 10, this._popupContainer.baseContainer.container.y, tbEase.easeInOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 260, this._containerPositionY - tgfGraphics.areaHeight/2, tbEase.easeOutCubic);
    this._animatorPopup.addEvent(this, 400, function() {

        tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
    }.bind(this));

    this._animatorPopup.setTime(0);
}
//******************************************************
//*****    Script Resource: BattleshipExtraShotPopup
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipExtraShotPopup = function(properties) {

	this.name = "BattleshipExtraShotPopup";

	properties = properties || {};
	properties.label = tgfDictionary.getText("ExtraShotPopupTitle");

	properties.stars = false;
	tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);

	this.animatedShadow = new tbContainer(1366, 1366);

	var shadowShape = tbGraphics.drawRectangle(0, 0, tgfGraphics.areaWidth, tgfGraphics.areaHeight, 0x000001, null, null, 0.5);

	this.animatedShadow.container.addChild(shadowShape);
	tgfGraphics.addChild(this.animatedShadow.container, 'BattleshipExtraShotPopup.shadow');
	this.animatedShadow.setAlpha(0);
	this.animatedShadow.container.buttonMode = false;
	this.animatedShadow.container.interactive = false;
}

tgfDialogs.inherit(tgfDialogs.BattleshipExtraShotPopup, tgfDialogs.BattleshipPopup);



tgfDialogs.BattleshipExtraShotPopup.prototype.setButtonCallback = function(callback) {

	this._buttonCallback = callback;
}

tgfDialogs.BattleshipExtraShotPopup.prototype._addCustom = function() {

	var self = this;

	this.fireButton = new tgfComponents.Picture({
		image: icon_firebutton,
		x: 150,
		y: -40 - 80
	});
	this.fireButton.originalY = this.fireButton.y;

	this.character = new BattleshipComponents.SpineAnimation({
		x: this.width - 5,
		y: this.height - 22,
		animation: popup_extra,
		onLoad: function () {
			self.character.animator.animation.alpha = 0;
		}
	});

	var acceptButtonDefinition = {
		width: 350,
		height: 86 * 1.45,
		x: 230,
		y: 550 - 95 - 66 - 16
	};

	var cancelButtonDefinition = {
		width: 350 / 2,
		height: 86,
		x: 230,
		y: 580 - 66 - 16
    };

	// Align the title above the button.
	this._textTop.x = acceptButtonDefinition.x;
	this._textTop.y = 130;
	this._textTop.width = acceptButtonDefinition.width * 1.1;
	this._textTop.wordWrap = false;
	this._textTop.baseline = "bottom";

	this.buttonExit = new tgfComponents.ComponentBattleshipButton({
		text: tgfDictionary.getText("ExtraShotPopupButtonCancel"),
		image: s_button_blue,
		width: cancelButtonDefinition.width,
		height: cancelButtonDefinition.height,
		x: cancelButtonDefinition.x,
		y: cancelButtonDefinition.y
	});

	this.fontContent = {
		fontFace: f_babas_regular_no_shadow.fontFace,
		fillColor: "#001c35",
		align: 'center',
		fontSize: 32,
		wordWrap: true,
		breakWords: true
	};

	this.infoLabel = new tgfComponents.Label({
		text: tgfDictionary.getText("ExtraShotPopupContentTop") + " " + tgfDictionary.getText("ExtraShotPopupContentBottom"),
		font: this.fontContent,
		x: acceptButtonDefinition.x,
		y: 530 - 95 - 66 - 16 - 95 - 50,
		width: acceptButtonDefinition.width * 0.9,
        height: 150,
		baseline: 'middle',
		align: "center",
		fitToBox: false,
		splitLines: true,
		breakWords: true
	});

	this._textTop.doPrepare = function () {
		tgfComponents.Label.prototype.doPrepare.call(this);

		var textWidth = this.font.font.width;
		var textHeight = this.font.font.height;
		var fontScale = 1;

		if (textWidth > this.width) {
			fontScale = this.width / textWidth;
		}
		if (textHeight > this.height) {
			fontScale = Math.min(fontScale, this.height / textHeight);
		}

		var newSize = Math.floor(this.font.fontSize * fontScale);
		this.font.fontSize = newSize;
		this.font.y -= newSize;
		this.font.setStyle();


	}.bind(this._textTop);

	this.infoLabel.doPrepare = function () {
		tgfComponents.Label.prototype.doPrepare.call(this);

		var textWidth = this.font.font.width;
		var textHeight = this.font.font.height;
		var fontScale = 1;

		if (textWidth > this.width) {
			fontScale = this.width / textWidth;
		}
		if (textHeight > this.height) {
			fontScale = Math.min(fontScale, this.height / textHeight);
		}

		this.font.fontSize = Math.floor(this.font.fontSize * fontScale);
		this.font.setStyle();

	}.bind(this.infoLabel);


	this.buttonExtraShotInactive = new tgfComponents.ComponentBattleshipButton({
		// text: (this._isRematch) ? 'start rematch' : 'confirm placement',
		text: '03:00',//tgfDictionary.getText("ExtraShotPopupButtonActive"),
		// text: tgfDictionary.getText("ExtraShotPopupButtonInActive"),
		icon: s_button_ad_gray,
		iconPosition: 'right',
		iconTextDistance: 20,
		image: s_button_gray,
		width: acceptButtonDefinition.width,
		height: acceptButtonDefinition.height,
		x: acceptButtonDefinition.x,
		y: acceptButtonDefinition.y,
	});

	this.buttonExtraShotActive = new tgfComponents.ComponentBattleshipButton({
		text: tgfDictionary.getText("ExtraShotPopupButtonActive"),
		icon: s_button_ad,
		iconPosition: 'right',
		iconTextDistance: 20,
		image: s_button_green,
		width: acceptButtonDefinition.width,
		height: acceptButtonDefinition.height,
		x: acceptButtonDefinition.x,
		y: acceptButtonDefinition.y,
	});

	this.buttonExtraShotInactive.changeImageFrame = function(frame) {

		tgfComponents.ComponentBattleshipButton.prototype.changeImageFrame.call(self.buttonExtraShotInactive, frame);
		self.buttonExtraShotActive.changeImageFrame(frame);
	};

	this.buttonExit.onClick = function() {

		if (self.onExit) self.onExit();

		if (self._canViewAd) {
			// BattleshipsAnalytics.reportRequestedFacebookAdvertisment(false);
		}

		self.hide(false);
	}

	this.buttonExtraShotInactive.onClick = function() {

		// console.log('extra shot click');

		if (!self._canViewAd || self._refreshClicked) {

			// if (self.onExit) self.onExit();
			// self.hide(false);
			return;
		}

		self._refreshClicked = true;
		self._countDownEnabled = false;

		if (self._buttonCallback) self._buttonCallback();

		self.hide(false);
	};

	this._popupContainer.addComponent(this.character);
	this._popupContainer.addComponent(this.fireButton);

	this._popupContainer.addComponent(this.infoLabel);
	this._popupContainer.addComponent(this.buttonExit);
	this._popupContainer.addComponent(this.buttonExtraShotActive);
	this._popupContainer.addComponent(this.buttonExtraShotInactive);

	setTimeout(function() {
		self.buttonExtraShotActive.icon.setPosition(self.buttonExtraShotActive.icon.x, self.buttonExtraShotActive.icon.y-5);
		self.buttonExtraShotInactive.icon.setPosition(self.buttonExtraShotInactive.icon.x, self.buttonExtraShotInactive.icon.y-5);
	}, 0);


	// // console.log(this.buttonExtraShotActive.icon);
	// // console.log(this.buttonExtraShotActive.icon.x, this.buttonExtraShotActive.icon.y);
}


tgfDialogs.BattleshipExtraShotPopup.prototype.show = function(arg) {
	Sequencer.require(["popup_extra_shot"], true)
	.then(function() {
		console.log('Showing BattleshipExtraShotPopup');
		tgfDialogs.BattleshipExtraShotPopup.uber.show.call(this);
		AnalyticsHelper.reportPopup("extra_shot", "open");
		this.animatedShadow.container.interactive = true;
		this._isHidden = false;
	}.bind(this))
	.catch(function(reason) {
		throw reason;
	}.bind(this));
}

tgfDialogs.BattleshipExtraShotPopup.prototype.animateExtraShot = function() {

	// console.log('showPlusOneButton');

	// this.buttonExtraShotActive
	this.buttonExtraShotActive.animator = this.buttonExtraShotActive.animator || new tbAnimator(this.buttonExtraShotActive);
	this.buttonExtraShotActive.trackScaleX = this.buttonExtraShotActive.trackScaleX || this.buttonExtraShotActive.animator.addTrack('xScale');
	this.buttonExtraShotActive.trackScaleY = this.buttonExtraShotActive.trackScaleY || this.buttonExtraShotActive.animator.addTrack('yScale');
	// this.buttonExtraShotActive.animator = new tbAnimator(this.buttonExtraShotActive);
	// this.buttonExtraShotActive.trackScaleX = this.buttonExtraShotActive.animator.addTrack('xScale');
	// this.buttonExtraShotActive.trackScaleY = this.buttonExtraShotActive.animator.addTrack('yScale');

	this.buttonExtraShotActive.animator.pause();
	this.buttonExtraShotActive.animator.removeAllKeys();
	this.buttonExtraShotActive.animator.removeEvents();

	// Start state
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 0, 	1.0, tbEase.easeOutCubic);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 0, 	1.0, tbEase.easeOutCubic);

	// Shrink
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 250, 0.9, tbEase.easeOutCubic);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 250, 0.6, tbEase.easeOutCubic);

	// Boing Y
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 400, 0.9, tbEase.easeOutElastic, 4.0);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 400, 1.2, tbEase.easeOutElastic, 4.0);

	// Boing X
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 450, 1.2, tbEase.easeOutElastic, 4.0);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 450, 1.0, tbEase.easeOutElastic, 4.0);

	// Reset
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 800, 1.0, tbEase.easeOutCubic);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 800, 1.0, tbEase.easeOutCubic);

	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleX, 1200, 1.0, tbEase.easeOutCubic);
	this.buttonExtraShotActive.animator.addKey(this.buttonExtraShotActive.trackScaleY, 1200, 1.0, tbEase.easeOutCubic);

	this.buttonExtraShotActive.animator.setLooping(true);


	this.buttonExtraShotActive.animator.setTime(0);
	this.buttonExtraShotActive.animator.resumeForced();
}

tgfDialogs.BattleshipExtraShotPopup.prototype.showPlusOneButton = function() {

	// console.log('showPlusOneButton');
	this.endTime = 400;

	this.fireButton.animator = this.fireButton.animator || new tbAnimator(this.fireButton.image.sprite);
	this.fireButton.trackY = this.fireButton.trackY || this.fireButton.animator.addTrack('y');
	this.fireButton.trackAlpha = this.fireButton.trackAlpha || this.fireButton.animator.addTrack('alpha');

	this.animatedShadow.animator = this.animatedShadow.animator || new tbAnimator(this.animatedShadow.container);
	this.animatedShadow.trackAlpha = this.animatedShadow.trackAlpha || this.animatedShadow.animator.addTrack('alpha');

	this.fireButton.animator.pause();
	this.fireButton.animator.removeAllKeys();
	this.fireButton.animator.removeEvents();

	this.animatedShadow.animator.pause();
	this.animatedShadow.animator.removeAllKeys();
	this.animatedShadow.animator.removeEvents();

	this.fireButton.animator.addKey(this.fireButton.trackY, 2300 + 0, 			 this.fireButton.originalY - 100, tbEase.easeOutOvershoot, 2);
	this.fireButton.animator.addKey(this.fireButton.trackY, 2300 + this.endTime, this.fireButton.originalY, tbEase.easeOutOvershoot, 2);

	this.fireButton.animator.addKey(this.fireButton.trackAlpha, 2300 + 0, 0, tbEase.easeOutCubic);
	this.fireButton.animator.addKey(this.fireButton.trackAlpha, 2300 + this.endTime, 1, tbEase.easeOutCubic);

	this.animatedShadow.animator.addKey(this.animatedShadow.trackAlpha, 2300 + 0, 0, tbEase.easeOutCubic);
	this.animatedShadow.animator.addKey(this.animatedShadow.trackAlpha, 2300 + this.endTime, 1, tbEase.easeOutCubic);

	this.fireButton.animator.addEvent(this, 2300 + this.endTime, function() {

		this.character.animator.animation.alpha = 1;
		this.character.playAnimation("intro", false, function () {
			this.character.playAnimation("loop", true);
		}.bind(this));

		this.animateExtraShot();
	}.bind(this));

	this.fireButton.animator.setTime(0);
	this.fireButton.animator.resumeForced();

	this.animatedShadow.animator.setTime(0);
	this.animatedShadow.animator.resumeForced();
}

tgfDialogs.BattleshipExtraShotPopup.prototype.onShow = function() {

	console.log('Calling OnShow for BattleshipExtraShotPopup');

	this._hasShadow = false; // Override it because we're handling it now, don't set the alpha in the parent
	// This can only be done in the show because the preparation is done in the show call which is great when you want to block the UI update

	this.animatedShadow.setAlpha(0);
	this.fireButton.image.sprite.alpha = 0;

	// re-enable countdown every time popup shows
	this._countDownEnabled = true;
	this._refreshClicked = false;

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	if (!this._firstCall) {
		this._firstCall = true;
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight;
	}

	if (this._popupContainer.baseContainer.container.y != this._containerPositionY) {
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight;
	}

	this._animatorPopup.addKey(this._animatorPopupTrackY, 2000, tgfGraphics.areaHeight + 1000, tbEase.easeOutOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 2300, this._containerPositionY, tbEase.easeOutCubic);
	// this._animatorPopup.addEvent(this, 2300, function() {


	// }.bind(this));
	this.showPlusOneButton();

	this._animatorPopup.setTime(0);
}


tgfDialogs.BattleshipExtraShotPopup.prototype.hide = function(arg) {

	if (this._isHidden) return;
	this._isHidden = true;

	if (this.isVisible){
		AnalyticsHelper.reportPopup("extra_shot", "close");
	}

	console.log('Hiding BattleshipExtraShotPopup');
	if (this.animatedShadow && this.animatedShadow.container)
		this.animatedShadow.container.interactive = false;



	var hideComponents = function () {

		if (this.character && this.character.animator)
			this.character.animator.animation.alpha = 0;
		if (this.fireButton && this.fireButton.image)
			this.fireButton.image.sprite.alpha = 0;
	}.bind(this);

	if (!this._animatorPopup) {
		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
		hideComponents();
		return;
	}

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	this._animatorPopup.addKey(this._animatorPopupTrackY, 10, this._popupContainer.baseContainer.container.y, tbEase.easeInOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 260, tgfGraphics.areaHeight + 1000, tbEase.easeOutCubic);

	this._animatorPopup.addEvent(this, 400, function() {

		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
		hideComponents();

		this.animatedShadow.container.buttonMode = false;
		this.animatedShadow.container.interactive = false;
	}.bind(this));

	this._animatorPopup.setTime(0);

	this.animatedShadow.animator.removeAllKeys();
	this.animatedShadow.animator.removeEvents();

	this.animatedShadow.animator.addKey(this.animatedShadow.trackAlpha, 10, 1, tbEase.easeOutCubic);
	this.animatedShadow.animator.addKey(this.animatedShadow.trackAlpha, 260, 0, tbEase.easeOutCubic);

	this.animatedShadow.animator.setTime(0);
}

tgfDialogs.BattleshipExtraShotPopup.prototype._customBeginStep = function(timePassed) {

	if (this.fireButton.animator) {
		this.fireButton.animator.updateTime(timePassed);
		this.fireButton.y = this.fireButton.image.sprite.y;
	}

	if (this.animatedShadow.animator) {
		this.animatedShadow.animator.updateTime(timePassed);
	}

	if (this.buttonExtraShotActive.animator) {
		this.buttonExtraShotActive.animator.updateTime(timePassed);
	}

	if (!this._countDownEnabled) return;

	if (this.buttonExtraShotInactive && this.buttonExtraShotActive && this.buttonExtraShotInactive.fontText) {

		var extraShotData = UserDataController.getExtraShotData();
		var time = TimeManager.getTime();

		var timeTo = extraShotData.availableAt;
		var timeNow = time.serverTime;

		var diff = Math.ceil(timeTo - timeNow) / 1000;


		if (diff <= 0) {
			diff = 0;

			this._canViewAd = true;

			this.buttonExtraShotInactive.setAlpha(0);
			this.buttonExtraShotActive.setAlpha(1);
		}
		else {

			this._canViewAd = false;
			this.buttonExtraShotInactive.setAlpha(1);
			this.buttonExtraShotActive.setAlpha(0);
		}

		var mins = Math.floor(diff / 60);
		var secs = Math.floor(diff - mins * 60);


		mins = (mins < 10) ? String('0' + mins) : String(mins);
		secs = (secs < 10) ? String('0' + secs) : String(secs);

		this.buttonExtraShotInactive.fontText.setText(String( mins + ':' + secs ));
	}
}

tgfDialogs.BattleshipExtraShotPopup.prototype.doFree = function() {

	tgfDialogs.BattleshipPopup.prototype.doFree.call(this);

	if (this.fontContent) {
		this.fontContent = null;
	}
	if (this.animatedShadow && this.animatedShadow.container) {
		tgfGraphics.removeChild(this.animatedShadow.container);
		this.animatedShadow.container.destroy();
		this.animatedShadow.container = null;
	}
}

//******************************************************
//*****    Script Resource: BattleshipAdFeedbackPopup
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipAdFeedbackPopup = function(properties) {

	this.name = "BattleshipAdFeedbackPopup";

	properties = properties || {};
	properties.label = tgfDictionary.getText("AdFeedbackPopupTitle");

	this._continueClicked = false;
	

	tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);
}

tgfDialogs.inherit(tgfDialogs.BattleshipAdFeedbackPopup, tgfDialogs.BattleshipPopup);



tgfDialogs.BattleshipAdFeedbackPopup.prototype.setButtonCallback = function(callback) {

	this._buttonCallback = callback;
}

tgfDialogs.BattleshipAdFeedbackPopup.prototype._customBeginStep = function(timePassed) {

	if (this._animatorPopup) {
        this._animatorPopup.updateTime(timePassed);
	}

	if (this.background.animator) {
        this.background.animator.updateTime(timePassed);
    }
};

tgfDialogs.BattleshipAdFeedbackPopup.prototype._addCustom = function() {
	
	var self = this;

	this.buttonContinue = new tgfComponents.ComponentBattleshipButton({ 
		text: tgfDictionary.getText("AdFeedbackPopupButton"),
		image: s_button_green,  
		width: 320, 
		height: 86,
		x: this.width / 2,
		y: 86 + 86/2 + 10 + 140
	});


	this.fontContent = f_babas_regular.clone();
	this.fontContent.fillColor = "#ffffcc";
	this.fontContent.strokeColor = "#001c35";
	this.fontContent.align = 'center';
	this.fontContent.fontSize = 32;
	this.fontContent.fillColor = '#ffffcc';

	var textTop = tgfDictionary.getText("AdFeedbackPopupContentTop");
	var textBottom = !this.hideExtraShotInfo ? tgfDictionary.getText("AdFeedbackPopupContentBottom") : "";

	var textProps = {
		text: textTop.toUpperCase() + '\n' + textBottom.toUpperCase(),
		font: this.fontContent,
		x: this.width / 2,
		y: 115 - 30,
		width: this.width - 100,
		height: 150,
		align: 'center',
		fitToBox: true,
		centerBox: true,
		baseline: 'middle',
		splitLines: true,
		fillColor: "#ffffcc"
	};

	this.labelInfo = new tgfComponents.Label(textProps);

	this.buttonContinue.onClick = function() {

		if (self._continueClicked) {
			return;
		}

		self._continueClicked = true;

		if (self._buttonCallback) self._buttonCallback();

		self.hide(false);
	};

	this.background = s_overlay_next_battle.clone();
	this.background.alpha = 0;
	this.background.sprite.width = 1366;

	this._popupContainer.parent.baseContainer.addChild(this.background);

	// this._popupContainer.addComponent(this.buttonExit);
	this._popupContainer.addComponent(this.buttonContinue);
	this._popupContainer.addComponent(this.labelInfo);
}

tgfDialogs.BattleshipAdFeedbackPopup.prototype.show = function(arg) {
	// console.log('show');

	// if (this._animatorPopup)
	// 	this.onShow();

	tgfDialogs.BattleshipPopup.prototype.show.call(this, arg);
}

tgfDialogs.BattleshipAdFeedbackPopup.prototype.onShow = function() {

	console.log('onShow');

	this._continueClicked = false;

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	if (!this._firstCall) {
		this._firstCall = true;
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight/2;
		
		this.background.animator = new tbAnimator(this.background.sprite);
		this.background.animator.alphaTrack = this.background.animator.addTrack('alpha');
	}

	if (this._popupContainer.baseContainer.container.y != this._containerPositionY) {
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight/2;
	}

	this._animatorPopup.addKey(this._animatorPopupTrackY, 500, this._popupContainer.baseContainer.container.y, tbEase.easeOutOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 800, this._containerPositionY, tbEase.easeOutCubic);

	this.background.animator.addKey(this.background.animator.alphaTrack, 500, this.background.alpha);
	this.background.animator.addKey(this.background.animator.alphaTrack, 800, 1);

	this._animatorPopup.setTime(0);
	this.background.animator.setTime(0);
}


tgfDialogs.BattleshipAdFeedbackPopup.prototype.hide = function(arg) {

	if (!this._animatorPopup) {
		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
		return;     
	}

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	this._animatorPopup.addKey(this._animatorPopupTrackY, 10, this._popupContainer.baseContainer.container.y, tbEase.easeInOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 260, this._containerPositionY - tgfGraphics.areaHeight/2, tbEase.easeOutCubic);

	this.background.animator.addKey(this.background.animator.alphaTrack, 000, this.background.alpha);
	this.background.animator.addKey(this.background.animator.alphaTrack, 260, 0);

	this._animatorPopup.addEvent(this, 400, function() {

		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
	}.bind(this));

	this._animatorPopup.setTime(0);
	this.background.animator.setTime(0);
}


tgfDialogs.BattleshipAdFeedbackPopup.prototype.doFree = function() {

	tgfDialogs.BattleshipPopup.prototype.doFree.call(this);

	if (this.fontContent)
	{
		if (this.fontContent.font) {
			this.fontContent.font.destroy();
			this.fontContent.font = null;			
		}
		this.fontContent = null;
	}
}
//******************************************************
//*****    Script Resource: BattleshipDisconnectPopup
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipDisconnectPopup = function(properties) {

	this.name = "BattleshipDisconnectPopup";

	properties = properties || {};
	// properties.label = 'NO INTERNET CONNECTION';//tgfDictionary.getText("DisconnectedTitle");
	properties.label = tgfDictionary.getText("DisconnectedTitle");

	tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);
}

tgfDialogs.inherit(tgfDialogs.BattleshipDisconnectPopup, tgfDialogs.BattleshipPopup);



tgfDialogs.BattleshipDisconnectPopup.prototype.setButtonCallback = function(callback) {

	this._buttonCallback = callback;
}

tgfDialogs.BattleshipDisconnectPopup.prototype._addCustom = function() {
	
	var self = this;

	this.buttonReconnect = new tgfComponents.ComponentBattleshipButton({ 
		// text: 'TRY AGAIN',//tgfDictionary.getText("DisconnectedButton"),
		text: tgfDictionary.getText("DisconnectedButton"),
		image: s_button_green,  
		width: 320, 
		height: 86,
		x: this.width / 2,
		y: this.height - 86 - 86/2
	});


	this._imageRobot = new tgfComponents.Picture({
		x: this.width/2 - s_connection_lost.width/2,
		y: 120,
		image: s_connection_lost
	});

	this.fontLabel = f_babas_regular.clone();
	this.fontLabel.fillColor = "#ffffcc";
	this.fontLabel.strokeColor = "#001c35";
	this.fontLabel.align = 'center';
	this.fontLabel.fontSize = 32;
	this.fontLabel.fillColor = '#ffffcc';
	this.fontLabel.wordWrap = true;
	this.fontLabel.breakWords = true;
	this.fontLabel.wordWrapWidth = this.width * 0.5;
	this.fontLabel.width = this.width * 0.5;

	var textTop = '';
	var textBottom = '';

	textTop = tgfDictionary.getText("DisconnectedBody");
	textBottom = '';

	var textProps = {
		text: textTop.toUpperCase() + ' ' + textBottom.toUpperCase(),
		font: this.fontLabel,
		x: this.width / 2,
		y: 86 + s_connection_lost.height + 60,
		width: this.width * 0.8,
		align: 'center',
		centerBox: true,
		fitToBox: false,
		splitLines: true,
		breakWords: true,
		baseline: 'top',
		fillColor: "#ffffcc"
	};

	this.labelInfo = new tgfComponents.Label(textProps);

	this.buttonReconnect.onClick = function() {

		if (self._buttonCallback) self._buttonCallback();
	};

	this.background = s_overlay_next_battle.clone();
	this.background.alpha = 0;
	this.background.sprite.width = 1366;

	this._popupContainer.parent.baseContainer.addChild(this.background);

	// this._popupContainer.addComponent(this.buttonExit);
	this._popupContainer.addComponent(this.buttonReconnect);
	this._popupContainer.addComponent(this.labelInfo);
	this._popupContainer.addComponent(this._imageRobot);
}


tgfDialogs.BattleshipDisconnectPopup.prototype.show = function(arg) {
	// console.log('show');

	// if (this._animatorPopup)
	// 	this.onShow();


	this._notConnected = true;

	tgfDialogs.BattleshipPopup.prototype.show.call(this, arg);
	
	
	if (UserDataController.isTimedMatch() ) {

		if (this.buttonReconnect) {

			this.buttonReconnect.setText(tgfDictionary.getText('ContinueBattle'));//'CONTINUE BATTLE');
		}

		if (this._textTop) {
			this._textTop.setText(tgfDictionary.getText('GamePaused'));//'GAME PAUSED');
		}
	}
	else {

		if (this.buttonReconnect) {

			this.buttonReconnect.setText( tgfDictionary.getText("DisconnectedButton") );
		}

		if (this._textTop) {
			this._textTop.setText( tgfDictionary.getText("DisconnectedTitle") );
		}	
	}

	AnalyticsHelper.reportPopup("disconnection", "open");
}

tgfDialogs.BattleshipDisconnectPopup.prototype._customBeginStep = function(timePassed) {

	if (this.background.animator) {
		this.background.animator.updateTime(timePassed);
	}

	if (this._notConnected) { 
		
		if (this._shadow) {

			tgfGraphics.addChild(this._shadow.container, 'Disconnect.shadow');
		}
		if (this.baseContainer && this.baseContainer.container) {

			tgfGraphics.addChild(this.baseContainer.container, 'Disconnect.container');
		}
	}
};

tgfDialogs.BattleshipDisconnectPopup.prototype.onShow = function() {

	console.log('BattleshipDisconnectPopup::onShow');

	if (this._shadow) {

		tgfGraphics.addChild(this._shadow.container, 'Disconnect.shadow');
	}
	if (this.baseContainer && this.baseContainer.container) {

		tgfGraphics.addChild(this.baseContainer.container, 'Disconnect.container');
	}

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	if (!this._firstCall) {
		this._firstCall = true;
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight/2 - this.height/2;
		
		this.background.animator = new tbAnimator(this.background.sprite);
		this.background.animator.alphaTrack = this.background.animator.addTrack('alpha');
	}

	if (this._popupContainer.baseContainer.container.y != this._containerPositionY) {
		this._popupContainer.baseContainer.container.y = this._containerPositionY - tgfGraphics.areaHeight/2 - this.height/2;
	}

	this._animatorPopup.addKey(this._animatorPopupTrackY, 0, this._popupContainer.baseContainer.container.y, tbEase.easeOutOvershoot, .65);
	this._animatorPopup.addKey(this._animatorPopupTrackY, 300, this._containerPositionY, tbEase.easeOutCubic);

	this.background.animator.addKey(this.background.animator.alphaTrack, 000, this.background.alpha);
	this.background.animator.addKey(this.background.animator.alphaTrack, 300, 1);

	this._animatorPopup.setTime(0);
	this.background.animator.setTime(0);
}


tgfDialogs.BattleshipDisconnectPopup.prototype.hide = function(arg) {

	this._notConnected = false;

	if (!this._animatorPopup) {
		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
		return;     
	}

	if (this.isVisible){
		AnalyticsHelper.reportPopup("disconnection", "close");
	}

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	// this._animatorPopup.addKey(this._animatorPopupTrackY, 10, this._popupContainer.baseContainer.container.y, tbEase.easeInOvershoot, .65);
	// this._animatorPopup.addKey(this._animatorPopupTrackY, 260, this._containerPositionY - tgfGraphics.areaHeight/2, tbEase.easeOutCubic);

	// this.background.animator.addKey(this.background.animator.alphaTrack, 000, this.background.alpha);
	// this.background.animator.addKey(this.background.animator.alphaTrack, 260, 0);

	// this._animatorPopup.addEvent(this, 400, function() {

	// 	tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
	// }.bind(this));

	this._animatorPopup.setTime(0);
	this.background.animator.setTime(0);

	tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
}
//******************************************************
//*****    Script Resource: BattleshipAdLoadingPopup
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipAdLoadingPopup = function(properties) {

	this.name = "BattleshipAdLoadingPopup";

	properties = properties || {};

	tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);

	window.adLoader = this;
}

tgfDialogs.inherit(tgfDialogs.BattleshipAdLoadingPopup, tgfDialogs.BattleshipPopup);



tgfDialogs.BattleshipAdLoadingPopup.prototype.setButtonCallback = function(callback) {

	this._buttonCallback = callback;
}


tgfDialogs.BattleshipAdLoadingPopup.prototype.doPrepare = function() {
	"use strict";
	var i;

	// add container
	// this._addContainer();

	// add (optional shadow)
	this._addShadow();

	this._spinnerBack = s_throbber_bg.clone();
	this._spinner = s_throbber.clone();
	this._spinnerBack.addChild(this._spinner);


	this._spinner.setPosition(s_throbber_bg.width/2, s_throbber_bg.height/2 - 16);
	this._spinnerBack.setPosition(tgfGraphics.areaWidth/2 - s_throbber_bg.width/2, tgfGraphics.areaHeight/4 - s_throbber_bg.height/2 + 50);

	this.infoLabel = f_babas_regular.clone();
	this.infoLabel.setPosition(this._spinnerBack.x + s_throbber_bg.width/2, this._spinnerBack.y + 275);
	this.infoLabel.setText(tgfDictionary.getText("BattleshipAdLoading"));
	this.infoLabel.setFontSize(50);
	this.infoLabel.setFillColor("#FFF");
	this.infoLabel.setAlign("center");

	tgfGraphics.addChild(this.infoLabel.font);
	tgfGraphics.addChild(this._spinnerBack.sprite);

	// add background
	// this._addBackground();

	// add label
	// this._addHeaderLabel();

	// add custom
	this._addCustom();
};


tgfDialogs.BattleshipAdLoadingPopup.prototype._addCustom = function() {
	
	var self = this;

	
	// this._popupContainer.addComponent(this._imageRobot);
}


tgfDialogs.BattleshipAdLoadingPopup.prototype._customBeginStep = function(timePassed) {


	if (this._isShowingAd) {

		if (this._shadow && this._shadow.container) {

			tgfGraphics.addChild(this._shadow.container, 'BattleshipAdLoadingPopup.shadow');
		}

		if (this._spinner && this._spinner.sprite) {
			this._spinner.sprite.rotation += .0035 * timePassed;

			tgfGraphics.addChild(this._spinnerBack.sprite, 'BattleshipAdLoadingPopup._spinnerBack');
			
		}

		if (this.infoLabel && this.infoLabel.font) 
			tgfGraphics.addChild(this.infoLabel.font);

	}
}


tgfDialogs.BattleshipAdLoadingPopup.prototype.show = function(arg) {
	

	if (this._isShowingAd) return;
	this._isShowingAd = true;

	tgfDialogs.BattleshipPopup.prototype.show.call(this, arg);
}

tgfDialogs.BattleshipAdLoadingPopup.prototype.onShow = function() {

	console.log('BattleshipAdLoadingPopup::onShow');

}


tgfDialogs.BattleshipAdLoadingPopup.prototype.hide = function(arg) {

	if (!this._isShowingAd) return;
	this._isShowingAd = false;

	if (this._spinnerBack && this._spinnerBack.sprite) {

		tgfGraphics.removeChild(this._spinnerBack.sprite);
	}
	if (this.infoLabel && this.infoLabel.font) {

		tgfGraphics.removeChild(this.infoLabel.font);
	}

	tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
}
//******************************************************
//*****    Script Resource: BattleshipNewBattlePopup
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipNewBattlePopup = function (properties) {

    this.name = "BattleshipNewBattlePopup";

    properties = properties || {};
    properties.label = tgfDictionary.getText("Options");
    properties.shadow = true;
    properties.stars = false;

    tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);
}

tgfDialogs.inherit(tgfDialogs.BattleshipNewBattlePopup, tgfDialogs.BattleshipPopup);


tgfDialogs.BattleshipNewBattlePopup.prototype._addBackground = function () {

    this._leftPadding = -770 + 12;


    this._bgPartBottom = new tgfComponents.Picture({
        x: this.width,
        y: 0,
        image: s_next_battle_button_updated,
    });

    // NEW
    this.fontNext = f_babas_bold_no_shadow.clone();
    this.fontNext.fontSize = 32;
    this.fontNext.breakWords = true;
    this.fontNext.wordWrap = true;
    this.fontNext.breakWords = true;
    this.fontNext.fillColor = 0x001c35;

    this._buttonNext = new tgfComponents.ComponentBattleshipButton({
        text: tgfDictionary.getText("LobbyListItemPlay"),
        image: s_button_green,
        width: 200,
        height: 86,
        x: - 200 - 20,
        y: 32
    });

    this._bgPartTop = new tgfComponents.Picture({
        x: this.width,
        y: 100,
        image: s_next_battle_header,
    });

    this._popupContainer.addComponent(this._bgPartTop);
    this._popupContainer.addComponent(this._bgPartBottom);
}

tgfDialogs.BattleshipNewBattlePopup.prototype.handleAvatarReady = function(res) {

    var self = this;
    if (res) {

        self._avatarImage = res;
        res.setPosition(self._avatarBox.x + 7, self._avatarBox.y + 7);
        self._imageAttentionNext.setPosition(self._avatarBox.x + 18, self._avatarBox.y + 18);

        if (self._avatarBox) {

            setTimeout(function () {

                self._avatarBox.addChild(res);

                self._avatarBox.addChild(self._imageAttentionNext);
            }, 0);
        }
    }
}

// tgfDialogs.BattleshipNewBattlePopup.prototype._addHeaderLabel = function () {


// }

tgfDialogs.BattleshipNewBattlePopup.prototype._reportAction = function (action) {

    // state - options
    // 'setup_ships'
    // 'battle_available'
    // 'battle_not_available'

    var state = null;
    if (this._isTimedRandomMatch) {

        state = 'tro';
    }
    else if (this._isSettings) {
        state = 'setup_ships';
    }
    else if (this._nextMatch) {
        state = 'battle_available'
    }
    else {
        state = 'battle_not_available';
    }

    if (this._isSettings) {

        BattleshipsAnalytics.reportNewNextPopupActionShipSetup(action);
    }
    else {

        BattleshipsAnalytics.reportNewNextPopupAction(state, this._actionMethod, action);
    }

},


tgfDialogs.BattleshipNewBattlePopup.prototype._addCustom = function () {

    console.log('in-game-menu.custom');

    this.buttonExit = new tgfComponents.Button({

        image: s_button_next_battle_exit,
        x: -846 + 40 - 1,
        y: s_next_battle_button_updated.height - 40 - 1 - 82
    });

    this._isTimedRandomMatch = UserDataController.isTimedMatch();


    var buttonLobbyText = tgfDictionary.getText("Restart");
    if (this._isTimedRandomMatch) {
        buttonLobbyText = tgfDictionary.getText("AbandonShip");//'Abandon ship';
    }

    // BUTTON - back to lobby
    this.buttonLobby = new tgfComponents.ComponentBattleshipButton({
        text: buttonLobbyText,
        image: s_button_blue,
        width: 372,
        height: 86,
        x: this._leftPadding + 372/2 + 140,
        y: 62,
        // alpha: 0.35
    });

    var sfxMute = StorageManager.get("sfxMute");
    var musicMute = StorageManager.get("musicMute");

    // BUTTON - effects toggle
    // this.buttonEffects = new tgfComponents.ComponentBattleshipButton({
    //     text: '',
    //     image: s_button_blue,
    //     icon: s_button_sound,
    //     iconPosition: "center",
    //     width: 176,
    //     height: 86,
    //     x: this.buttonLobby.x - 176 / 2 - 10,
    //     y: 162,
    //     _active: !sfxMute
    // });

    // BUTTON - music toggle
    // this.buttonMusic = new tgfComponents.ComponentBattleshipButton({
    //     text: '',
    //     image: s_button_blue,
    //     icon: s_button_music,
    //     iconPosition: "center",
    //     width: 176,
    //     height: 86,
    //     x: this.buttonLobby.x + 176 / 2 + 10,// + 92 / 4,
    //     y: 162,
    //     _active: !musicMute
    // });

    // setTimeout(function () {
    //     this.buttonEffects.icon.gotoAndStop(sfxMute ? 1 : 0);
    //     this.buttonMusic.icon.gotoAndStop(musicMute ? 1 : 0);

    // }.bind(this), 0);


    var self = this;

    this._buttonNext.onClick = function () {

        self._reportAction('existing_game');

        console.log('BNBP::next');
        if (self.onNext) self.onNext();
    };

    // this.buttonEffects.onClick = function () {
    //     // Sound Control

    //     if (this._active) {

    //         this._active = false;
    //         this.icon.gotoAndStop(1);
    //         tgfAudio.muteEffects();
    //         AnalyticsService.reportEvent("interaction", "interaction", {
    //             eventType: "sound/effects",
    //             valueBoolean: false,
    //             id: "options"
    //         })
    //     }
    //     else {

    //         this._active = true;
    //         this.icon.gotoAndStop(0);
    //         tgfAudio.unmuteEffects();
    //         AnalyticsService.reportEvent("interaction", "interaction", {
    //             eventType: "sound/effects",
    //             valueBoolean: true,
    //             id: "options"
    //         })
    //     }

    //     StorageManager.set("sfxMute", !this._active);
    // };

    // this.buttonMusic.onClick = function () {
    //     // Music Control    

    //     if (this._active) {

    //         this._active = false;
    //         this.icon.gotoAndStop(1);

    //         tgfAudio.muteMusic();
    //         AnalyticsService.reportEvent("interaction", "interaction", {
    //             eventType: "sound/music",
    //             valueBoolean: false,
    //             id: "options"
    //         })
    //     }
    //     else {

    //         this._active = true;
    //         this.icon.gotoAndStop(0);
    //         tgfAudio.unmuteMusic();
    //         AnalyticsService.reportEvent("interaction", "interaction", {
    //             eventType: "sound/music",
    //             valueBoolean: true,
    //             id: "options"
    //         })
    //     }

    //     StorageManager.set("musicMute", !this._active);
    // };

    this.buttonLobby.onClick = function () {
        self._reportAction('new_game');

        StorageManager.set('autoStart', true);

        console.log("Gamesnacks Game Over");
        //GAMESNACKS.gameOver();

        if (self.onNew) self.onNew();

    }

    this.buttonExit.onClick = function () {

        console.log('BNBP::exit');

        self._reportAction('close');

        AnalyticsService.reportEvent("interaction", "interaction", {
            eventType: "close",
            id: "options"
        });

        if (self.onExit) self.onExit();

        self.hide(false);
    }

    var fontDebug = {fontFace: f_babas_regular_no_shadow.fontFace, align: 'center', fontSize: 20, fillColor: '#2f394c'};


    this.labelVersion = new tgfComponents.Label({
        text: typeof _version !== 'undefined' ? "version: " + _version : "BETA",
        font: fontDebug,
        x:  this.buttonLobby.x + 176 / 2 + 10,// + 92 / 4,
        y: s_next_battle_button_updated.height - 33,
        width: 320,
        height: 50,
        baseline: 'middle'
    });

    this._bgPartBottom.addComponent(this.labelVersion);
    //this._bgPartBottom.addComponent(this.buttonEffects);
    //this._bgPartBottom.addComponent(this.buttonMusic);
    this._bgPartBottom.addComponent(this.buttonLobby);
    this._bgPartBottom.addComponent(this.buttonExit);
}

tgfDialogs.BattleshipNewBattlePopup.prototype._customBeginStep = function (timePassed) {

    if (this._bgPartTop) {
        this._bgPartTop.y = -this._bgPartTop.image.height;
    }

    if (this._textTop && this._textTop.font) {
        window.texttop = this._textTop;
        this._textTop.x = this._bgPartTop.x + this._leftPadding + 140 + 372/2;
        this._textTop.y = this._bgPartTop.y + this._bgPartTop.image.height / 2 - 10;
    }
}

tgfDialogs.BattleshipNewBattlePopup.prototype.show = function (alsoChildren, isSettings, isEndOfTurn) {

    this._isSettings = isSettings || false;
    this._isEndOfTurn = isEndOfTurn || false;


    // action method
    this._actionMethod = 'click';
    if (this._isEndOfTurn) this._actionMethod = 'end_of_turn';

    // next match

    if (this._isSettings) {

        BattleshipsAnalytics.reportScreenOptionsClickShipSetup();
    }
    else if (this._isEndOfTurn) {

        BattleshipsAnalytics.reportScreenOptionsEndOfTurn();
    }
    else {

        BattleshipsAnalytics.reportScreenOptionsClick();
    }

    AnalyticsHelper.reportPopup("options", "open");

    tgfDialogs.Base.prototype.show.call(this, alsoChildren);
}

tgfDialogs.BattleshipNewBattlePopup.prototype.onShow = function () {

    if (flowController.getGameController()) {

        flowController.getGameController().pausePlay();
    }


    if (this._shadow && this._shadow.container) {
        tgfGraphics.addChild(this._shadow.container, 'BattleshipNewBattlePopup.shadow');
    }
    if (this.baseContainer && this.baseContainer.container) {

        tgfGraphics.addChild(this.baseContainer.container, 'BattleshipNewBattlePopup.container');
    }


    this._animatorPopup.removeAllKeys();
    this._animatorPopup.removeEvents();

    this._animatorPopup.addKey(this._animatorPopupTrackX, 0, this._containerPositionX + tgfGraphics.areaWidth / 2 * 1.5, tbEase.easeOutOvershoot, .85);
    this._animatorPopup.addKey(this._animatorPopupTrackX, 350, this._containerPositionX, tbEase.easeOutCubic);


    var bumpY = 40;
    if (this._isSettings) {
        bumpY = 0;
    }
    this._animatorPopup.addKey(this._animatorPopupTrackY, 0, this._containerPositionY);
    this._animatorPopup.addKey(this._animatorPopupTrackY, 140, this._containerPositionY + bumpY);
    this._animatorPopup.addKey(this._animatorPopupTrackY, 425, this._containerPositionY);


    this._animatorPopup.setTime(0);
}


tgfDialogs.BattleshipNewBattlePopup.prototype.hide = function (arg) {

    if (flowController.getGameController()) {

        flowController.getGameController().resumePlay();
    }

    this._animatorPopup.removeAllKeys();
    this._animatorPopup.removeEvents();

    this._animatorPopup.addKey(this._animatorPopupTrackX, 0, this._popupContainer.baseContainer.container.y, tbEase.easeInOvershoot, .85);
    this._animatorPopup.addKey(this._animatorPopupTrackX, 350, this._containerPositionX + tgfGraphics.areaWidth / 2 * 1.5, tbEase.easeOutCubic);
    this._animatorPopup.addEvent(this, 350, function () {

        tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
    }.bind(this));

	if (this.isVisible){
        AnalyticsHelper.reportPopup("options", "close");
	}

    this._animatorPopup.setTime(0);
}

//******************************************************
//*****    Script Resource: BattleshipEndOfTurnPopup
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.BattleshipEndOfTurnPopup = function(properties) {

	properties = properties || {};
	properties.label = tgfDictionary.getText("EndOfTurn_Title");

	properties.starImage = s_star_yellow.clone();
	properties.starOffset = 32;

	properties.shadow = true;

	this._isSending = true;

	// Timings
	this._moveInOutTime = 450;
	this._turnSendTime = this._moveInOutTime + 1500;
	this._delayBeforeMovingOut = 500;

    tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);
}

tgfDialogs.inherit(tgfDialogs.BattleshipEndOfTurnPopup, tgfDialogs.BattleshipPopup);

tgfDialogs.BattleshipEndOfTurnPopup.prototype.show = function(arg) {	

	tgfDialogs.BattleshipPopup.prototype.show.call(this, arg);

	BattleshipsAnalytics.reportEndTurnScreen();

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	this._animatorPopup.addKey(this._animatorPopupTrackY, 0, tgfGraphics.areaHeight + this.height, tbEase.easeOutOvershoot);
	this._animatorPopup.addKey(this._animatorPopupTrackY, this._moveInOutTime, tgfGraphics.areaHeight/2);

	this._animatorPopup.setTime(0);
}

/** Sets a callback that is called at the moment the turn was sent */
tgfDialogs.BattleshipEndOfTurnPopup.prototype.setOnHiddenCallback = function(onHidden) {
	this._onHidden = onHidden;
}

tgfDialogs.BattleshipPopup.prototype._addCustom = function() {

	this._fontSendingTurn = f_autoradiographic_italic.clone();
	this._fontSendingTurn.fontSize = 40;
	this._fontSendingTurn.fillColor = 0x001c34;
	this._fontSendingTurn.strokeWidth = 0;
	
	var textProps = {
        text: tgfDictionary.getText("EndOfTurn_Sending"),
        font: this._fontSendingTurn,
        x: this.width / 2,
        y: this.height / 1.25,
        align: 'center',
        centerBox: true,
        baseline: 'middle',
        splitLines: true
    };
	this._labelSendingTurn = new tgfComponents.Label(textProps);
	
	this._popupContainer.addComponent(this._labelSendingTurn);

	this._spinner = s_throbber.clone();
	this._spinnerBack = s_throbber_bg.clone();

	this._spinner.setPosition(s_throbber_bg.width/2, s_throbber_bg.height/2 - 16);
	this._spinnerBack.setPosition(s_throbber_bg.width/2, s_throbber_bg.height/2);

	this._spinnerComponent = new tgfComponents.Picture({
		x: this.width/2 - s_throbber_bg.width/2,
		y: this.height/2 - s_throbber_bg.height/2,
		image: this._spinnerBack
	});
	this._popupContainer.addComponent(this._spinnerComponent);

	this._turnSentCheckMark = new tgfComponents.Picture({
		x: this.width/2 + 24,
		y: this.height/2 - 100,
		image: s_icon_match.clone()
	});
	this._popupContainer.addComponent(this._turnSentCheckMark);
	this._turnSentCheckMark.setAlpha(0);

	// Add the spinner as a child a frame later when the base container is initialized
	setTimeout(function() {
		this._spinnerComponent.image.addChild(this._spinner);
	}.bind(this), 0);

	// Turn is sent after x amount of time
	this._sendTurnTimeout = setTimeout(this.turnSent.bind(this), this._turnSendTime);
}

/** The moment the turn has been sent */
tgfDialogs.BattleshipEndOfTurnPopup.prototype.turnSent = function() {
	console.log("BattleshipEndOfTurnPopup::turnSent", this._labelSendingTurn);

	this._labelSendingTurn.setText(tgfDictionary.getText("EndOfTurn_TurnSent"));
	this._isSending = false;

	this._turnSentCheckMark.setAlpha(1);

	// Hide after x amount of time
	this._sendTurnTimeout = setTimeout(this.hide.bind(this), this._delayBeforeMovingOut);
}

tgfDialogs.BattleshipEndOfTurnPopup.prototype.hide = function(arg) {
	console.log("BattleshipEndOfTurnPopup::hide");

	// Hide immediately when the animator is null
	if (!this._animatorPopup) {

		if (this._onHidden) this._onHidden();
		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
		return;     
	}

	this._animatorPopup.removeAllKeys();
	this._animatorPopup.removeEvents();

	this._animatorPopup.addKey(this._animatorPopupTrackY, 0, this._popupContainer.baseContainer.container.y, tbEase.easeInOvershoot);
	this._animatorPopup.addKey(this._animatorPopupTrackY, this._moveInOutTime, tgfGraphics.areaHeight + this.height);

	this._animatorPopup.addEvent(this, this._moveInOutTime, function() {

		if (this._onHidden) this._onHidden();
		tgfDialogs.BattleshipPopup.prototype.hide.call(this, arg);
	}.bind(this));

	this._animatorPopup.setTime(0);
}

tgfDialogs.BattleshipEndOfTurnPopup.prototype.handleBeginStep = function(timePassed) {

	if (this._isSending && this._spinner) {
		this._spinner.sprite.rotation += .0035 * timePassed;
	}

	tgfDialogs.BattleshipPopup.prototype.handleBeginStep.call(this, timePassed);
}

tgfDialogs.BattleshipEndOfTurnPopup.prototype.doFree = function() {
	console.log("BattleshipEndOfTurnPopup::doFree", this._spinnerComponent);

	if (this._spinnerComponent) {
		this._spinnerComponent.free();
		this._spinnerComponent = null;
	}
	if (this._labelSendingTurn) {
		this._labelSendingTurn.free();
		this._labelSendingTurn = null;
	}
	if (this._sendTurnTimeout) {
		clearTimeout(this._sendTurnTimeout);
	}

	tgfDialogs.BattleshipPopup.prototype.doFree.call(this);
}
//******************************************************
//*****    Script Resource: BattleshipMockDialog
//******************************************************

// ***************************************
// tgfDialogs.BattleshipMockDialog
//
// A battleshipMockDialog for new dialogs
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// TODO: Everywhere replace battleshipMockDialog and battleshipMockDialog by the appropriate name

// Directives for jslint
/*global tgfSettings, tgfDialogs, tgfComponents */

tgfSettings.dialogDefaults.battleshipMockDialog = {
	components: []					// The additional components to add
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.BattleshipMockDialog = function(properties) {
	"use strict";
	this.name = "battleshipMockDialog";			// The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.battleshipMockDialog);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.BattleshipMockDialog, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************


// ***************************************
// Internal methods
// ***************************************


// ***************************************
// Preparing and showing
//		- These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.BattleshipMockDialog.prototype.doPrepare = function() {
	"use strict";
	var i;

	console.log('BattleshipMockDialog.doPrepare');

	var backgroundGame = s_ingame_background;
	var backgroundLobby = s_background_main;

	this._backgroundImage = backgroundGame.clone();
	this.baseContainer.addChild(this._backgroundImage);

	var self = this;


	// var rankUp = new tgfDialogs.BattleshipRankUpDialog({
	// 	x: 0,
	// 	y: 0
	// });

	// rankUp.show();

	var resultScreen = new tgfDialogs.BattleshipResultDialog({

	});

	resultScreen.show();



	// Add the additional components
	if (this.components) {
		for (i = 0; i < this.components.length; i += 1) {
			this.addComponent(this.components[i]);
		}
	}
};

tgfDialogs.BattleshipMockDialog.prototype.handleBeginStep = function(timePassed) {

	// this.rankBar.update(timePassed);
}

// Processing required when showing the dialog
tgfDialogs.BattleshipMockDialog.prototype.doShow = function() {
	"use strict";
};

// Processing required when hiding the dialog
tgfDialogs.BattleshipMockDialog.prototype.doHide = function() {
	"use strict";
};

//******************************************************
//*****    Script Resource: BattleshipChestOpenDialog
//******************************************************

// ***************************************
// tgfDialogs.BattleshipChestOpenDialog
//
// A BattleshipChestOpenDialog for new dialogs
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// TODO: Everywhere replace BattleshipChestOpenDialog and BattleshipChestOpenDialog by the appropriate name

// Directives for jslint
/*global tgfSettings, tgfDialogs, tgfComponents */

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.BattleshipChestOpenDialog = function(properties) {
	"use strict";
	this.name = "BattleshipChestOpenDialog";			// The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.BattleshipChestOpenDialog);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

tgfDialogs.BattleshipChestOpenDialog.REWARDS = {
	TORPEDO: "torpedo",
	ROCKET: "rocket",
	SCATTER: "scatter",
	AIRSTRIKE: "airstrike"
}

tgfSettings.dialogDefaults.BattleshipChestOpenDialog = {
	rewardType: tgfDialogs.BattleshipChestOpenDialog.REWARDS.TORPEDO
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.BattleshipChestOpenDialog, tgfDialogs.Base);

// Processing required when preparing the dialog for use
tgfDialogs.BattleshipChestOpenDialog.prototype.doPrepare = function() {
	"use strict";

	this.currentStep = 0;

	this._addShadow()

	this.chestAnimation = new tgfComponents.SpineComponent({
		spineAnimation: sw_reward_unlock,
		x: tgfGraphics.areaWidth / 2,
		y: tgfGraphics.areaHeight / 2,
		animationClip: '01_chest_intro',
		onComplete: this._nextStep.bind(this)
	});
	this.addComponent(this.chestAnimation);

	var unlockTextKey;
	switch(this.rewardType) {
		case tgfDialogs.BattleshipChestOpenDialog.REWARDS.TORPEDO: {
			unlockTextKey = 'SpecialWeaponCelebrationPopUp_TorpedoUnlocked';
			break;
		}
		case tgfDialogs.BattleshipChestOpenDialog.REWARDS.SCATTER: {
			unlockTextKey = 'SpecialWeaponCelebrationPopUp_ScatterShotUnlocked';
			break;
		}
		case tgfDialogs.BattleshipChestOpenDialog.REWARDS.ROCKET: {
			unlockTextKey = 'SpecialWeaponCelebrationPopUp_BombUnlocked';
			break;
		}
		case tgfDialogs.BattleshipChestOpenDialog.REWARDS.AIRSTRIKE: {
			unlockTextKey = 'SpecialWeaponCelebrationPopUp_AirStrikeUnlocked';
			break;
		}
	}
	var label = new tgfComponents.Label({
		text: tgfDictionary.getText(unlockTextKey).replace(" \\n ", "\n"),
		font: {
			fontFace: f_babas_bold.fontFace,
			fillColor: '#ffffcc',
			fontSize: 84,
			strokeWidth: 8,
			strokeColor: "#002d57",
			align: "center",
			baseline: "middle",
		},
		splitLines: true,
		fitToBox: false
	});
	this.chestAnimation.addLabelToSlot(41, label);

	this.buttonOpen = new tgfComponents.ComponentBattleshipButton({
		x: tgfGraphics.areaWidth / 2,
		y: tgfGraphics.areaHeight / 2 + 300,
		text: tgfDictionary.getText('SpecialWeaponCelebrationPopUp_Open'),
		image: s_button_green,
		width: 275,
		height: 90,
		alpha: 0,
		onClick: function() {
			this._nextStep();

			AnalyticsService.reportEvent("interaction", "interaction", {
				eventType: "button_open",
				id: "celebration_" + this.rewardType
			});
			OldAnalyticsService.reportDesignEvent(["ux", "open", "celebration_" + this.rewardType])
		}.bind(this),
		interactive: false
	});
	this.addComponent(this.buttonOpen);

	this.buttonClose = new tgfComponents.ComponentBattleshipButton({
		x: tgfGraphics.areaWidth / 2,
		y: tgfGraphics.areaHeight / 2 + 400,
		text: tgfDictionary.getText("AdFeedbackPopupButton"),
		image: s_tgf_transparent,
		width: 195,
		height: 86,
		alpha: 0,
		onClick: function() {
			this._nextStep()
			AnalyticsService.reportEvent("interaction", "interaction", {
				eventType: "button_continue",
				id: "celebration_" + this.rewardType
			});
			OldAnalyticsService.reportDesignEvent(["ux", "continue", "celebration_" + this.rewardType]);
		}.bind(this),
		interactive: false
	});
	this.addComponent(this.buttonClose);

	tgfAudio.play(a_reward_torpedo_appear);
};

tgfDialogs.BattleshipChestOpenDialog.prototype._addShadow = function() {

	this._shadow = new tbContainer(1366, 1366);

	var shadowShape = tbGraphics.drawRectangle(0, 0, tgfGraphics.areaWidth, tgfGraphics.areaHeight, 0x000001, null, null, 0.5);

	this._shadow.container.addChild(shadowShape);

	this._shadow.container.buttonMode = false;
	this._shadow.container.interactive = true;

	tgfGraphics.addChild(this._shadow.container);
	tgfGraphics.addChild(this.baseContainer.container);
}

tgfDialogs.BattleshipChestOpenDialog.prototype._nextStep = function() {
	this.currentStep++;

	switch(this.currentStep) {
		case 1: {
			this._startGlowLoop();
			this.glowLoop = tgfAudio.play(a_reward_torpedo_chest_glow_loop);
			tgfAudio.setLooping(this.glowLoop, true)
			break;
		}
		case 2: {
			this.showOpenButton();
			break;
		}
		case 3: {
			console.log("rewardType", this.rewardType)
			// if (this.rewardType === 'airstrike') {
			// 	this.rewardType = 'torpedo';
			// }



			this.buttonOpen.setInteraction(false);
			this.buttonOpen.setAlpha(0);
			this.chestAnimation.repeat = false;
			this.chestAnimation.setAnimation('03_chest_open_' + this.rewardType, this._nextStep.bind(this));
			tgfAudio.stop(this.glowLoop);
			tgfAudio.play(a_reward_torpedo_chest_open);
			break;
		}
		case 4: {
			this.chestAnimation.repeat = true;
			this.chestAnimation.setAnimation('04_button_' + this.rewardType +'_loop');
			setTimeout(function() {
				if (this._nextStep) {
					this._nextStep();
				}
			}.bind(this), 500)
			break;
		}
		case 5: {
			// this.buttonShare.setInteraction(true);
			// this.buttonShare.setAlpha(1);
			this.buttonClose.setInteraction(true);
			this.buttonClose.setAlpha(1);
			break;
		}
		case 6: {
			// this.buttonShare.setInteraction(false);
			// this.buttonShare.setAlpha(0);
			this.buttonClose.setInteraction(false);
			this.buttonClose.setAlpha(0);
			this.chestAnimation.repeat = false;
			this.chestAnimation.setAnimation('05_button_' + this.rewardType + '_end', this._nextStep.bind(this));
			break;
		}
		case 7: {
			this.free()
			break;
		}
		default: {
			throw "Chest open popup tried to enter a nonexistant state"
		}
	}
};

tgfDialogs.BattleshipChestOpenDialog.prototype.show = function() {
	Sequencer.require(["weapon_unlock"], true)
	.then(function() {
		tgfDialogs.BattleshipChestOpenDialog.uber.show.call(this);
	}.bind(this))
	.catch(function(reason) {
		throw reason;
	}.bind(this));
};

tgfDialogs.BattleshipChestOpenDialog.prototype._startGlowLoop = function() {
	this.chestAnimation.repeat = true;
	this.chestAnimation.setAnimation('02_chest_intro_loop');

	setTimeout(function() {
		if (this._nextStep) {
			this._nextStep();
		}
	}.bind(this), 500)
};

tgfDialogs.BattleshipChestOpenDialog.prototype.showOpenButton = function() {
	this.buttonOpen.setAlpha(1);
	this.buttonOpen.setInteraction(true);
};

// Processing required when showing the dialog
tgfDialogs.BattleshipChestOpenDialog.prototype.doShow = function() {
	"use strict";

	this._shadow.setAlpha(1);
	this._shadow.container.interactive = true;

	AnalyticsHelper.reportPopup("celebration_" + this.rewardType, "open");
	OldAnalyticsService.reportDesignEvent(["screen", "popup", "celebration_" + this.rewardType, "open"]);
};

// Processing required when hiding the dialog
tgfDialogs.BattleshipChestOpenDialog.prototype.doHide = function() {
	"use strict";

	this._shadow.setAlpha(0);
	this._shadow.container.interactive = false;

	AnalyticsHelper.reportPopup("celebration_" + this.rewardType, "close");
	OldAnalyticsService.reportDesignEvent(["screen", "popup", "celebration_" + this.rewardType, "close"]);
};

tgfDialogs.BattleshipChestOpenDialog.prototype.doFree = function() {
	"use strict";

	tgfGraphics.removeChild(this._shadow.container);
	this._shadow.container.destroy();
	this._shadow.container = null;

	if (this.onClose) {
		this.onClose();
	}
};


//******************************************************
//*****    Script Resource: BattleshipRankUpDialog
//******************************************************

// ***************************************
// tgfDialogs.BattleshipRankUpDialog
//
// A battleshipRankUpDialog for new dialogs
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 23-9-2015
// ***************************************

// TODO: Everywhere replace battleshipRankUpDialog and battleshipRankUpDialog by the appropriate name

// Directives for jslint
/*global tgfSettings, tgfDialogs, tgfComponents */

tgfSettings.dialogDefaults.battleshipRankUpDialog = {
    components: []                  // The additional components to add
};

// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.BattleshipRankUpDialog = function(properties) {
    "use strict";
    this.name = "battleshipRankUpDialog";         // The name of the dialog
    // Initialize properties
    this.initialize(tgfSettings.dialogDefaults.battleshipRankUpDialog);
    // Set user properties
    if (properties !== undefined) { this.setProperties(properties); }
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.BattleshipRankUpDialog, tgfDialogs.Base);


// ***************************************
// Specific methods for this dialog
// ***************************************


// ***************************************
// Internal methods
// ***************************************


// ***************************************
// Preparing and showing
//      - These can be removed if no processing is required
// ***************************************

// Processing required when preparing the dialog for use
tgfDialogs.BattleshipRankUpDialog.prototype.doPrepare = function() {
    "use strict";
    var i;

    console.log('BattleshipRankUpDialog.doPrepare', this.score);

    this.score -= 1;

    var self = this;

    var rankFrom = this.rankFrom || RankChart.getRankData(this.score);
    var rankTo = this.rankTo || RankChart.getNextDataByScore(this.score);

    var cloneA = rankFrom.icon.clone();
    cloneA.setScale(1.6, 1.6);

    var cloneB = rankTo.icon.clone();
    cloneB.setScale(1.6, 1.6);

    // var labelA = f_autoradiographic_italic.clone();

    // labelA.setFontSize(34);
    // labelA.setAlign('center');
    // labelA.setBaseline('middle');

    // labelA.setFillColor('#ffffcc');
    // labelA.setStrokeWidth(4);
    // labelA.setStrokeColor('#002d57');

    // labelA.setText('7');
    // labelA.setPosition(cloneA.width / 2 - 1.5, cloneA.height / 2 + 1);

    // labelA.setStyle();

    this._addShadow();

    var fontSpecs = {
        fontSize: 54,
        fontFace: f_autoradiographic_italic.fontFace,
        fillColor: '#ffffcc',
        strokeWidth: 4,
        strokeColor: '#002d57',
        baseline: 'middle',
        align: 'center'
    };

    var labelAA = new tgfComponents.Label({
        // textProps,
        text: String(rankFrom.rank),
        font: fontSpecs,
        x: -2.4,
        y: 1.6,
    });

    var labelBB = new tgfComponents.Label({
        text: String(rankTo.rank),
        font: fontSpecs,
        x: -2.4,
        y: 1.6,
    });

    var labelBanner = new tgfComponents.Label({
        text: tgfDictionary.getText('ranks_rankUp'),//'RANK UP!!',
        font: fontSpecs,
        x: -2.4,
        y: 1.6,
    });


    this.addComponent(labelAA);
    this.addComponent(labelBB);
    this.addComponent(labelBanner);


    // var refImage = s_ui_icon_rank02_59.clone();
    // refImage.setPosition(tgfGraphics.areaWidth/2 + 100, tgfGraphics.areaHeight/2 - 194);
    // this.baseContainer.addChild(refImage);
    // refImage.addChild(labelA);


    this.rankUpAnimation = new tgfComponents.SpineComponent({
        spineAnimation: rank_up_shield,
        x: tgfGraphics.areaWidth/2 - 302,
        y: tgfGraphics.areaHeight/2 + 206 - 40,
        animationClip: 'totaal2',
        imagesToSlots: [
            {
                slotIndex: 20,
                image: cloneA
            },
            {
                slotIndex: 21,
                image: cloneB
            }
        ]
    });



    // this.rankUpAnimation.setAlpha(0.01);
    this.addComponent(this.rankUpAnimation);

    setTimeout(function() {

        this.rankUpAnimation.spineClone.animation.state.addListener({
            event: function(entry, event) {
                console.log('STATE::event fired '+event.data+' at track' + entry.trackIndex)
            },
            complete: function(entry) {
                console.log('STATE::track '+ entry.trackIndex +' completed '+ entry.loopsCount() +' times for -->', entry);
            },
            start: function(entry) {
                console.log('STATE::animation is set at '+entry.trackIndex)
            },
            end: function(entry) {
                console.log('STATE::animation was ended at '+entry.trackIndex)
            },
        });

        this._animator = new tbAnimator(this.rankUpAnimation);
        this._animatorTrackX = this._animator.addTrack('function', this, function(value) {

        	// console.log(this.rankUpAnimation.x, this.rankUpAnimation.y, value);

        	var value = Math.round(value);
        	this.rankUpAnimation.setPosition(tgfGraphics.areaWidth/2 + value, tgfGraphics.areaHeight/2 + 206 - 40); // Applied offset
        });

        this._animator.addKey(this._animatorTrackX, 0, 0);
        this._animator.addKey(this._animatorTrackX, 3050, 0, tbEase.easeOutOvershoot, 0.6);
        this._animator.addKey(this._animatorTrackX, 3350, -302);
        this._animator.addEvent(this, 2750, function() {
            this._shadowAlphaTarget = 0;
        }.bind(this));
        this._animator.addEvent(this, 3350, function() {
            if (this.callback) this.callback();
        }.bind(this));

        // console.log('HACK::', this.rankUpAnimation.spineClone.animation.state);
        // console.log('HACK::', this.rankUpAnimation.spineClone.animation.state.listeners);
        this.rankUpAnimation.addLabelToSlot(20, labelAA);
        this.rankUpAnimation.addLabelToSlot(21, labelBB);
        this.rankUpAnimation.addLabelToSlot(25, labelBanner);

    }.bind(this), 0);



    // Add the additional components
    if (this.components) {
        for (i = 0; i < this.components.length; i += 1) {
            this.addComponent(this.components[i]);
        }
    }
};

tgfDialogs.BattleshipRankUpDialog.prototype._addShadow = function() {
	this._shadow = new tbContainer(1366, 1366);

	var shadowShape = tbGraphics.drawRectangle(0, 0, tgfGraphics.areaWidth, tgfGraphics.areaHeight, 0x000001, null, null, 0.5);

	this._shadow.container.addChild(shadowShape);

	this._shadow.container.buttonMode = false;
    this._shadow.container.interactive = true;

    this._shadow.setAlpha(0);
    this._shadowAlphaTarget = 1;

	tgfGraphics.addChild(this._shadow.container, 'BattleshipPopup.shadow');
	tgfGraphics.addChild(this.baseContainer.container, 'BattleshipPopup.container');
}

tgfDialogs.BattleshipRankUpDialog.prototype.handleBeginStep = function(timePassed) {

    // this.rankBar.update(timePassed);
    if (this._animator) {
    	this._animator.updateTime(timePassed);
    }

    if (this._shadow.alpha != this._shadowAlphaTarget && this._shadow.container) {
        var increment = timePassed * 0.004;

        if (this._shadow.alpha > this._shadowAlphaTarget) {
            increment = -increment;
        }

        if (this._shadow.alpha + increment > this._shadowAlphaTarget === this._shadow.alpha > this._shadowAlphaTarget) {
            this._shadow.setAlpha(this._shadow.alpha + increment);
        } else {
            this._shadow.setAlpha(this._shadowAlphaTarget);
        }
    }
}

tgfDialogs.BattleshipRankUpDialog.prototype.doFree = function() {
    tgfGraphics.removeChild(this._shadow.container);
    this._shadow.container.destroy();
    this._shadow.container = null;
}

// Processing required when showing the dialog
tgfDialogs.BattleshipRankUpDialog.prototype.doShow = function() {
    "use strict";
};

// Processing required when hiding the dialog
tgfDialogs.BattleshipRankUpDialog.prototype.doHide = function() {
    "use strict";
};

tgfDialogs.BattleshipRankUpDialog.prototype.show = function() {
	Sequencer.require(["rankup_shield"], true)
	.then(function() {
		tgfDialogs.BattleshipRankUpDialog.uber.show.call(this);
	}.bind(this))
	.catch(function(reason) {
		throw reason;
	}.bind(this));
};

//******************************************************
//*****    Script Resource: BattleshipOnboardingAnimationDialog
//******************************************************


// The constructor for the dialog
/**
 * @constructor
 * @base tgfDialogs.Base
 */
tgfDialogs.BattleshipOnboardingAnimationDialog = function(properties) {
	"use strict";
	this.name = "BattleshipOnboardingAnimationDialog";			// The name of the dialog
	// Initialize properties
	this.initialize(tgfSettings.dialogDefaults.BattleshipOnboardingAnimationDialog);
	// Set user properties
	if (properties !== undefined) { this.setProperties(properties); }
};

tgfDialogs.BattleshipOnboardingAnimationDialog.ANIMATIONS = {
	NORMAL_SHOT: "onboarding_first_play",
	SPECIAL_WEAPON: "onboarding_special_weapon"
}

tgfSettings.dialogDefaults.BattleshipOnboardingAnimationDialog = {
	animationClip: tgfDialogs.BattleshipOnboardingAnimationDialog.ANIMATIONS.NORMAL_SHOT
};

// Inherit the base dialog
tgfDialogs.inherit(tgfDialogs.BattleshipOnboardingAnimationDialog, tgfDialogs.Base);

// Processing required when preparing the dialog for use
tgfDialogs.BattleshipOnboardingAnimationDialog.prototype.doPrepare = function() {
	"use strict";

	this.handAnimation = new tgfComponents.SpineComponent({
		spineAnimation: Onboarding,
		x: tgfGraphics.areaWidth / 2,
		y: tgfGraphics.areaHeight / 2,
		animationClip: this.animationClip,
		onComplete: function() {
			if (this.onDone) {
				this.onDone();
			}
			this.hide();
			this.free();
		}.bind(this)
	});
	this.addComponent(this.handAnimation);
};

tgfDialogs.BattleshipOnboardingAnimationDialog.prototype.show = function() {
	Sequencer.require(["onboarding"], false)
	.then(function() {
		tgfDialogs.BattleshipOnboardingAnimationDialog.uber.show.call(this);
	}.bind(this))
	.catch(function(reason) {
		throw reason;
	}.bind(this));
};

//******************************************************
//*****    Script Resource: BattleshipSplashLoadingDialog
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfSettings.dialogDefaults.battleshipSplashLoadingDialog = {};

tgfDialogs.BattleshipSplashLoadingDialog = function(properties) {
  "use strict";

  this.name = "BattleshipSplashLoadingDialog";

  this.initialize(tgfSettings.dialogDefaults.battleshipSplashLoadingDialog)

  if (properties !== undefined) { this.setProperties(properties); }

};

tgfDialogs.inherit(tgfDialogs.BattleshipSplashLoadingDialog, tgfDialogs.Base);

tgfDialogs.BattleshipSplashLoadingDialog.prototype.doPrepare = function() {
  this.time = 0;
  this.isDone = false;
  this._start = false;

  this._positions = {
    loadingbarBackgroundX: s_splash_loadingscreen.width / 2 - s_ui_loadingbar_loadscreen_bg.width / 2,
    loadingbarBackgroundY: 320,
    loadingTextX: s_splash_loadingscreen.width / 2,
    loadingTextY: 270,

  };

  this.background = new tgfComponents.Picture({
    x: -1,
    y: -1,
    image: s_splash_loadingscreen,
  });

  this.loadingBarBackground = new tgfComponents.Picture({
    x: this._positions.loadingbarBackgroundX,
    y: this._positions.loadingbarBackgroundY,
    image: s_ui_loadingbar_loadscreen_bg,
  });

  var fillX = this.loadingBarBackground.x + 20;
  var fillY = this.loadingBarBackground.y + 12

  this.loadingBarFill = new tgfComponents.Picture({
    x: fillX,
    y: fillY,
    image: s_ui_loadingbar_loadscreen_fill,
    mask: this._progressBarMask
  });

  var text = tgfDictionary.getText('Loading');

  this.loadingText = new tgfComponents.Label({
    x: this._positions.loadingTextX,
    y: this._positions.loadingTextY,
    text: text,
    font: {
      fontFace: f_babas_regular.fontFace,
      fontSize: 35,
      fillColor: "#000"
    },
    align: 'center',
    fitToBox: false,
    baseline: 'middle'
  });

  this.loadingBarFill.xScale = 0;

  this.loadingBarFill.mask = this._progressBarMask;

  this.addComponent(this.background);
  this.addComponent(this.loadingBarBackground);
  this.addComponent(this.loadingBarFill);
  this.addComponent(this.loadingText);
}

tgfDialogs.BattleshipSplashLoadingDialog.prototype.start = function() {
  this._start = true;
}


tgfDialogs.BattleshipSplashLoadingDialog.prototype.handleBeginStep = function(timePassed) {
  if (this.isDone || !this._start) {
    return;
  }

  this.time += timePassed;

  if (this.time > 4000)  {
    this.loadDone();
  } else {
    var percentage = tgfFunctions.loadPercentage();
    this.setLoadingProgress(percentage);

    if (percentage === 100) {
      this.loadDone();
    }
  }
};

tgfDialogs.BattleshipSplashLoadingDialog.prototype.loadDone = function() {
  if (this.isDone) {
    return;
  }

  this.setLoadingProgress(100);
  this.isDone = true;

  setTimeout(function() {
    if (this.onLoadingDone) this.onLoadingDone();
  }.bind(this), 200);
};

tgfDialogs.BattleshipSplashLoadingDialog.prototype.setLoadingProgress = function(percentage) {
  "use strict";
  console.log(percentage);

  this.loadingBarFill.setScale(percentage / 100, 1);
  console.log(this.loadingBarFill)
}


tgfDialogs.BattleshipSplashLoadingDialog.prototype.doHide = function() {
  "use strict";

  this.free();
}

tgfDialogs.BattleshipSplashLoadingDialog.prototype.doShow = function() {
  this.hidden = false;
}

//******************************************************
//*****    Script Resource: flowSettings
//******************************************************

// ***************************************
// flowSettings
//
// This object contains the setting for the flow.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 24-10-2015
// ***************************************

// We use a function for this to make sure all global variables used actually exist
var flowSettings = function () {
	"use strict";
	return {
		//
		// The properties of the various dialogs
		//
		splashScreenDialogProperties: {                             // The properties for the splash screen
			image: undefined,                                           // The image to be shown
			color: "white",                                             // The background color
			duration: 2                                                 // The duration in seconds
		},

		loadScreenDialogProperties: {                               // The properties for the load screen
			fillImage: s_logo_tinglygames_background,                   // Image used to fill the background
			backgroundImage: s_dialog_load_frame,                       // Background image for the dialog
			gameLogo: s_logo,                                      // Game logo
			companyLogo: s_logo_tinglygames_small                       // Company logo
		},

		titleScreenDialogProperties: {                                  // The properties for the title screen
			backgroundImage: s_screen_start,                        // Background image for the dialog
			gameLogo: s_logo,                                 // Game logo
			companyLogo: [s_logo_tinglygames_small],      // Company logo
			companyLogoPosition: [{x: tgfScale(-100), y: tgfScale(900)}],
			companyLogoLink: ["http://www.coolgames.com"],
			modeButtonCreate: false,
			languageButtonCreate: false,
			playButtonX: tgfScale(0),
			playButtonY: tgfScale(240),
			gameLogoX: tgfScale(0),
			playButtonIcon: s_buttons_bigtext_play,
			playButtonImage: s_btn_standard,
			menuButtonIcon: undefined,
			menuButtonX: tgfScale(65),
			menuButtonY: tgfScale(900),
			menuButtonImage: s_btn_small_options,
			menuButtonWidth: tgfScale(100),
			menuButtonHeight: tgfScale(92),
			multiplayButtonY: tgfScale(80),
			hasBuyButton: false
		},

		titleLanguageDialogProperties: {                                // The properties for the language selection dialog
			width: tgfScale(600), height: tgfScale(600),
			buttonScrollBoxWidth: tgfScale(600), buttonScrollBoxHeight: tgfScale(590),
			buttons: [[{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}],
					 [{image: [s_tgf_button ,s_tgf_buttonSelect]}]]
		},

		titleOptionsDialogProperties: {                             // The properties for the title screen options dialog
			backgroundImage: s_overlay_options,                         // Background image for the dialog
			hasCloseButton: true,                                       // Whether it has a close button
			optionSettings:["tutorial", "oldSound", "oldLanguage", "moregames", "about"],          // Array of options to show
			marginTop: tgfScale(16),
			//titleFont: Lobster,
			titleDictionaryKey: "optionsTitle",
			marginLeft: tgfScale(170),
			marginRight: tgfScale(175)
		},

		lobbyScreenDialogProperties: {
			backgroundImage: s_background_main,

			// imageTop: s_playerbox_lobby_top,
			// imageItem: s_playerbox_lobby,
			// imageItemLast: s_playerbox_lobby_bottom_only,
			// imageItemWin: s_playerbox_lobby_green,
			// imageItemLoss: s_playerbox_lobby_red,

			// componentLobbyListItemClass: tgfComponents.BattleshipLobbyListItem,

			// headings: {
			// 	active: 'YourTurn',
			// 	inactive: 'TheirTurn',
			// 	done: 'FinishedMatches',
			// },

			font: f_babas_bold,
			fontTopFillColor: '#ffffff'
		},

		levelMapProperties: {
			menuButtonX: 65,
			menuButtonY: 580,
			menuButtonImage: s_btn_small_options,
			menuButtonWidth: 100,
			menuButtonHeight: 92,
			//levelButtonFont: OpenSansExtraBold,
			//levelButtonFontLocked: OpenSansExtraBoldLocked,
			//gateFonts: [{fontFace: f_open_sans_bold.fontFace, fontSize: 22, fillColor: "#8f7c64"}, {fontFace: f_open_sans_bold.fontFace, fontSize: 22, fillColor: "#d0853e"}, {fontFace: f_open_sans_bold.fontFace, fontSize: 22, fillColor: "#592902"}, {fontFace: f_open_sans_bold.fontFace, fontSize: 22, fillColor: "#d0853e"}],
			//indicatorImage: s_profilepicture_penguin,
			//comingsoonFont: LobsterComingsoon
		},

		levelSelectionProperties: {
			//popUpBackgroundImage: s_overlay_worldmap_levelselect,
			closeButtonWidth:tgfScale(400),
			hasCloseButton: true,
			levelPressed: 0,
			//titleFont: Lobster,
			//labelTitleFont: {fontFace: f_lobster.fontFace, fontSize: 36, fillColor: "#ea8c9d"},
			//labelFont: {fontFace: f_open_sans_bold.fontFace, fontSize: 18, fillColor: "#452f5a"},
			titleTextDict: "LevelHeader",
			marginTop: tgfScale(16),
			labelTitleDictionaryKey: "",
			labelY: tgfScale(55)
		},

		optionsAboutDialogProperties: {                             // The properties for the about screen
			width: tgfScale(600), height: tgfScale(600),
			aboutBackgroundImage: s_tutorial,
			hasCloseButton: true
		},

		optionsTutorialDialogProperties: {                          // The properties for the tutorial screen
			width: tgfScale(578), height: tgfScale(600),
			titlePercentage: 18,
			imagePercentage: 30,
			messagePercentage: 40,
			buttonPercentage: 10,
			backgroundImage: s_tutorial,
			//previousButtonImage: s_tutorialButton_previous_pink,
			//nextButtonImage: s_tutorialButton_next_pink,
			//closeButtonImage: s_tutorialButton_exit_pink,
			//tutorial:[{image: s_tutorial_01, titleKey: "TutorialHeader_01", messageKey: "TutorialText_01", animationSpeed: 0}, {image: s_tutorial_02, titleKey: "Tutorial_Header_02", messageKey: "TutorialText_02", animationSpeed: 0}
			//,{image: s_tutorial_04, titleKey: "Tutorial_Header_03", messageKey: "TutorialText_03", animationSpeed: 0},
			//{image: s_tutorial_05, titleKey: "Tutorial_Header_04", messageKey: "TutorialText_04", animationSpeed: 0},{image: s_tutorial_06, titleKey: "Tutorial_Header_05", messageKey: "TutorialText_05", animationSpeed: 0},
			//{image: s_tutorial_07, titleKey: "Tutorial_Header_06", messageKey: "TutorialText_06", animationSpeed: 0},{image: s_tutorial_08, titleKey: "Tutorial_Header_07", messageKey: "TutorialText_07", animationSpeed: 0},
			//{image: s_tutorial_09, titleKey: "Tutorial_Header_08", messageKey: "TutorialText_08", animationSpeed: 0},{image: s_tutorial_010, titleKey: "Tutorial_Header_09", messageKey: "TutorialText_09", animationSpeed: 0},
			//{image: s_tutorial_011, titleKey: "Tutorial_Header_10", messageKey: "TutorialText_10", animationSpeed: 0},{image: s_tutorial_012, titleKey: "Tutorial_Header_11", messageKey: "TutorialText_11", animationSpeed: 0}]
		},

		completionScreenDialogProperties: {                             // The properties for the completion screen
			backgroundImage: typeof s_completion_background !== "undefined" ? s_completion_background : null,                   // Background image for the dialog
			congratulationImage: typeof s_completion_congratulation !== "undefined" ? s_completion_congratulation : null,       // Congratulation image for the dialog
			congratulationFont: typeof f_completion_congratulation !== "undefined" ? f_completion_congratulation : f_tgf_title, // Font for the congratulation text
			continueButtonImage: typeof s_completion_continue !== "undefined" ? s_completion_continue : s_tgf_button,           // Image for the continue button
			continueButtonFont: typeof f_completion_continue !== "undefined" ? f_completion_continue : f_tgf_button             // Font for the continue button
		},

		startPlayDialogProperties: {                                // The properties for the play start dialog
			width: tgfScale(780), height: tgfScale(300)
		},

		endPlayWonDialogProperties: {                               // The properties for the end play edialog when won
			backgroundImage: typeof s_overlay_win !== "undefined" ? s_overlay_win : undefined,
//          width: tgfScale(500), height: tgfScale(300),
			//buttons: [ { text: "Back", id: "title" }, { text: "Retry", id: "restart" }, { text: "Next", id: "next" } ],
			showSettings: ["stars","score", "highscore"],
			marginTop: tgfScale(16),
			marginLeft: tgfScale(450),
			marginRight: tgfScale(460),
			//titleFont: Lobster,
			//primaryStatsHeaderFont: {fontFace: f_open_sans_bold.fontFace, fontSize: 24, fillColor: "#ea8c9d"},
			//primaryStatsFont: {fontFace: f_open_sans_bold.fontFace, fontSize: 24, fillColor: "#120825"},
			//secondaryStatsHeaderFont: {fontFace: f_open_sans_bold.fontFace, fontSize: 24, fillColor: "#ea8c9d"},
			//secondaryStatsFont: {fontFace: f_open_sans_bold.fontFace, fontSize: 24, fillColor: "#120825"},
			hasCloseButton:true,
			closeButtonWidth:tgfScale(400),
			primaryStatsHeaderDictionaryKey: "EndScore",
			secondaryStatsHeaderDictionaryKey: "HighScore",
			closeButtonId: "title",
			nextButtonId: "restart",
			titleDict:"LevelHeader",
			hasPrimaryStats: true,
			hasSecondaryStats: true
		},

		endPlayLostDialogProperties: {                              // The properties for the end play dialog when lost
			backgroundImage: typeof s_overlay_fail !== "undefined" ? s_overlay_fail : undefined,
			//width: tgfScale(500), height: tgfScale(300),
			//buttons: [ { text: "Back", id: "title" }, { text: "Retry", id: "restart" } ],
			showSettings: ["score", "highscore"],
			marginTop: tgfScale(16),
			marginLeft: tgfScale(450),
			marginRight: tgfScale(460),
			//titleFont: Lobster,
			hasCloseButton:true,
			closeButtonWidth:tgfScale(400),
			closeButtonId: "title",
			titleDict:"LevelHeader",
			titleDictionaryKey: "LevelFailedHeader",
			hasPrimaryStats: false,
			hasSecondaryStats: false,
			hasFailedLabel: true,
			failLabelY: tgfScale(-145),
			//failLabelFont: {fontFace: f_open_sans_bold.fontFace, fontSize: 24, fillColor: "#ffffff"},
			failLabelDictionaryKey: ""
		},
		stageCompletedDialogProperties: {                           // The properties for the stage completed dialog
			width: tgfScale(500), height: tgfScale(300)
		},

//      gameTutorialDialogProperties: {                             // The properties for the in-game tutorial dialog
//          width: tgfScale(500), height: tgfScale(300)
//      },

		gameOptionsDialogProperties: {                              // The properties for the title screen options dialog
			backgroundImage: s_overlay_options,                         // Background image for the dialog
			hasCloseButton: true,                                       // Whether it has a close button
			optionSettings:["exit", "oldSound", "oldLanguage", "moregames", "about"] ,  // Array of options to show
			buttonExitDictionaryKey: "optionsStartScreen",
			marginTop: tgfScale(16),
			marginLeft: tgfScale(170),
			marginRight: tgfScale(175),
			//titleFont: Lobster,
			titleDictionaryKey: "optionsTitle"
		},

		inGameOptionsDialogProperties:{
			backgroundImage: s_overlay_options,                         // Background image for the dialog
			hasCloseButton: true,                                       // Whether it has a close button
			optionSettings:["resume", "tutorial","oldSound", "moregames", "quit"] ,  // Array of options to show
			marginTop: tgfScale(16),
			marginLeft: tgfScale(170),
			marginRight: tgfScale(175),
			//titleFont: Lobster,
			titleDictionaryKey: "optionsTitle",
			quitYesButtonId: "title",
			//quitTitleFont : {fontFace: f_open_sans_bold.fontFace, fontSize: 32, fillColor: "#452f5a", baseline: "middle", align: "center"}
		},

		tgfAdsProperties:{
			providers: "none",
			adTimer: 1
		},

		tgfFirebaseProperties:{

		},

//      matchMakingProperies:{
//          width: tgfScale(602), height: tgfScale(273),
//          backgroundImage: s_overlay_multi,
//          nameFont:  {fontFace: f_open_sans_bold.fontFace, fontSize: 14, fillColor: "#452f5a", baseline: "middle", align: "center"}
//      },

		adDialogProperties:{
			provider: "none",
			fillImage: s_logo_tinglygames_background,
			hasFrame:true
		},

		adStageDialogProperties: {
			provider: "none",
			hasFrame:true
		},


		flow: {

			//
			// Which dialogs to use (when undefined the default is used)
			//
			splashScreenDialog: tgfDialogs.BattleshipSplashDialog,        // The dialog to use for the splash screen
			loadScreenDialog: undefined,                        // The dialog to use for the load screen
			optionsAboutDialog: tgfDialogs.AboutScreen,         // The dialog to use for the about dialog
			optionsTutorialDialog: tgfDialogs.Tutorial,                   // The dialog to use for the tutorial dialog
			levelScreenDialog: tgfDialogs.LevelMap,             // The dialog to use for the level selection screen
			levelSelectionDialog: tgfDialogs.LevelPopUp,
			startPlayDialog: tgfDialogs.LevelPlay,              // The dialog to use for start play
			startMultiplayDialog: tgfDialogs.LevelPlay,              // The dialog to use for start play
			matchMakingDialog: tgfDialogs.MatchMaking,
			endPlayWonDialog: tgfDialogs.EndPlayWon,            // The dialog to use for end play when won
			endPlayLostDialog: tgfDialogs.EndPlayLost,          // The dialog to use for end play when lost
			stageCompletedDialog: undefined,                    // The dialog to use for stage completed
//          gameTutorialDialog: undefined,                      // The dialog to use for the in-game tutorial
			gameOptionsDialog:  tgfDialogs.OptionScreen,                        // The dialog to use for the in-game options
			inGameOptionsDialog: tgfDialogs.OptionScreen,
			facebookLoginDialog: tgfDialogs.LoginScreen,

			// Whether to show certain dialogs
			showSplashScreenDialog: true,                      // Whether to show the splash screen

			// Which dialogs to use (when undefined the default is used)
			showLoadScreenDialog: false,                         // Whether to show the load screen
			showLevelScreenDialog: false,                        // Whether to show the level selection screen
			showLevelSelectionDialog: false,
			showFacebookLogin: false,

			// Settings related to the title screen
			adDialog: tgfDialogs.AdDialog,
			midrollDialog: tgfDialogs.AdDialogStage,
			titleScreenDialog: tgfDialogs.BattleshipDialogLobby,         // The dialog to use for the title screen
			titleOptionsDialog: tgfDialogs.OptionScreen,        // The dialog to use for the title screen options dialog
			titleLanguageDialog: tgfDialogs.LanguageScreen, // The dialog to use for the title screen languages dialog
			showAdDialog: false,
			showMidroll: false,
			showTitleScreenDialog: true,                        // Whether to show the title screen
			showLanguageMenuDialog: true,
			showTitleMenuDialog: false,
			showAboutScreenDialog: false,
			showTutorialScreen: true,
			titleScreenMusic: null,                          // Music to play when the title screen is shown

			//Setting related to the Game Screen
			showGameMenuDialog: true,

			//Setting related to the In Game Screen
			showInGameMenuDialog: true,

			// Settings related to the completion screen
			completionScreenDialog: undefined,                  // The dialog to use for the completion screen after the last level
			showCompletionScreenDialog: true,                   // Whether to show the completion screen after the last level
			completionScreenAction: "title",                    // What to do after the dialog ("title", "level", "restart")

			// Settings related to loading
			// loadMoments: [ "load", "images", "fonts", "spine", "audio" ],    // The moments that must be loaded at main loading
			// loadRequired: [ "load", "images", "fonts", "spine"],                      // The moments that must be completed before continuing
			loadMoments: [ "load", "images", "fonts" ],    // The moments that must be loaded at main loading
			loadRequired: [ "load", "images", "fonts" ],                      // The moments that must be completed before continuing
			lazyLoadMoments: [ "spine" ],
			lazyLoadRequired: [ "" ],
			audioLoadMoments: [ "audio"],
			audioLoadRequired: [ ],

			loadMinTime: 0.1,                                       // Minimal loading time (in seconds) before continuing
			loadMaxTime: 2                                          // Maximal loading time (in seconds) for the other moments before continuing
		},



		framework: {
			focusOnClick: false
		},
		errors: { },
		analytics: { },
		graphics: {
			areaWidth: tgfScale(1366), areaHeight: tgfScale(1366),
			// safeZoneLeft: tgfScale(1366 - 768) / 2, safeZoneTop: tgfScale(0), safeZoneWidth: tgfScale(768), safeZoneHeight: tgfScale(1366),
			safeZoneLeft: tgfScale(0), safeZoneTop: tgfScale(0), safeZoneWidth: tgfScale(768), safeZoneHeight: tgfScale(1366),
			centerSquare: true,
			transparent: false,
			safeZoneVerticalAnchor: "top"
			// allowScalingUp: false,
			// allowScalingDown: true
		},
		audio: { },
		dictionary: {
			dictionaries: [dictionaryVar]                           // Array of dictionaries to use
		},
		game: { }

	};
};





















//******************************************************
//*****    Script Resource: flowController
//******************************************************

// ***************************************
// flowController
//
//This object controls the flow for a standard game.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 2-11-2015
// ***************************************

// Directives for jslint
/*global tbGame, tbGraphics, tbKeyCodes, tbLoader */
/*global tgfHooks, tgfFunctions, tgfDialogs, tgfComponents, tgfStatus, tgfDictionary, tgfGraphics, tgfAudio, tgfSettings, tgfFramework */
/*global flowSettings, GameController, ThemeController, ClientController, playController */
/*global document */

// ***************************************
// Global variables created by the flow controller
// ***************************************

var gameController = null;                  // Object controlling the game
var themeController = null;                 // Object controlling the theme

var OldAnalyticsService = null;
var AnalyticsService = null;
var messagingPlatformService = null;

var ABTestInstance = null

// ***************************************
// The constructor for this flow token
// ***************************************

// The constructor for the FlowController game token.
var FlowController = function () {
  "use strict";
  // Properties used by the engine
  this.depth = 0;
  this.layer = 10000000;                              // Below everything else
  this.visible = false;
  this.active = true;
  this.adTimer = -1;
  this._cheatTimer = 0;
  this._fingersDown = 0;
  // Own properties
  this.paused = 0;                                    // Whether the flow is paused (by a hook)
  this.currentAction = this.actionBeforeInitializing; // Current action to be performed
  // Add it to the game engine
  tbGame.addToken(this);
};

// Pause the flow
FlowController.prototype.pauseFlow = function () {
  "use strict";
  this.paused += 1;
};

// Resumes the flow
FlowController.prototype.resumeFlow = function () {
  "use strict";
  this.paused -= 1;
};

// Forces a resumes the flow ignoring the stacking
FlowController.prototype.resumeFlow = function () {
  "use strict";
  this.paused = 0;
};

FlowController.prototype.getGameController = function () {

  return gameController;
}

// ***************************************
// Methods to be called by the play controller
// ***************************************

// Start playing the game (handles dialog, status, analytics and hooks)
FlowController.prototype.startPlay = function (action, dialogProperties, onContinue) {
  "use strict";
  var dialog, callback, res;
  // Pause the playing
  gameController.pausePlay();
  // Call the hook if any
  res = tgfHooks.execute("playStart");
  if (res !== undefined) {
    action = res;
  }
  // Create the callback function for after the dialog is shown
  callback = function (dialog) {
    var level = "Level" + tgfSettings.game.currentLevel;
    // Resume the playing
    gameController.resumePlay();
    // Update the status
    tgfStatus.startPlay(tgfSettings.game.currentMode, tgfSettings.game.currentLevel);

    // Call the callback if any
    if (onContinue) {
      onContinue.call(playController);
    }
  };
  // If no dialog is shown, simply call the callback
  if (action !== "dialog") {
    callback();
    return;
  }
  // Now show the dialog

  if (tgfSettings.flow.startPlayDialog) {
    dialog = new tgfSettings.flow.startPlayDialog(dialogProperties);
  } else {
    dialog = new tgfDialogs.StartPlay(dialogProperties);
  }
  dialog.onHide = callback;
  dialog.show();
};


// End a play by winning or loosing (determined by won argument)
FlowController.prototype.resetAll = function () {

  // OpponentOnlineManager.reset();
  // BackendServiceProvider.disconnectReset();
}


FlowController.prototype.endPlay = function (won, score, time, stars, moves, action, dialogProperties, onContinue) {
  "use strict";

  var self = this, dialog, callback, res;
  // Pause the playing
  gameController.pausePlay();


  gameController.stopPlay();

  self.currentAction = self.actionShowTitleScreen;
};


// ***************************************
// Handle the flow. This consists of a number of
// actions. The current actions is called in the
// handleStep method. Some actions though are
// single actions or they wait for a dialog to
// finish, which then sets the next action
// ***************************************

// This action is done before initialization happens
FlowController.prototype.actionBeforeInitializing = function () {
  "use strict";

  AnalyticsService = new LochMessAnalyticsService(true);
  AnalyticsService.startSession();
  this._loadStartTime = Date.now();

  this._timeLoadOverallStart = Date.now();
  ScreenDebugger.initialize();

  // if (Stats) {
  // 	var stats = new Stats();
  // 	this._stats = stats;
  //     stats.showPanel( 2 ); // 0: fps, 1: ms, 2: mb, 3+: custom
  //     document.body.appendChild( stats.dom );

  //     function animate() {

  //         stats.begin();

  //         // monitored code goes here

  //         stats.end();

  //         requestAnimationFrame( animate );
  //     }

  //     requestAnimationFrame( animate );
  // }


  var siteLocks, timeLock;
  // Initialize the flow settings
  tgfSettings.mergeSettings(flowSettings());


  // Create the game and theme controllers. These will merge their own settings in.
  gameController = new GameController();
  themeController = new ThemeController();
  // Initialize the hooks and deal with client settings
  tgfHooks.initialize();
  if (tgfSettings.client.initialLanguage !== undefined) {
    tgfSettings.dictionary.initialLanguage = tgfSettings.client.initialLanguage;
  }
  if (tgfSettings.client.availableLanguages !== undefined) {
    tgfSettings.dictionary.languages = tgfSettings.client.availableLanguages;
  }
  if (tgfSettings.client.splashScreenImage !== undefined) {
    tgfSettings.splashScreenDialogProperties.image = tgfSettings.client.splashScreenImage;
  }
  if (tgfSettings.client.splashScreenColor !== undefined) {
    tgfSettings.splashScreenDialogProperties.color = tgfSettings.client.splashScreenColor;
  }
  if (tgfSettings.client.splashScreenDuration !== undefined) {
    tgfSettings.splashScreenDialogProperties.duration = tgfSettings.client.splashScreenDuration;
    tgfSettings.flow.showSplashScreenDialog = true;
  }

  // Check for site locks
  siteLocks = tgfHooks.execute("getSiteLocks");

  console.log('siteLocks', siteLocks);

  if (siteLocks === undefined) {
    if (testMode) {
      console.log("Warning: Check this out!!!");
    } else {
      this.currentAction = undefined;
      return;
    }
  } else if (!tgfFunctions.checkSiteLocks(siteLocks)) {

    console.log('FC::flowController.checkSiteLocks -> false');
    // this.currentAction = undefined;
    // return;
  }
  // Check for time lock
  timeLock = tgfHooks.execute("getTimeLock");
  if (timeLock !== undefined || !tgfFunctions.checkTimeLock(timeLock)) {
    this.currentAction = undefined;
    return;
  }

  // TODO: Handle the other client settings

  // Change the document title if it is specified in the game
  if (tgfSettings.game.documentTitle) {
    document.title = tgfSettings.game.documentTitle;
  }
  // Continue to the next action
  tgfHooks.execute("beforeInitializing");

  console.log('asdf');

  this.currentAction = this.actionInitializing;
};

// This action is done once in the first step only to initialize stuff
FlowController.prototype.actionInitializing = function () {
  "use strict";
  // Initialize the framework
  tgfFramework.initialize(tgfSettings.framework);

  //tgfGraphics.setBackgroundColor("black");

  // tgfAds.initialize(tgfSettings.tgfAdsProperties);
  // console.log('tgfAds', tgfAds);

  //FIREBASE INIT TEST
  // tgfFirebase.initialize(tgfSettings.tgfFirebaseProperties);
  // console.log('tgfFirebase', tgfFirebase);

  // Continue to the next action
  this.currentAction = this.actionWaitForInitializationToFinish;
};

// This action is performed while waiting for the initialization to finish
FlowController.prototype.actionWaitForInitializationToFinish = function () {
  "use strict";

  // console.log('tot-1', tgfFunctions.loadPercentage() );
  // tgfHooks.execute('loadingProgress', Math.floor(tgfFunctions.loadPercentage() ) );

  if (!tgfFramework.initComplete) {
    return;
  }         // Wait until the framework is completely loaded

  this.canvas = tgfGraphics.mainCanvas;               // Can only be done now that initialization is ready
  this.visible = true;
  // Now start the loading of the resources
  tgfHooks.execute("afterInitializing"); // <-- deprecated MessagingModule

  this.currentAction = null;

  this._timeLoadSDKStart = Date.now();
  // BattleshipsAnalytics.reportLoadDoneSDK(this._timeLoadSDKStart);


  this.currentAction = this.actionStartLoadingResources;
};


// Start the loading of the resources, showing the load dialog when required
FlowController.prototype.actionStartLoadingResources = function () {
  "use strict";
  var self = this;

  this._timeLoadAssetStart = Date.now();

  this._messagingLoader = new MessagingLoader();


	// messagingPlatformService = new FBMessagingPlatformService(FBInstant);
	// messagingPlatformService._initializationState = 4; // hacky-hack-hack <- engine & tools approves
	// messagingPlatformService.initialize(this._messagingLoader);

  // Start the actual loading
  tgfFunctions.loadStart({
    moments: tgfSettings.flow.loadMoments,
    required: tgfSettings.flow.loadRequired,
    minTime: tgfSettings.flow.loadMinTime,
    maxTime: tgfSettings.flow.loadMaxTime
  });

  SpineLoader.initialize();

  this.currentAction = this.actionWaitForLoadingToFinish;
};


FlowController.prototype.actionWaitForLoadingToFinish = function () {
  "use strict";
  // Check whether the resources are loaded

  // var loadLoad = tbLoader.percentage('load')
  // var loadFonts = tbLoader.percentage('fonts')
  // var loadImages = tbLoader.percentage('images')
  tgfHooks.execute('loadingProgress', tgfFunctions.loadPercentage());

  if (!tgfFunctions.loadComplete()) {
    return;
  }


  // Start the title screen
  this.currentAction = undefined;


  tgfHooks.setStartCallback(function () {
    // console.log('FBI-UPDATE::FBInstant::startGameAsync --> tgfHooks.setStartCallback --> this.actionAfterLoading');

    if (window.ErrorLogger) {
      ErrorLogger.setUserInfo(tgfHooks.getPlayerID(), tgfHooks.getPlayerName());
    }

    BattleshipsAnalytics.reportLoadDoneSDK(this._timeLoadSDKStart);

    tbLoader.addResource(BattleshipDictionary, "localisation", 2);
    tbLoader.startLoading("localisation");
    BattleshipDictionary.onLoadDone = function () {
      this.currentAction = this.actionAfterLoading;

    }.bind(this);

  }.bind(this));

  tgfHooks.execute("afterLoading");
};


// This action is performed after the loading is completed (hence, only once)
FlowController.prototype.actionAfterLoading = function () {
  console.log("actionAfterLoading")
  "use strict";
  var music;

  // Apply a hack to clear browser back buffer on Android stock browser
  // at this moment again because too early is not effective
  tgfGraphics.performBufferClearHack();


  // Now initialize analytics
  this.currentAction = this.actionInitializeABTests;
};

FlowController.prototype.actionInitializeABTests = function () {
  console.log("actionInitializeABTests")
  this.currentAction = null;
  var self = this;
  if (!window.location.href.includes('fbinstant')) {
    var lastVersion = _version;
    console.log(lastVersion)
    ABTestInstance = new ABTestManager(tgfSettings.abTests, _version, lastVersion);
    self.currentAction = self.actionInitializeAnalytics
  } else {
    FBInstant.player.getDataAsync(["lastVersion"])
      .then(function (data) {
        console.log("data")
        console.log(data)
        console.log(JSON.stringify(data))
        var lastVersion = data.lastVersion || _version;
        ABTestInstance = new ABTestManager(tgfSettings.abTests, _version, lastVersion);
        _version = ABTestInstance.getFullVersionString();

        FBInstant.player.setDataAsync({
          lastVersion: ABTestInstance.getFullVersionString()
        }).then(function () {
          self.currentAction = self.actionInitializeAnalytics;
        });
      }).catch(function (e) {
      console.error(e);
    });
  }
};


FlowController.prototype.actionInitializeAnalytics = function () {
  "use strict";

  console.log('FC::actionInitializeAnalytics');

  this.currentAction = undefined;

  var self = this;
  var settings = (new AnalyticsServiceSettings(null, _version, null));
  settings.debugInfo = false;

  // function GameAnalyticsService(gameKey, gameSecret, settings) {
  OldAnalyticsService = new GameAnalyticsService(tgfSettings.analytics.gameAnalyticsGameKey, tgfSettings.analytics.gameAnalyticsSecretKey, settings);


	var analyticsServiceSettings = new LochMessAnalyticsServiceSettings();
	analyticsServiceSettings.validationSchema = "json_schema_v_0_2";
	analyticsServiceSettings.appName = "battleship";
	analyticsServiceSettings.appGenre = "board game";
	analyticsServiceSettings.userId = tgfHooks.getPlayerID();
	analyticsServiceSettings.buildVersion = _version;
	analyticsServiceSettings.appId = tgfSettings.gamebot.appId;
	analyticsServiceSettings.sdkVersion = "1.0.0";//messagingPlatformService.getPlatformInfo().sdkVersion;
	analyticsServiceSettings.platform = "distribution";
	analyticsServiceSettings.environment = tgfSettings.analytics.analyticsEnvironment;

	AnalyticsService.putSettings(analyticsServiceSettings);


  Promise.all([OldAnalyticsService.initialize(), AnalyticsService.initialize()]).then(function () {

    self.currentAction = self.actionShowSplashScreen;

    // BattleshipsAnalytics.reportFBLoaderDone();

  }, function (reason) {
    self.currentAction = self.actionShowSplashScreen;
  });
};


// This action shows the splash screen, if any
FlowController.prototype.actionShowSplashScreen = function () {
  "use strict";
  console.log("actionShowSplashScreen")
  this._loadingScreen = new tgfDialogs.BattleshipSplashLoadingDialog();
  this._loadingScreen.show();

  this.currentAction = undefined;

  var self = this;

  // this.splashScreenDialog.onSplashDone = function (dialog) {
  //   self.currentAction = self.actionHideSplashScreen;
  // };
  // this.splashScreenDialog.show();
console.log("set on loading done")
  this._loadingScreen.onLoadingDone = function () {
    self.currentAction = self.actionHideSplashScreen;
  };

  this._loadingScreen.start();

  tgfFunctions.loadStart({
    moments: tgfSettings.flow.lazyLoadMoments,
    required: tgfSettings.flow.lazyLoadRequired,
    minTime: tgfSettings.flow.loadMinTime,
    maxTime: tgfSettings.flow.loadMaxTime
  });


  window.audioDebugProgress = 0;

  var checkAudioLoad = function () {

    var audioLoaded = tbLoader.loaded('audio');
    var audioFailed = tbLoader.failed('audio');
    var audioTotal = tbLoader.total('audio');

    if (!tgfFunctions.loadComplete()) {

      // console.log('spine and or audio not loaded yet');

      var p = audioLoaded + audioFailed;
      if (p > window.audioDebugProgress) {

        window.audioDebugProgress = p;
        // ScreenDebugger.debug('audio', String(audioLoaded + ' + ' + audioFailed + ' / ' + audioTotal) );
      }

      console.log('spine and or audio not loaded yet', p, window.audioDebugProgress, audioLoaded, audioFailed, audioTotal);

      self._audioProgress = setTimeout(checkAudioLoad, 100);
    } else {

      // ScreenDebugger.debug('audio-loaded', String(audioLoaded + ' + ' + audioFailed + ' / ' + audioTotal) );

      tgfFunctions.loadStart({
        moments: tgfSettings.flow.audioLoadMoments,
        required: tgfSettings.flow.audioLoadRequired,
        minTime: tgfSettings.flow.loadMinTime,
        maxTime: tgfSettings.flow.loadMaxTime
      });
    }
  };

  this._timeoutAudioProgress = setTimeout(checkAudioLoad, 100);
};

// Hide the splash screen
FlowController.prototype.actionHideSplashScreen = function () {
  console.log("actionHideSplashScreen")

  if (!tgfFunctions.loadComplete()) {

    console.log('spine not loaded yet');
    return;
  }

  this.currentAction = this.actionLoadAudioNow;
}


FlowController.prototype.actionLoadAudioNow = function () {

  "use strict";

  if (!tgfFunctions.loadComplete()) {

    console.log('spine && (required)audio not loaded yet');
    return;
  } else {

    console.log('spine && (required)audio loaded');
  }

	if (!window.boosterReady)
	{
		console.log("BS-dist waiting for boost!");
		return;
	}

	this.currentAction = undefined;

	AdManager.showAdBanner();

	// TODO:: is this smart developer? <-- no: so removing it
	// if (this._timeoutAudioProgress) {
	// 	clearTimeout(this._timeoutAudioProgress);
	// 	this._timeoutAudioProgress = null;
	// }

  BattleshipsAnalytics.reportLoadDoneAssets(this._timeLoadAssetStart);


  this._loadingScreen.hide();
  this._loadingScreen.free();
  // this.splashScreenDialog.hide();
  // this.splashScreenDialog.free();

  this._loadingScreen = null;


  this.splashScreenDialog = undefined;
  this.currentAction = this.actionShowTitleScreen;
};


var muteSettings = muteSettings || (function () {
  var storage = new TGFStorage("muteSettings");

  storage.initialize({
    "sfx": false,
    "music": false
  });

  return storage;
})();


// Show the title screen dialog
FlowController.prototype.actionShowTitleScreen = function () {
  "use strict";
  var self = this;

  console.log('FC::FC.actionShowTitleScreen');

  // console.warn('Uncomment this line -> window.tbGame = tbGame');

  if (!this._debugInitOnce) {

    this._debugInitOnce = true;

    window.debugTokens = tbGame._tokens;
    window.pixiC = tgfGraphics.pixiContainer;
    window.PIXI = PIXI;
    window.pixiChildren = function () {

      for (var i = 0; i < window.pixiC.children.length; i++) {
        console.log(i + ' ' + window.pixiC.children[i].ref);
      }
    }
    window.tbGame = tbGame;
  }


  this.currentAction = undefined;

  // default entryData = null
  var entryData = null;

  this._firstTimeLobbySkip = null;

  // initialize once
  if (!this._initializedOnce) {

    console.log('FC::FlowController::initializeOnce');
    
    console.log("Gamesnacks: Lobby is done and ready");
    //GAMESNACKS.gameReady();
  
    console.log("Gamesnacks: Enable or Disable sound initially."/*, GAMESNACKS.isAudioEnabled()*/);
    /*if (GAMESNACKS.isAudioEnabled()) {
      tgfAudio.unmuteEffects();
      tgfAudio.unmuteMusic();
    }else{
      tgfAudio.muteEffects();
      tgfAudio.muteMusic();
    }*/
  
    /*GAMESNACKS.subscribeToAudioUpdates((isAudioEnabled) => {
      console.log("Gamesnacks: Enable or Disable sound by callback.", isAudioEnabled);
  
      if (isAudioEnabled) {
        tgfAudio.unmuteEffects();
        tgfAudio.unmuteMusic();
      } else {
        tgfAudio.muteEffects();
        tgfAudio.muteMusic();
      }
    });  */

    this._initializedOnce = true;
    this._firstTimeLobbySkip = true;

    var data = StorageManager.loadSaveData();


    // // Sfx settings
    // var sett = StorageManager.get("sfxMute");
    // if (sett === true) {

    //   tgfAudio.muteEffects();
    // }


    // // Music settings
    // sett = StorageManager.get("musicMute");
    // if (sett === true) {

    //   tgfAudio.muteMusic();
    // }


    // initialize UserDataController.userData.id
    UserDataController.initialize(tgfHooks.getPlayerID(), {});

    // setup ad-loading popup
    this.uiAdLoadingPopup = new tgfDialogs.BattleshipAdLoadingPopup({
      x: 0,
      y: 0,
      positionX: tgfGraphics.areaWidth / 2,
      positionY: tgfGraphics.areaHeight / 2,
      width: 640,
      height: 380,
      shadow: true
    });


    // initialize AdManager
    AdManager.initialize(messagingPlatformService);
    AdManager.setAdStartCallback(this.uiAdLoadingPopup.show, this.uiAdLoadingPopup);
    AdManager.setAdCompleteCallback(this.uiAdLoadingPopup.hide, this.uiAdLoadingPopup);


    // initialize AdManager
    AdManager.initialize({});
    AdManager.setAdStartCallback(this.uiAdLoadingPopup.show, this.uiAdLoadingPopup);
    AdManager.setAdCompleteCallback(this.uiAdLoadingPopup.hide, this.uiAdLoadingPopup);


    // console.log('FC::FlowController::consecutive play');
    this._firstTimeLobbySkip = false;

  }
    TimeManager.initialize(function () {
      if (entryData) {

        var matchId = entryData.matchId;
        UserDataController.setCurrentMatchId(matchId);

        console.log('entryData found::this._backendService.joinMatch()', entryData);

      }
      data = StorageManager.loadSaveData();
      var extraShotData = new ExtraShotData();
      var specialWeaponData = new SpecialWeaponData(true);
      var appUsageData = new AppUsageData();
      var groupMatchMap = {};
      var rankData = new RankData();


      // -------------------------
      //
      // 		EXTRA SHOT
      //
      // -------------------------
      if (data && data['extraShot']) {

        // console.log('	parsing existing data');
        extraShotData.parseData(data['extraShot']);
      } else {

        StorageManager.set('extraShot', extraShotData);
      }

      // -------------------------
      //
      // 		SPECIAL WEAPONS
      //
      // -------------------------
      if (data && data['specialWeapon']) {

        // console.log('	parsing existing data');
        specialWeaponData.parseData(data['specialWeapon']);
      } else {

        StorageManager.set('specialWeapon', specialWeaponData);
      }


      // -------------------------
      //
      // 		RANKING
      //
      // -------------------------
      if (data && data['rank']) {
        console.log(data['rank']);
        rankData.parseData(data['rank']);

      }

      // -------------------------
      //
      // 		APP USAGE
      //
      // -------------------------
      if (data && data['appUsage']) {

        // console.log('	parsing existing data');
        appUsageData.parseData(data['appUsage']);
      }

      if (data && data['groupMatchMap']) {
        groupMatchMap = data['groupMatchMap'];
      }


      var bootAmount = appUsageData.getKeyValue('numBoots');
      if (!bootAmount) bootAmount = 0;
      bootAmount++;
console.log("test")

      appUsageData.setKeyPairValue('numBoots', bootAmount, false);
      appUsageData.boot();

      UserDataController.setExtraShotData(extraShotData);
      UserDataController.setSpecialWeaponData(specialWeaponData);

      UserDataController.setRankData(rankData);
      UserDataController.setAppUsageData(appUsageData);
      UserDataController.setGroupMatchIdMap(groupMatchMap);
      this.actionGotoLobby()
    }.bind(this));

};

FlowController.prototype.actionHideTitleScreen = function () {
  "use strict";

  console.log('actionHideTitleScreen');
  this.currentAction = undefined;

  if (this.titleScreenDialog) {

    this.titleScreenDialog.free();
    this.titleScreenDialog = undefined;
  }

  this.currentAction = this.actionStartPlay;
};

FlowController.prototype.actionListGames = function () {

  console.log('actionListGames');

  var self = this;

  self._timeLoadLobbyStart = Date.now();
  UserMatches.initialize(function () {

    BattleshipsAnalytics.reportLoadDoneLobby(self._timeLoadLobbyStart);
    BattleshipsAnalytics.reportLoadDoneLoading(self._timeLoadOverallStart);

    if (tgfSettings.test.StartBotGameImmediately) {

      console.warn('STARTGAMEWITHBOTIMMEDIATELY');
      this.currentAction = this.actionStartPlay;

      return;
    }

    AnalyticsService.reportEvent("general_flow", "loading", {
      eventType: "general",
      length: Date.now() - this._loadStartTime
    });

    // get matchId to switch on
    var matchId = UserDataController.getCurrentMatchId();

    console.log('LG::Listing games');
    console.log('	LG::has matchId?', matchId);
    // console.log('matches ready, amount?', UserMatches.getMatchesAmount());

    // has existing match + match is not completed
    if (matchId && UserMatches.getMatchLobbyStateById(matchId)) {// && !UserMatches.getMatchLobbyStateById(matchId).completed) {

      // goto match
      console.log('	LG::goto match directly', matchId);
      this.currentAction = this.actionStartPlay;
    } else if (matchId) {

      console.log('	LG::match not found, starting new one');
      UserDataController.clearMatch();
      this.currentAction = this.actionStartPlay;
    }
    // already in context? direct battle!
    else if (BootBattleController.isDirectChallenge() && this._firstTimeLobbySkip) {

      console.log('	LG::direct challenge, skipping lobby');
      // try get match by context (from loaded list)
      if (tgfHooks.getContextID()) {

        var matchId = UserMatches.getMatchByContext(tgfHooks.getContextID());
        if (matchId) UserDataController.setCurrentMatchId(matchId);
      }

      this.currentAction = this.actionStartPlay;
    }
    // no matches for me? Are we testing with a bot game?
    else if ((UserMatches.getMatchesAmount() == 0 && this._firstTimeLobbySkip)) {

      console.log('	LG::first time user, skipping lobby');
      // UserDataController.clearMatch();
      this.currentAction = this.actionStartPlay;
    }
    // Show the title screen if required
    else if (tgfSettings.flow.showTitleScreenDialog) {

      // goto lobby
      console.log('	LG::show lobby normally');

      tgfHooks.execute("beforeTitleScreen");

      this.currentAction = this.actionGotoLobby;

    } else {
      this.currentAction = this.actionStartPlay;
    }

  }.bind(this));
}

FlowController.prototype.actionGotoLobby = function() {
console.log('actionGotoLobby')
	this.currentAction = undefined;
  if (Environment.get() == Environment._ENVS.MOCK) {

    console.log('want to goto lobby, but -> entering mock state');

    this.mockDialog = new tgfDialogs.BattleshipMockDialog({});
    this.mockDialog.show();
  } else {
    this.titleScreenDialog = new tgfSettings.flow.titleScreenDialog();
    this.titleScreenDialog.show();
  }

  // Hacky way to immediatly start a game.
  var start = StorageManager.get('autoStart');

  if (start === false) {
    this.currentAction = null;
  } else {
    this.titleScreenDialog.hide();
    StorageManager.set('autoStart', false);
  }
}

FlowController.prototype.actionStartPlay = function () {
  "use strict";

  this.currentAction = undefined;

  if (Environment.get() == Environment._ENVS.MOCK) {

    console.log('want to start game, but -> entering mock state');

    this.mockDialog = new tgfDialogs.BattleshipMockDialog({});
    this.mockDialog.show();
  } else {

    tgfSettings.game.currentLevel = 1;

    // Pass control over to the game controller
    gameController.startPlay();
  }
};


// ***************************************
// Event handling methods
// ***************************************

FlowController.prototype.handleEndStep = function (timePassed) {
  "use strict";
  // Check whether the flow is paused
  if (this.paused > 0) {
    return;
  }
  // Perform the current action
  if (this.currentAction) {
    this.currentAction(timePassed);
  }

  if (this.adTimer > -1) {
    this.adTimer -= timePassed;
//      console.log(this.adTimer);
  }

  if (this._fingersDown > 0) {
    this._cheatTimer += timePassed;
  } else {
    this._cheatTimer = 0;
  }

  if (this._cheatTimer > 3000 && typeof CheatManager !== 'undefined') {
    CheatManager.openMenu();
    this._cheatTimer = 0;
    this._fingersDown = 0;
  }
};

FlowController.prototype.handleTouchDown = function (finger, x, y) {
  "use strict";
  this._fingersDown++;
};

FlowController.prototype.handleTouchUp = function (finger, x, y) {
  "use strict";
  this._fingersDown--;
  if (this._fingersDown < 0) {
    this._fingersDown = 0;
  }
};

FlowController.prototype.handleDraw = function () {
  "use strict";
  // Clear the dynamic canvasses
  tgfGraphics.clearDynamicCanvasses();
};


// ***************************************
// Create the flow object
// ***************************************

// Create the flow object
var flowController = new FlowController();

//******************************************************
//*****    Script Resource: ScreenDebugger
//******************************************************

var ScreenDebugger = (function() {

	var _ScreenDebugger = function() {

	}

	_ScreenDebugger.prototype.constructor = _ScreenDebugger;

	_ScreenDebugger.prototype.initialize = function() {

        return;

		this._game_container = this._game_container || document.createElement('div');
        this._initialized = true;

        this._game_container.innerText = this._game_container.innerText + '\n' + 'DEBUG::SETUP';
        this._game_container.style.display = "block"; 
        this._game_container.style.position = "absolute"; 
        this._game_container.style.right = "0px"; 
        this._game_container.style.width = "100%"; 
        this._game_container.style.height = "auto";
        this._game_container.style.backgroundColor = "rgba(255, 255,255, 0.75)";
        this._game_container.style.zIndex = 1;
        this._game_container.style.lineHeight = 'auto';
        this._game_container.style.fontSize = '3.5vw';
        this._game_container.style.pointerEvents = 'none';
        this._game_container.style.minHeight = '40px';

        document.body.appendChild(this._game_container);


        // if (this._stats && this._stats.dom) {
        // 	document.body.appendChild( this._stats.dom );
        // }

    	var memory = -1;
    	var memory1024 = -1;
    	if (navigator.deviceMemory) {
    		memory = navigator.deviceMemory;
    		memory1024 = memory * 1024;
    	}

    	this.debug('NavMem', memory + '::' + memory1024);
	}
	
	_ScreenDebugger.prototype.debug = function(code, message) {

		if (!this._initialized) return;

        code = code;// || 'NO_CODE';
        message = message;// || 'NO_MESSAGE';

        if (code == undefined) code = 'NO_CODE';
        if (message == undefined) message = 'NO_MESSAGE';

        if (this._game_container && this._game_container.innerText) {

            this._game_container.innerText = this._game_container.innerText + '\n' + code + '::' + message;
        }
        else {
            console.log('CANT DEBUG');
        } 
    }

	return new _ScreenDebugger();

}());
//******************************************************
//*****    Script Resource: tbBattleshipLoading
//******************************************************

/////////////////////////////////////////////////////////////
// tbLoader: The engine part dealing with loading
//
// Copyright 2013-2015 CoolGames
// Last Changed: 9-6-2015
/////////////////////////////////////////////////////////////

// The constructor for the loader object

var TBLoader = TBLoader;
// start the actual loading for the moment
TBLoader.prototype.startLoading = function(moment) {
	"use strict";
	var i;

	console.log('Start.loading', moment);

	if (moment == 'frameworkAudio') {
		this._items[moment] = null;
	}

	// console.log('TBL::arguablyBETTER-LOADER', moment, this._loading[moment], ((this._items[moment]) ? this._items[moment].length : -1));

	// Check whether it is or has already been loaded
	if (this._loading[moment]) { return; }
	this._loading[moment] = true;
	// If nothing to load, generate event and return
	if (!this._items[moment] || this._items[moment].length === 0) {
		tbGame.addSpecial("Load Complete", { moment: moment} );
		return;
	}



	if (moment == "audio") {

		var self = this;

		var momentLoaded = tbLoader.loaded(moment);
		var momentFailed = tbLoader.failed(moment);
		var momentTotal = tbLoader.total(moment);


		var loadNext = function() {

			momentLoaded = tbLoader.loaded(moment);
			momentFailed = tbLoader.failed(moment);
			momentTotal = tbLoader.total(moment);


			if (momentLoaded > self._timeouts[moment].loadIndex) {

			// console.log('CL::audio-item-done', moment, momentLoaded, momentTotal);

				self._timeouts[moment].loadIndex++;// = momentLoaded;
				if (self._items[moment][self._timeouts[moment].loadIndex]) {

					setTimeout(function() {

						// ScreenDebugger.debug('audio-load-start', String((self._timeouts[moment].loadIndex + 1) + '/' +  momentTotal + " ?f = " + momentFailed) );
						self._items[moment][self._timeouts[moment].loadIndex].startLoading(moment, self._location);

						self._timeouts[moment].timeout = setTimeout(loadNext, 100);
					}, 100);

					return;
				}
				else {
					return;
				}
			}

			self._timeouts[moment].timeout = setTimeout(loadNext, 100);
		}

		this._timeouts = this._timeouts || {};
		this._timeouts[moment] = this._timeouts[moment] || {};
		this._timeouts[moment].loadIndex = momentLoaded || 0;
		this._items[moment][this._timeouts[moment].loadIndex].startLoading(moment, this._location);
		// ScreenDebugger.debug('audio-load-start', String((self._timeouts[moment].loadIndex + 1) + '/' +  momentTotal + " ?f = " + momentFailed) );
		this._timeouts[moment].timeout = setTimeout(loadNext, 100);
	}
	else {

		// Start loading the items
		for (i =0 ; i < this._items[moment].length; i += 1) {
			console.log('load-start', moment, this._items[moment][i] );
			this._items[moment][i].startLoading(moment, this._location);
		}
	}
};


TBLoader.prototype.getLoadMoments = function () {
    var returnValue = [];
    for (var moment in this._total) {
        returnValue.push(moment);
    }
    return returnValue;
}

TBLoader.prototype.getLoadedMoments = function () {
    var returnValue = [];
    for (var moment in this._items) {
        returnValue.push(this._items[moment]);
    }
    return returnValue;
}


TBLoader.prototype.getLoadedItemsInMoment = function (moment) {

    // console.log('SQ::getLoadedItemsInMoment', this._items[moment], moment);

    var loadInfo = {
    	total: this._items[moment].length,
    	loaded: 0,
    	items: []
    };

    for (var item in this._items[moment]) {

    	// console.log('SQ::getLoadedItemsInMoment::item', this._items[moment][item].didLoad);

    	if (this._items[moment][item].didLoad) {
    		loadInfo.loaded++;
    	}
        loadInfo.items.push(item);
    }

    // console.log('SQ::getLoadedItemsInMoment::loadInfo', loadInfo);

    return loadInfo;
}


window.tbLoader = tbLoader;

//******************************************************
//*****    Script Resource: CheatManager
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var CheatManager = {
	armageddon: function(button) {
		var cheatWeapon = new SpecialWeaponScattershot();
		cheatWeapon.generateShotTiles = function(x, y) {
			var tiles = this.makeTileSquare(0, 0, TileMapValues.COLS - 1, TileMapValues.ROWS - 1);
			tiles = tiles.sort(function(a, b) {
				return (Math.pow(a.x - x, 2) + Math.pow(a.y - y, 2)) - (Math.pow(b.x - x, 2) + Math.pow(b.y - y, 2))
			})
			return tiles;
		}

		button.onFire(cheatWeapon);
	},

	openMenu: function() {
		var cheatMenu = new tgfDialogs.CheatMenu();
		cheatMenu.show();
	},

	resetAllData: function() {
		StorageManager.clear();

		location.reload();
	},

	changeRank: function(change) {
		var rankData = UserDataController.getRankData();
		var currentRank = rankData.rank;
		var newRank = currentRank + change;
		newRank = Math.min(50, Math.max(1, newRank));
		var newRankData = {
			score: RankChart.ranks[newRank - 1].value,
			wins: rankData.wins,
			shipsSunk: rankData.shipsSunk
		}
		rankData.parseData(newRankData);
		rankData._save();
	},

	sendGamebotMessages: function() {
		if (NotificationScheduler.hasBeenCheated) {
			throw "This cheat only works once per session"
		}

		var oldDataFunction = NotificationScheduler._getNotificationDataByIndex
		NotificationScheduler._getNotificationDataByIndex = function(i) {
			var notificationData = oldDataFunction(i);

			notificationData.time = new Date(Date.now() + 5000 * i)

			return notificationData;
		}

		NotificationScheduler._scheduleReminders();

		NotificationScheduler.hasBeenCheated = true;
	}
}

//******************************************************
//*****    Script Resource: CheatMenu
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

tgfDialogs.CheatMenu = function(properties) {

	this.name = "CheatMenu";

	properties = properties || {
		height: tgfGraphics.areaHeight,
		width: 700,
		shadow: true,
		stars: false,
		label: " "
	};

	tgfDialogs.BattleshipPopup.prototype.constructor.call(this, properties);
};

tgfDialogs.inherit(tgfDialogs.CheatMenu, tgfDialogs.BattleshipPopup);

tgfDialogs.CheatMenu.prototype._addCustom = function() {
	var nextButtonX = this.width / 2;
	var nextButtonY = 150;

	var fireUnit;
	var playControllers = tbGame.findTokens("playcontroller");
	if (playControllers.length != 0) {
		fireUnit = playControllers[0].getFireUnit();
	}

	if (fireUnit) {
		var winButton = new tgfComponents.ComponentBattleshipButton({
			x: nextButtonX,
			y: nextButtonY,
			width: 500,
			height: 80,
			text: "Win (W)",
			image: s_button_green,
			onClick: function() {
				CheatManager.armageddon(fireUnit.buttonFire);
				this.hide();
				this.free();
			}.bind(this)
		});
		this._popupContainer.addComponent(winButton);
		nextButtonY += 90;
	}

	var resetButton = new tgfComponents.ComponentBattleshipButton({
		x: nextButtonX,
		y: nextButtonY,
		width: 500,
		height: 80,
		text: "Reset data (requires restart)",
		image: d_buttons_yellow,
		onClick: function() {
			CheatManager.resetAllData();
		}.bind(this)
	});
	this._popupContainer.addComponent(resetButton);
	nextButtonY += 90;

	var rankChanges = [-10, -5, -1, 1, 5, 10]
	for (var i = 0; i < rankChanges.length; i++) {
		var buttonWidth = this.width / rankChanges.length
		var versionButton = new tgfComponents.ComponentBattleshipButton({
			x: nextButtonX + i * buttonWidth - (rankChanges.length - 1) / 2 * buttonWidth,
			y: nextButtonY,
			width: buttonWidth,
			height: 80,
			text: String(rankChanges[i]),
			image: d_buttons_yellow,
			onClick: function(change) {
				CheatManager.changeRank(change);
			}.bind(this, rankChanges[i])
		});
		this._popupContainer.addComponent(versionButton);
	}
	nextButtonY += 90;

	var swapTargetSegments = [];
	var swapTargetTests = [];

	var tests = tgfSettings.abTests.tests;
	for (var i = 0; i < tests.length; i++) {
		var test = tests[i];
		if (test.segmentation && test.segmentation.tests.length > 0) {
			for (var j = 0; j < test.segmentation.tests.length; j++) {
				swapTargetSegments.push(test.segmentation.tests[j]);
				swapTargetTests.push(test);
			}
		} else {
			swapTargetSegments.push(null);
			swapTargetTests.push(test);
		}
	}

	for (var i = 0; i < swapTargetSegments.length; i++) {
		var buttonWidth = this.width / swapTargetSegments.length;
		var versionButton = new tgfComponents.ComponentBattleshipButton({
			x: nextButtonX + i * buttonWidth - (swapTargetSegments.length - 1) / 2 * buttonWidth,
			y: nextButtonY,
			width: buttonWidth,
			height: 80,
			text: swapTargetTests[i].version + (swapTargetSegments[i] ? swapTargetSegments[i].version : ""),
			image: d_buttons_yellow,
			onClick: function(i) {
				ABTestInstance.setTestsById(swapTargetTests[i].version, (swapTargetSegments[i] ? swapTargetSegments[i].version : null));
				FBInstant.player.setDataAsync({
					lastVersion: ABTestInstance.getFullVersionString()
				}).then(function() {
					location.reload();
				});
			}.bind(this, i)
		});
		this._popupContainer.addComponent(versionButton);
	}
	nextButtonY += 90;

	var gamebotButton = new tgfComponents.ComponentBattleshipButton({
		x: nextButtonX,
		y: nextButtonY,
		width: 500,
		height: 80,
		text: "Send gamebot (once per session)",
		image: s_button_green,
		onClick: function() {
			CheatManager.sendGamebotMessages();
		}.bind(this)
	});
	this._popupContainer.addComponent(gamebotButton)
	nextButtonY += 90;

	var closeButton = new tgfComponents.ComponentBattleshipButton({
		x: nextButtonX,
		y: nextButtonY,
		width: 500,
		height: 80,
		text: "Close",
		image: s_button_green,
		onClick: function() {
			this.hide();
			this.free();
		}.bind(this)
	});
	this._popupContainer.addComponent(closeButton)
	nextButtonY += 90;

	// var infoText = new tgfComponents.Label({
	// 	x: nextButtonX,
	// 	y: nextButtonY,
	// 	font: {fontFace: f_babas_regular_no_shadow.fontFace, align: 'center', fontSize: 20, fillColor: '#2f394c'},
	// 	text: "interstitial placement: " + AdManager._adsService._interstitialPlacementId
	// 		+ "\nrewarded placement: " + AdManager._adsService._rewardedPlacementId
	// 		+ "\nversion: " + _version,
	// 	align: "center",
	// 	baseline: "middle"
	// });
	// this._popupContainer.addComponent(infoText);
	nextButtonY += 90;
};

//******************************************************
//*****    Script Resource: themeSettings
//******************************************************

// ***************************************
// themeController
//
// This function returns the settings for the theme.
// It is used in the constructor for the theme controller.
//
// This version is just a template.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 12-10-2015
// ***************************************


var themeSettings = function () {
	"use strict";
	return {
		// Required theme related settings
		theme: {
			name: "<UNKNOWN>",						// Name of the theme
			id: "<UNKNOWN>",						// Id of the theme
			version: "1.0"							// Version of the theme
		},
		// Specific flow settings that override the default flow settings
		flow: {
		}		
	};
};

//******************************************************
//*****    Script Resource: themeController
//******************************************************

// ***************************************
// themeController
//
// Each game must include a theme controller that contains methods related to the visual theme. 
// These methods are called by the flow controller that also created the object.
//
// This version is just a template.
//
// Copyright 2015 Tingly Games B.V.
// Last Changed: 12-10-2015
// ***************************************

// Directives for jslint
/*global tgfSettings */
/*global themeSettings */

// The constructor 
var ThemeController = function() {
	"use strict";
	// Merge the settings into the total settings
	// When required settings can also be computed here and other initialization can take place
	tgfSettings.mergeSettings(themeSettings());
};


//******************************************************
//*****    Script Resource: _privacy
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var __privacy = "Privacy policy\n\n1. Introduction\n\nThis Privacy Policy explains who we are, how we collect, share and use personal data about  you, and how you can exercise your privacy rights. This Privacy Policy applies to CoolGames games, websites and related services, which we here collectively call the Service. We may periodically update this Privacy Policy by posting a new version on www.coolgames.com. If we make any material changes, we will notify you by posting a notice in the Service prior to the change becoming effective. Your continued use of the Service after the effective date will be subject to the new Privacy Policy.\n\nIf you have questions about data protection, or if you have any requests concerning your personal data, we encourage you to primarily contact us through the game, so we can reply to you more quickly.\n\nName of the data controller: CoolGames b.v.\n\nAddress: Herengracht 433, 1017 BR Amsterdam, the Netherlands\n\nE-mail:  privacy@coolgames.com\n\n2. Legal basis for data processing\n\nThe legal basis for data processing including use of cookies is Art. 6(1)(f) of the GDPR. If the e-mail contact is aimed to conclude a contract or serves the contract execution, additional legal basis for the processing is Art. 6 (1)(b) GDPR.\n\n3. The data we collect about you\n\nPersonal data, or personal information, means any information about an individual from which that person can be identified. It does not include data where the identity has been removed (anonymous data).\n\nWe may collect, use, store and transfer various kinds of personal data about you which we have grouped together as follows:\n\n3.1 Data you provide us.\n\n-   Contact information (such as name and email address)\n\n-   Player name and password\n\n-   Profile information (such as profile photo, friends)\n\n-   Your messages to the Service (such as chat logs and player support tickets)\n\n-   Other data you choose to give us\n\n3.2 Data we collect automatically.\n\n-   Data about your account and game progress\n\n-   Your IP address and mobile device identifiers (such as your device ID, advertising ID,  MAC address, IMEI)\n\n-   Data about your device, such as device name and operating system, browser type and language\n\n-   Data we collect with cookies and similar technologies\n\n-   General location data\n\n-   Precise geo-location data (GPS, with your consent)\n\n-   Data about your use of the Service, such as gameplay data and your interactions  with other players inside the Service\n\nIn most cases, we also create a CoolGames-specific ID for you when you use the Service.\n\n3.3 Data we collect from our partners.\n\n-   Data we receive if you link a third-party tool with the Service (such as Facebook, Apple, KakaoTalk, LINE or Google)\n\n-   Demographic data (such as to determine the coarse location of your IP address)\n\n-   Data to fight fraud (such as refund abuse in games or click fraud in advertising)\n\n-   Data from platforms that the games run on (such as to verify payment)\n\n-   Data for advertising and analytics purposes, so we can provide you a better Service\n\n4. Purpose of data collection\n\nWe use your personal information for following purposes:\n\n4.1 To make the Service work.\n\nTo perform the contract, we process data necessary to\n\n-   Create accounts and allow you to play our games and use our Service\n\n-   Operate the Service\n\n-   Verify and confirm payments\n\n-   Provide and deliver products and services you request\n\n-   Send you Service-related communications\n\n4.2 To make the Service more suitable for our players.\n\nTo provide a great Service to our players, we have a legitimate interest to collect and process necessary data to\n\n-   Update and develop player profiles\n\n-   Develop and improve the Service and player experience\n\n-   Manage our relationship with you\n\n-   Provide social features as part of the Service\n\n-   Customize your Service experience\n\n-   Respond to your comments and questions and provide player support\n\n-   Provide you CoolGames offers in the Service as well as in other websites and  services, and by email\n\n-   Send you related information, such as updates, security alerts, and support  messages\n\n-   Enable you to communicate with other players\n\n4.3 To show   personalised  advertisements.\n\nTo show you   personalised  advertisements in the Service as well as in other websites and services (including email) we have a legitimate interest to process necessary data to\n\n-   Track the content you access in connection with the Service and your online behaviour\n\n-   Deliver, target and improve our advertising and the Service\n\n-   For information on how to opt-out from personalised advertisements, see section  'Opting out of cookie tracking' below.\n\n4.4 To keep the Service safe and fair.\n\nEnsuring a level playing field in the Service is a top priority for us. For more information on our acceptable use policy, see the CoolGames Terms of Service.\n\nIn order to keep the Service and its social features safe and fair, to fight fraud and ensure acceptable use otherwise, we have a legitimate interest to process necessary data to\n\n-   Analyse and monitor use of the Service and its social features\n\n-   Moderate chats either automatically or manually\n\n-   Take action against fraudulent or misbehaving players\n\n4.5 To analyse, profile, and segment. In all of the above cases and purposes, we may analyse, profile and segment all collected data.\n\n4.6 With your consent. With your consent, we may process your data for additional purposes, such as using yourGPS location to show you local events.\n\n5. Cookies and Automated Information Collection\n\nLike many websites, CoolGames and service providers acting on our behalf, like GoogleAnalytics, store log files and use tracking technologies such as 'cookies' to collect  information. A cookie is a small data file that is transferred to your computers hard disk or  your mobile device for record-keeping purposes. The Service may send cookies to a computer or a mobile device when a user accesses or views a Service. Information contained in a cookie may be linked to personal information for purposes such as improving  the quality of CoolGames Service, tailoring recommendations to interest s, and making theService easier to use.\n\nThird party advertisers on the Services may also use, place or read cookies or other technologies as described below on your browser, and those practices are subject to their own policies. Cookies can be disabled   at any time by changing your web browsers options  to stop accepting cookies, to prompt you before accepting a cookie from the websites you visit or limit the type of cookies you allow. Flash cookies operate differently than browser cookies and cookie management tools available in a web browser may not remove flash  cookies. If you do not accept cookies, however, you may not be able to use all features, portions or functionalities of the Service.\n\nWe and our service providers may also employ other technologies including (i) web beacons, which allow us to know if a certain page was visited or whether an e-mail was opened; (ii) tracking pixels, which allow us or our advertising partners to advertise more efficiently and effectively by excluding our current users from certain promotional messages, identifying the source of a new installation or delivering ads to you on other websites; and (iii) local shared objects also known as flash cookies, which help us to reduce fraud, remember your in-game preferences and speed up load times.\n\n5.1 Tracking technologies\n\nWe and our service providers use these log files, tags, and tracking technologies to collect and analyse certain kinds of technical information, including;\n\n-   the type of device you are using;\n\n-   your operating system version;\n\n-   your mobile devices identifiers, like your MAC Address, Identifier For Advertising\n\n(IDFA), and/or International Mobile Equipment Identity (IMEI);\n\n-   your browser types;\n\n-   your browser language;\n\n-   referring and exit pages, and URLs;\n\n-   platform type;\n\n-   the number of clicks on a page or feature;\n\n-   domain names;\n\n-   landing pages;\n\n-   pages viewed and the order of those pages;\n\n-   the amount of time spent on particular pages; and\n\n-   game state and the date and time of activity on our websites or games.\n\nIn some cases, we will connect this information with your social network ID or CoolGames user ID.\n\n5.2 Opting out of cookie Tracking\n\nMost browsers are initially set to accept cookies, but you can (re)set your browser to refuse all cookies or to indicate when a cookie is being sent. You can opt out of receiving cookies from certain third-party advertising networks by resetting your browser. You may also use the following link to the Network Advertising Initiatives cookies   opt-out page   or the link to the European Interactive Digital Advertising Alliance (EDAA)   opt-out page . However, some features and services may not function properly if cookies are disabled.\n\n6. Who can see your data\n\nApart from CoolGames, your data can be accessed by others in the following situations:\n\n6.1 Other players and users\n\nSocial features are a core component of our games. Other players and users may, for example, see your profile data, in-game activities and read the messages you have posted.\n\n6.2 Partners working for CoolGames\n\nCoolGames has partners to perform services for us. These partners process your data only at and according to CoolGames    instructions to provide the Service, such as hosting, player support, advertising, analytics and fraud prevention.\n\n6.3 Other companies and public authorities.\n\nTo combat fraud and illegal activity, we may exchange data with other companies and organisations and provide it to public authorities in response to lawful requests.\n\nWe may also disclose your data to comply with the law or to protect the rights, property or safety of us, our players or others.\n\n7. How we protect your data\n\nIn order to help ensure a secure and safe player experience, we are continuously developing and implementing administrative, technical and physical security measures to protect your data from unauthorised access or against loss, misuse or alteration.\n\n7.1 Data retention\n\nWe retain your data for as long as your account is active or as needed to provide you theService. We will for example periodically de-identify unused game accounts and we regularly review and de-identify unnecessary data.Note that if you ask us to remove your personal data, we will retain your data as necessary for our legitimate business interests, such as to comply with our legal obligations, resolve disputes, and enforce our agreements.\n\n7.2 Age limit\n\nWe do not knowingly collect or solicit personal data about or direct or target interest based advertising to anyone under the age of 13 or knowingly allow such persons to use ourServices. If you are under 13, please do not send any data about yourself to us, including your name, address, telephone number, or email address. No one under the age of 13 may provide any personal data.\n\nIf we learn that we have collected personal data about a child under age 13, we will delete that data as quickly as possible. If you believe that we might have any data from or about a child under the age of 13, please  contact us .\n\n7.3 International transfers outside of EEA\n\nOur Service is global by nature and your data can therefore be transferred to anywhere in the world. Because different countries may have different data protection laws than your own country, we take steps to ensure adequate safeguards are in place to protect your data as explained in this Policy. Adequate safeguards that our partners may use include standard contractual clauses approved by EU Commission and the Privacy Shield certification in case of transfers to the USA.\n\n8 Legal rights\n\nUnder certain circumstances, you have rights under data protection laws in relation to your personal data. We set out below a brief description of such rights:\n\n8.1 Right to access your personal data\n\nThis enables you to receive a copy of the personal data we hold about you and to check that we are lawfully processing it.\n\n8.2 Right to correct your personal data\n\nThis enables you to have any incomplete or inaccurate data we hold about you corrected, though we may need to verify the accuracy of the new data you provide to us.\n\n8.3 Right to erase your personal data\n\nThis enables you to ask us to delete or remove personal data where there is no good reason for us continuing to process it. You also have the right to ask us to delete or remove your personal data where you have successfully exercised your right to object to processing (see below), where we may have processed your information unlawfully or where we are required to erase your personal data to comply with local law. Note, however, that we may not always be able to comply with your request of erasure for specific legal reasons which will be notified to you, if applicable, at the time of your request.\n\n8.4 Right to object to processing of your personal data\n\nWhere we are relying on a legitimate interest (or those of a third party) and there is something about your particular situation which makes you want to object to processing on this ground as you feel it impacts on your fundamental rights and freedoms. You also have the right to object where we are processing your personal data for direct marketing purposes. In some cases, we may demonstrate that we have compelling legitimate grounds to process your information which override your rights and freedoms\n\n8.5 Right to restrict the processing of your personal data\n\nThis enables you to ask us to suspend the processing of your personal data in the following scenarios: (a) if you want us to establish the dat as accuracy; or (b) you have objected to our  use of your data but we need to verify whether we have overriding legitimate grounds to use it\n\n8.6 Right to request the transfer of your personal data to you or to a third party\n\nWe will provide to you, or a third party you have chosen, your personal data in a structured, commonly used, machine-readable format. Note that this right only applies to automated information which you initially provided consent for us to use or where we used the information to perform a contract with you.\n\n8.7 Right to withdraw your consent   at any time where we are relying on consent to process your personal data\n\nThis will not affect the lawfulness of any processing carried out before you withdraw your consent. If you withdraw your consent, we may not be able to provide certain products or services to you. We will advise you if this is the case at the time you withdraw your consentIf you wish to exercise any of the rights set out above, please contact us through privacy@coolgames.com.\n\n8.8 Costs\n\nYou will not have to pay a fee to access your personal data (or to exercise any of the other rights). However, we may charge a reasonable fee if your request is clearly unfounded, repetitive or excessive. Alternatively, we may refuse to comply with your request in these circumstances.\n\n8.9 Information required\n\nWe may need to request specific information from you to help us confirm your identity and ensure your right to access your personal data (or to exercise any of your other rights). This is a security measure to ensure that personal data is not disclosed to any person who has no right to receive it. We may also contact you to ask you for further information in relation to your request to speed up our response.\n\n8.10 Response time\n\nWe try to respond to all legitimate requests within one month. Occasionally it may take us longer than a month if your request is particularly complex or you have made a number of requests, in which case we will inform you of an extension period. In this case, we will keep you informed on progress.\n\n9. Policy updates\n\nWe may update our Privacy Policy from time to time to reflect changes in technology, legislation, our operations, or as we otherwise determine is necessary or appropriate. ";
	__privacy += "Any such changes will become effective when we make the revised policy available on our website. We encourage you to review the date above frequently to ensure you are aware of when our policy was last revised, and to help you better understand the nature of your interactions with us.\n\nThis document has been updated on May 25 th, 2018";
//******************************************************
//*****    Script Resource: _terms
//******************************************************

// *********************************
// CoolGames Builder JavaScript file
// *********************************

var __terms = 'Terms of use\n\nWelcome to this free gaming service website of CoolGames,(the Services). The following terms and conditions (Terms ofUse) govern your access to and use of the Services and any features or software provided through the Services, any software you download or embed and,except as otherwise provided in these Terms of Use, all games, text, graphics,images, music, software, audio, video, information or other materials available through the Services (Content). Please read carefully these Terms of Use. They constitute a binding legal agreement between you and CoolGames.\n\nYou acknowledge and agree that, by accessing or using theServices or by downloading or embedding any software or any Content from or through the Services, you are indicating that you have read, you understand and you agree to be bound by these Terms of Use, whether or not you have registered with our website. If you do not agree to these Terms of Use, then you have no right to access or use the Services or Content.\n\nModification\n\nCoolGames reserves the right, at its sole discretion, to modify or terminate the Services or to modify these Terms of Use, at any time and without prior notice. If we modify these Terms of Use, we will post the modification on our website and other primary access points to the Services or provide you with notice of the modification. We will also update the LastUpdated Date at the bottom of this page on the home page of our website.By continuing to access or use the Services after we have posted a modification or have provided you with notice of a modification, you are indicating that you agree to be bound by the modified Terms of Use. If the modified Terms of Use are not acceptable to you, your only recourse is to cease using the Services.\n\nOwnership\n\nThe Services and Content are protected by copyright,trademark, and other laws of the Netherlands and foreign countries. CoolGames(or in some cases its licensors) exclusively own all right, title and interest in and to the Services and Content, including all associated intellectual property rights. You will not remove, alter or obscure any copyright,trademark, service mark or other proprietary rights notices incorporated in or accompanying the Services or Content.\n\nSoftware License\n\nConditioned upon your compliance with the terms and conditions of these Terms of Use, CoolGames grants you a non-exclusive and non-transferable license for a single user to download and use the executable form of our underlying platform software and the executable form of the software for each of our game offerings on a single computer or mobile device,solely for your personal, non-commercial purposes. CoolGames reserves all rights in the software not expressly granted to you in these Terms of Use. For purposes of these Terms of Use, Execute means to load, install and run the software in order to benefit from its functionality.\n\nSoftware License Term\n\nThe license granted under these Terms of Use remains in effect for an indefinite period of time, until terminated in accordance with these Terms of Use. You may terminate the license at any time by destroying all copies of the software in your possession or control. CoolGames shall have the right to immediately suspend and/or terminate the license granted under theseTerms of Use if you breach any term of these Terms of Use. Upon termination,you must promptly cease the use of the Services and destroy all copies of the software in your possession or control.\n\nCoolGames reserves the right to revoke your access to and use of the Services and Content at any time, with or without cause. In the event CoolGames terminates these Terms of Use for your breach, you will remain liable for all amounts due hereunder.\n\nSoftware Restrictions\n\nExcept as expressly specified in these Terms of Use, you may not: (a) copy (except in the course of loading or installing) or modify the software, including but not limited to adding new features or otherwise making adaptations that alter the functioning of the software; (b) transfer,sublicense, lease, lend, rent or otherwise distribute the software to any third party; or (c) make the functionality of the software available to multiple users through any means, including but not limited to by uploading the software to a network or file-sharing service or through any hosting, software services provider, service bureau, software-as-a-service (SaaS) or any other type of services. You agree that portions of the software, including but not limited to the source code and the specific design and structure of individual modules or programs, constitute or contain trade secrets of CoolGames and its licensors.Accordingly, you agree not to disassemble, decompile or reverse engineer the software, in whole or in part, or permit or authorise a third party to do so,except to the extent such activities are expressly permitted by law not withstanding this prohibition.\n\nContent License\n\nSubject to your compliance with the terms and conditions of these Terms of Use, CoolGames grants you a limited, non-exclusive,non-transferable license, without the right to sublicense, to use, access,view, download and print any Content solely for your non-commercial,personal-entertainment purposes. You will not use, copy, adapt, modify, prepare derivative works based upon, distribute, license, sell, transfer, publicly display, publicly perform, transmit, stream, broadcast or otherwise exploit theServices or Content, except as expressly permitted in these Terms of Use. No licenses or rights are granted to you by implication or otherwise under any intellectual property rights owned or controlled by CoolGames, except for the licenses and rights expressly granted in these Terms of Use Copyright policy\n\nNotification of Copyright Infringement:\n\nCoolGames respects the intellectual property rights of others and expects its users to do the same.\n\nIt is CoolGames policy, in appropriate circumstances and at its discretion, to disable and/or terminate the accounts of users who repeatedly infringe or are repeatedly charged with infringing the copyrights or other intellectual property rights of others.\n\nIn accordance with the Dutch Copyright Act (in Dutch:Auteurswet) CoolGames will respond expeditiously to claims of copyright infringement committed using the CoolGames Service whether via an e-mail sent to copyright@coolgames.com or via the website www.coolgames.com or various sites (either,the Services) that are reported to CoolGames, identified in the sample notice below.\n\nIf you are a copyright owner, or are authorised to act on behalf of one, or authorised to act under any exclusive right under copyright,please report alleged copyright infringements taking place on or through theServices by completing the following Notice of Alleged Infringement and delivering it to CoolGames. Upon receipt of the Notice as described below, CoolGames will take whatever action, in its sole discretion, it deems appropriate, including removal of the challenged material from the Services.\n\nNotice of Alleged Infringement (Notice)\n\nIdentify the copyrighted work that you claim has been infringed, or  if multiple copyrighted works are covered by this Notice  you may provide a representative list of the copyrighted works that you claim have been infringed.\n\nIdentify the material that you claim is infringing (or to be the subject of infringing activity) and that is to be removed or access to which is to be disabled, and information reasonably sufficient to permit us to locate the material, including at a minimum, if applicable, the URL of the link shown on the website(s) where such material may be found.\n\nProvide your mailing address, telephone number, and, if available, email address.\n\nInclude both of the following statements in the body of theNotice:\n\n I hereby state that I have a good faith belief that the disputed use of the copyrighted material is not authorised by the copyright owner, its agent, or the law (e.g., as a fair use).\n\n I hereby unconditionally warrant that the information in this Notice is accurate and that I am the owner, or authorised to act on behalf of the owner, of the copyright or of an exclusive right under the copyright that is allegedly infringed.\n\nProvide your full legal name and your electronic or physical signature.\n\nDeliver this Notice, with all items completed, to CoolGames:\n\nCoolGames\n\ncopyright@coolgames.com\n\nLast Updated Date: 16/03/16';
//******************************************************
//*****    Script Resource: config_general
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************
/* exported game_configuration */
var configuration_general = {
	publisherId: "CoolGames",
	track: false,
	siteLock: {
		lock: false,
		domains: [
			"8784d238b5a81ab432d0bf303850ed8a",
			"9f5ffc7a10e0bad054458b089947ce2f",
			"0c73b027c77dd2c1ee6cd996c2c83efc",
			"03a60a509d53952c91fc9865fbd492ef", //http://games.mobinozer.com
			"0e26dbc8d26a0880786e55e3e950a320", //http://games.gamesplaza.com/
			"7e77fcbd9a8ec327db79b6c753a5eef1", //http://cdn.mobinozer.com/
			"5ff97ceeea117a01f512adc7ece5ade7", //http://games.nolimitsgames.com/
			"54f5ededff723ca5c52bc75764ceb738", //http://cdn.nolimitsgames.com/
			"526ceb1f05b2418711e1eb59058e0b09", //http://games.jeux.com/
			"ae11a4449bebb3561a078bac793dc74b", //http://games.connectedgamestore.com/
			"f51482fb5ecee35fd139f89728a7a616" //http://games.bmmob.com
		]
	},
	languages: {
		initial: "en-us",
		available: ["en-us"]
	}
};





//******************************************************
//*****    Script Resource: hooks
//******************************************************

// ******************************
// Tingly Builder JavaScript file
// ******************************
//

// Called when loading has finished and start screen (i.e. buttons and logo) are about to be shown
tgfHooks.afterLoading = function () {
	"use strict";
	tgfHooks.getStartCallback()();
}

// Called at the end of the play, when  everything is cleaned up. (also when the player quit the game through the menu)
// quit indicates whether the player quit through the menu and, hence,  did not finish the play
// This is the ideal place to show ads
tgfHooks.playEnd = function(quit) {
	"use strict";
};

//Called when game restarted
tgfHooks.playRestart = function(){
	"use strict";
};

// Called each step during the running of the game (also during the framework dialogs)
tgfHooks.stepGame = function(timePassed) {
	"use strict";
};

// Called each step during the playing only
tgfHooks.stepPlay = function(timePassed) {
	"use strict";
};

// Called when the game is completed and the game complete screen is shown (so after playEnd)
// Does only happen for level based games
tgfHooks.gameCompleted = function() {
	"use strict";
};

tgfHooks.getSiteLocks = function() {
	"use strict";
	return configuration_general.siteLock.domains;
};

tgfHooks.getAnalyticsTracking = function() {
	"use strict";
	return false;
};

tgfHooks.setStartCallback = function(call){
	"use strict";
	tgfHooks.startCall = call;
};

tgfHooks.getStartCallback = function(){
	"use strict";
	return tgfHooks.startCall;
};

tgfHooks.getPlayerID = function(){
	"use strict";
	return '0';
};

//******************************************************
//*****    Script Resource: WeaponUnlockChart
//******************************************************

var WeaponUnlockChart = function() {


}

WeaponUnlockChart.prototype.constructor = WeaponUnlockChart;

/** Returns a list of all the special weapons that should be unlocked with the current rank */
WeaponUnlockChart.getUnlockableWeaponsByRank = function(rank) {
    var weapons = [];

	for (var i = 0; i < WeaponUnlockChart.weaponRankUnlocks.length; i++) {

		if (rank >= WeaponUnlockChart.weaponRankUnlocks[i].rank) {
			weapons.push(WeaponUnlockChart.weaponRankUnlocks[i].weapon);
		}
		else break;
	}
	return weapons;
}

WeaponUnlockChart.getUnlockableWeaponAtRank = function(rank) {
	for (var i = 0; i < WeaponUnlockChart.weaponRankUnlocks.length; i++) {

		if (rank === WeaponUnlockChart.weaponRankUnlocks[i].rank) {
			return WeaponUnlockChart.weaponRankUnlocks[i].weapon;
		}
	}
}

/** Returns the text that should be show on a lock icon based on the special weapon type */
WeaponUnlockChart.getLockText = function(weaponType) {

    for (var i = 0; i < WeaponUnlockChart.weaponData.length; i++) {

        if (WeaponUnlockChart.weaponData[i].weapon == weaponType) {

            return WeaponUnlockChart.weaponData[i].lockText;
        }
    }
    console.warn("WeaponUnlockChart::Special weapon type not found in weaponData");
    return "";
}

WeaponUnlockChart.weaponData = [
    {weapon: SpecialWeaponData.SpecialWeapon.airStrike, lockText: "2"},
    {weapon: SpecialWeaponData.SpecialWeapon.bomb, lockText: "10"},
    {weapon: SpecialWeaponData.SpecialWeapon.torpedo, lockText: "20"},
	  {weapon: SpecialWeaponData.SpecialWeapon.scatter, lockText: "30"},
]

WeaponUnlockChart.weaponRankUnlocks = [
	{rank:  2, weapon: SpecialWeaponData.SpecialWeapon.airStrike},
	{rank: 10, weapon: SpecialWeaponData.SpecialWeapon.bomb},
	{rank: 20, weapon: SpecialWeaponData.SpecialWeapon.torpedo},
	{rank: 30, weapon: SpecialWeaponData.SpecialWeapon.scatter},
]
}());
